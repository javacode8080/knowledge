> 最后更新：2025-11-10 | [返回主目录](../README.md)

# 一、概述
> 首先， 从Spring框架的整体架构和组成对整体框架有个认知。
- Spring基础 - Spring和Spring框架组成
  - Spring是什么？它是怎么诞生的？有哪些主要的组件和核心功能呢? 通过这几个问题帮助你构筑Spring和Spring Framework的整体认知。

![1.spring-framework-introduce-8.png](../../assets/images/04-主流框架/spring/1.spring-framework-introduce-8.png)
> 其次，通过案例引出Spring的核心（IoC和AOP），同时对IoC和AOP进行案例使用分析。
- Spring基础 - Spring简单例子引入Spring的核心
  - 上文中我们简单介绍了Spring和Spring Framework的组件，那么这些Spring Framework组件是如何配合工作的呢？本文主要承接上文，向你展示Spring Framework组件的典型应用场景和基于这个场景设计出的简单案例，并以此引出Spring的核心要点，比如IOC和AOP等；在此基础上还引入了不同的配置方式， 如XML，Java配置和注解方式的差异。

![2.spring-framework-helloworld-2.png](../../assets/images/04-主流框架/spring/2.spring-framework-helloworld-2.png)
- Spring基础 - Spring核心之控制反转(IOC)
  - 在Spring基础 - Spring简单例子引入Spring的核心中向你展示了IoC的基础含义，同时以此发散了一些IoC相关知识点; 本节将在此基础上进一步解读IOC的含义以及IOC的使用方式

![3.spring-framework-ioc-2.png](../../assets/images/04-主流框架/spring/3.spring-framework-ioc-2.png)
- Spring基础 - Spring核心之面向切面编程(AOP)
  - 在Spring基础 - Spring简单例子引入Spring的核心中向你展示了AOP的基础含义，同时以此发散了一些AOP相关知识点; 本节将在此基础上进一步解读AOP的含义以及AOP的使用方式。

![4.spring-framework-aop-2.png](../../assets/images/04-主流框架/spring/4.spring-framework-aop-2.png)
> 基于Spring框架和IOC，AOP的基础，为构建上层web应用，需要进一步学习SpringMVC。
- Spring基础 - SpringMVC请求流程和案例
  - 前文我们介绍了Spring框架和Spring框架中最为重要的两个技术点（IOC和AOP），那我们如何更好的构建上层的应用呢（比如web 应用），这便是SpringMVC；Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发。 本文主要介绍SpringMVC的请求流程和基础案例的编写和运行。

![5.spring-springframework-mvc-5.png](../../assets/images/04-主流框架/spring/5.spring-springframework-mvc-5.png)
> Spring进阶 - IoC，AOP以及SpringMVC的源码分析
- Spring进阶 - Spring IOC实现原理详解之IOC体系结构设计
  - 在对IoC有了初步的认知后，我们开始对IOC的实现原理进行深入理解。本文将帮助你站在设计者的角度去看IOC最顶层的结构设计

![6.spring-framework-ioc-source-71.png](../../assets/images/04-主流框架/spring/6.spring-framework-ioc-source-71.png)
- Spring进阶 - Spring IOC实现原理详解之IOC初始化流程
  - 上文，我们看了IOC设计要点和设计结构；紧接着这篇，我们可以看下源码的实现了：Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的

![7.spring-framework-ioc-source-8.png](../../assets/images/04-主流框架/spring/7.spring-framework-ioc-source-8.png)
- Spring进阶 - Spring IOC实现原理详解之Bean实例化(生命周期,循环依赖等)
  - 上文，我们看了IOC设计要点和设计结构；以及Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的；容器中存放的是Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个`ConcurrentHashMap<String, Object>`；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。那么如何从BeanDefinition中实例化Bean对象呢，这是本文主要研究的内容？
![8.spring-framework-ioc-source-102.png](../../assets/images/04-主流框架/spring/8.spring-framework-ioc-source-102.png)
- Spring进阶 - Spring AOP实现原理详解之切面实现
  - 前文，我们分析了Spring IOC的初始化过程和Bean的生命周期等，而Spring AOP也是基于IOC的Bean加载来实现的。本文主要介绍Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor，为后续交给代理增强实现做准备的过程)。

![9.spring-springframework-aop-4.png](../../assets/images/04-主流框架/spring/9.spring-springframework-aop-4.png)
- Spring进阶 - Spring AOP实现原理详解之AOP代理上文
  - 我们介绍了Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。本文在此基础上继续介绍，代理（cglib代理和JDK代理）的实现过程。

![10.spring-springframework-aop-51.png](../../assets/images/04-主流框架/spring/10.spring-springframework-aop-51.png)
- Spring进阶 - Spring AOP实现原理详解之Cglib代理实现
  - 我们在前文中已经介绍了SpringAOP的切面实现和创建动态代理的过程，那么动态代理是如何工作的呢？本文主要介绍Cglib动态代理的案例和SpringAOP实现的原理。

![11.spring-springframework-aop-63.png](../../assets/images/04-主流框架/spring/11.spring-springframework-aop-63.png)

- Spring进阶 - Spring AOP实现原理详解之JDK代理实现
  - 上文我们学习了SpringAOP Cglib动态代理的实现，本文主要是SpringAOP JDK动态代理的案例和实现部分。

![12.spring-springframework-aop-71.png](../../assets/images/04-主流框架/spring/12.spring-springframework-aop-71.png)
- Spring进阶 - SpringMVC实现原理之DispatcherServlet初始化的过程
  - 前文我们有了IOC的源码基础以及SpringMVC的基础，我们便可以进一步深入理解SpringMVC主要实现原理，包含DispatcherServlet的初始化过程和DispatcherServlet处理请求的过程的源码解析。本文是第一篇：DispatcherServlet的初始化过程的源码解析。

![13.spring-springframework-mvc-23.png](../../assets/images/04-主流框架/spring/13.spring-springframework-mvc-23.png)
- Spring进阶 - SpringMVC实现原理之DispatcherServlet处理请求的过程
  - 前文我们有了IOC的源码基础以及SpringMVC的基础，我们便可以进一步深入理解SpringMVC主要实现原理，包含DispatcherServlet的初始化过程和DispatcherServlet处理请求的过程的源码解析。本文是第二篇：DispatcherServlet处理请求的过程的源码解析。

![14.spring-springframework-mvc-30.png](../../assets/images/04-主流框架/spring/14.spring-springframework-mvc-30.png)
# 二、Spring基础 - Spring和Spring框架组成
## 2.1 什么是Spring?
> 首先，Spring是什么？它是怎么诞生的？它的诞生是为了解决什么问题？
### 2.1.1 Spring的起源
> 百度百科中关于Spring的起源介绍如下：

要谈Spring的历史，就要先谈J2EE。J2EE应用程序的广泛实现是在1999年和2000年开始的，它的出现带来了诸如事务管理之类的核心中间层概念的标准化，但是在实践中并没有获得绝对的成功，因为开发效率，开发难度和实际的性能都令人失望。

曾经使用过**EJB开发JAVA EE应用**的人，一定知道，在EJB开始的学习和应用非常的艰苦，很多东西都不能一下子就很容易的理解。EJB要严格地实现各种不同类型的接口，类似的或者重复的代码大量存在。而配置也是复杂和单调，同样使用JNDI进行对象查找的代码也是单调而枯燥。虽然有一些开发工作随着xdoclet的出现，而有所缓解，但是学习EJB的高昂代价，和极低的开发效率，极高的资源消耗，都造成了EJB的使用困难。而Spring出现的初衷就是为了解决类似的这些问题。

**Spring的一个最大的目的就是使JAVA EE开发更加容易**。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO(Plain Ordinary Java Object)对象提供企业级的服务。

Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍<a href = 'https://item.jd.com/68619611892.html'>《Expert One-on-One J2EE Design and Development》</a>，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。
### 2.1.2 Spring的特性和优势
> Spring Framework有哪些特性，用了这个框架对开发而言有什么好处呢？

从Spring 框架的**特性**来看：
- 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API
- 控制反转：IOC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。
- 依赖注入：DI——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。
- 面向切面编程：Aspect Oriented Programming——AOP
- 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期
- 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。
- 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC）

从使用Spring 框架的**好处**看：
- Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。
- Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。
- Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。
- 测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。
- Spring 的 web 框架是一个设计良好的 web MVC 框架，它为比如 Structs 或者其他工程上的或者不怎么受欢迎的 web 框架提供了一个很好的供替代的选择。MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。模型(Model)封装了应用程序数据，通常它们将由 POJO 类组成。视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。
- Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。
- 轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。
- Spring 提供了一致的事务管理接口，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）
### 2.1.3 Spring有哪些组件?
下图来自，官方文档 Spring-framework 5.0；需要注意的是，虽然这个图来源于Spring Framwork5.0 M4 版本，但是它依然是V4版本的图，比如Spring 5版本中的web模块已经去掉了Portlet模块，新增了WebFlux模块等。
![1.spring-framework-introduce-8.png](../../assets/images/04-主流框架/spring/1.spring-framework-introduce-8.png)

上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍（并且结合SpringFramework5.x源码模块帮助你对应好各模块关系）。
#### 2.1.3.1 Core Container（Spring的核心容器）

Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。

- `Beans 模块`：提供了框架的基础部分，包括控制反转和依赖注入。
- `Core 核心模块`：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。
- `Context 上下文模块`：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。
- `SpEL 模块`：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。

对应的源码模块如下：
![15.spring-framework-introduce-9.png](../../assets/images/04-主流框架/spring/15.spring-framework-introduce-9.png)
#### 2.1.3.2 Data Access/Integration（数据访问／集成）
数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。

- `JDBC 模块`：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。
- `ORM 模块`：提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。
- `OXM 模块`：提供了一个支持 Object /XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。
- `JMS 模块`：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。
- `Transactions 事务模块`：支持编程和声明式事务管理。

对应的源码模块如下：
![16.spring-framework-introduce-10.png](../../assets/images/04-主流框架/spring/16.spring-framework-introduce-10.png)
#### 2.1.3.3 Web模块
Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Webflux 组件，具体介绍如下。
- `Web 模块`：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC 容器初始化以及 Web 应用上下文。
- `Servlet 模块`：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。
- `WebSocket 模块`：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。
- `Webflux 模块`： Spring WebFlux 是 Spring Framework 5.x中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。Spring WebFlux 用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。

此外Spring4.x中还有Portlet 模块，在Spring 5.x中已经移除
- `Portlet 模块`：提供了在 Portlet 环境中使用 MVC 实现，类似 Web-Servlet 模块的功能。

对应的源码模块如下：
![17.spring-framework-introduce-11.png](../../assets/images/04-主流框架/spring/17.spring-framework-introduce-11.png)
#### 2.1.3.4 AOP、Aspects、Instrumentation和Messaging
在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：
- `AOP 模块`：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。
- `Aspects 模块`：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。
- `Instrumentation 模块`：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。
- `messaging 模块`：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。
- `jcl 模块`： Spring 5.x中新增了日志框架集成的模块。

对应的源码模块如下：
![18.spring-framework-introduce-12.png](../../assets/images/04-主流框架/spring/18.spring-framework-introduce-12.png)
#### 2.1.3.5 Test模块
Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。

包含Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient。

对应的源码模块如下：
![19.spring-framework-introduce-13.png](../../assets/images/04-主流框架/spring/19.spring-framework-introduce-13.png)
## 2.2 为什么用Spring?
> 那么为什么用Spring呢？来看看<a href='https://spring.io/why-spring'>官网</a>对这个问题的回答
## 2.3 学习Spring时参考哪些资料呢？
### 2.3.1 Spring 的官方项目和教程
官方的项目和教程，地址在<a href='https://spring.io/projects/spring-framework'>这里</a>，在学习Spring时，一定要把它当做生态体系，而是不是一个简单的开发框架。
![20.spring-framework-introduce-4.png](../../assets/images/04-主流框架/spring/20.spring-framework-introduce-4.png)
### 2.3.2 Spring 的归档文档
官方提供了系统性的文档的FTP，你可以在<a href ='https://docs.spring.io/spring-framework/docs/'>这里</a>找到所有历史版本的PDF/HTML版本。
![21.spring-framework-introduce-1.png](../../assets/images/04-主流框架/spring/21.spring-framework-introduce-1.png)

可以看到很多系统性的文档，包括上面引用的图，
![22.spring-framework-introduce-3.png](../../assets/images/04-主流框架/spring/22.spring-framework-introduce-3.png)
![23.spring-framework-introduce-2.png](../../assets/images/04-主流框架/spring/23.spring-framework-introduce-2.png)
### 2.3.3 Spring 的官方Github
Spring官方的GitHub在<a href = 'https://github.com/spring-projects/spring-framework'>这里</a>，它包含着Spring-framework的源码，如果你感兴趣，可以从这里clone代码进行阅读。
![24.spring-framework-introduce-5.png](../../assets/images/04-主流框架/spring/24.spring-framework-introduce-5.png)
# 三 Spring基础 - Spring简单例子引入Spring要点
## 3.1 Spring框架如何应用
> 上文中，我们展示了Spring和Spring Framework的组件, 这里对于开发者来说有几个问题：
> 
> 首先，对于Spring进阶，直接去看IOC和AOP，存在一个断层，所以需要整体上构建对Spring框架认知上进一步深入，这样才能构建知识体系。
> 
> 其次，很多开发者入门都是从Spring Boot开始的，他对Spring整体框架底层，以及发展历史不是很了解； 特别是对于一些老旧项目维护和底层bug分析没有全局观。
> 
> 再者，Spring代表的是一种框架设计理念，需要全局上理解Spring Framework组件是如何配合工作的，需要理解它设计的初衷和未来趋势。

如下是官方在解释Spring框架的常用场景的图
![2.spring-framework-helloworld-2.png](../../assets/images/04-主流框架/spring/2.spring-framework-helloworld-2.png)

我加上一些注释后，是比较好理解的；引入这个图，重要的原因是为后面设计一个案例帮助你构建认知。

## 3.2 设计一个Spring的Hello World
> 结合上面的使用场景，设计一个查询用户的案例的两个需求，来看Spring框架帮我们简化了什么开发工作:
> 
> 查询用户数据 - 来看DAO+POJO-> Service 的初始化和装载。
> 
> 给所有Service的查询方法记录日志
- 创建一个Maven的Java项目
![25.spring-framework-helloworld-3.png](../../assets/images/04-主流框架/spring/25.spring-framework-helloworld-3.png)
- 引入Spring框架的POM依赖，以及查看这些依赖之间的关系
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>tech.pdai</groupId>
    <artifactId>001-spring-framework-demo-helloworld-xml</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <spring.version>5.3.9</spring.version>
        <aspectjweaver.version>1.9.6</aspectjweaver.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>${aspectjweaver.version}</version>
        </dependency>
    </dependencies>

</project>
```
![26.spring-framework-helloworld-4.png](../../assets/images/04-主流框架/spring/26.spring-framework-helloworld-4.png)
- POJO - User
```java
package tech.pdai.springframework.entity;

/**
 * @author pdai
 */
public class User {

    /**
     * user's name.
     */
    private String name;

    /**
     * user's age.
     */
    private int age;

    /**
     * init.
     *
     * @param name name
     * @param age  age
     */
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```
- DAO 获取 POJO， UserDaoServiceImpl (mock 数据)
```java
package tech.pdai.springframework.dao;

import java.util.Collections;
import java.util.List;

import tech.pdai.springframework.entity.User;

/**
 * @author pdai
 */
public class UserDaoImpl {

    /**
     * init.
     */
    public UserDaoImpl() {
    }

    /**
     * mocked to find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return Collections.singletonList(new User("pdai", 18));
    }
}
```
并增加daos.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="userDao" class="tech.pdai.springframework.dao.UserDaoImpl">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions for data access objects go here -->
</beans>
```
- 业务层 UserServiceImpl（调用DAO层）
```java
package tech.pdai.springframework.service;

import java.util.List;

import tech.pdai.springframework.dao.UserDaoImpl;
import tech.pdai.springframework.entity.User;

/**
 * @author pdai
 */
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    private UserDaoImpl userDao;

    /**
     * init.
     */
    public UserServiceImpl() {
    }

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return this.userDao.findUserList();
    }

    /**
     * set dao.
     *
     * @param userDao user dao
     */
    public void setUserDao(UserDaoImpl userDao) {
        this.userDao = userDao;
    }
}
```
并增加services.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- services -->
    <bean id="userService" class="tech.pdai.springframework.service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions for services go here -->
</beans>
```
- 拦截所有service中的方法，并输出记录
```java
package tech.pdai.springframework.aspect;

import java.lang.reflect.Method;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

/**
 * @author pdai
 */
@Aspect
public class LogAspect {

    /**
     * aspect for every methods under service package.
     */
    @Around("execution(* tech.pdai.springframework.service.*.*(..))")
    public Object businessService(ProceedingJoinPoint pjp) throws Throwable {
        // get attribute through annotation
        Method method = ((MethodSignature) pjp.getSignature()).getMethod();
        System.out.println("execute method: " + method.getName());

        // continue to process
        return pjp.proceed();
    }

}
```
并增加aspects.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd
 http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd
">

    <context:component-scan base-package="tech.pdai.springframework" />

    <aop:aspectj-autoproxy/>

    <bean id="logAspect" class="tech.pdai.springframework.aspect.LogAspect">
        <!-- configure properties of aspect here as normal -->
    </bean>
    <!-- more bean definitions for data access objects go here -->
</beans>
```
- 组装App
```java
package tech.pdai.springframework;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import tech.pdai.springframework.entity.User;
import tech.pdai.springframework.service.UserServiceImpl;

/**
 * @author pdai
 */
public class App {

    /**
     * main interfaces.
     *
     * @param args args
     */
    public static void main(String[] args) {
        // create and configure beans
        ApplicationContext context =
                new ClassPathXmlApplicationContext("aspects.xml", "daos.xml", "services.xml");

        // retrieve configured instance
        UserServiceImpl service = context.getBean("userService", UserServiceImpl.class);

        // use configured instance
        List<User> userList = service.findUserList();

        // print info from beans
        userList.forEach(a -> System.out.println(a.getName() + "," + a.getAge()));
    }
}
```
- 整体结构和运行app
![27.spring-framework-helloworld-5.png](../../assets/images/04-主流框架/spring/27.spring-framework-helloworld-5.png)

## 3.3 这个例子体现了Spring的哪些核心要点
### 3.3.1 控制反转 - IOC
来看第一个需求：查询用户（service通过调用dao查询pojo），本质上如何创建User/Dao/Service等；
- 如果没有Spring框架，我们需要自己创建User/Dao/Service等，比如：
```java
UserDaoImpl userDao = new UserDaoImpl();
UserSericeImpl userService = new UserServiceImpl();
userService.setUserDao(userDao);
List<User> userList = userService.findUserList();
```
- 有了Spring框架，可以将原有Bean的创建工作转给框架, 需要用时从Bean的容器中获取即可，这样便简化了开发工作

Bean的创建和使用分离了。
```java
// create and configure beans
ApplicationContext context =
        new ClassPathXmlApplicationContext("aspects.xml", "daos.xml", "services.xml");

// retrieve configured instance
UserServiceImpl service = context.getBean("userService", UserServiceImpl.class);

// use configured instance
List<User> userList = service.findUserList();
```
![28.spring-framework-helloworld-6.png](../../assets/images/04-主流框架/spring/28.spring-framework-helloworld-6.png)

更进一步，你便能理解为何会有如下的知识点了：
- Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫**控制反转Inversion of Control (IoC)**
- Spring 框架托管创建的Bean放在哪里呢？ 这便是**IoC Container**;
- Spring 框架为了更好让用户配置Bean，必然会引入不同方式来配置Bean？ 这便是xml配置，Java配置，注解配置等
- 支持Spring 框架既然接管了Bean的生成，必然需要管理整个Bean的生命周期等；
- 应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中，这个过程叫**依赖注入(Dependency Injection，DI)**； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是**IoC是设计思想，DI是实现方式**
- 在依赖注入时，有哪些方式呢？这就是构造器方式，@Autowired, @Resource, @Qualifier... 同时Bean之间存在依赖（可能存在先后顺序问题，以及**循环依赖问题**等）
### 3.3.2 面向切面 - AOP
> 来看第二个需求：给Service所有方法调用**添加日志（调用方法时）**，本质上是解耦问题；
- 如果没有Spring框架，我们需要在每个service的方法中都添加记录日志的方法，比如：
```java
/**
* find user list.
*
* @return user list
*/
public List<User> findUserList() {
    System.out.println("execute method findUserList");
    return this.userDao.findUserList();
}
```
- 有了Spring框架，通过@Aspect注解 定义了切面，这个切面中定义了拦截所有service中的方法，并记录日志； 可以明显看到，框架将日志记录和业务需求的代码解耦了，不再是侵入式的了
```java
/**
* aspect for every methods under service package.
*/
@Around("execution(* tech.pdai.springframework.service.*.*(..))")
public Object businessService(ProceedingJoinPoint pjp) throws Throwable {
    // get attribute through annotation
    Method method = ((MethodSignature) pjp.getSignature()).getMethod();
    System.out.println("execute method: " + method.getName());

    // continue to process
    return pjp.proceed();
}
```
更进一步，你便能理解为何会有如下的知识点了：
- Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫**面向切面编程 - Aspect Oriented Programming (AOP)**
- 为什么@Aspect注解使用的是aspectj的jar包呢？这就引出了**Aspect4J和Spring AOP的历史渊源**，只有理解了Aspect4J和Spring的渊源才能理解有些注解上的兼容设计
- 如何支持更多拦截方式来实现解耦， 以满足更多场景需求呢？ 这就是@Around, @Pointcut... 等的设计
- 那么Spring框架又是如何实现AOP的呢？ 这就引入**代理技术，分静态代理和动态代理**，动态代理又包含**JDK代理和CGLIB代理**等
## 3.4 Spring框架设计如何逐步简化开发的
> 通过上述的框架介绍和例子，已经初步知道了Spring设计的两个大的要点：IOC和AOP；从框架的设计角度而言，更为重要的是简化开发，比如提供更为便捷的配置Bean的方式，直至0配置（即约定大于配置）。这里我将通过Spring历史版本的发展，和SpringBoot的推出等，来帮你理解Spring框架是如何逐步简化开发的
### 3.4.1 Java 配置方式改造
在前文的例子中， 通过xml配置方式实现的，这种方式实际上比较麻烦； 我通过Java配置进行改造：

- User，UserDaoImpl, UserServiceImpl，LogAspect不用改
- 将原通过.xml配置转换为Java配置
```java
package tech.pdai.springframework.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
import tech.pdai.springframework.aspect.LogAspect;
import tech.pdai.springframework.dao.UserDaoImpl;
import tech.pdai.springframework.service.UserServiceImpl;

/**
 * @author pdai
 */
@EnableAspectJAutoProxy
@Configuration
public class BeansConfig {

    /**
     * @return user dao
     */
    @Bean("userDao")
    public UserDaoImpl userDao() {
        return new UserDaoImpl();
    }

    /**
     * @return user service
     */
    @Bean("userService")
    public UserServiceImpl userService() {
        UserServiceImpl userService = new UserServiceImpl();
        userService.setUserDao(userDao());
        return userService;
    }

    /**
     * @return log aspect
     */
    @Bean("logAspect")
    public LogAspect logAspect() {
        return new LogAspect();
    }
}
```
- 在App中加载BeansConfig的配置
```java
package tech.pdai.springframework;

import java.util.List;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import tech.pdai.springframework.config.BeansConfig;
import tech.pdai.springframework.entity.User;
import tech.pdai.springframework.service.UserServiceImpl;

/**
 * @author pdai
 */
public class App {

    /**
     * main interfaces.
     *
     * @param args args
     */
    public static void main(String[] args) {
        // create and configure beans
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(BeansConfig.class);

        // retrieve configured instance
        UserServiceImpl service = context.getBean("userService", UserServiceImpl.class);

        // use configured instance
        List<User> userList = service.findUserList();

        // print info from beans
        userList.forEach(a -> System.out.println(a.getName() + "," + a.getAge()));
    }
}
```
- 整体结构和运行app
![29.spring-framework-helloworld-7.png](../../assets/images/04-主流框架/spring/29.spring-framework-helloworld-7.png)
### 3.4.2 注解配置方式改造
更进一步，Java 5开始提供注解支持，Spring 2.5 开始完全支持基于注解的配置并且也支持JSR250 注解。在Spring后续的版本发展倾向于通过注解和Java配置结合使用.
- BeanConfig 不再需要Java配置
```java
package tech.pdai.springframework.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.ComponentScans;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

/**
 * @author pdai
 */
@Configuration
@EnableAspectJAutoProxy
public class BeansConfig {

}
```
- UserDaoImpl 增加了 @Repository注解
```java
/**
 * @author pdai
 */
@Repository
public class UserDaoImpl {

    /**
     * mocked to find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return Collections.singletonList(new User("pdai", 18));
    }
}
```
- UserServiceImpl 增加了@Service 注解，并通过@Autowired注入userDao.
```java
/**
 * @author pdai
 */
@Service
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    @Autowired
    private UserDaoImpl userDao;

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return userDao.findUserList();
    }

}
```
- 在App中扫描tech.pdai.springframework包
```java
package tech.pdai.springframework;

import java.util.List;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import tech.pdai.springframework.entity.User;
import tech.pdai.springframework.service.UserServiceImpl;

/**
 * @author pdai
 */
public class App {

    /**
     * main interfaces.
     *
     * @param args args
     */
    public static void main(String[] args) {
        // create and configure beans
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
                "tech.pdai.springframework");

        // retrieve configured instance
        UserServiceImpl service = context.getBean(UserServiceImpl.class);

        // use configured instance
        List<User> userList = service.findUserList();

        // print info from beans
        userList.forEach(a -> System.out.println(a.getName() + "," + a.getAge()));
    }
}
```
- 整体结构和运行app
![30.spring-framework-helloworld-9.png](../../assets/images/04-主流框架/spring/30.spring-framework-helloworld-9.png)
### 3.4.3 SpringBoot托管配置
Springboot实际上通过约定大于配置的方式，使用xx-starter统一的对Bean进行默认初始化，用户只需要很少的配置就可以进行开发了。

这个因为很多开发者都是从SpringBoot开始着手开发的，所以这个比较好理解。我们需要的是将知识点都串联起来，构筑认知体系。
## 3.5 结合Spring历史版本和SpringBoot看发展
最后结合Spring历史版本总结下它的发展：（这样是不是能够帮助你在整体上构建了知识体系的认知了呢？）
![31.spring-framework-helloworld-8.png](../../assets/images/04-主流框架/spring/31.spring-framework-helloworld-8.png)
# 四、Spring基础 - Spring核心之控制反转(IOC)
## 4.1 引入
> 我们在Spring基础 - Spring简单例子引入Spring的核心中向你展示了IoC的基础含义，同时以此发散了一些IoC相关知识点。
- Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫**控制反转Inversion of Control (IoC)**
- Spring 框架托管创建的Bean放在哪里呢？ 这便是**IoC Container**;
- Spring 框架为了更好让用户配置Bean，必然会引入不同方式来配置Bean？ 这便是xml配置，Java配置，注解配置等
- 支持Spring 框架既然接管了Bean的生成，必然需要管理整个Bean的生命周期等；
- 应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中，这个过程叫**依赖注入(Dependency Injection，DI)**； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是**IoC是设计思想，DI是实现方式**
- 在依赖注入时，有哪些方式呢？这就是构造器方式，@Autowired, @Resource, @Qualifier... 同时Bean之间存在依赖（可能存在先后顺序问题，以及**循环依赖问题**等）

本节将在此基础上进一步解读IOC的含义以及IOC的使用方式；后续的文章还将深入IOC的实现原理：
- Spring进阶- Spring IOC实现原理详解之IOC体系结构设计
- Spring进阶- Spring IOC实现原理详解之IOC初始化流程
- Spring进阶- Spring IOC实现原理详解之Bean的注入和生命周期
## 4.2 如何理解IoC
如果你有精力看英文，首推 Martin Fowler大师的 <a href = 'https://www.martinfowler.com/articles/injection.html'>Inversion of Control Containers and the Dependency Injection pattern</a>；其次IoC作为一种设计思想，不要过度解读，而是应该简化理解，所以我这里也整合了 张开涛早前的博客<a href = 'https://www.iteye.com/blog/jinnianshilongnian-1413846'>IoC基础</a>并加入了自己的理解。
### 4.2.1 Spring Bean是什么
> IoC Container管理的是Spring Bean， 那么Spring Bean是什么呢？

Spring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。
### 4.2.2 IoC是什么
> Ioc—Inversion of Control，即“控制反转”，**不是什么技术，而是一种设计思想**。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

我们来深入分析一下：
- 谁控制谁，控制什么？

传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。
- 为何是反转，哪些方面反转了?

有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。
- 用图例说明一下?

传统程序设计下，都是主动去创建相关对象然后再组合起来：
![32.spring-framework-ioc-1.png](../../assets/images/04-主流框架/spring/32.spring-framework-ioc-1.png)

当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图

![33.spring-framework-ioc-2.png](../../assets/images/04-主流框架/spring/33.spring-framework-ioc-2.png)
### 4.2.3 IoC能做什么
> **IoC 不是一种技术，只是一种思想**，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。

传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；**有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。**

其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。

IoC很好的体现了面向对象设计法则之一——**好莱坞法则：“别找我们，我们找你”**；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。

### 4.2.4 IoC和DI是什么关系
> 控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是**IoC是设计思想，DI是实现方式。**

DI—Dependency Injection，即依赖注入：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

我们来深入分析一下：
- 谁依赖于谁？

当然是应用程序依赖于IoC容器；
- 为什么需要依赖？

应用程序需要IoC容器来提供对象需要的外部资源；
- 谁注入谁？

很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；
- 注入了什么？

就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。
- IoC和DI有什么关系呢？

其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。通俗来说就是IoC是设计思想，DI是实现方式。
## 4.3 Ioc 配置的三种方式
> 在Spring基础 - Spring简单例子引入Spring的核心已经给出了三种配置方式，这里再总结下；总体上目前的主流方式是 注解 + Java 配置。
### 4.3.1 xml 配置
顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。
- 优点： 可以使用于任何场景，结构清晰，通俗易懂
- 缺点： 配置繁琐，不易维护，枯燥无味，扩展性差

**举例：**
1. 配置xx.xml文件
2. 声明命名空间和配置bean
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- services -->
    <bean id="userService" class="tech.pdai.springframework.service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions for services go here -->
</beans>
```
### 4.3.2 Java 配置
将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。其本质上就是把在XML上的配置声明转移到Java配置类中
- 优点：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活
- 缺点：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差

**举例：**
1. 创建一个配置类， 添加@Configuration注解声明为配置类
2. 创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解
```java
/**
 * @author pdai
 */
@Configuration
public class BeansConfig {

    /**
     * @return user dao
     */
    @Bean("userDao")
    public UserDaoImpl userDao() {
        return new UserDaoImpl();
    }

    /**
     * @return user service
     */
    @Bean("userService")
    public UserServiceImpl userService() {
        UserServiceImpl userService = new UserServiceImpl();
        userService.setUserDao(userDao());
        return userService;
    }
}
```
### 4.3.3 注解配置
通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。
- 优点：开发便捷，通俗易懂，方便维护。
- 缺点：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置

**举例：**
1. 对类添加@Component相关的注解，比如@Controller，@Service，@Repository
2. 设置ComponentScan的basePackage, 比如`<context:component-scan base-package='tech.pdai.springframework'>`, 或者`@ComponentScan("tech.pdai.springframework")`注解，或者`new AnnotationConfigApplicationContext("tech.pdai.springframework")`指定扫描的basePackage.
```java
/**
 * @author pdai
 */
@Service
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    @Autowired
    private UserDaoImpl userDao;

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return userDao.findUserList();
    }

}
```
## 4.4 依赖注入的三种方式
> 常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，字段(属性)注入
### 4.4.1 setter方式
- 在**XML配置方式**中，property都是setter方式注入，比如下面的xml:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- services -->
    <bean id="userService" class="tech.pdai.springframework.service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions for services go here -->
</beans>
```
本质上包含两步：

1. 第一步，需要new UserServiceImpl()创建对象, 所以需要默认构造函数
2. 第二步，调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数

所以对应的service类是这样的：
```java
/**
 * @author pdai
 */
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    private UserDaoImpl userDao;

    /**
     * init.
     */
    public UserServiceImpl() {
    }

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return this.userDao.findUserList();
    }

    /**
     * set dao.
     *
     * @param userDao user dao
     */
    public void setUserDao(UserDaoImpl userDao) {
        this.userDao = userDao;
    }
}
```
- 在注解和Java配置方式下
```java
/**
 * @author pdai
 */
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    private UserDaoImpl userDao;

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return this.userDao.findUserList();
    }

    /**
     * set dao.
     *
     * @param userDao user dao
     */
    @Autowired
    public void setUserDao(UserDaoImpl userDao) {
        this.userDao = userDao;
    }
}
```
在Spring3.x刚推出的时候，推荐使用注入的就是这种, 但是这种方式比较麻烦，所以在Spring4.x版本中推荐构造函数注入。

### 4.4.2 构造函数
- 在**XML配置方式**中，`<constructor-arg>`是通过构造函数参数注入，比如下面的xml:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!-- services -->
    <bean id="userService" class="tech.pdai.springframework.service.UserServiceImpl">
        <constructor-arg name="userDao" ref="userDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>
    <!-- more bean definitions for services go here -->
</beans>
```
本质上是new UserServiceImpl(userDao)创建对象, 所以对应的service类是这样的：
```java
/**
 * @author pdai
 */
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    private final UserDaoImpl userDao;

    /**
     * init.
     * @param userDaoImpl user dao impl
     */
    public UserServiceImpl(UserDaoImpl userDaoImpl) {
        this.userDao = userDaoImpl;
    }

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return this.userDao.findUserList();
    }

}
```
- 在注解和Java配置方式下
```java
/**
 * @author pdai
 */
 @Service
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    private final UserDaoImpl userDao;

    /**
     * init.
     * @param userDaoImpl user dao impl
     */
    @Autowired // 这里@Autowired也可以省略
    public UserServiceImpl(final UserDaoImpl userDaoImpl) {
        this.userDao = userDaoImpl;
    }

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return this.userDao.findUserList();
    }

}
```
在Spring4.x版本中推荐的注入方式就是这种， 具体原因看后续章节。

### 4.4.3 字段(属性)注入
以@Autowired（自动注入）注解注入为例，字段注入（也称为属性注入）是将依赖直接注入到类的字段上，而不需要通过构造器或setter方法。Spring默认按类型（byType）进行匹配，但也可以通过注解调整匹配策略。

- **byType**：默认方式，Spring会根据字段的类型在容器中查找匹配的bean。如果容器中只有一个与字段类型一致的bean，则注入成功；如果找到多个同类型bean，Spring会抛出异常，此时需要结合@Qualifier注解按名称区分。
- **byName**：如果需要按名称注入，可以在@Autowired基础上添加@Qualifier注解，指定bean的名称（即bean的id）。字段注入本身不直接支持基于setter方法名的byName匹配，但@Qualifier可以实现类似效果。

字段注入的优点是代码简洁，但缺点是隐藏了依赖关系，不利于单元测试和代码的可维护性。因此，Spring官方推荐优先使用构造器注入。

示例代码：
```java
/**
 * @author pdai
 */
@Service
public class UserServiceImpl {

    /**
     * user dao impl. 通过@Autowired直接注入字段，默认按类型匹配。
     */
    @Autowired
    private UserDaoImpl userDao;

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return userDao.findUserList();
    }

}
```

如果存在多个同类型bean，需要使用@Qualifier按名称注入：
```java
@Service
public class UserServiceImpl {

    @Autowired
    @Qualifier("userDaoImpl") // 指定bean名称，按名称注入
    private UserDao userDao;

    // ... 其他代码
}
```
## 4.5 IoC和DI使用问题小结
> 这里总结下实际开发中会遇到的一些问题：

### 4.5.1 为什么推荐构造器注入方式？
先来看看Spring在文档里怎么说：
> The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state.
> 
> Spring 团队通常提倡构造函数注入，因为它允许将应用程序组件实现为不可变对象，并确保所需的依赖项不为空。此外，构造函数注入的组件始终以完全初始化的状态返回给客户端（调用）代码。

简单的翻译一下：这个构造器注入的方式**能够保证注入的组件不可变，并且确保需要的依赖不为空**。此外，**构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态**。

下面来简单的解释一下：
- **依赖不可变**：其实说的就是final关键字。
- **依赖不为空（省去了我们对其检查）**：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数->传入，OK 。2：无该类型的参数->报错。
- **完全初始化的状态**：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。

所以通常是这样的
```java
/**
 * @author pdai
 */
 @Service
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    private final UserDaoImpl userDao;

    /**
     * init.
     * @param userDaoImpl user dao impl
     */
    public UserServiceImpl(final UserDaoImpl userDaoImpl) {
        this.userDao = userDaoImpl;
    }

}
```
如果使用setter注入，缺点显而易见，对于IOC容器以外的环境，除了使用反射来提供它需要的依赖之外，**无法复用该实现类**。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NPE的存在。
```java
// 这里只是模拟一下，正常来说我们只会暴露接口给客户端，不会暴露实现。
UserServiceImpl userService = new UserServiceImpl();
userService.findUserList(); // -> NullPointerException, 潜在的隐患
```
**循环依赖的问题**：使用field注入可能会导致循环依赖，即A里面注入B，B里面又注入A：
```java
public class A {
    @Autowired
    private B b;
}

public class B {
    @Autowired
    private A a;
}
```
如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错。
### 4.5.2 我在使用构造器注入方式时注入了太多的类导致Bad Smell怎么办？
比如当你一个Controller中注入了太多的Service类，Sonar会给你提示相关告警
![34.spring-framework-ioc-3.png](../../assets/images/04-主流框架/spring/34.spring-framework-ioc-3.png)

对于这个问题，说明你的类当中有太多的责任，那么你要好好想一想是不是自己违反了类的**单一性职责原则**，从而导致有这么多的依赖要注入。
### 4.5.3 @Autowired和@Resource以及@Inject等注解注入有何区别？
#### 4.5.3.1 @Autowired
- Autowired注解源码

在Spring 2.5 引入了 @Autowired 注解
```java
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
  boolean required() default true;
}
```
从Autowired注解源码上看，可以使用在下面这些地方：
```java
@Target(ElementType.CONSTRUCTOR) #构造函数
@Target(ElementType.METHOD) #方法
@Target(ElementType.PARAMETER) #方法参数
@Target(ElementType.FIELD) #字段、枚举的常量
@Target(ElementType.ANNOTATION_TYPE) #注解
```
还有一个value属性，默认是true。
- 简单总结：
1. @Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入
2. @Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE
3. @Autowired默认是根据类型（byType ）进行自动装配的
4. 如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合@Qualifier。
5. 指定名称后，如果Spring IOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常
- 简单使用代码：

在字段属性上。
```java
@Autowired
private HelloDao helloDao;
```
或者
```java
private HelloDao helloDao;
public HelloDao getHelloDao() {
 return helloDao;
}
@Autowired
public void setHelloDao(HelloDao helloDao) {
 this.helloDao = helloDao;
}
```
或者
```java
private HelloDao helloDao;
//@Autowired
public HelloServiceImpl(@Autowired HelloDao helloDao) {
 this.helloDao = helloDao;
}
// 构造器注入也可不写@Autowired，也可以注入成功。
```
将@Autowired写在被注入的成员变量上，setter或者构造器上，就不用再xml文件中配置了。

如果有多个类型一样的Bean候选者，则默认根据设定的属性名称进行获取。如 HelloDao 在Spring中有 helloWorldDao 和 helloDao 两个Bean候选者。
```java
@Autowired
private HelloDao helloDao;
```
首先根据类型获取，发现多个HelloDao，然后根据helloDao进行获取，如果要获取限定的其中一个候选者，结合@Qualifier进行注入。
```java
@Autowired
@Qualifier("helloWorldDao")
private HelloDao helloDao;
```
注入名称为helloWorldDao 的Bean组件。@Qualifier("XXX") 中的 XX是 Bean 的名称，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。

多个类型一样的Bean候选者，也可以@Primary进行使用，设置首选的组件，也就是默认优先使用哪一个。

注意：使用@Qualifier 时候，如何设置的指定名称的Bean不存在，则会抛出异常，如果防止抛出异常，可以使用：
```java
@Qualifier("xxxxyyyy")
@Autowired(required = false)
private HelloDao helloDao;
```
在SpringBoot中也可以使用@Bean+@Autowired进行组件注入，将@Autowired加到参数上，其实也可以省略。
```java
@Bean
public Person getPerson(@Autowired Car car){
 return new Person();
}
// @Autowired 其实也可以省略
```
#### 4.5.3.2 @Resource
- Resource注解源码
```java
@Target({TYPE, FIELD, METHOD})
@Retention(RUNTIME)
public @interface Resource {
    String name() default "";
    // 其他省略
}
```
从Resource注解源码上看，可以使用在下面这些地方：
```java
@Target(ElementType.TYPE) #接口、类、枚举、注解
@Target(ElementType.FIELD) #字段、枚举的常量
@Target(ElementType.METHOD) #方法
```
name 指定注入指定名称的组件。
- 简单总结：
1. @Resource是JSR250规范的实现，在javax.annotation包下
2. @Resource可以作用TYPE、FIELD、METHOD上
3. @Resource是默认根据属性名称进行自动装配的，如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入
4. 在Spring容器解析@Resource注解时，使用的后置处理器为CommonAnnotationBeanPostProcessor
5.  默认是按照组件名称进行装配的，根据@Resource注解name属性的名称去容器中查找，如果name没有指定，则根据标注了@Resource的属性名称去判断容器中是否存在该名称的bean，如果不存在，则会走和@Autowired一样的逻辑，这个时候就会支持@Primary注解（有的博客说不支持，那么错误的，源码不会骗人）。
- 简单使用代码：
```java
@Component
public class SuperMan {
    @Resource
    private Car car;
}
```
按照属性名称 car 注入容器中的组件。如果容器中BMW还有BYD两种类型组件。指定加入BMW。如下代码：
```java
@Component
public class SuperMan {
    @Resource(name = "BMW")
    private Car car;
}
```
name 的作用类似 @Qualifier

#### 4.5.3.3 @Inject
- Inject注解源码
```java
@Target({ METHOD, CONSTRUCTOR, FIELD })
@Retention(RUNTIME)
@Documented
public @interface Inject {}
```
从Inject注解源码上看，可以使用在下面这些地方：
```java
@Target(ElementType.CONSTRUCTOR) #构造函数
@Target(ElementType.METHOD) #方法
@Target(ElementType.FIELD) #字段、枚举的常量
```
- 简单总结：
1. @Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject jar包 ，才能实现注入
2. @Inject可以作用CONSTRUCTOR、METHOD、FIELD上
3. @Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；
4. .在Spring容器解析@Inject注解时，使用的后置处理器和@Autowired是一样的，都是AutowiredAnnotationBeanPostProcessor。
5. 由于@Inject注解没有属性，在加载所需bean失败时，会报错
- 简单使用代码：
```java
@Inject
private Car car;
```
指定加入BMW组件。
```java
@Inject
@Named("BMW")
private Car car;
```
@Named 的作用类似 @Qualifier！

#### 总结
1. @Autowired是Spring自带的，@Resource是JSR250规范实现的，@Inject是JSR330规范实现的
2. @Autowired、@Inject用法基本一样，不同的是@Inject没有required属性
3. @Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的
4. @Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定

如果你还期望源码层理解，我给你找了一篇文章Spring源码分析<a href = 'https://blog.csdn.net/qq_35634181/article/details/104802906'>@Autowired、@Resource注解的区别</a>
# 五、Spring基础 - Spring核心之面向切面编程(AOP)
## 5.1 引入
> 我们在Spring基础 - Spring简单例子引入Spring的核心中向你展示了AOP的基础含义，同时以此发散了一些AOP相关知识点。
- Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫**面向切面编程 - Aspect Oriented Programming (AOP)**
- 为什么@Aspect注解使用的是aspectj的jar包呢？这就引出了**Aspect4J和Spring AOP的历史渊源**，只有理解了Aspect4J和Spring的渊源才能理解有些注解上的兼容设计
- 如何支持更多拦截方式来实现解耦， 以满足更多场景需求呢？ 这就是@Around, @Pointcut... 等的设计
- 那么Spring框架又是如何实现AOP的呢？ 这就引入**代理技术，分静态代理和动态代理**，动态代理又包含**JDK代理和CGLIB代理**等

本节将在此基础上进一步解读AOP的含义以及AOP的使用方式；后续的文章还将深入AOP的实现原理：
- Spring进阶 - Spring AOP实现原理详解之切面实现
- Spring进阶 - Spring AOP实现原理详解之AOP代理
## 5.2 如何理解AOP
> AOP的本质也是为了解耦，它是一种设计思想； 在理解时也应该简化理解。
### 5.2.1 AOP是什么
> AOP为Aspect Oriented Programming的缩写，意为：面向切面编程

AOP最早是AOP联盟的组织提出的,指定的一套规范,spring将AOP的思想引入框架之中,通过**预编译方式和运行期间动态代理**实现程序的统一维护的一种技术,
- 先来看一个例子， 如何给如下UserServiceImpl中所有方法添加进入方法的日志，
```java
/**
 * @author pdai
 */
public class UserServiceImpl implements IUserService {

    /**
     * find user list.
     *
     * @return user list
     */
    @Override
    public List<User> findUserList() {
        System.out.println("execute method： findUserList");
        return Collections.singletonList(new User("pdai", 18));
    }

    /**
     * add user
     */
    @Override
    public void addUser() {
        System.out.println("execute method： addUser");
        // do something
    }

}
```
我们将记录日志功能解耦为日志切面，它的目标是解耦。进而引出AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过**横向切割**的方式抽取到一个独立的模块中！
![35.spring-framework-aop-4.png](../../assets/images/04-主流框架/spring/35.spring-framework-aop-4.png)

OOP面向对象编程，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程的中各部分之间低耦合的隔离效果。这两种设计思想在目标上有着本质的差异。
![4.spring-framework-aop-2.png](../../assets/images/04-主流框架/spring/4.spring-framework-aop-2.png)
### 5.2.2 AOP术语
> 首先让我们从一些重要的AOP概念和术语开始。**这些术语不是Spring特有的**。
- `连接点（Jointpoint）`：表示需要在程序中插入横切关注点的扩展点，连接点可能是**类初始化、方法执行、方法调用、字段调用或处理异常**等等，`Spring只支持方法执行连接点`，在AOP中表示为**在哪里干**；
- `切入点（Pointcut）`： 选择一组相关连接点的模式，即可以认为**连接点的集合**，`Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法`，在AOP中表示为**在哪里干的集合**；
- `通知（Advice）`：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在`Spring中通过代理模式实现AOP`，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为**干什么**；
- `方面/切面（Aspect）`：横切关注点的模块化，比如上边提到的日志组件。可以认为是**通知、引入和切入点的组合**；`在Spring中可以使用Schema和@AspectJ方式进行组织实现`；在AOP中表示为**在哪干和干什么集合**；
- `引入（inter-type declaration）`：也称为内部类型声明，为已有的类添加额外新的字段或方法，`Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）`, 在AOP中表示为**干什么（引入什么）**；
- `目标对象（Target Object）`：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为**对谁干**；
- `织入（Weaving）`：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。`Spring和其他纯Java AOP框架一样，在运行时完成织入`。在AOP中表示为**怎么实现的**；
- `AOP代理（AOP Proxy）`：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。`在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现`，而通过拦截器模型应用切面。在AOP中表示为**怎么实现的一种典型方式**；
> 通知类型：
- `前置通知（Before advice）`：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。
- `后置通知（After returning advice）`：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。
- `异常通知（After throwing advice）`：在方法抛出异常退出时执行的通知。
- `最终通知（After (finally) advice）`：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。
- `环绕通知（Around Advice）`：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。

环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知，我们推荐你使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成同样的事情。用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要在JoinPoint上调用用于环绕通知的proceed()方法，就不会有调用的问题。
> 我们把这些术语串联到一起，方便理解
![36.spring-framework-aop-3.png](../../assets/images/04-主流框架/spring/36.spring-framework-aop-3.png)
## 5.3 Spring AOP和AspectJ是什么关系
- 首先AspectJ是什么？

AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）

可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。
- 其次，为什么需要理清楚Spring AOP和AspectJ的关系？

我们看下@Aspect以及增强的几个注解，为什么不是Spring包，而是来源于aspectJ呢？
![37.spring-framework-aop-5.png](../../assets/images/04-主流框架/spring/37.spring-framework-aop-5.png)
- Spring AOP和AspectJ是什么关系？
1. AspectJ是更强的AOP框架，是实际意义的AOP标准；
2. Spring为何不写类似AspectJ的框架？ Spring AOP使用纯Java实现, 它不需要专门的编译过程, 它一个重要的原则就是无侵入性（non-invasiveness）; Spring 小组完全有能力写类似的框架，只是Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring的开发小组相信无论是基于代理（proxy-based）的框架如Spring AOP或者是成熟的框架如AspectJ都是很有价值的，他们之间应该是互补而不是竞争的关系。
3. Spring小组喜欢@AspectJ注解风格更胜于Spring XML配置； 所以在Spring 2.0使用了和AspectJ 5一样的注解，并使用AspectJ来做切入点解析和匹配。但是，AOP在运行时仍旧是纯的Spring AOP，并不依赖于AspectJ的编译器或者织入器（weaver）。
4. Spring 2.5对AspectJ的支持：在一些环境下，增加了对AspectJ的装载时编织支持，同时提供了一个新的bean切入点。
- 更多关于AspectJ？

了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。

对于这个过程，一般分为**动态织入**和**静态织入**：

1. 动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，`Spring AOP采用的就是基于运行时增强的代理技术`
2. ApectJ采用的就是静态织入的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。
![38.spring-framework-aop-6.png](../../assets/images/04-主流框架/spring/38.spring-framework-aop-6.png)

| 特性         | Spring AOP       | AspectJ          |
|--------------|------------------|------------------|
| **织入时机** | 运行时（动态）   | 主要编译时/加载时（静态） |
| **支持范围** | 方法级别         | 全范围（方法、字段等） |
| **性能**     | 较低（代理开销） | 较高（无运行时开销） |
| **依赖性**   | 依赖 Spring 容器 | 可独立使用       |
| **配置复杂度** | **极简**。在 Spring Boot 中，只需添加 `@EnableAspectJAutoProxy`（通常已默认开启）即可开始使用。 | **复杂**。需要显式配置织入器，并可能改变项目的构建流程。 |
| **构建/编译依赖** | **无额外依赖**。利用 Spring IoC 容器和动态代理，与标准 Java 编译流程完全一致。 | **需要额外的织入步骤**。必须引入 AspectJ 的织入器来修改字节码。 |
| **打包部署** | **无影响**。与普通 Spring 应用打包方式完全相同。 | **有影响**。需要确保织入过程在编译时或加载时正确完成，可能会增加部署复杂度。 |

**一言以蔽之：Spring AOP 提供了“开箱即用”的便利，而 AspectJ 提供了“专业强大”的功能，但需要付出配置和学习的成本。**
## 5.4 AOP的配置方式
> Spring AOP 支持对XML模式和基于@AspectJ注解的两种配置方式。
### 5.4.1 XML Schema配置方式
Spring提供了使用"aop"命名空间来定义一个切面，我们来看个例子：
- 定义目标类
```java
package tech.pdai.springframework.service;

/**
 * @author pdai
 */
public class AopDemoServiceImpl {

    public void doMethod1() {
        System.out.println("AopDemoServiceImpl.doMethod1()");
    }

    public String doMethod2() {
        System.out.println("AopDemoServiceImpl.doMethod2()");
        return "hello world";
    }

    public String doMethod3() throws Exception {
        System.out.println("AopDemoServiceImpl.doMethod3()");
        throw new Exception("some exception");
    }
}
```
- 定义切面类
```java
package tech.pdai.springframework.aspect;

import org.aspectj.lang.ProceedingJoinPoint;

/**
 * @author pdai
 */
public class LogAspect {

    /**
     * 环绕通知.
     *
     * @param pjp pjp
     * @return obj
     * @throws Throwable exception
     */
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("-----------------------");
        System.out.println("环绕通知: 进入方法");
        Object o = pjp.proceed();
        System.out.println("环绕通知: 退出方法");
        return o;
    }

    /**
     * 前置通知.
     */
    public void doBefore() {
        System.out.println("前置通知");
    }

    /**
     * 后置通知.
     *
     * @param result return val
     */
    public void doAfterReturning(String result) {
        System.out.println("后置通知, 返回值: " + result);
    }

    /**
     * 异常通知.
     *
     * @param e exception
     */
    public void doAfterThrowing(Exception e) {
        System.out.println("异常通知, 异常: " + e.getMessage());
    }

    /**
     * 最终通知.
     */
    public void doAfter() {
        System.out.println("最终通知");
    }

}
```
- XML配置AOP
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd
 http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd
">

    <context:component-scan base-package="tech.pdai.springframework" />

    <aop:aspectj-autoproxy/>

    <!-- 目标类 -->
    <bean id="demoService" class="tech.pdai.springframework.service.AopDemoServiceImpl">
        <!-- configure properties of bean here as normal -->
    </bean>

    <!-- 切面 -->
    <bean id="logAspect" class="tech.pdai.springframework.aspect.LogAspect">
        <!-- configure properties of aspect here as normal -->
    </bean>

    <aop:config>
        <!-- 配置切面 -->
        <aop:aspect ref="logAspect">
            <!-- 配置切入点 -->
            <aop:pointcut id="pointCutMethod" expression="execution(* tech.pdai.springframework.service.*.*(..))"/>
            <!-- 环绕通知 -->
            <aop:around method="doAround" pointcut-ref="pointCutMethod"/>
            <!-- 前置通知 -->
            <aop:before method="doBefore" pointcut-ref="pointCutMethod"/>
            <!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object -->
            <aop:after-returning method="doAfterReturning" pointcut-ref="pointCutMethod" returning="result"/>
            <!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型-->
            <aop:after-throwing method="doAfterThrowing" pointcut-ref="pointCutMethod" throwing="e"/>
            <!-- 最终通知 -->
            <aop:after method="doAfter" pointcut-ref="pointCutMethod"/>
        </aop:aspect>
    </aop:config>

    <!-- more bean definitions for data access objects go here -->
</beans>
```
- 测试类
```java
/**
  * main interfaces.
  *
  * @param args args
  */
public static void main(String[] args) {
    // create and configure beans
    ApplicationContext context = new ClassPathXmlApplicationContext("aspects.xml");

    // retrieve configured instance
    AopDemoServiceImpl service = context.getBean("demoService", AopDemoServiceImpl.class);

    // use configured instance
    service.doMethod1();
    service.doMethod2();
    try {
        service.doMethod3();
    } catch (Exception e) {
        // e.printStackTrace();
    }
}
```
- 输出结果
```java
-----------------------
环绕通知: 进入方法
前置通知
AopDemoServiceImpl.doMethod1()
环绕通知: 退出方法
最终通知
-----------------------
环绕通知: 进入方法
前置通知
AopDemoServiceImpl.doMethod2()
环绕通知: 退出方法
最终通知
后置通知, 返回值: hello world
-----------------------
环绕通知: 进入方法
前置通知
AopDemoServiceImpl.doMethod3()
最终通知
异常通知, 异常: some exception
```
### 5.4.2 AspectJ注解方式
基于XML的声明式AspectJ存在一些不足，需要在Spring配置文件配置大量的代码信息，为了解决这个问题，Spring 使用了@AspectJ框架为AOP的实现提供了一套注解。


| 注解名称 | 用途说明 | 关键属性及说明 |
|---------|---------|--------------|
| **@Aspect** | 定义一个切面类 | 无特殊属性，标记类为切面 |
| **@Pointcut** | 定义切入点表达式 | `value`：切入点表达式<br>需搭配空方法体方法签名 |
| **@Before** | 定义前置通知（目标方法执行前） | `value`：指定切入点表达式 |
| **@AfterReturning** | 定义后置通知（目标方法正常返回后） | `value/pointcut`：切入点表达式<br>`returning`：接收返回值的形参名 |
| **@Around** | 定义环绕通知（包裹目标方法） | `value`：指定切入点表达式 |
| **@AfterThrowing** | 定义异常通知（目标方法抛出异常时） | `value/pointcut`：切入点表达式<br>`throwing`：接收异常的形参名 |
| **@After** | 定义最终通知（无论是否异常都会执行） | `value`：指定切入点表达式 |
| **@DeclareParents** | 定义引介通知（为类添加新接口） | `value`：目标类型模式<br>`defaultImpl`：默认实现类 |

补充说明：

- **@Pointcut** 需要配合方法签名使用，方法返回类型必须为 `void`，方法体为空
- 所有通知注解都支持直接定义切入点表达式或引用已有的 `@Pointcut` 定义
- **@Around** 是最强大的通知类型，可以控制是否执行目标方法以及返回值处理


> Spring AOP的实现方式是动态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的；如Java JDK的动态代理(Proxy，底层通过反射实现)或者CGLIB的动态代理(底层通过继承实现)，Spring AOP采用的就是基于运行时增强的代理技术。
#### 5.4.2.1 接口使用JDK代理
- 定义接口
```java
/**
 * Jdk Proxy Service.
 *
 * @author pdai
 */
public interface IJdkProxyService {

    void doMethod1();

    String doMethod2();

    String doMethod3() throws Exception;
}
```
- 实现类
```java
/**
 * @author pdai
 */
@Service
public class JdkProxyDemoServiceImpl implements IJdkProxyService {

    @Override
    public void doMethod1() {
        System.out.println("JdkProxyServiceImpl.doMethod1()");
    }

    @Override
    public String doMethod2() {
        System.out.println("JdkProxyServiceImpl.doMethod2()");
        return "hello world";
    }

    @Override
    public String doMethod3() throws Exception {
        System.out.println("JdkProxyServiceImpl.doMethod3()");
        throw new Exception("some exception");
    }
}
```
- 定义切面
```java
package tech.pdai.springframework.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
import org.springframework.stereotype.Component;

/**
 * @author pdai
 */
@EnableAspectJAutoProxy
@Component
@Aspect
public class LogAspect {

    /**
     * define point cut.
     */
    @Pointcut("execution(* tech.pdai.springframework.service.*.*(..))")
    private void pointCutMethod() {
    }


    /**
     * 环绕通知.
     *
     * @param pjp pjp
     * @return obj
     * @throws Throwable exception
     */
    @Around("pointCutMethod()")
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("-----------------------");
        System.out.println("环绕通知: 进入方法");
        Object o = pjp.proceed();
        System.out.println("环绕通知: 退出方法");
        return o;
    }

    /**
     * 前置通知.
     */
    @Before("pointCutMethod()")
    public void doBefore() {
        System.out.println("前置通知");
    }


    /**
     * 后置通知.
     *
     * @param result return val
     */
    @AfterReturning(pointcut = "pointCutMethod()", returning = "result")
    public void doAfterReturning(String result) {
        System.out.println("后置通知, 返回值: " + result);
    }

    /**
     * 异常通知.
     *
     * @param e exception
     */
    @AfterThrowing(pointcut = "pointCutMethod()", throwing = "e")
    public void doAfterThrowing(Exception e) {
        System.out.println("异常通知, 异常: " + e.getMessage());
    }

    /**
     * 最终通知.
     */
    @After("pointCutMethod()")
    public void doAfter() {
        System.out.println("最终通知");
    }

}
```
- 输出
```java
-----------------------
环绕通知: 进入方法
前置通知
JdkProxyServiceImpl.doMethod1()
最终通知
环绕通知: 退出方法
-----------------------
环绕通知: 进入方法
前置通知
JdkProxyServiceImpl.doMethod2()
后置通知, 返回值: hello world
最终通知
环绕通知: 退出方法
-----------------------
环绕通知: 进入方法
前置通知
JdkProxyServiceImpl.doMethod3()
异常通知, 异常: some exception
最终通知
```
#### 5.4.2.2 非接口使用Cglib代理
- 类定义
```java
/**
 * Cglib proxy.
 *
 * @author pdai
 */
@Service
public class CglibProxyDemoServiceImpl {

    public void doMethod1() {
        System.out.println("CglibProxyDemoServiceImpl.doMethod1()");
    }

    public String doMethod2() {
        System.out.println("CglibProxyDemoServiceImpl.doMethod2()");
        return "hello world";
    }

    public String doMethod3() throws Exception {
        System.out.println("CglibProxyDemoServiceImpl.doMethod3()");
        throw new Exception("some exception");
    }
}
```
- 切面定义

和上面相同

- 输出
```java
-----------------------
环绕通知: 进入方法
前置通知
CglibProxyDemoServiceImpl.doMethod1()
最终通知
环绕通知: 退出方法
-----------------------
环绕通知: 进入方法
前置通知
CglibProxyDemoServiceImpl.doMethod2()
后置通知, 返回值: hello world
最终通知
环绕通知: 退出方法
-----------------------
环绕通知: 进入方法
前置通知
CglibProxyDemoServiceImpl.doMethod3()
异常通知, 异常: some exception
最终通知
```
## 5.5 AOP使用问题小结
### 5.5.1 切入点（pointcut）的申明规则?

Spring AOP 用户可能会经常使用 execution切入点指示符。执行表达式的格式如下：
```java
execution（modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern（param-pattern） throws-pattern?）
```
- `ret-type-pattern` 返回类型模式, `name-pattern`名字模式和`param-pattern`参数模式是必选的， 其它部分都是可选的。返回类型模式决定了方法的返回类型必须依次匹配一个连接点。 你会使用的最频繁的返回类型模式是`*`，它代表了匹配任意的返回类型。
- `declaring-type-pattern`, 一个全限定的类型名将只会匹配返回给定类型的方法。
- `name-pattern` 名字模式匹配的是方法名。 你可以使用`*`通配符作为所有或者部分命名模式。
- `param-pattern` 参数模式稍微有点复杂：`()`匹配了一个不接受任何参数的方法， 而`(..)`匹配了一个接受任意数量参数的方法（零或者更多）。 模式`(*)`匹配了一个接受一个任何类型的参数的方法。 模式`(*,String)`匹配了一个接受两个参数的方法，第一个可以是任意类型， 第二个则必须是String类型。

对应到我们上面的例子：
![39.spring-framework-aop-7.png](../../assets/images/04-主流框架/spring/39.spring-framework-aop-7.png)

下面给出一些通用切入点表达式的例子。
```java
// 任意公共方法的执行：
execution（public * *（..））

// 任何一个名字以“set”开始的方法的执行：
execution（* set*（..））

// AccountService接口定义的任意方法的执行：
execution（* com.xyz.service.AccountService.*（..））

// 在service包中定义的任意方法的执行：
execution（* com.xyz.service.*.*（..））

// 在service包或其子包中定义的任意方法的执行：
execution（* com.xyz.service..*.*（..））

// 在service包中的任意连接点（在Spring AOP中只是方法执行）：
within（com.xyz.service.*）

// 在service包或其子包中的任意连接点（在Spring AOP中只是方法执行）：
within（com.xyz.service..*）

// 实现了AccountService接口的代理对象的任意连接点 （在Spring AOP中只是方法执行）：
this（com.xyz.service.AccountService）// 'this'在绑定表单中更加常用

// 实现AccountService接口的目标对象的任意连接点 （在Spring AOP中只是方法执行）：
target（com.xyz.service.AccountService） // 'target'在绑定表单中更加常用

// 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点（在Spring AOP中只是方法执行）
args（java.io.Serializable） // 'args'在绑定表单中更加常用; 请注意在例子中给出的切入点不同于 execution(* *(java.io.Serializable))： args版本只有在动态运行时候传入参数是Serializable时才匹配，而execution版本在方法签名中声明只有一个 Serializable类型的参数时候匹配。

// 目标对象中有一个 @Transactional 注解的任意连接点 （在Spring AOP中只是方法执行）
@target（org.springframework.transaction.annotation.Transactional）// '@target'在绑定表单中更加常用

// 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）：
@within（org.springframework.transaction.annotation.Transactional） // '@within'在绑定表单中更加常用

// 任何一个执行的方法有一个 @Transactional 注解的连接点 （在Spring AOP中只是方法执行）
@annotation（org.springframework.transaction.annotation.Transactional） // '@annotation'在绑定表单中更加常用

// 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点（在Spring AOP中只是方法执行）
@args（com.xyz.security.Classified） // '@args'在绑定表单中更加常用

// 任何一个在名为'tradeService'的Spring bean之上的连接点 （在Spring AOP中只是方法执行）
bean（tradeService）

// 任何一个在名字匹配通配符表达式'*Service'的Spring bean之上的连接点 （在Spring AOP中只是方法执行）
bean（*Service）
```
此外Spring 支持如下三个逻辑运算符来组合切入点表达式
```java
&&：要求连接点同时匹配两个切入点表达式
||：要求连接点匹配任意个切入点表达式
!:：要求连接点不匹配指定的切入点表达式
```
### 5.5.2 多种增强通知的顺序？
如果**同一个切面中有多个通知(前置通知、后置通知)想要在同一连接点**运行会发生什么？Spring AOP遵循跟AspectJ一样的优先规则来确定通知执行的顺序。 在“进入”连接点的情况下，最高优先级的通知会先执行（所以给定的两个前置通知中，优先级高的那个会先执行）。 在“退出”连接点的情况下，最高优先级的通知会最后执行。（所以给定的两个后置通知中， 优先级高的那个会第二个执行）。
```java
// 切面
@Aspect
public class LoggingAspect {
    @Before("execution(* UserService.doSomething(..))")
    public void logBefore() {
        System.out.println("日志记录 - 前置通知");
    }
    @AfterReturning("execution(* UserService.doSomething(..))")
    public void logAfter() {
        System.out.println("日志记录 - 后置通知");
    }
}
// 执行结果当调用 doSomething() 时：
// 日志记录 - 前置通知（优先级高先执行）
// ... 目标方法执行 ...
// 日志记录 - 后置通知（优先级高后执行）
```
所有的通知的执行顺序
![40.AOP各种通知之间的执行顺序.png](../../assets/images/04-主流框架/spring/40.AOP各种通知之间的执行顺序.png)


当**定义在不同的切面里的两个通知都需要在一个相同的连接点**中运行， 那么除非你指定，否则执行的顺序是未知的。你可以通过指定优先级来控制执行顺序。 在标准的Spring方法中可以在切面类中实现org.springframework.core.Ordered 接口或者用Order注解做到这一点。在两个切面中， Ordered.getValue()方法返回值（或者注解值）较低的那个有更高的优先级。
```java
// 切面1：高优先级
@Aspect
@Order(1)
public class LoggingAspect {
    @Before("execution(* UserService.doSomething(..))")
    public void logBefore() {
        System.out.println("日志记录 - 前置通知");
    }
    @AfterReturning("execution(* UserService.doSomething(..))")
    public void logAfter() {
        System.out.println("日志记录 - 后置通知");
    }
}

// 切面2：低优先级
@Aspect
@Order(2)
public class SecurityAspect {
    @Before("execution(* UserService.doSomething(..))")
    public void checkSecurity() {
        System.out.println("安全检查 - 前置通知");
    }
    @AfterReturning("execution(* UserService.doSomething(..))")
    public void auditAfter() {
        System.out.println("安全审计 - 后置通知");
    }
}

// 执行结果当调用 doSomething() 时：
// 日志记录 - 前置通知（优先级高先执行）
// 安全检查 - 前置通知（优先级低后执行）
// ... 目标方法执行 ...
// 安全审计 - 后置通知（优先级低先执行）
// 日志记录 - 后置通知（优先级高后执行）
```
当**定义在相同的切面里的两个通知都需要在一个相同的连接点**中运行， 执行的顺序是未知的（因为这里没有方法通过反射javac编译的类来获取声明顺序）。 考虑在每个切面类中按连接点压缩这些通知方法到一个通知方法，或者重构通知的片段到各自的切面类中 - 它能在切面级别进行排序。
```java
@Aspect
public class MonitorAspect {
    // 两个通知在同一切面中，顺序不确定
    @Before("execution(* UserService.update(..))")
    public void monitorPerformance() {
        System.out.println("性能监控");
    }

    @Before("execution(* UserService.update(..))")
    public void monitorBusiness() {
        System.out.println("业务监控");
    }
}

// 执行时，可能先输出"性能监控"再输出"业务监控"，也可能相反！
```

**解决方案**：
- **方案1（合并通知）**：将两个通知合并为一个方法，在内部控制顺序。
  ```java
  @Before("execution(* UserService.update(..))")
  public void combinedMonitor() {
      monitorPerformance();
      monitorBusiness();
  }
  ```
- **方案2（拆分切面）**：将每个通知移到独立的切面类，然后用 `@Order` 控制顺序：
  ```java
  @Aspect
  @Order(1)
  public class PerformanceAspect { ... }
  
  @Aspect
  @Order(2)
  public class BusinessAspect { ... }
  ```
### 5.5.3 Spring AOP 和 AspectJ 之间的关键区别？
AspectJ可以做Spring AOP干不了的事情，**它(AspectJ)是AOP编程的完全解决方案，Spring AOP则致力于解决企业级开发中最普遍的AOP（方法织入）**。

下表总结了 Spring AOP 和 AspectJ 之间的关键区别:
| 比较方面 | Spring AOP | AspectJ |
|----------|------------|---------|
| **实现基础** | 在纯 Java 中实现 | 使用 Java 编程语言的扩展实现 |
| **编译过程** | 不需要单独的编译过程 | 除非设置 LTW（ Load-Time Weaving-加载时织入），否则需要 AspectJ 编译器 (ajc) |
| **织入方式** | 只能使用运行时织入 | 运行时织入不可用，支持编译时、编译后和加载时织入 |
| **编织粒度** | 功能不强，仅支持方法级编织 | 更强大，可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等...... |
| **适用对象** | 只能在由 Spring 容器管理的 bean 上实现 | 可以在所有域对象上实现 |
| **切入点支持** | 仅支持方法执行切入点 | 支持所有切入点 |
| **织入机制** | 代理是由目标对象创建的，并且切面应用在这些代理上 | 在执行应用程序之前（在运行时前），各方面直接在代码中进行织入 |
| **性能** | 比 AspectJ 慢多了 | 更好的性能 |
| **易用性** | 易于学习和应用 | 相对于 Spring AOP 来说更复杂 |

### 5.5.4 Spring AOP还是完全用AspectJ？
以下Spring官方的回答：（总结来说就是 **Spring AOP更易用，AspectJ更强大**）。
- Spring AOP比完全使用AspectJ更加简单， 因为它不需要引入AspectJ的编译器／织入器到你开发和构建过程中。 如果你**仅仅需要在Spring bean上通知执行操作，那么Spring AOP是合适的选择**。
- 如果你需要通知domain对象或其它没有在Spring容器中管理的任意对象，那么**你需要使用AspectJ**。
- 如果你想通知除了简单的方法执行之外的连接点（如：调用连接点、字段get或set的连接点等等）， 也**需要使用AspectJ**。

当使用AspectJ时，你可以选择使用AspectJ语言（也称为“代码风格”）或@AspectJ注解风格。 如果切面在你的设计中扮演一个很大的角色，并且你能在Eclipse等IDE中使用AspectJ Development Tools (AJDT)， 那么首选AspectJ语言 :- 因为该语言专门被设计用来编写切面，所以会更清晰、更简单。如果你没有使用 Eclipse等IDE，或者在你的应用中只有很少的切面并没有作为一个主要的角色，你或许应该考虑使用@AspectJ风格 并在你的IDE中附加一个普通的Java编辑器，并且在你的构建脚本中增加切面织入（链接）的段落。
# 六、Spring基础 - SpringMVC请求流程和案例
## 6.1 引入
前文我们介绍了Spring框架和Spring框架中最为重要的两个技术点（IOC和AOP），同时我们也通过几个Demo应用了Core Container中的包
![41.spring-springframework-mvc-3.png](../../assets/images/04-主流框架/spring/41.spring-springframework-mvc-3.png)

Demo中core container中包使用如下
![42.spring-springframework-mvc-2.png](../../assets/images/04-主流框架/spring/42.spring-springframework-mvc-2.png)

那么问题是，我们如何更好的构建上层的应用呢？比如web 应用？
![43.spring-springframework-mvc-1.png](../../assets/images/04-主流框架/spring/43.spring-springframework-mvc-1.png)

针对上层的Web应用，SpringMVC诞生了，它也是Spring技术栈中最为重要的一个框架。

**所以为了更好的帮助你串联整个知识体系，我列出了几个问题，通过如下几个问题帮你深入浅出的构建对SpringMVC的认知。**

- Java技术栈的Web应用是如何发展的？
- 什么是MVC，什么是SpringMVC？
- SpringMVC主要的请求流程是什么样的？
- SpringMVC中还有哪些组件？
- 如何编写一个简单的SpringMVC程序呢？
## 6.2 什么是MVC
> MVC英文是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范。本质上也是一种解耦。

用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。
![44.spring-springframework-mvc-4.png](../../assets/images/04-主流框架/spring/44.spring-springframework-mvc-4.png)

- `Model（模型）`是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。
- `View（视图）`是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
- `Controller（控制器）`是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
## 6.3 什么是Spring MVC
> 简单而言，Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发。

Spring Web MVC 是一种基于Java 的实现了Web MVC 设计模式的请求驱动类型的轻量级Web 框架，即使用了MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC 也是要简化我们日常Web开发的。

**相关特性如下：**
- 让我们能非常简单的设计出干净的Web 层和薄薄的Web 层；
- 进行更简洁的Web 层的开发；
- 天生与Spring 框架集成（如IoC 容器、AOP 等）；
- 提供强大的约定大于配置的契约式编程支持；
- 能简单的进行Web 层的单元测试；
- 支持灵活的URL 到页面控制器的映射；
- 非常容易与其他视图技术集成，如 Velocity、FreeMarker 等等，因为模型数据不放在特定的 API 里，而是放在一个 Model 里（Map 数据结构实现，因此很容易被其他框架使用）；
- 非常灵活的数据验证、格式化和数据绑定机制，能使用任何对象进行数据绑定，不必实现特定框架的API；
- 提供一套强大的JSP 标签库，简化JSP 开发；
- 支持灵活的本地化、主题等解析；
- 更加简单的异常处理；
- 对静态资源的支持；
- 支持Restful 风格。
## 6.4 Spring MVC的请求流程
> Spring Web MVC 框架也是一个基于请求驱动的Web 框架，并且也使用了前端控制器模式来进行设计，再根据请求映射 规则分发给相应的页面控制器（动作/处理器）进行处理。
### 6.4.1 核心架构的具体流程步骤
> 首先让我们整体看一下Spring Web MVC 处理请求的流程：
![45.spring-springframework-mvc-5.png](../../assets/images/04-主流框架/spring/45.spring-springframework-mvc-5.png)

**核心架构的具体流程步骤**如下：
1. `首先用户发送请求——>DispatcherServlet`，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制；
2. `DispatcherServlet——>HandlerMapping`， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一 个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新 的映射策略；
3. `DispatcherServlet——>HandlerAdapter`，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；
4. `HandlerAdapter——>处理器功能处理方法的调用`，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；
5. `ModelAndView 的逻辑视图名`——> ViewResolver，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策 略模式，很容易更换其他视图技术；
6. `View——>渲染`，View 会根据传进来的Model 模型数据进行渲染，此处的Model 实际是一个Map 数据结构，因此 很容易支持其他视图技术；
7. `返回控制权给DispatcherServlet`，由DispatcherServlet 返回响应给用户，到此一个流程结束。
### 6.4.2 对上述流程的补充
> 上述流程只是核心流程，这里我们再补充一些其它组件：
#### 6.4.2.1 Filter(ServletFilter)
进入Servlet前可以有preFilter, Servlet处理之后还可有postFilter
![46.spring-springframework-mvc-8.png](../../assets/images/04-主流框架/spring/46.spring-springframework-mvc-8.png)
#### 6.4.2.2 LocaleResolver
在视图解析/渲染时，还需要考虑国际化(Local)，显然这里需要有LocaleResolver.
![47.spring-springframework-mvc-6.png](../../assets/images/04-主流框架/spring/47.spring-springframework-mvc-6.png)
#### 6.4.2.3 ThemeResolver
如何控制视图样式呢？SpringMVC中还设计了ThemeSource接口和ThemeResolver，包含一些静态资源的集合(样式及图片等)，用来控制应用的视觉风格。
![48.spring-springframework-mvc-9.png](../../assets/images/04-主流框架/spring/48.spring-springframework-mvc-9.png)
#### 6.4.2.4 对于文件的上传请求？(MultipartResolver)
对于常规请求上述流程是合理的，但是如果是文件的上传请求，那么就不太一样了；所以这里便出现了MultipartResolver。
![49.spring-springframework-mvc-7.png](../../assets/images/04-主流框架/spring/49.spring-springframework-mvc-7.png)
### 6.4.3 Spring MVC案例
> 这里主要向你展示一个基本的SpringMVC例子，后文中将通过以Debug的方式分析源码。

本例子中主要文件和结构如下：
![50.spring-springframework-mvc-14.png](../../assets/images/04-主流框架/spring/50.spring-springframework-mvc-14.png)
#### 6.4.3.1 Maven包引入
主要引入spring-webmvc包（spring-webmvc包中已经包含了Spring Core Container相关的包），以及servlet和jstl（JSP中使用jstl）的包。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>tech-pdai-spring-demos</artifactId>
        <groupId>tech.pdai</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>011-spring-framework-demo-springmvc</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <spring.version>5.3.9</spring.version>
        <servlet.version>4.0.1</servlet.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>${servlet.version}</version>
        </dependency>

        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
        <dependency>
            <groupId>taglibs</groupId>
            <artifactId>standard</artifactId>
            <version>1.1.2</version>
        </dependency>
    </dependencies>

</project>
```
#### 6.4.3.2 业务代码的编写
- User实体
```java
package tech.pdai.springframework.springmvc.entity;

/**
 * @author pdai
 */
public class User {

    /**
     * user's name.
     */
    private String name;

    /**
     * user's age.
     */
    private int age;

    /**
     * init.
     *
     * @param name name
     * @param age  age
     */
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```
- Dao
```java
package tech.pdai.springframework.springmvc.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springframework.springmvc.entity.User;

import java.util.Collections;
import java.util.List;

/**
 * @author pdai
 */
@Repository
public class UserDaoImpl {

    /**
     * mocked to find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return Collections.singletonList(new User("pdai", 18));
    }
}
```
- Service
```java
package tech.pdai.springframework.springmvc.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import tech.pdai.springframework.springmvc.dao.UserDaoImpl;
import tech.pdai.springframework.springmvc.entity.User;

import java.util.List;

/**
 * @author pdai
 */
@Service
public class UserServiceImpl {

    /**
     * user dao impl.
     */
    @Autowired
    private UserDaoImpl userDao;

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return userDao.findUserList();
    }

}
```
- Controller
```java
package tech.pdai.springframework.springmvc.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import tech.pdai.springframework.springmvc.service.UserServiceImpl;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Date;

/**
 * User Controller.
 *
 * @author pdai
 */
@Controller
public class UserController {

    @Autowired
    private UserServiceImpl userService;

    /**
     * find user list.
     *
     * @param request  request
     * @param response response
     * @return model and view
     */
    @RequestMapping("/user")
    public ModelAndView list(HttpServletRequest request, HttpServletResponse response) {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject("dateTime", new Date());
        modelAndView.addObject("userList", userService.findUserList());
        modelAndView.setViewName("userList"); // views目录下userList.jsp
        return modelAndView;
    }
}
```
#### 6.4.3.3 webapp下的web.xml
（创建上图的文件结构）

webapp下的web.xml如下：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">

    <display-name>SpringFramework - SpringMVC Demo @pdai</display-name>

    <servlet>
        <servlet-name>springmvc-demo</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>springmvc-demo</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>

    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>
```
#### 6.4.3.4 springmvc.xml
web.xml中我们配置初始化参数contextConfigLocation，路径是classpath:springmvc.xml
```xml
<init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:springmvc.xml</param-value>
</init-param>
```
在resources目录下创建
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
       http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <!-- 扫描注解 -->
    <context:component-scan base-package="tech.pdai.springframework.springmvc"/>

    <!-- 静态资源处理 -->
    <mvc:default-servlet-handler/>

    <!-- 开启注解 -->
    <mvc:annotation-driven/>

    <!-- 视图解析器 -->
    <bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

</beans>
```
#### 6.4.3.5 JSP视图
- 创建userList.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>User List</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">

</head>
<body>
    <div class="container">
        <c:if test="${!empty userList}">
            <table class="table table-bordered table-striped">
                <tr>
                    <th>Name</th>
                    <th>Age</th>
                </tr>
                <c:forEach items="${userList}" var="user">
                    <tr>
                        <td>${user.name}</td>
                        <td>${user.age}</td>
                    </tr>
                </c:forEach>
            </table>
        </c:if>
    </div>
</body>
</html>
```
#### 6.4.3.6 部署测试
> 我们通过IDEA的tomcat插件来进行测试

- 下载Tomcat：<a href = 'https://downloads.apache.org/tomcat/'>tomcat地址</a>

- 下载后给tomcat/bin执行文件赋权
```sh
pdai@MacBook-Pro pdai % cd apache-tomcat-9.0.62 
pdai@MacBook-Pro apache-tomcat-9.0.62 % cd bin 
pdai@MacBook-Pro bin % ls
bootstrap.jar			makebase.sh
catalina-tasks.xml		setclasspath.bat
catalina.bat			setclasspath.sh
catalina.sh			shutdown.bat
ciphers.bat			shutdown.sh
ciphers.sh			startup.bat
commons-daemon-native.tar.gz	startup.sh
commons-daemon.jar		tomcat-juli.jar
configtest.bat			tomcat-native.tar.gz
configtest.sh			tool-wrapper.bat
daemon.sh			tool-wrapper.sh
digest.bat			version.bat
digest.sh			version.sh
makebase.bat
pdai@MacBook-Pro bin % chmod 777 *.sh
pdai@MacBook-Pro bin % 
```
- 配置Run Congfiuration
![51.spring-springframework-mvc-15.png](../../assets/images/04-主流框架/spring/51.spring-springframework-mvc-15.png)
- 添加Tomcat Server - Local
![52.spring-springframework-mvc-16.png](../../assets/images/04-主流框架/spring/52.spring-springframework-mvc-16.png)
- 将我们下载的Tomcat和Tomcat Server - Local关联
![53.spring-springframework-mvc-17.png](../../assets/images/04-主流框架/spring/53.spring-springframework-mvc-17.png)
- 在Deploy中添加我们的项目
![54.spring-springframework-mvc-18.png](../../assets/images/04-主流框架/spring/54.spring-springframework-mvc-18.png)
- 运行和管理Tomcat Sever（注意context路径）
![55.spring-springframework-mvc-19.png](../../assets/images/04-主流框架/spring/55.spring-springframework-mvc-19.png)
- 运行后访问我们的web程序页面（注意context路径）
![56.spring-springframework-mvc-20.png](../../assets/images/04-主流框架/spring/56.spring-springframework-mvc-20.png)


全面学习springMVC参考<a href='https://www.pdai.tech/files/kaitao-springMVC.pdf'>跟开涛学 SpringMVC</a>
# 七、Spring进阶- Spring IOC实现原理详解之IOC体系结构设计
## 7.1 站在设计者的角度考虑设计IOC容器
> 如果让你来设计一个IoC容器，你会怎么设计？我们初步的通过这个问题，来帮助我们更好的理解IOC的设计。

在设计时，首先需要考虑的是IOC容器的功能（输入和输出）, 承接前面的文章，我们初步的画出IOC容器的整体功能。
![57.spring-framework-ioc-source-7.png](../../assets/images/04-主流框架/spring/57.spring-framework-ioc-source-7.png)

在此基础上，我们初步的去思考，如果作为一个IOC容器的设计者，主体上应该包含哪几个部分：

- 加载Bean的配置（比如xml配置） 
  - 比如不同类型资源的加载，解析成生成统一Bean的定义
- 根据Bean的定义加载生成Bean的实例，并放置在Bean容器中 
  - 比如Bean的依赖注入，Bean的嵌套，Bean存放（缓存）等
- 除了基础Bean外，还有常规针对企业级业务的特别Bean 
  - 比如国际化Message，事件Event等生成特殊的类结构去支撑
- 对容器中的Bean提供统一的管理和调用 
  - 比如用工厂模式管理，提供方法根据名字/类的类型等从容器中获取Bean
- ...
## 7.2 Spring IoC的体系结构设计
> 那么我们来看下Spring设计者是如何设计IoC并解决这些问题的。
### 7.2.1 BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册
> Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，这是IOC容器的基础；在顶层的结构设计主要围绕着BeanFactory和xxxRegistry进行：
> - BeanFactory： 工厂模式定义了IOC容器的基本功能规范
> - BeanRegistry： 向IOC容器手工注册 BeanDefinition 对象的方法

其相互关系如下：
![58.spring-framework-ioc-source-2.png](../../assets/images/04-主流框架/spring/58.spring-framework-ioc-source-2.png)

我们再通过几个问题来辅助理解。

#### 7.2.1.1 BeanFactory定义了IOC 容器基本功能规范？

**BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范**，BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。我们看下BeanFactory接口：
```java
public interface BeanFactory {    
      
    //用于取消引用实例并将其与FactoryBean创建的bean区分开来。例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。
    String FACTORY_BEAN_PREFIX = "&"; 
        
    //根据bean的名字和Class类型等来得到bean实例    
    Object getBean(String name) throws BeansException;    
    Object getBean(String name, Class requiredType) throws BeansException;    
    Object getBean(String name, Object... args) throws BeansException;
    <T> T getBean(Class<T> requiredType) throws BeansException;
    <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;

    //返回指定bean的Provider
    <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
    <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);

    //检查工厂中是否包含给定name的bean，或者外部注册的bean
    boolean containsBean(String name);

    //检查所给定name的bean是否为单例/原型
    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;

    //判断所给name的类型与type是否匹配
    boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
    boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;

    //获取给定name的bean的类型
    @Nullable
    Class<?> getType(String name) throws NoSuchBeanDefinitionException;

    //返回给定name的bean的别名
    String[] getAliases(String name);
     
}
```
#### 7.2.1.2 BeanFactory为何要定义这么多层次的接口？定义了哪些接口？
主要是为了**区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。**
- `ListableBeanFactory`：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法；
- `HierarchicalBeanFactory`：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。
- `ConfigurableBeanFactory`：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；
- `ConfigurableListableBeanFactory`: ListableBeanFactory 和 ConfigurableBeanFactory的融合；
- `AutowireCapableBeanFactory`：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；
#### 7.2.1.3 如何将Bean注册到BeanFactory中？BeanRegistry
Spring 配置文件中每一个`<bean>`节点元素在 Spring 容器里都通过一个 `BeanDefinition` 对象表示，它描述了 Bean 的配置信息。而 `BeanDefinitionRegistry` 接口提供了向容器手工注册 `BeanDefinition`对象的方法。
### 7.2.2 BeanDefinition：各种Bean对象及其相互的关系
> Bean对象存在依赖嵌套等关系，所以设计者设计了BeanDefinition，它用来对Bean对象及关系定义；我们在理解时只需要抓住如下三个要点：
> - BeanDefinition 定义了各种Bean对象及其相互的关系
> - BeanDefinitionReader 这是BeanDefinition的解析器
> - BeanDefinitionHolder 这是BeanDefination的包装类，用来存储BeanDefinition，name以及aliases等。
#### 7.2.2.1 BeanDefinition

SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下
![59.spring-framework-ioc-source-3.png](../../assets/images/04-主流框架/spring/59.spring-framework-ioc-source-3.png)
#### 7.2.2.2 BeanDefinitionReader

Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成：
![60.spring-framework-ioc-source-5.png](../../assets/images/04-主流框架/spring/60.spring-framework-ioc-source-5.png)
#### 7.2.2.3 BeanDefinitionHolder

BeanDefinitionHolder 这是BeanDefination的包装类，用来存储BeanDefinition，name以及aliases等
![61.spring-framework-ioc-source-4.png](../../assets/images/04-主流框架/spring/61.spring-framework-ioc-source-4.png)
## 7.3 ApplicationContext：IOC接口设计和实现
> IoC容器的接口类是ApplicationContext，很显然它必然继承BeanFactory对Bean规范（最基本的ioc容器的实现）进行定义。而ApplicationContext表示的是应用的上下文，除了对Bean的管理外，还至少应该包含了
> - **访问资源**： 对不同方式的Bean配置（即资源）进行加载。(实现ResourcePatternResolver接口)
> - **国际化**: 支持信息源，可以实现国际化。（实现MessageSource接口）
> - **应用事件**: 支持应用事件。(实现ApplicationEventPublisher接口)
### 7.3.1 ApplicationContext接口的设计
我们来看下ApplicationContext整体结构
![62.spring-framework-ioc-source-51.png](../../assets/images/04-主流框架/spring/62.spring-framework-ioc-source-51.png)
- `HierarchicalBeanFactory 和 ListableBeanFactory`： ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：
- `ApplicationEventPublisher`：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件 ， 并对事件进行响应处理 。 在 ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。
- `MessageSource`：为应用提供 i18n 国际化消息访问的功能；
- `ResourcePatternResolver` ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。
- `LifeCycle`：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。
### 7.3.2 ApplicationContext接口的实现
在考虑ApplicationContext接口的实现时，关键的点在于，不同Bean的配置方式（比如xml,groovy,annotation等）有着不同的资源加载方式，这便衍生除了众多ApplicationContext的实现类。
![63.spring-framework-ioc-source-61.png](../../assets/images/04-主流框架/spring/63.spring-framework-ioc-source-61.png)

- 第一，从类结构设计上看， 围绕着是否需要Refresh容器衍生出两个抽象类：
  - GenericApplicationContext： 是初始化的时候就创建容器，往后的每次refresh都不会更改
  - AbstractRefreshableApplicationContext： AbstractRefreshableApplicationContext及子类的每次refresh都是先清除已有(如果不存在就创建)的容器，然后再重新创建；AbstractRefreshableApplicationContext及子类无法做到GenericApplicationContext**混合搭配从不同源头获取bean的定义信息**
- 第二， 从加载的源来看（比如xml,groovy,annotation等）， 衍生出众多类型的ApplicationContext, 典型比如:
  - `FileSystemXmlApplicationContext`： 从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。
  - `ClassPathXmlApplicationContext`： 从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。
  - `AnnotationConfigApplicationContext`： 从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。
  - `ConfigurableApplicationContext`： 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。
- 第三， 更进一步理解：
  - *计者在设计时`AnnotationConfigApplicationContext`为什么是继承GenericApplicationContext？* 因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态Bean配置和刷新容器，所以只需要GenericApplicationContext。
  - 而基于XML这种配置文件，这种文件是容易修改的，需要动态性刷新Bean的支持，所以XML相关的配置必然继承AbstractRefreshableApplicationContext； 且存在多种xml的加载方式（位置不同的设计），所以必然会设计出AbstractXmlApplicationContext, 其中包含对XML配置解析成BeanDefination的过程。
  - 那么细心的你从上图可以发现`AnnotationWebConfigApplicationContext`却是继承了AbstractRefreshableApplicationContext而不是GenericApplicationContext， *为什么AnnotationWebConfigApplicationContext继承自AbstractRefreshableApplicationContext呢 ？* 因为用户可以通过ApplicationContextInitializer来设置contextInitializerClasses（context-param / init-param）， 在这种情况下用户倾向于刷新Bean的，所以设计者选择让AnnotationWebConfigApplicationContext继承了AbstractRefreshableApplicationContext。（如下是源码中Spring设计者对它的解释）
```java
 * <p>As an alternative to setting the "contextConfigLocation" parameter, users may
 * implement an {@link org.springframework.context.ApplicationContextInitializer
 * ApplicationContextInitializer} and set the
 * {@linkplain ContextLoader#CONTEXT_INITIALIZER_CLASSES_PARAM "contextInitializerClasses"}
 * context-param / init-param. In such cases, users should favor the {@link #refresh()}
 * and {@link #scan(String...)} methods over the {@link #setConfigLocation(String)}
 * method, which is primarily for use by {@code ContextLoader}.
```



| 比较方面 | AnnotationConfigApplicationContext | AnnotationConfigWebApplicationContext |
|---------|-----------------------------------|--------------------------------------|
| **应用场景** | 独立的Java应用程序、桌面应用、单元测试等非Web环境 | Web应用程序（Servlet容器环境） |
| **继承关系** | 继承自 `GenericApplicationContext` | 继承自 `GenericWebApplicationContext`，间接继承自 `GenericApplicationContext` |
| **环境支持** | 标准Java环境 | Web环境，支持Servlet API、Web作用域等 |
| **配置方式** | 基于注解的配置类（@Configuration） | 基于注解的配置类（@Configuration），同时支持Web相关配置 |
| **作用域支持** | 支持单例（singleton）、原型（prototype）作用域 | 额外支持Web作用域：request、session、application |
| **初始化方式** | 直接通过构造函数注册配置类：<br>`new AnnotationConfigApplicationContext(AppConfig.class)` | 可通过web.xml配置或编程方式初始化，支持上下文参数 |
| **典型使用场景** | Spring Boot命令行应用、单元测试、桌面应用 | Spring MVC Web应用、Spring Boot Web应用 |
| **依赖** | 只需要Spring核心容器 | 需要Spring Web模块（spring-web） |
| **配置文件支持** | 主要支持Java配置类，也可结合Properties文件 | 支持Java配置类，同时可读取web.xml参数、初始化参数等 |

我们把之前的设计要点和设计结构结合起来看：
![64.spring-framework-ioc-source-71.png](../../assets/images/04-主流框架/spring/64.spring-framework-ioc-source-71.png)

到此，基本可以帮助你**从顶层构建对IoC容器的设计理解，而不是过早沉溺于代码的细节;**
# 八、Spring进阶- <a id = 'Spring IOC实现原理详解之IOC初始化流程'>Spring IOC实现原理详解之IOC初始化流程</a>
## 8.1 引入
上文，我们看了IOC设计要点和设计结构；紧接着这篇，我们可以看下源码的实现了：Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的（就是我们圈出来的部分）
![65.spring-framework-ioc-source-73.png](../../assets/images/04-主流框架/spring/65.spring-framework-ioc-source-73.png)
## 8.2 如何将Bean从XML配置中解析后放到IoC容器中的？
> 本文的目标就是分析Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成BeanDefination并注册到IoC容器中的。
### 8.2.1 初始化的入口
对于xml配置的Spring应用，在main()方法中实例化ClasspathXmlApplicationContext即可创建一个IoC容器。我们可以从这个构造方法开始，探究一下IoC容器的初始化过程。
```java
 // create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("aspects.xml", "daos.xml", "services.xml");
```
```java
public ClassPathXmlApplicationContext(String... configLocations) throws BeansException {
    this(configLocations, true, (ApplicationContext)null);
}

public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {
    // 设置Bean资源加载器
    super(parent);

    // 设置配置路径
    this.setConfigLocations(configLocations);

    // 初始化容器
    if (refresh) {
        this.refresh();
    }
}
```
### 8.2.2 设置资源解析器和环境
调用父类容器AbstractApplicationContext的构造方法`(super(parent)方法)`为容器设置好Bean资源加载器
```java
public AbstractApplicationContext(@Nullable ApplicationContext parent) {
    // 默认构造函数初始化容器id, name, 状态 以及 资源解析器
    this();

    // 将父容器的Environment合并到当前容器
    this.setParent(parent);
}
```
通过AbstractApplicationContext默认构造函数初始化容器id, name, 状态 以及 资源解析器
```java
public AbstractApplicationContext() {
    this.logger = LogFactory.getLog(this.getClass());
    this.id = ObjectUtils.identityToString(this);
    this.displayName = ObjectUtils.identityToString(this);
    this.beanFactoryPostProcessors = new ArrayList();
    this.active = new AtomicBoolean();
    this.closed = new AtomicBoolean();
    this.startupShutdownMonitor = new Object();
    this.applicationStartup = ApplicationStartup.DEFAULT;
    this.applicationListeners = new LinkedHashSet();
    this.resourcePatternResolver = this.getResourcePatternResolver();
}
// Spring资源加载器
protected ResourcePatternResolver getResourcePatternResolver() {
    return new PathMatchingResourcePatternResolver(this);
}
```
通过AbstractApplicationContext的setParent(parent)方法将父容器的Environment合并到当前容器
```java
public void setParent(@Nullable ApplicationContext parent) {
    this.parent = parent;
    if (parent != null) {
        Environment parentEnvironment = parent.getEnvironment();
        if (parentEnvironment instanceof ConfigurableEnvironment) {
            this.getEnvironment().merge((ConfigurableEnvironment)parentEnvironment);
        }
    }
}
```
### 8.2.3 设置配置路径
在设置容器的资源加载器之后，接下来ClassPathXmlApplicationContext执行setConfigLocations方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean定义资源文件的定位
```java
public void setConfigLocations(@Nullable String... locations) {
    if (locations != null) {
        Assert.noNullElements(locations, "Config locations must not be null");
        this.configLocations = new String[locations.length];

        for(int i = 0; i < locations.length; ++i) {
            // 解析配置路径
            this.configLocations[i] = this.resolvePath(locations[i]).trim();
        }
    } else {
        this.configLocations = null;
    }
}
protected String resolvePath(String path) {
    // 从上一步Environment中解析
    return this.getEnvironment().resolveRequiredPlaceholders(path);
}
```
### 8.2.4 初始化的主体流程
Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，`refresh()是一个模板方法`，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入。

首先需要明白什么是`模板方法:(“骨架不变，细节可变”)`：

在软件设计中，**模板方法模式（Template Method Pattern）** 是一种行为设计模式，它定义了一个操作中的算法骨架，而将一些步骤延迟到子类中实现。这样，子类可以在不改变算法结构的情况下重新定义算法的某些特定步骤。

- 关键特点：
  - **算法骨架固定**：父类（或抽象类）中定义一个模板方法，该方法包含了一系列步骤（这些步骤可以是抽象的或具有默认实现）。
  - **步骤可定制**：子类通过覆盖某些步骤方法来改变具体行为，但整个算法的流程由父类控制。
  - **避免代码重复**：通过将通用流程放在父类中，子类只需关注差异部分。

- 以 Spring 中的 `refresh()` 方法为例：
在 Spring 框架中，`AbstractApplicationContext` 类的 `refresh()` 方法就是一个典型的模板方法。它定义了 Spring 容器启动或刷新的标准流程，包括以下步骤：
1. **准备刷新**（`prepareRefresh()`）
2. **获取 Bean 工厂**（`obtainFreshBeanFactory()`）
3. **准备 Bean 工厂**（`prepareBeanFactory()`）
4. **后处理 Bean 工厂**（`postProcessBeanFactory()`）
5. **调用 Bean 工厂后处理器**（`invokeBeanFactoryPostProcessors()`）
6. **注册 Bean 后处理器**（`registerBeanPostProcessors()`）
7. **初始化消息源**（`initMessageSource()`）
8. **初始化事件广播器**（`initApplicationEventMulticaster()`）
9. **初始化其他特殊 Bean**（`onRefresh()`）
10. **注册事件监听器**（`registerListeners()`）
11. **完成 Bean 工厂初始化**（`finishBeanFactoryInitialization()`）
12. **完成刷新**（`finishRefresh()`）

这些步骤中，有些是抽象方法（需要子类实现），有些有默认实现。子类（如 `AnnotationConfigApplicationContext`）可以覆盖特定步骤来定制行为，但整体刷新流程由父类固定。


```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");

        // Prepare this context for refreshing.
        prepareRefresh();

        // Tell the subclass to refresh the internal bean factory.
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // Prepare the bean factory for use in this context.
        prepareBeanFactory(beanFactory);

        try {
            // Allows post-processing of the bean factory in context subclasses.
            postProcessBeanFactory(beanFactory);

            StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
            // Invoke factory processors registered as beans in the context.
            invokeBeanFactoryPostProcessors(beanFactory);

            // Register bean processors that intercept bean creation.
            registerBeanPostProcessors(beanFactory);
            beanPostProcess.end();

            // Initialize message source for this context.
            initMessageSource();

            // Initialize event multicaster for this context.
            initApplicationEventMulticaster();

            // Initialize other special beans in specific context subclasses.
            onRefresh();

            // Check for listener beans and register them.
            registerListeners();

            // Instantiate all remaining (non-lazy-init) singletons.
            finishBeanFactoryInitialization(beanFactory);

            // Last step: publish corresponding event.
            finishRefresh();
        }

        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization - " +
                        "cancelling refresh attempt: " + ex);
            }

            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();

            // Reset 'active' flag.
            cancelRefresh(ex);

            // Propagate exception to caller.
            throw ex;
        }

        finally {
            // Reset common introspection caches in Spring's core, since we
            // might not ever need metadata for singleton beans anymore...
            resetCommonCaches();
            contextRefresh.end();
        }
    }
}
```
这里的设计上是一个非常典型的资源类加载处理型的思路，头脑中需要形成如下图的顶层思路（而不是只停留在流水式的方法上面）：
- 模板方法设计模式，模板方法中使用典型的**钩子方法**
- 将**具体的初始化加载方法**插入到钩子方法之间
- 将初始化的阶段封装，用来记录当前初始化到什么阶段；常见的设计是xxxPhase/xxxStage；
- 资源加载初始化有失败等处理，必然是try/catch/finally...
![66.spring-framework-ioc-source-8.png](../../assets/images/04-主流框架/spring/66.spring-framework-ioc-source-8.png)
#### 8.2.4.1 初始化BeanFactory之obtainFreshBeanFactory
AbstractApplicationContext的obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean定义资源文件的过程，代码如下：
```java
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    // 这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
    refreshBeanFactory();
    return getBeanFactory();
}
```
AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法; 在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。方法的源码如下：
```java
protected final void refreshBeanFactory() throws BeansException {
    // 如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        // 创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory); // 对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等 
        loadBeanDefinitions(beanFactory); // 调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  
        this.beanFactory = beanFactory;
    }
    catch (IOException ex) {
        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    }
}
```
#### 8.2.4.2 初始化BeanFactory之loadBeanDefinitions
AbstractRefreshableApplicationContext中只定义了抽象的loadBeanDefinitions方法，容器真正调用的是其子类AbstractXmlApplicationContext对该方法的实现，AbstractXmlApplicationContext的主要源码如下：
```java
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
    // 创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean定义资源  
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    // 配置上下文的环境，资源加载器、解析器
    beanDefinitionReader.setEnvironment(this.getEnvironment());
    beanDefinitionReader.setResourceLoader(this);
    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 为Bean读取器设置SAX xml解析器

    // 允许子类自行初始化（比如校验机制），并提供真正的加载方法
    initBeanDefinitionReader(beanDefinitionReader); // 当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制  
    loadBeanDefinitions(beanDefinitionReader);
}

protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
    // 加载XML配置方式里的Bean定义的资源
    Resource[] configResources = getConfigResources();
    if (configResources != null) {
        reader.loadBeanDefinitions(configResources);
    }
    // 加载构造函数里配置的Bean配置文件，即{"aspects.xml", "daos.xml", "services.xml"}
    String[] configLocations = getConfigLocations();
    if (configLocations != null) {
        reader.loadBeanDefinitions(configLocations);
    }
}
```
Xml Bean读取器(XmlBeanDefinitionReader)调用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions方法读取Bean定义资源。

由于我们使用ClassPathXmlApplicationContext作为例子分析，因此getConfigResources的返回值为null，因此程序执行reader.loadBeanDefinitions(configLocations)分支。
#### 8.2.4.3 AbstractBeanDefinitionReader读取Bean定义资源
AbstractBeanDefinitionReader的loadBeanDefinitions方法源码如下：
```java
@Override
public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(location, null);
}

public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
    ResourceLoader resourceLoader = getResourceLoader();
    if (resourceLoader == null) {
        throw new BeanDefinitionStoreException(
                "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
    }

    // 模式匹配类型的解析器，这种方式是加载多个满足匹配条件的资源
    if (resourceLoader instanceof ResourcePatternResolver) {
        try {
            // 获取到要加载的资源
            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
            int count = loadBeanDefinitions(resources); // 委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能  
            if (actualResources != null) {
                Collections.addAll(actualResources, resources);
            }
            if (logger.isTraceEnabled()) {
                logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");
            }
            return count;
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(
                    "Could not resolve bean definition resource pattern [" + location + "]", ex);
        }
    }
    else {
        // 只能通过绝对路径URL加载单个资源.
        Resource resource = resourceLoader.getResource(location);
        int count = loadBeanDefinitions(resource);
        if (actualResources != null) {
            actualResources.add(resource);
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
        }
        return count;
    }
}
```
从对AbstractBeanDefinitionReader的loadBeanDefinitions方法源码分析可以看出该方法做了以下两件事：
- 首先，调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。
- 其次，真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions方法。
#### 8.2.4.4 XmlBeanDefinitionReader加载Bean定义资源
继续看子类XmlBeanDefinitionReader的loadBeanDefinitions(Resource …)方法看到代表bean文件的资源定义以后的载入过程。
```java
/**
    * 本质上是加载XML配置的Bean。
    * @param inputSource the SAX InputSource to read from
    * @param resource the resource descriptor for the XML file
    */
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {

    try {
        Document doc = doLoadDocument(inputSource, resource); // 将Bean定义资源转换成Document对象
        int count = registerBeanDefinitions(doc, resource);
        if (logger.isDebugEnabled()) {
            logger.debug("Loaded " + count + " bean definitions from " + resource);
        }
        return count;
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                "XML document from " + resource + " is invalid", ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                "Parser configuration exception parsing XML from " + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                "IOException parsing XML document from " + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                "Unexpected exception parsing XML document from " + resource, ex);
    }
}

// 使用配置的DocumentLoader加载XML定义文件为Document.
protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
    return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
            getValidationModeForResource(resource), isNamespaceAware());
}
```
通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现
#### 8.2.4.5 DocumentLoader将Bean定义资源转换为Document对象
DocumentLoader将Bean定义资源转换成Document对象的源码如下：
```java
// 使用标准的JAXP将载入的Bean定义资源转换成document对象
@Override
public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
        ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

    // 创建文件解析器工厂
    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
    if (logger.isTraceEnabled()) {
        logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
    }
    // 创建文档解析器
    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
    return builder.parse(inputSource); // 解析
}

protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
        throws ParserConfigurationException {

    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(namespaceAware);

    // 设置解析XML的校验
    if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
        factory.setValidating(true);
        if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
            // Enforce namespace aware for XSD...
            factory.setNamespaceAware(true);
            try {
                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
            }
            catch (IllegalArgumentException ex) {
                ParserConfigurationException pcex = new ParserConfigurationException(
                        "Unable to validate using XSD: Your JAXP provider [" + factory +
                        "] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? " +
                        "Upgrade to Apache Xerces (or Java 1.5) for full XSD support.");
                pcex.initCause(ex);
                throw pcex;
            }
        }
    }

    return factory;
}
```
该解析过程调用JavaEE标准的JAXP标准进行处理。

至此Spring IoC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。

接下来我们要继续分析Spring IoC容器将载入的Bean定义资源文件转换为Document对象之后，是如何将其解析为Spring IoC管理的Bean对象并将其注册到容器中的。
#### 8.2.4.6 XmlBeanDefinitionReader解析载入的Bean定义资源文件
XmlBeanDefinitionReader类中的doLoadBeanDefinitions方法是从特定XML文件中实际载入Bean定义资源的方法，该方法在载入Bean定义资源之后将其转换为Document对象，接下来调用registerBeanDefinitions启动Spring IoC容器对Bean定义的解析过程，registerBeanDefinitions方法源码如下：
```java
// 按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构 
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    int countBefore = getRegistry().getBeanDefinitionCount();
    // 解析过程入口，这里使用了委派模式，具体的解析实现过程由实现类DefaultBeanDefinitionDocumentReader完成  
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    return getRegistry().getBeanDefinitionCount() - countBefore;  // 返回此次解析了多少个对象
}

// 创建BeanDefinitionDocumentReader对象，解析Document对象  
protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
    return BeanUtils.instantiateClass(this.documentReaderClass);
}

/**
    * Create the {@link XmlReaderContext} to pass over to the document reader.
    */
public XmlReaderContext createReaderContext(Resource resource) {
    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
            this.sourceExtractor, this, getNamespaceHandlerResolver());
}
```
Bean定义资源的载入解析分为以下两个过程：
- 首先，通过调用XML解析器将Bean定义资源文件转换得到Document对象，但是这些Document对象并没有按照Spring的Bean规则进行解析。这一步是载入的过程
- 其次，在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析。

按照Spring的Bean规则对Document对象解析的过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现的。
#### 8.2.4.7 DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析
BeanDefinitionDocumentReader接口通过registerBeanDefinitions方法调用其实现类DefaultBeanDefinitionDocumentReader对Document对象进行解析，解析的代码如下：
```java
@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    doRegisterBeanDefinitions(doc.getDocumentElement());
}

// 注册<beans/>配置的Beans
@SuppressWarnings("deprecation")  // for Environment.acceptsProfiles(String...)
protected void doRegisterBeanDefinitions(Element root) {
    // Any nested <beans> elements will cause recursion in this method. In
    // order to propagate and preserve <beans> default-* attributes correctly,
    // keep track of the current (parent) delegate, which may be null. Create
    // the new (child) delegate with a reference to the parent for fallback purposes,
    // then ultimately reset this.delegate back to its original (parent) reference.
    // this behavior emulates a stack of delegates without actually necessitating one.
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            // We cannot use Profiles.of(...) since profile expressions are not supported
            // in XML config. See SPR-12458 for details.
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
                            "] not matching: " + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    parseBeanDefinitions(root, this.delegate); // 从Document的根元素开始进行Bean定义的Document对象  
    postProcessXml(root);

    this.delegate = parent;
}
```
#### 8.2.4.8 BeanDefinitionParserDelegate解析Bean定义资源文件生成BeanDefinition
```java
/**
    * Parse the elements at the root level in the document:
    * "import", "alias", "bean".
    * @param root the DOM root element of the document
    */
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}

private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
      
    // 如果元素节点是<Import>导入元素，进行导入解析
    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }
    // 如果元素节点是<Alias>别名元素，进行别名解析 
    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }
    // 如果元素节点<Bean>元素, 按照Spring的Bean规则解析元素  
    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }
    // 如果元素节点<Beans>元素，即它是嵌套类型的
    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        // 递归解析
        doRegisterBeanDefinitions(ele);
    }
}
```
解析Bean生成BeanDefinitionHolder的方法
```java
/**
    * Process the given bean element, parsing the bean definition
    * and registering it with the registry.
    */
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // 注册最终的装饰实例
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error("Failed to register bean definition with name '" +
                    bdHolder.getBeanName() + "'", ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
```
（这里就不展开了，无非就是解析XML各种元素，来生成BeanDefinition）
#### 8.2.4.9 解析过后的BeanDefinition在IoC容器中的注册
Document对象的解析后得到封装BeanDefinition的BeanDefinitionHolder对象，然后调用BeanDefinitionReaderUtils的registerBeanDefinition方法向IoC容器注册解析的Bean，BeanDefinitionReaderUtils的注册的源码如下：
```java
// 通过BeanDefinitionRegistry将BeanDefinitionHolder注册到BeanFactory
public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
```
当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory。
#### 8.2.4.9 DefaultListableBeanFactory向IoC容器注册解析后的BeanDefinition
IOC容器本质上就是一个beanDefinitionMap， 注册即将BeanDefinition put到map中
```java
/** Map of bean definition objects, keyed by bean name. */
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

/** Map from bean name to merged BeanDefinitionHolder. */
private final Map<String, BeanDefinitionHolder> mergedBeanDefinitionHolders = new ConcurrentHashMap<>(256);


@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {

    Assert.hasText(beanName, "Bean name must not be empty");
    Assert.notNull(beanDefinition, "BeanDefinition must not be null");

    if (beanDefinition instanceof AbstractBeanDefinition) {
        try {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    "Validation of bean definition failed", ex);
        }
    }

    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    // 如果已经注册
    if (existingDefinition != null) {
        // 检查是否可以覆盖
        if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
        }
        else if (existingDefinition.getRole() < beanDefinition.getRole()) {
            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
            if (logger.isInfoEnabled()) {
                logger.info("Overriding user-defined bean definition for bean '" + beanName +
                        "' with a framework-generated bean definition: replacing [" +
                        existingDefinition + "] with [" + beanDefinition + "]");
            }
        }
        else if (!beanDefinition.equals(existingDefinition)) {
            if (logger.isDebugEnabled()) {
                logger.debug("Overriding bean definition for bean '" + beanName +
                        "' with a different definition: replacing [" + existingDefinition +
                        "] with [" + beanDefinition + "]");
            }
        }
        else {
            if (logger.isTraceEnabled()) {
                logger.trace("Overriding bean definition for bean '" + beanName +
                        "' with an equivalent definition: replacing [" + existingDefinition +
                        "] with [" + beanDefinition + "]");
            }
        }
        // 覆盖
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        //重置所有已经注册过的BeanDefinition的缓存  
        this.frozenBeanDefinitionNames = null;
    }

    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
    else if (isConfigurationFrozen()) {
        clearByTypeCache();
    }
}
```
至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现 在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。
## 8.3 总结
现在通过上面的代码，总结一下IOC容器初始化的基本步骤：
![67.spring-framework-ioc-source-9.png](../../assets/images/04-主流框架/spring/67.spring-framework-ioc-source-9.png)

- 初始化的入口在容器实现中的 refresh()调用来完成
- 对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,其中的大致过程如下：
  - 通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的
  - 通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册, 往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition 这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的
  - 容器解析得到 BeanDefinition 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.
- 然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在ServletContext 中的框架实现。
# 九、Spring进阶- Spring IOC实现原理详解之Bean实例化(生命周期,循环依赖等)
## 9.1 引入
> 上文，我们看了IOC设计要点和设计结构；以及Spring如何实现将资源配置（以xml配置为例）通过加载，解析，生成`BeanDefination`并注册到IoC容器中的；容器中存放的是Bean的定义即`BeanDefinition`放到`beanDefinitionMap`中，本质上是一个`ConcurrentHashMap<String, Object>`；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等。那么如何从BeanDefinition中实例化Bean对象呢？

本文主要研究如何从IOC容器已有的BeanDefinition信息，实例化出Bean对象；这里还会包括三块重点内容：
- BeanFactory中getBean的主体思路
- Spring如何解决循环依赖问题
- Spring中Bean的生命周期
![68.spring-framework-ioc-source-74.png](../../assets/images/04-主流框架/spring/68.spring-framework-ioc-source-74.png)
## 9.2 BeanFactory中getBean的主体思路
> 上文中我们知道BeanFactory定义了Bean容器的规范，其中包含根据bean的名字, Class类型和参数等来得到bean实例。
```java
// 根据bean的名字和Class类型等来得到bean实例    
Object getBean(String name) throws BeansException;    
Object getBean(String name, Class requiredType) throws BeansException;    
Object getBean(String name, Object... args) throws BeansException;
<T> T getBean(Class<T> requiredType) throws BeansException;
<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
```
### 9.2.1 初步的思考
上文我们已经分析了IoC初始化的流程，最终的将Bean的定义即BeanDefinition放到beanDefinitionMap中，本质上是一个`ConcurrentHashMap<String, Object>`；并且BeanDefinition接口中包含了这个类的Class信息以及是否是单例等；
![69.spring-framework-ioc-source-100.png](../../assets/images/04-主流框架/spring/69.spring-framework-ioc-source-100.png)

这样我们初步有了实现`Object getBean(String name)`这个方法的思路：
- 从beanDefinitionMap通过beanName获得BeanDefinition
- 从BeanDefinition中获得beanClassName
- 通过反射初始化beanClassName的实例instance 
  - 构造函数从BeanDefinition的getConstructorArgumentValues()方法获取
  - 属性值从BeanDefinition的getPropertyValues()方法获取
- 返回beanName的实例instance

由于BeanDefinition还有单例的信息，如果是无参构造函数的实例还可以放在一个缓存中，这样下次获取这个单例的实例时只需要从缓存中获取，如果获取不到再通过上述步骤获取。

（PS：如上只是我们初步的思路，而Spring还需要考虑各种设计上的问题，比如beanDefinition中其它定义，循环依赖等；所以我们来看下Spring是如何是如何实现的）
### 9.2.2 Spring中getBean的主体思路
BeanFactory实现getBean方法在AbstractBeanFactory中，这个方法重载都是调用doGetBean方法进行实现的：
```java
public Object getBean(String name) throws BeansException {
  return doGetBean(name, null, null, false);
}
public <T> T getBean(String name, Class<T> requiredType) throws BeansException {
  return doGetBean(name, requiredType, null, false);
}
public Object getBean(String name, Object... args) throws BeansException {
  return doGetBean(name, null, args, false);
}
public <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)
    throws BeansException {
  return doGetBean(name, requiredType, args, false);
}
```
我们来看下doGetBean方法（这个方法很长，我们主要看它的整体思路和设计要点）：
```java
// 参数typeCheckOnly：bean实例是否包含一个类型检查
protected <T> T doGetBean(
			String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
			throws BeansException {

  // 解析bean的真正name，如果bean是工厂类，name前缀会加&，需要去掉
  String beanName = transformedBeanName(name);
  Object beanInstance;

  // Eagerly check singleton cache for manually registered singletons.
  Object sharedInstance = getSingleton(beanName);
  if (sharedInstance != null && args == null) {
    // 无参单例从缓存中获取
    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
  }

  else {
    // 如果bean实例还在创建中，则直接抛出异常
    if (isPrototypeCurrentlyInCreation(beanName)) {
      throw new BeanCurrentlyInCreationException(beanName);
    }

    // 如果 bean definition 存在于父的bean工厂中，委派给父Bean工厂获取
    BeanFactory parentBeanFactory = getParentBeanFactory();
    if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
      // Not found -> check parent.
      String nameToLookup = originalBeanName(name);
      if (parentBeanFactory instanceof AbstractBeanFactory) {
        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
            nameToLookup, requiredType, args, typeCheckOnly);
      }
      else if (args != null) {
        // Delegation to parent with explicit args.
        return (T) parentBeanFactory.getBean(nameToLookup, args);
      }
      else if (requiredType != null) {
        // No args -> delegate to standard getBean method.
        return parentBeanFactory.getBean(nameToLookup, requiredType);
      }
      else {
        return (T) parentBeanFactory.getBean(nameToLookup);
      }
    }

    if (!typeCheckOnly) {
      // 将当前bean实例放入alreadyCreated集合里，标识这个bean准备创建了
      markBeanAsCreated(beanName);
    }

    StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
        .tag("beanName", name);
    try {
      if (requiredType != null) {
        beanCreation.tag("beanType", requiredType::toString);
      }
      RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
      checkMergedBeanDefinition(mbd, beanName, args);

      // 确保它的依赖也被初始化了.
      String[] dependsOn = mbd.getDependsOn();
      if (dependsOn != null) {
        for (String dep : dependsOn) {
          if (isDependent(beanName, dep)) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
          }
          registerDependentBean(dep, beanName);
          try {
            getBean(dep); // 初始化它依赖的Bean
          }
          catch (NoSuchBeanDefinitionException ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
          }
        }
      }

      // 创建Bean实例：单例
      if (mbd.isSingleton()) {
        sharedInstance = getSingleton(beanName, () -> {
          try {
            // 真正创建bean的方法
            return createBean(beanName, mbd, args);
          }
          catch (BeansException ex) {
            // Explicitly remove instance from singleton cache: It might have been put there
            // eagerly by the creation process, to allow for circular reference resolution.
            // Also remove any beans that received a temporary reference to the bean.
            destroySingleton(beanName);
            throw ex;
          }
        });
        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
      }
      // 创建Bean实例：原型
      else if (mbd.isPrototype()) {
        // It's a prototype -> create a new instance.
        Object prototypeInstance = null;
        try {
          beforePrototypeCreation(beanName);
          prototypeInstance = createBean(beanName, mbd, args);
        }
        finally {
          afterPrototypeCreation(beanName);
        }
        beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
      }
      // 创建Bean实例：根据bean的scope创建
      else {
        String scopeName = mbd.getScope();
        if (!StringUtils.hasLength(scopeName)) {
          throw new IllegalStateException("No scope name defined for bean ´" + beanName + "'");
        }
        Scope scope = this.scopes.get(scopeName);
        if (scope == null) {
          throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
        }
        try {
          Object scopedInstance = scope.get(beanName, () -> {
            beforePrototypeCreation(beanName);
            try {
              return createBean(beanName, mbd, args);
            }
            finally {
              afterPrototypeCreation(beanName);
            }
          });
          beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
        }
        catch (IllegalStateException ex) {
          throw new ScopeNotActiveException(beanName, scopeName, ex);
        }
      }
    }
    catch (BeansException ex) {
      beanCreation.tag("exception", ex.getClass().toString());
      beanCreation.tag("message", String.valueOf(ex.getMessage()));
      cleanupAfterBeanCreationFailure(beanName);
      throw ex;
    }
    finally {
      beanCreation.end();
    }
  }

  return adaptBeanInstance(name, beanInstance, requiredType);
}
```
这段代码很长，主要看我加中文注释的方法即可。

- 解析bean的真正name，如果bean是工厂类，name前缀会加&，需要去掉
- 无参单例先从缓存中尝试获取
- 如果bean实例还在创建中，则直接抛出异常
- 如果bean definition 存在于父的bean工厂中，委派给父Bean工厂获取
- 标记这个beanName的实例正在创建
- 确保它的依赖也被初始化
- 真正创建 
  - 单例时
  - 原型时
  - 根据bean的scope创建
## 9.3 重点：Spring如何解决循环依赖问题
> 首先我们需要说明，`Spring只是解决了单例模式下属性依赖的循环问题`；Spring为了解决单例的循环依赖问题，使用了三级缓存。
### 9.3.1 Spring单例模式下的属性依赖
先来看下这三级缓存
```java
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);
 
/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
```
- `第一层缓存（singletonObjects）`：单例对象缓存池，已经实例化并且属性赋值，这里的对象是成熟对象；
- `第二层缓存（earlySingletonObjects）`：单例对象缓存池，已经实例化但尚未属性赋值，这里的对象是半成品对象；
- `第三层缓存（singletonFactories）`: 单例工厂的缓存

如下是获取单例中
```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
  // Spring首先从singletonObjects（一级缓存）中尝试获取
  Object singletonObject = this.singletonObjects.get(beanName);
  // 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取
  if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
    synchronized (this.singletonObjects) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
          ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
          if (singletonFactory != null) {
            //若是仍是获取不到而且容许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取
              singletonObject = singletonFactory.getObject();
              //若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中
              this.earlySingletonObjects.put(beanName, singletonObject);
              this.singletonFactories.remove(beanName);
          }
        }
    }
  }
  return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```
补充一些方法和参数
- `isSingletonCurrentlyInCreation()`：判断当前单例bean是否正在建立中，也就是没有初始化完成(好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)
- `allowEarlyReference` ：是否容许从singletonFactories中经过getObject拿到对象

分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。若是获取不到，而且对象正在建立中，就再从二级缓存earlySingletonObjects中获取。若是仍是获取不到且容许singletonFactories经过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，若是获取到了则从三级缓存移动到了二级缓存。

从上面三级缓存的分析，咱们能够知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义以下：
```java
public interface ObjectFactory<T> {
    T getObject() throws BeansException;
}
```
在bean建立过程当中，有两处比较重要的匿名内部类实现了该接口。一处是Spring利用其建立bean的时候，另外一处就是:
```java
addSingletonFactory(beanName, new ObjectFactory<Object>() {
   @Override   public Object getObject() throws BeansException {
      return getEarlyBeanReference(beanName, mbd, bean);
   }});
```
此处就是解决循环依赖的关键，这段代码发生在createBeanInstance以后，也就是说单例对象此时已经被建立出来的。这个对象已经被生产出来了，虽然还不完美（尚未进行初始化的第二步和第三步），可是已经能被人认出来了（根据对象引用能定位到堆中的对象），因此Spring此时将这个对象提早曝光出来让你们认识，让你们使用。

好比“A对象setter依赖B对象，B对象setter依赖A对象”，A首先完成了初始化的第一步，而且将本身提早曝光到singletonFactories中，此时进行初始化的第二步，发现本身依赖对象B，此时就尝试去get(B)，发现B尚未被create，因此走create流程，B在初始化第一步的时候发现本身依赖了对象A，因而尝试get(A)，尝试一级缓存singletonObjects(确定没有，由于A还没初始化彻底)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，因为A经过ObjectFactory将本身提早曝光了，因此B可以经过ObjectFactory.getObject拿到A对象(半成品)，B拿到A对象后顺利完成了初始化阶段一、二、三，彻底初始化以后将本身放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成本身的初始化阶段二、三，最终A也完成了初始化，进去了一级缓存singletonObjects中，并且更加幸运的是，因为B拿到了A的对象引用，因此B如今hold住的A对象完成了初始化。
### 9.3.2 Spring为何不能解决非单例属性之外的循环依赖？
> 通过以下几个问题，辅助我们进一步理解。
#### 9.3.2.1 Spring为什么不能解决构造器的循环依赖？
构造器注入形成的循环依赖： 也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决

Spring解决循环依赖主要是依赖三级缓存，但是的在调用构造方法之前还未将其放入三级缓存之中，因此后续的依赖调用构造方法的时候并不能从三级缓存中获取到依赖的Bean，因此不能解决。

因为循环依赖发生在 实例化 这一步。Spring 在调用 new ClassA(classB) 之前，必须先实例化 ClassB。而实例化 ClassB 时，又需要先实例化 ClassA。这就陷入了“先有鸡还是先有蛋”的死循环，在三级缓存机制有机会介入之前就会抛出 BeanCurrentlyInCreationException。
```java
@Component
public class ClassA {
    private ClassB classB;
    // 构造器注入：在实例化阶段就需要完整的 classB，此时三级缓存无法帮忙
    public ClassA(ClassB classB) {
        this.classB = classB;
    }
}
```
#### 9.3.2.2 Spring为什么不能解决prototype作用域（多例）循环依赖？
这种循环依赖同样无法解决，因为spring不会缓存‘prototype’作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。

多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖。

##### 9.3.2.2.1 核心原因：原型 Bean 的生命周期特性与三级缓存机制不兼容

###### 1. 原型 Bean 的生命周期特性
- **每次获取都创建新实例**：每次调用 `getBean()` 或注入时，Spring 都会创建一个全新的实例
- **容器不管理完整生命周期**：Spring 只负责创建，不负责销毁，生命周期由使用者管理
- **无缓存机制**：原型 Bean 不会被缓存，每次都是全新的创建过程

###### 2. 三级缓存的工作机制回顾
三级缓存是为**单例 Bean**设计的，它的核心思想是：
- **提前暴露**：在 Bean 还未完全初始化时，就暴露其引用给其他 Bean 使用
- **缓存复用**：同一个 Bean 在整个容器中只有一份实例，可以被安全地缓存和复用

##### 9.3.2.2.2 为什么原型 Bean 无法使用三级缓存？

###### 问题一：无限递归创建
让我们通过代码来理解：

```java
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class PrototypeA {
    @Autowired
    private PrototypeB prototypeB;
}

@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)  
public class PrototypeB {
    @Autowired
    private PrototypeA prototypeA;
}
```

**如果 Spring 尝试解决原型循环依赖，会发生什么？**

1. 第一次获取 `PrototypeA` → 需要注入 `PrototypeB`
2. 创建 `PrototypeB` → 需要注入 `PrototypeA`
3. 由于是原型作用域，Spring **必须创建新的 `PrototypeA` 实例**
4. 新的 `PrototypeA` 又需要新的 `PrototypeB` → 无限递归！

```mermaid
graph TD
    A[获取 PrototypeA] --> B[创建 PrototypeA 实例1]
    B --> C[需要注入 PrototypeB]
    C --> D[创建 PrototypeB 实例1]
    D --> E[需要注入 PrototypeA]
    E --> F[创建 PrototypeA 实例2]
    F --> G[需要注入 PrototypeB]
    G --> H[创建 PrototypeB 实例2]
    H --> I[无限递归...]
```

###### 问题二：缓存机制失效
三级缓存的核心是"提前暴露并复用"，但原型 Bean 的设计原则是"每次都是新的"：

| 机制 | 单例 Bean | 原型 Bean |
|------|-----------|-----------|
| **缓存策略** | 可以缓存半成品，后续复用 | 不能缓存，每次都要新建 |
| **暴露引用** | 暴露的引用最终会指向完整的 Bean | 暴露的引用指向的是即将被丢弃的半成品 |
| **结果** | 循环依赖可解 | 循环依赖无解 |

###### 问题三：内存泄漏风险
如果 Spring 尝试缓存原型 Bean 的半成品实例：
- 每次循环依赖都会创建新的半成品实例
- 这些半成品实例无法被垃圾回收（因为被其他 Bean 引用）
- 导致内存不断增长，最终内存泄漏

##### 9.3.2.2.3 Spring 的实际处理方式

Spring 在检测到原型 Bean 的循环依赖时，会直接抛出异常：

```java
// 模拟 Spring 的检测逻辑（简化版）
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}
```

**实际错误信息示例：**
```
Error creating bean with name 'prototypeA': 
Requested bean is currently in creation: 
Is there an unresolvable circular reference?
```

###### 9.3.2.2.4 代码演示：原型循环依赖的错误

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import static org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE;

@Configuration
@ComponentScan
public class AppConfig {
}

@Component
@Scope(SCOPE_PROTOTYPE)
class PrototypeA {
    @Autowired
    private PrototypeB prototypeB;
    
    public PrototypeA() {
        System.out.println("创建 PrototypeA 实例: " + this.hashCode());
    }
}

@Component
@Scope(SCOPE_PROTOTYPE)
class PrototypeB {
    @Autowired
    private PrototypeA prototypeA;
    
    public PrototypeB() {
        System.out.println("创建 PrototypeB 实例: " + this.hashCode());
    }
}

public class PrototypeCircularDependencyDemo {
    public static void main(String[] args) {
        try {
            var context = new AnnotationConfigApplicationContext(AppConfig.class);
            
            // 即使容器启动成功，获取 Bean 时也会报错
            PrototypeA a = context.getBean(PrototypeA.class);
        } catch (Exception e) {
            System.out.println("错误信息: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

运行这个代码，你会看到 Spring 直接抛出异常，拒绝创建这种循环依赖的原型 Bean。

##### 9.3.2.2.5 如何避免或解决原型循环依赖？

###### 1. 重新设计（推荐）
重新审视业务逻辑，通常原型 Bean 的循环依赖意味着设计有问题：

```java
// 不好的设计：循环依赖
@Component
@Scope(SCOPE_PROTOTYPE)
class Order {
    @Autowired
    private Customer customer; // 订单依赖客户
}

@Component  
@Scope(SCOPE_PROTOTYPE)
class Customer {
    @Autowired
    private Order lastOrder; // 客户依赖最新订单 → 循环依赖！
}

// 好的设计：打破循环
@Component
@Scope(SCOPE_PROTOTYPE)
class Order {
    private String customerId; // 只保存ID，不直接依赖Customer对象
    // 通过服务类获取Customer信息
    public Customer getCustomer(CustomerService service) {
        return service.findCustomer(customerId);
    }
}
```

###### 2. 使用 @Lazy 注解（临时方案）
```java
@Component
@Scope(SCOPE_PROTOTYPE)
class PrototypeA {
    @Lazy
    @Autowired
    private PrototypeB prototypeB; // 延迟加载，打破即时循环
}
```

###### 3. 使用方法注入（Method Injection）
```java
@Component
@Scope(SCOPE_PROTOTYPE)
public abstract class PrototypeA {
    // 通过抽象方法获取依赖
    public abstract PrototypeB getPrototypeB();
    
    public void doSomething() {
        PrototypeB b = getPrototypeB(); // 使用时才获取
        // 使用b...
    }
}
```

##### 9.3.2.2.6 总结

Spring 不能解决原型 Bean 循环依赖的根本原因是：

| 层面 | 原因 |
|------|------|
| **设计哲学** | 原型 Bean "每次都是新的" 与 循环依赖解决机制"缓存复用" 相矛盾 |
| **技术实现** | 会导致无限递归创建，无法确定何时停止 |
| **内存安全** | 会造成内存泄漏，半成品实例无法被回收 |
| **业务合理性** | 原型 Bean 通常不应该有复杂的相互依赖关系 |

**最佳实践：**
- 单例 Bean 用于有状态的服务和组件
- 原型 Bean 用于无状态、需要频繁创建销毁的对象
- 避免在原型 Bean 之间建立复杂的依赖关系
- 如果确实需要，考虑使用 `@Lazy` 或重新设计架构

理解这个限制能帮助你在设计 Spring 应用时做出更合理的架构决策。
### 9.3.3 那么其它循环依赖如何解决？
这类循环依赖问题解决方法很多，主要有：
- 使用@Lazy注解，延迟加载
- 使用@DependsOn注解，指定加载先后关系
- 修改文件名称，改变循环依赖类的加载顺序
#### 9.3.3.1 生成代理对象产生的循环依赖(@Lazy)
`@Lazy` 注解的作用是**延迟注入**，它通过创建一个代理对象来打破循环依赖的"死锁"状态。让我详细解释：

- 原来的问题场景（没有 `@Lazy`）

假设你有两个相互依赖的类：

```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB; // 直接依赖
}

@Service  
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // 直接依赖
}
```

**启动失败的原因：**
1. Spring 开始创建 `ServiceA`
2. 发现需要注入 `ServiceB` → 去创建 `ServiceB`
3. 创建 `ServiceB` 时发现需要注入 `ServiceA` → 但 `ServiceA` 还在创建中（半成品）
4. **形成死锁** → Spring 抛出 `BeanCurrentlyInCreationException`

- 加了 `@Lazy` 后的工作流程

```java
@Service
public class ServiceA {
    @Lazy // 关键在这里！
    @Autowired
    private ServiceB serviceB; // 现在是延迟依赖
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
}
```

**现在启动成功的原因：**

1. **Spring 开始创建 `ServiceA`**
2. 发现需要注入 `ServiceB`，但因为有 `@Lazy` 注解：
   - Spring **不立即创建真实的 `ServiceB` 实例**
   - 而是创建一个 `ServiceB` 的**代理对象**（如 CGLIB 代理）
   - 将这个代理对象注入到 `ServiceA` 中
3. **`ServiceA` 的依赖注入完成**，可以继续后续初始化
4. `ServiceA` 完全创建好后放入一级缓存
5. **现在 Spring 开始创建 `ServiceB`**
6. `ServiceB` 需要注入 `ServiceA` → 此时 `ServiceA` 已完全创建好 → 成功注入
7. `ServiceB` 完成创建

**关键点：** `@Lazy` 通过**延迟真实对象的创建时机**，打破了循环依赖的"同时创建"的死锁。

---

- `@Lazy` 与三级缓存的区别

| 机制 | 工作原理 | 适用场景 |
|------|----------|----------|
| **三级缓存** | 提前暴露**半成品 Bean 的引用**，让依赖方先拿到不完整的对象 | 适用于**属性注入**方式的循环依赖 |
| **`@Lazy` 注解** | 创建**代理对象**延迟真实依赖的创建，打破循环创建顺序 | 适用于**构造器注入**或三级缓存无法解决的复杂场景 |

- 为什么有时候三级缓存不够用？

三级缓存能解决大部分**属性注入**的循环依赖，但在以下情况下会失效：

1. **构造器注入的循环依赖**
   ```java
   @Service
   public class ServiceA {
       // 构造器注入 - 三级缓存无法解决
       public ServiceA(ServiceB serviceB) { ... }
   }
   
   @Service
   public class ServiceB {
       public ServiceB(ServiceA serviceA) { ... }
   }
   ```
   这种情况下，加 `@Lazy` 是有效的解决方案。

2. **复杂的多层级循环依赖**
   当循环依赖链较长或结构复杂时，三级缓存可能也无法解决。

3. **某些代理场景下的限制**
   在某些 AOP 代理配置下，三级缓存机制可能无法正常工作。

---

- `@Lazy` 的几种用法

1. 在注入点使用（你最常用的方式）
```java
@Service
public class ServiceA {
    @Lazy
    @Autowired
    private ServiceB serviceB;
    
    // 或者用在构造器参数上
    public ServiceA(@Lazy ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}
```

2. 在配置类中的 `@Bean` 方法上使用
```java
@Configuration
public class AppConfig {
    @Lazy
    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }
}
```

3. 在类级别使用（延迟整个 Bean 的初始化）
```java
@Lazy
@Service
public class ServiceA {
    // 整个 Bean 都会延迟初始化
}
```

---

- 实际代码演示

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Service;
import javax.annotation.PostConstruct;

@Configuration
@ComponentScan
public class AppConfig {
}

@Service
class OrderService {
    @Lazy // 关键：加上这个注解
    @Autowired
    private UserService userService;
    
    @PostConstruct
    public void init() {
        System.out.println("OrderService 初始化完成");
    }
    
    public void createOrder() {
        System.out.println("创建订单，用户服务: " + userService);
        // 只有在第一次调用 userService 的方法时，才会真正初始化 UserService
        userService.getUserInfo();
    }
}

@Service
class UserService {
    @Autowired
    private OrderService orderService;
    
    @PostConstruct
    public void init() {
        System.out.println("UserService 初始化完成");
    }
    
    public void getUserInfo() {
        System.out.println("获取用户信息");
    }
}

public class LazySolutionDemo {
    public static void main(String[] args) {
        System.out.println("启动 Spring 容器（使用 @Lazy 解决循环依赖）...");
        var context = new AnnotationConfigApplicationContext(AppConfig.class);
        System.out.println("容器启动成功！");
        
        OrderService orderService = context.getBean(OrderService.class);
        System.out.println("OrderService: " + orderService);
        
        // 第一次调用才会真正初始化 UserService
        orderService.createOrder();
    }
}
```

运行结果：
```
启动 Spring 容器（使用 @Lazy 解决循环依赖）...
OrderService 初始化完成
UserService 初始化完成
容器启动成功！
OrderService: com.example.OrderService@...
创建订单，用户服务: com.example.UserService$$EnhancerBySpringCGLIB$$...  // 注意这里是代理对象
获取用户信息
```

---

- 总结

**加 `@Lazy` 能解决循环依赖的原因是：**

1. **打破创建顺序**：通过创建代理对象延迟真实依赖的初始化
2. **避免死锁**：让其中一个 Bean 先完成创建，再创建另一个
3. **代理机制**：Spring 创建的是目标对象的代理，只有在真正使用时才初始化真实对象

**使用建议：**
- 对于简单的属性注入循环依赖，优先让 Spring 的三级缓存自动解决
- 对于构造器注入或复杂循环依赖，使用 `@Lazy` 注解
- 注意 `@Lazy` 会引入代理对象，可能在某些场景下带来微小的性能开销

`@Lazy` 是 Spring 提供的另一种强大的循环依赖解决方案，理解它的工作原理能帮助你在实际开发中更好地处理依赖关系问题。
#### 9.3.3.2 使用@DependsOn产生的循环依赖
这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。
#### 9.3.3.3 多例循环依赖
这类循环依赖问题可以通过把bean改成单例的解决。
#### 9.3.3.4 构造器循环依赖
这类循环依赖问题可以通过使用@Lazy注解解决。
### 9.3.4 为什么要3级缓存而不是2级缓存
#### 9.3.4.1 先快速回顾三级缓存的作用

Spring 的三级缓存结构：

| 缓存级别 | 名称 | 存储内容 | 作用 |
|---------|------|----------|------|
| **一级缓存** | `singletonObjects` | 完全初始化好的单例 Bean | 提供最终可用的 Bean |
| **二级缓存** | `earlySingletonObjects` | 早期暴露的 Bean（半成品） | 解决循环依赖的临时存储 |
| **三级缓存** | `singletonFactories` | Bean 的工厂对象（`ObjectFactory`） | 处理 AOP 代理等特殊场景 |

#### 9.3.4.2 为什么不能只用两级缓存？

假设我们去掉三级缓存，只用一级和二级缓存，会发生什么问题？

#####  场景分析：有 AOP 代理的循环依赖

```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Service  
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // 这里需要的是代理对象！
}

// ServiceA 需要被 AOP 代理（比如有 @Transactional 注解）
```

**如果只有两级缓存的工作流程：**

1. **创建 ServiceA**
   - 实例化 ServiceA（原始对象）
   - 将 ServiceA 的**原始对象**放入二级缓存（earlySingletonObjects）
   - 开始属性注入，发现需要 ServiceB

2. **创建 ServiceB**
   - 实例化 ServiceB
   - 将 ServiceB 放入二级缓存
   - 属性注入时需要 ServiceA
   - 从二级缓存拿到 ServiceA 的**原始对象**（不是代理对象！）
   - ServiceB 初始化完成

3. **继续初始化 ServiceA**
   - 现在需要对 ServiceA 进行 AOP 代理
   - 但 ServiceB 中已经注入了 ServiceA 的**原始对象**
   - **问题：ServiceB 持有的是原始对象，不是代理对象！**

这就导致了**数据不一致**：有的地方用的是代理对象，有的地方用的是原始对象。

#### 9.3.4.3 三级缓存如何解决这个问题？

三级缓存存储的是 `ObjectFactory`，它可以在需要时**动态决定返回什么对象**。

**三级缓存的工作流程：**

1. **创建 ServiceA**
   - 实例化 ServiceA（原始对象）
   - 将 ServiceA 的 **ObjectFactory** 放入三级缓存
   - 这个 ObjectFactory 知道如何创建代理对象
   - 开始属性注入，需要 ServiceB

2. **创建 ServiceB**  
   - 实例化 ServiceB
   - 属性注入时需要 ServiceA
   - 从三级缓存拿到 ObjectFactory
   - ObjectFactory 判断 ServiceA 需要代理 → **返回代理对象**
   - ServiceB 注入的是 ServiceA 的**代理对象**
   - ServiceB 初始化完成

3. **继续初始化 ServiceA**
   - 完成属性注入
   - 进行 AOP 代理（如果之前已经创建过代理，这里会复用）
   - 将最终对象放入一级缓存

**关键优势：** 三级缓存通过 `ObjectFactory` 实现了**延迟决策**，只有在真正需要的时候才决定返回原始对象还是代理对象。

#### 9.3.4.4 代码层面看区别

##### 两级缓存方案（有问题）
```java
// 伪代码：只有两级缓存
public class DefaultSingletonBeanRegistry {
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(); // 一级缓存
    private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(); // 二级缓存
    
    // 问题：无法处理代理场景
    protected Object getSingleton(String beanName) {
        Object singleton = singletonObjects.get(beanName);
        if (singleton == null) {
            singleton = earlySingletonObjects.get(beanName); // 直接返回半成品
        }
        return singleton;
    }
}
```

##### 三级缓存方案（正确方案）
```java
// Spring 实际实现（简化）
public class DefaultSingletonBeanRegistry {
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(); // 一级
    private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(); // 二级  
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(); // 三级
    
    protected Object getSingleton(String beanName) {
        Object singleton = singletonObjects.get(beanName);
        if (singleton == null) {
            singleton = earlySingletonObjects.get(beanName);
            if (singleton == null) {
                ObjectFactory<?> singletonFactory = singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    // 关键：通过工厂动态创建（可能是代理对象）
                    singleton = singletonFactory.getObject();
                    earlySingletonObjects.put(beanName, singleton);
                    singletonFactories.remove(beanName);
                }
            }
        }
        return singleton;
    }
}
```

#### 9.3.4.5 实际案例演示

假设我们有需要 AOP 代理的循环依赖：

```java
@Service
@Transactional // 这个注解会让 ServiceA 被代理
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
    
    public void methodA() {
        System.out.println("ServiceA 方法执行");
    }
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // 这里需要的是代理对象！
    
    public void methodB() {
        serviceA.methodA(); // 如果 serviceA 不是代理，@Transactional 会失效
    }
}
```

**只有两级缓存的结果：**
- ServiceB 中的 serviceA 是原始对象，不是代理
- 调用 `serviceA.methodA()` 时，@Transactional 注解失效，没有事务管理

**三级缓存的结果：**
- ServiceB 中的 serviceA 是代理对象
- 调用 `serviceA.methodA()` 时，事务正常生效

## 为什么不能合并二级和三级缓存？

有人可能会想：能不能把二级和三级缓存合并成一个"早期对象缓存"？

**不行，原因如下：**

1. **职责分离原则**
   - 二级缓存：存储已经确定的早期对象
   - 三级缓存：存储创建对象的工厂，支持动态决策

2. **性能考量**  
   - 如果合并，每次获取早期对象都需要通过工厂创建，影响性能
   - 三级缓存方案只在第一次需要时创建代理，后续直接从二级缓存获取

3. **逻辑清晰性**
   - 分离后代码更易理解和维护
   - 每个缓存有明确的职责边界

#### 9.3.4.6 总结

Spring 使用三级缓存而不是两级缓存的主要原因：

| 考量点 | 两级缓存的问题 | 三级缓存的优势 |
|--------|----------------|----------------|
| **AOP 代理支持** | 无法正确处理代理对象，导致不一致 | 动态返回代理对象，保证一致性 |
| **设计灵活性** | 硬编码对象创建逻辑，扩展性差 | 通过工厂模式，支持各种扩展 |
| **性能优化** | 可能需要重复创建对象 | 缓存机制更精细，避免不必要的创建 |
| **代码维护性** | 逻辑混杂，难以维护 | 职责分离，结构清晰 |

**简单来说：三级缓存是 Spring 在"解决循环依赖"和"支持 AOP"之间找到的最佳平衡点。** 它确保了即使在复杂的代理场景下，Bean 的依赖关系也能正确建立。

这也是 Spring 框架设计精妙之处——看似复杂的机制，实际上都是为了解决实际应用中的各种边界情况。



## 9.4  工厂类（FactoryBean）

### 9.4.1. 工厂类（FactoryBean）是什么意思？

这里的“工厂类”特指 Spring 框架中的一个接口：**`FactoryBean`**。

*   **普通 Bean**：在 Spring 容器中，当你定义一个普通的 Bean（比如通过 `@Component` 注解或 XML 配置），容器会直接创建这个类（如 `MyService`）的实例，并管理它的生命周期。
*   **`FactoryBean`**：它是一个**特殊的 Bean**，它本身也是一个工厂。它的职责不是提供自身的实例，而是负责**创建并返回另一个对象（目标对象）的实例**。你可以把它想象成一个“对象工厂”。

**`FactoryBean` 接口有三个核心方法：**
*   `T getObject()`：返回由这个工厂创建的目标对象实例。这是最重要的方法。
*   `Class<?> getObjectType()`：返回`getObject()`方法所返回对象的类型。
*   `boolean isSingleton()`：指示`getObject()`返回的对象是否是单例。

### 9.4.2. 为什么名字前面要加上 `&`？

**`&` 前缀的作用是：当你想获取 `FactoryBean` 工厂本身，而不是它生产的对象时，使用的标识符。**

这解决了潜在的歧义问题。我们通过一个例子来理解：

假设我们有一个 `FactoryBean`，它负责创建 `SqlSessionFactory` 对象（这是 MyBatis 框架中的核心接口）。

```java
// 这是一个 FactoryBean，它的产品是 SqlSessionFactory
@Component("sqlSessionFactory")
public class SqlSessionFactoryBean implements FactoryBean<SqlSessionFactory> {
    @Override
    public SqlSessionFactory getObject() throws Exception {
        // 复杂的创建逻辑...
        return new SqlSessionFactoryImpl();
    }

    @Override
    public Class<?> getObjectType() {
        return SqlSessionFactory.class;
    }
}
```

现在，我们在 Spring 容器中通过名称 `sqlSessionFactory` 来获取这个 Bean：

```java
ApplicationContext context = ...;

// 情况一：不加 ‘&’ 前缀
Object bean1 = context.getBean("sqlSessionFactory");
// bean1 是什么？是 SqlSessionFactoryBean 这个工厂类本身吗？
// 不是！这里获取到的是工厂生产的产品，也就是 getObject() 返回的 SqlSessionFactory 对象。

// 情况二：加 ‘&’ 前缀
Object bean2 = context.getBean("&sqlSessionFactory");
// bean2 是什么？这里获取到的才是 SqlSessionFactoryBean 这个工厂对象本身。
```

**总结一下命名规则：**

| Bean 名称 | 获取到的对象 |
| :--- | :--- |
| `sqlSessionFactory` | `SqlSessionFactory`（工厂生产的产品） |
| `&sqlSessionFactory` | `SqlSessionFactoryBean`（工厂本身） |

### 9.4.3. 回到代码：`String beanName = transformedBeanName(name);`

这行代码所在的逻辑（通常是在 `AbstractBeanFactory` 中）正是为了处理上述的歧义。

它的作用是：**如果传入的 `name` 带有 `&` 前缀，说明调用者明确想要获取的是 `FactoryBean` 本身。但在 Spring 内部进行依赖查找、初始化等核心流程时，它需要的是 Bean 的“真实名称”（即不带 `&` 的名称），以便找到正确的 Bean 定义（BeanDefinition）。**

所以，`transformedBeanName(name)` 方法会**去掉 `&` 前缀**，返回这个 Bean 在容器中注册的真实名称。

**内部处理流程简化如下：**

1.  你调用 `getBean("&myFactoryBean")` 想要获取工厂本身。
2.  Spring 收到请求 `name = "&myFactoryBean"`。
3.  在开始查找之前，先调用 `transformedBeanName("&myFactoryBean")`，得到 `beanName = "myFactoryBean"`。
4.  Spring 用这个真实的 `beanName`（`"myFactoryBean"`）去容器里找到对应的 `BeanDefinition`。
5.  根据 `BeanDefinition` 创建或获取实例。
6.  在最后返回实例前，Spring 检查到原始的 `name` 是带 `&` 的，于是它判断出：“哦，用户要的是工厂本身，而不是产品”。所以它直接返回第 5 步创建好的 `FactoryBean` 实例。
7.  如果原始的 `name` 不带 `&`，Spring 就会检查第 5 步得到的实例是不是 `FactoryBean`。如果是，则调用其 `getObject()` 方法返回产品；如果不是，直接返回该实例。

### 结论

*   **工厂类**：指的是 Spring 的 `FactoryBean` 接口实现类，它是一个能生产其他对象的特殊 Bean。
*   **加 `&` 前缀**：是一种语法约定，用于区分“获取工厂生产的产品”和“获取工厂本身”。这是解决命名歧义的一种巧妙设计。
*   `transformedBeanName()` **方法**：是 Spring 内部用来统一处理 Bean 名称的工具方法，它会去掉 `&` 前缀，找到 Bean 的真实名称，以便进行后续的核心流程。
## 9.5 为什么要用FactoryBean

### 9.5.1. 封装复杂的创建逻辑

有些对象的创建过程涉及多个步骤、需要读取外部配置、或者需要进行大量的初始化工作。如果把这些代码全部写在配置类或 XML 里，会非常臃肿且难以维护。

**示例：** 创建 MyBatis 的 `SqlSessionFactory`。
这个对象需要：
1.  加载数据源。
2.  解析 MyBatis 的全局配置文件（`mybatis-config.xml`）。
3.  扫描并解析所有的 Mapper XML 文件。
4.  创建映射器接口的代理对象。
...等等。

如果不用 `FactoryBean`，你可能需要在 `@Bean` 方法里写几十行初始化代码。而 MyBatis-Spring 整合包提供了一个 `SqlSessionFactoryBean`，它把这些复杂的逻辑全部封装在了内部。你只需要进行简单的属性配置（比如设置数据源和配置文件路径），Spring 就能通过这个工厂轻松地创建出 `SqlSessionFactory`。

```java
@Bean
public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
    SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
    factoryBean.setDataSource(dataSource); // 简单配置
    factoryBean.setConfigLocation(new ClassPathResource("mybatis-config.xml"));
    // ... 其他简单配置
    return factoryBean; // Spring 会自动调用它的 getObject() 方法
}
```

### 9.5.2. 集成第三方库

许多第三方框架（如 MyBatis、Apache Shiro、Thymeleaf 等）需要将其核心对象交给 Spring 管理。但这些对象通常有自己独特的创建方式，不遵循 Spring 的标准生命周期。

`FactoryBean` 充当了一个**适配器**（Adapter）的角色。它由 Spring 管理（遵循 Spring 的生命周期），然后在内部以第三方库要求的方式创建目标对象，并将其“伪装”成一个普通的 Spring Bean。

### 9.5.3. 控制对象的创建方式

有时，我们不想通过构造函数来创建对象，而是想通过：
*   **静态工厂方法**（如 `Calendar.getInstance()`）
*   **实例工厂方法**
*   **从某个服务定位器（Service Locator）中获取**

`FactoryBean` 提供了比标准 XML/Java Config 更强大、更灵活的编程能力来实现这些模式。

### 9.5.4. 实现“延迟初始化”或“动态代理”的增强逻辑

你可以在 `FactoryBean` 的 `getObject()` 方法中加入自定义逻辑。例如：
*   **每次返回新实例（原型模式）**：即使工厂本身是单例，也可以在 `getObject()` 中返回新的对象。
*   **返回代理对象**：在返回真实对象前，先为其创建一个 AOP 代理，从而实现切面编程。
*   **根据条件返回不同的实现**：根据运行时环境或配置，决定返回哪个具体类的实例。

### 9.5.5. 隐藏实现细节

对于调用者来说，它只需要通过一个简单的 Bean 名称（如 `sqlSessionFactory`）就能获取到一个完全初始化好的、复杂的对象。它完全不需要关心这个对象是怎么被创建出来的。这符合“依赖倒置”和“最少知识”原则。

---

### 9.5.6 一个简单的自建 FactoryBean 示例

假设我们要创建一个 Bean，它的内容是当前时间戳。但我们希望每次获取它时，都得到一个新的时间戳（即原型作用域）。

```java
// 1. 定义产品（一个简单的值对象）
public class Timestamp {
    private final long value;
    public Timestamp(long value) { this.value = value; }
    public long getValue() { return value; }
}

// 2. 实现 FactoryBean
@Component("currentTimestamp") // 给工厂本身起个名字
public class TimestampFactoryBean implements FactoryBean<Timestamp> {

    @Override
    public Timestamp getObject() throws Exception {
        // 核心逻辑：每次调用都返回一个新的 Timestamp 对象
        return new Timestamp(System.currentTimeMillis());
    }

    @Override
    public Class<?> getObjectType() {
        return Timestamp.class;
    }

    @Override
    public boolean isSingleton() {
        // 返回 false，表示产品不是单例。工厂本身（TimestampFactoryBean）仍然是单例。
        return false;
    }
}
```

**使用方式：**

```java
@Autowired
private ApplicationContext context;

public void doSomething() {
    // 获取产品（每次都是新的）
    Timestamp ts1 = (Timestamp) context.getBean("currentTimestamp");
    System.out.println(ts1.getValue()); // 输出如：1720789321000

    Thread.sleep(1000);

    Timestamp ts2 = (Timestamp) context.getBean("currentTimestamp");
    System.out.println(ts2.getValue()); // 输出如：1720789322000 (值不同)

    // 获取工厂本身
    TimestampFactoryBean factory = (TimestampFactoryBean) context.getBean("&currentTimestamp");
    System.out.println(factory.getClass().getSimpleName()); // 输出：TimestampFactoryBean
}
```

### 9.5.7 总结：为什么要用 FactoryBean？

| 场景 | 优势 |
| :--- | :--- |
| **创建过程复杂** | **封装性**：将繁琐的初始化代码隐藏起来，提供简单的配置接口。 |
| **集成第三方库** | **适配性**：作为 Spring 和非 Spring 世界之间的桥梁。 |
| **需要特殊创建逻辑** | **灵活性**：完全通过 Java 代码控制对象的创建，比静态配置更强大。 |
| **需要增强对象** | **可扩展性**：可以在 `getObject()` 中轻松加入代理、缓存等逻辑。 |
| **为调用者简化** | **简洁性**：调用者无需关心底层实现，直接使用即可。 |

因此，`FactoryBean` 是 Spring 框架可扩展性设计中至关重要的一环，它让 Spring 容器具备了管理任何类型对象的能力。
## 9.6 FactoryBean和BeanFactory对比

### 9.6.1 `FactoryBean` vs `BeanFactory` 对比表

| 特性 | **BeanFactory** | **FactoryBean** |
| :--- | :--- | :--- |
| **角色/定位** | **Spring 容器的顶层核心接口，是 IOC 容器本身** | **Spring 容器中一种特殊的 Bean，是 IOC 容器的“居民”** |
| **本质** | 它是**基础设施**，是**工厂的工厂**，是整个 Spring 框架的基石。 | 它是**被管理的对象**，是一个**能生产其他对象的特殊工厂**。 |
| **设计模式** | 主要体现了 **工厂方法模式** (Factory Method Pattern)，用于创建和管理各种对象。 | 主要体现了 **工厂方法模式** 和 **抽象工厂模式**，专注于创建某一类复杂对象。 |
| **功能职责** | 负责读取配置信息、管理 Bean 的生命周期（创建、初始化、销毁）、依赖注入、获取 Bean 实例等。 | 负责封装复杂对象的创建逻辑，其 `getObject()` 方法返回一个特定的、通常很复杂的对象实例。 |
| **与容器的关系** | **它就是容器的心脏和大脑**。`ApplicationContext` 是其子接口，功能更丰富。 | **它是容器内部的一个“高级工人”**。它本身被 `BeanFactory` 所管理和调度。 |
| **获取对象的方式** | 通过 `getBean(String name)` 等方法从容器中获取 Bean。 | 当通过名字获取它时，默认返回的是它生产的**产品**；要获取它**本身**，需要在名字前加 `&`。 |
| **使用场景** | 任何使用 Spring 框架的场景，你都在间接或直接使用 `BeanFactory`/`ApplicationContext`。 | 需要创建过程复杂的对象（如 `SqlSessionFactory`）、集成第三方库、或需要特殊初始化逻辑的 Bean。 |
| **简单比喻** | **整个汽车制造厂**。它拥有生产线、资源和管理体系，能生产各种零部件和整车。 | **厂里的一个“发动机精密组装车间”**。这个车间本身是工厂的一部分（一个 Bean），但它专门负责生产复杂的发动机（产品）。 |

---

### 9.6.2 深入解析与比喻

为了让你理解得更透彻，我们再用一个更生动的比喻：

**把 Spring 容器想象成一家庞大的“对象工厂”（`BeanFactory`）。**

1.  **`BeanFactory`（对象工厂总部）**
    *   它是这家工厂的**总指挥部**。
    *   它制定了生产各种对象（Bean）的流水线和标准（生命周期）。
    *   它管理着所有员工（Bean）的档案（BeanDefinition），知道怎么找到他们，怎么给他们配齐工具（依赖注入）。
    *   你想要任何产品（Bean），比如一辆“购物车”（`ShoppingCart`）或者一个“用户服务”（`UserService`），都要向总部（`BeanFactory`）申请（调用 `getBean`）。

2.  **`FactoryBean`（特种零件车间）**
    *   它是这家工厂里的一个**特殊的、高度专业化的车间**。
    *   比如，有一个“加密芯片车间”（`EncryptionChipFactoryBean`）。
    *   这个车间本身也是工厂的员工（它是一个 Bean，被 `BeanFactory` 管理）。
    *   但是，这个车间的特殊之处在于：**它不生产自己，它只生产一种非常复杂、需要特殊工艺的“加密芯片”**。
    *   当你向总部（`BeanFactory`）说：“给我一个‘加密芯片’（`encryptionChip`）”，总部不会自己去造，而是会把任务派给这个“加密芯片车间”（`FactoryBean`），并让它交出产品（调用 `getObject()`）。
    *   如果你想知道这个车间本身长什么样，你需要明确告诉总部：“我要的是‘**&**加密芯片车间’（`&encryptionChip`）本身”，而不是它生产的产品。

### 9.6.3 代码示例回顾

```java
// BeanFactory (以 ApplicationContext 形式出现) 是容器
ApplicationContext factory = new AnnotationConfigApplicationContext(AppConfig.class);

// 从容器（BeanFactory）中获取一个 Bean
// 如果 ‘myBean’ 是一个普通 Bean，直接返回 MyBean 的实例
// 如果 ‘myBean’ 是一个 FactoryBean，则返回它的产品（getObject() 的结果）
Object product = factory.getBean("myBean");

// 如果想获取 FactoryBean 本身，而不是它的产品，需要加 ‘&’
Object factoryBeanItself = factory.getBean("&myBean");
```

### 9.6.4 总结

| 概念 | 一句话总结 |
| :--- | :--- |
| **`BeanFactory`** | **我是容器，我管着所有 Bean（包括 `FactoryBean`）的生老病死。** |
| **`FactoryBean`** | **我是容器里的一个特殊 Bean，我的职责是帮容器制造那些“不好造”的复杂对象。** |

简单来说，**`BeanFactory` 是 Spring 的 IOC 容器，而 `FactoryBean` 是存在于这个容器中的一个用于生产复杂对象的特殊工具 Bean。** 它们是管理者与被管理者、容器与内容物的关系。
## 9.7 重点：Spring中Bean的生命周期
> Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。

Spring 容器可以管理 singleton 作用域 Bean 的生命周期，在此作用域下，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁。

而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。每次客户端请求 prototype 作用域的 Bean 时，Spring 容器都会创建一个新的实例，并且不会管那些被配置成 prototype 作用域的 Bean 的生命周期。

了解 Spring 生命周期的意义就在于，**可以利用 Bean 在其存活期间的指定时刻完成一些相关操作**。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作。
### 9.7.1 Spring Bean生命周期流程
> 在 Spring 中，Bean 的生命周期是一个很复杂的执行过程，我们可以利用 Spring 提供的方法定制 Bean 的创建过程。
- Spring 容器中 Bean 的生命周期流程
![70.spring-framework-ioc-source-102.png](../../assets/images/04-主流框架/spring/70.spring-framework-ioc-source-102.png)
- 如果 BeanFactoryPostProcessor 和 Bean 关联, 则调用postProcessBeanFactory方法.(即首先尝试从Bean工厂中获取Bean)
- 如果 InstantiationAwareBeanPostProcessor 和 Bean 关联，则调用postProcessBeforeInstantiation方法
- 根据配置情况调用 Bean 构造方法**实例化 Bean**。
- 利用依赖注入完成 Bean 中所有属性值的**配置注入**。
- 如果 InstantiationAwareBeanPostProcessor 和 Bean 关联，则调用postProcessAfterInstantiation方法和postProcessProperties
- 调用xxxAware接口 (上图只是给了几个例子)
    - 第一类Aware接口
      - 如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。
      - 如果 Bean 实现了 BeanClassLoaderAware 接口，则 Spring 调用 setBeanClassLoader() 方法传入classLoader的引用。
      - 如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。
    - 第二类Aware接口
      - 如果 Bean 实现了 EnvironmentAware 接口，则 Spring 调用 setEnvironment() 方法传入当前 Environment 实例的引用。
      - 如果 Bean 实现了 EmbeddedValueResolverAware 接口，则 Spring 调用 setEmbeddedValueResolver() 方法传入当前 StringValueResolver 实例的引用。
      - 如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。
      - ...
- 如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。
- 如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。(或者有执行@PostConstruct注解的方法)
- 如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。
- 如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。
- 如果在`<bean>`中指定了该 Bean 的作用范围为 scope="singleton"，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在`<bean>` 中指定了该 Bean 的作用范围为 scope="prototype"，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。
- 如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；(或者有执行@PreDestroy注解的方法)
- 如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。

**Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：(结合上图，需要有如下顶层思维)**
- `Bean自身的方法`： 这个包括了Bean本身调用的方法和通过配置文件中`<bean>`的init-method和destroy-method指定的方法
- `Bean级生命周期接口方法`： 这个包括了BeanNameAware、BeanFactoryAware、ApplicationContextAware；当然也包括InitializingBean和DiposableBean这些接口的方法（可以被@PostConstruct和@PreDestroy注解替代）
- `容器级生命周期接口方法`： 这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。
- `工厂后处理器接口方法`： 这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。
### 9.7.2 更详细的整理一下生命周期流程以及各流程的作用
#### 9.7.2.1 生命周期增强功能详解
![71.Bean生命周期.png](../../assets/images/04-主流框架/spring/71.Bean生命周期.png)

我们可以将整个生命周期分为两大阶段：**Bean 的实例化与属性赋值阶段** 和 **Bean 的初始化与销毁阶段**。整个过程由 Spring IoC 容器（主要是 `BeanFactory`）精细地控制。

##### 阶段一：Bean 的实例化与属性赋值

这个阶段的目标是创建一个 Bean 的实例，并填充其属性。

1.  **实例化（Instantiate）**
    *   Spring 容器首先读取 Bean 的配置信息（如 XML、注解或 Java Config），找到对应的类。
    *   容器通过**反射**调用类的**构造方法**来创建一个新的对象实例。此时只是一个普通的 Java 对象，内部的依赖还没有被设置。

2.  **属性赋值（Populate Properties）**
    *   容器解析并注入 Bean 所依赖的其他 Bean（通过 `@Autowired`, `@Resource` 或 XML 中的 `<property>` 标签等）。
    *   注入普通属性值（如 String, int 等）。

**对于上述实例化和属性赋值阶段，Spring提供了一部分增强点：**

1. BeanFactoryPostProcessor（在 Bean 实例化之前）

- **作用阶段**：在 Spring 容器加载了所有 Bean 的定义（`BeanDefinition`）之后，但在任何 Bean 实例化**之前**执行。
- **功能**：它可以读取、修改甚至注册新的 Bean 定义。这是一个**容器级别**的扩展，允许你在 Bean 创建前调整其配置（例如，修改属性值）。
- **常见用途**：属性占位符配置（PropertyPlaceholderConfigurer）、自定义配置调整。

2. InstantiationAwareBeanPostProcessor（在实例化和属性注入阶段）

这是 `BeanPostProcessor` 的子接口，专门针对实例化和属性注入阶段提供了三个关键方法：

- **postProcessBeforeInstantiation(Class<?> beanClass, String beanName)**：
    - **作用阶段**：在 Bean **实例化之前**（即调用构造器之前）。
    - **功能**：如果此方法返回一个非 null 对象，则 Spring 会使用这个返回的对象作为 Bean 实例，并**短路**后续的标准实例化流程（包括属性注入和初始化）。这常用于创建 AOP 代理或其他高级场景。
- **postProcessAfterInstantiation(Object bean, String beanName)**：
    - **作用阶段**：在 Bean **实例化之后**（对象已通过构造器创建），但在**属性注入之前**。
    - **功能**：如果返回 `false`，Spring 将跳过后续对该 Bean 的属性注入阶段。这允许你完全手动控制依赖注入。
- **postProcessProperties(PropertyValues pvs, Object bean, String beanName)**：
    - **作用阶段**：在**属性注入之时**（如果 `postProcessAfterInstantiation` 返回 `true`）。
    - **功能**：允许你检查、修改或完全替换要注入的属性值（`PropertyValues`）。这是进行自定义依赖注入的强力钩子。
---

##### 阶段二：Bean 的初始化与销毁

这个阶段是 Bean 生命周期的核心，包含了大量的扩展点，让开发者可以介入 Bean 的创建过程。**请注意此阶段与流程图的对应关系**。

3.  **设置 Bean 的感知接口（Aware Interfaces）**
    *   如果 Bean 实现了各种 `Aware` 接口，容器会回调相应的方法，将一些基础设施注入到 Bean 中。
    - **作用阶段**：基础的 Aware 接口（BeanName、BeanFactory）最先执行(先于BeanPostProcessor )。ApplicationContextAware 是通过一个特殊的 BeanPostProcessor 来处理的顺序则不同。
    - **功能**：Spring 容器会检查 Bean 是否实现了特定的 `Aware` 接口，如果是，则回调相应方法，将容器的基础设施注入到 Bean 中。这使 Bean 能感知到它的运行环境。
    - **常见接口**：
        *   `BeanNameAware`: 将 Bean 在容器中的 ID（名称）传递给 Bean。
        *   `BeanFactoryAware`: 将创建它的 `BeanFactory` 容器实例传递给 Bean。
        *   `ApplicationContextAware`: 将创建它的 `ApplicationContext` 容器实例传递给 Bean（因为 `ApplicationContext` 是 `BeanFactory` 的子接口，所以这个更常用）。

4.  **BeanPostProcessor 前置处理**
    *   `BeanPostProcessor` 是 Spring 提供的一个极其强大的**容器级**扩展接口。如果容器中存在 `BeanPostProcessor` 的实现类，那么**每个 Bean** 在初始化前后都会执行它的方法。
    *   首先执行 `postProcessBeforeInitialization` 方法。你可以在这个方法中对 Bean 进行包装或修改。**Spring AOP 的动态代理就是在这个阶段生成的**。

5.  **初始化方法（Initialization）**
    *   这个阶段按顺序执行三种自定义的初始化逻辑：
        *   **使用 `@PostConstruct` 注解的方法**: 这是 JSR-250 规范提供的注解，是推荐的现代方式。
        *   **实现 `InitializingBean` 接口**: Bean 实现 `InitializingBean` 接口，然后实现 `afterPropertiesSet` 方法。这种方式将代码与 Spring 接口耦合，不推荐。
        *   **配置自定义 `init-method`**: 在 XML 配置中指定 `init-method` 属性，或通过 `@Bean(initMethod = "...")` 指定一个普通方法。这种方式无侵入性。

6.  **BeanPostProcessor 后置处理**
    *   接着，执行 `BeanPostProcessor` 的 `postProcessAfterInitialization` 方法。此时 Bean 已经完全初始化，可以进行最终的修饰或代理。

7.  **Bean 就绪（Ready）**
    *   经过以上所有步骤，Bean 已经创建并初始化完毕，将一直驻留在容器的**单例缓存池**（Singleton Cache）中。此时，Bean 可以被应用程序请求和使用，也就是我们通常所说的“依赖注入”。

---

##### 阶段三：Bean 的销毁

当 Spring 容器被关闭时（例如，调用 `ApplicationContext` 的 `close()` 方法），它会管理容器中所有单例 Bean 的销毁。

8.  **销毁方法（Destruction）**
    *   销毁阶段的执行顺序与初始化阶段相反：
        *   **使用 `@PreDestroy` 注解的方法**: JSR-250 规范，推荐方式。
        *   **实现 `DisposableBean` 接口**: 实现 `destroy` 方法。同样不推荐，因为会造成耦合。
        *   **配置自定义 `destroy-method`**: 在 XML 或 `@Bean` 注解中指定。无侵入性。

9.  **Bean 被垃圾回收**
    *   当 Bean 被销毁，并且没有其他引用指向它时，它最终会被 Java 垃圾回收器（GC）回收。

---

#### 9.7.2.2 完整生命周期示例概述
接下来，我将通过一个完整的代码示例来演示这些阶段。我们将创建一个简单的 `UserService` Bean，并实现所有提到的扩展点。

**示例组件列表：**
1.  `MyBeanFactoryPostProcessor`：演示修改 Bean 定义。
2.  `MyInstantiationAwareBeanPostProcessor`：演示干预实例化和属性注入。
3.  `UserService`：主 Bean，实现各种 `Aware` 接口和生命周期方法。
4.  `AppConfig`：Java 配置类，用于组装整个应用。
5.  `MainApp`：主类，启动容器并演示生命周期。

- 代码开始：

**1. AppConfig.java (配置类)**
```java
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    // 定义主要的 Bean：UserService
    @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
    public UserService userService() {
        UserService userService = new UserService();
        userService.setName("Default User"); // 设置一个初始属性
        return userService;
    }

    // 注册 BeanFactoryPostProcessor
    @Bean
    public static BeanFactoryPostProcessor myBeanFactoryPostProcessor() {
        return new MyBeanFactoryPostProcessor();
    }

    // 注册 InstantiationAwareBeanPostProcessor
    // 注意：这种处理器需要直接注册，不能通过 @Bean 的普通方式，因为它需要提前被识别。
    // 更常见的方式是让其本身成为一个 Bean，并实现 PriorityOrdered 或 Ordered 来控制顺序。
    @Bean
    public InstantiationAwareBeanPostProcessor myInstantiationAwareBeanPostProcessor() {
        return new MyInstantiationAwareBeanPostProcessor();
    }
}
```

**2. MyBeanFactoryPostProcessor.java**
```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.stereotype.Component;

public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("【BeanFactoryPostProcessor】执行 >>>> 在所有 Bean 实例化之前，可以修改 Bean 定义");

        // 示例：获取 "userService" 的 Bean 定义并修改其属性
        BeanDefinition beanDefinition = beanFactory.getBeanDefinition("userService");
        if (beanDefinition.getPropertyValues().contains("name")) {
            System.out.println("  - 修改 userService 的 name 属性值从 'Default User' 到 'Modified by BeanFactoryPostProcessor'");
            beanDefinition.getPropertyValues().add("name", "Modified by BeanFactoryPostProcessor");
        }
    }
}
```

**3. MyInstantiationAwareBeanPostProcessor.java**
```java
import org.springframework.beans.BeansException;
import org.springframework.beans.PropertyValues;
import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;
import org.springframework.stereotype.Component;

public class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {

    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        if ("userService".equals(beanName)) {
            System.out.println("【InstantiationAwareBeanPostProcessor】1. postProcessBeforeInstantiation 执行 >>>> 在实例化之前，可返回代理对象");
            // 如果这里返回一个非null对象，会短路后续的实例化过程。此处返回 null，走正常流程。
        }
        return null; // 返回 null 表示继续正常实例化
    }

    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        if ("userService".equals(beanName)) {
            System.out.println("【InstantiationAwareBeanPostProcessor】2. postProcessAfterInstantiation 执行 >>>> 在实例化之后，属性注入之前。返回 true 允许属性注入");
        }
        return true; // 返回 true 表示继续属性注入
    }

    @Override
    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {
        if ("userService".equals(beanName)) {
            System.out.println("【InstantiationAwareBeanPostProcessor】3. postProcessProperties 执行 >>>> 在属性注入之时，可修改属性值");
            // 这里可以修改 pvs，例如更改注入的值
        }
        return pvs; // 返回原始的或修改后的 PropertyValues
    }

    // 以下是普通的 BeanPostProcessor 方法（也属于生命周期）
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if ("userService".equals(beanName)) {
            System.out.println("【BeanPostProcessor】前置处理 - postProcessBeforeInitialization 执行");
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if ("userService".equals(beanName)) {
            System.out.println("【BeanPostProcessor】后置处理 - postProcessAfterInitialization 执行");
        }
        return bean;
    }
}
```

---

- UserService 和主类

**4. UserService.java (主 Bean，实现各种接口)**
```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.*;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.EnvironmentAware;
import org.springframework.core.env.Environment;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class UserService implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, EnvironmentAware, InitializingBean, DisposableBean {

    private String name;
    private String beanName;
    private BeanFactory beanFactory;
    private ApplicationContext applicationContext;
    private Environment environment;

    public UserService() {
        System.out.println("【1. 实例化】>>>> UserService 构造器被调用");
    }

    public void setName(String name) {
        System.out.println("  - 【属性注入】>>>> 设置 name 属性: " + name);
        this.name = name;
    }

    // ========== Aware 接口方法 ==========
    @Override
    public void setBeanName(String name) {
        this.beanName = name;
        System.out.println("【Aware】>>>> BeanNameAware.setBeanName 被调用，beanName = " + name);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
        System.out.println("【Aware】>>>> BeanFactoryAware.setBeanFactory 被调用");
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        System.out.println("【Aware】>>>> ApplicationContextAware.setApplicationContext 被调用");
    }

    @Override
    public void setEnvironment(Environment environment) {
        this.environment = environment;
        System.out.println("【Aware】>>>> EnvironmentAware.setEnvironment 被调用");
    }

    // ========== 初始化方法 ==========
    @PostConstruct
    public void postConstruct() {
        System.out.println("【初始化】>>>> @PostConstruct 注解方法被调用");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("【初始化】>>>> InitializingBean.afterPropertiesSet 被调用");
    }

    public void customInit() {
        System.out.println("【初始化】>>>> 自定义 init-method (customInit) 被调用");
    }

    // ========== 销毁方法 ==========
    @PreDestroy
    public void preDestroy() {
        System.out.println("【销毁】>>>> @PreDestroy 注解方法被调用");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("【销毁】>>>> DisposableBean.destroy 被调用");
    }

    public void customDestroy() {
        System.out.println("【销毁】>>>> 自定义 destroy-method (customDestroy) 被调用");
    }

    // ========== 业务方法 ==========
    public void sayHello() {
        System.out.println("【业务方法】>>>> UserService (" + beanName + ") says: Hello, " + name + "!");
    }

    // Getter 和 Setter
    public String getName() {
        return name;
    }
}
```

**5. MainApp.java (主类，启动容器)**
```java
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MainApp {
    public static void main(String[] args) {
        System.out.println("================== Spring 容器启动 ==================");
        // 创建应用上下文
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        
        System.out.println("\n================== Bean 使用阶段 ==================");
        // 获取并使用 Bean
        UserService userService = context.getBean(UserService.class);
        userService.sayHello();
        
        System.out.println("\n================== Spring 容器关闭 ==================");
        // 关闭容器，触发销毁生命周期
        context.close();
        System.out.println("================== 程序结束 ==================");
    }
}
```

---

- 完整的执行流程和输出分析

现在让我们运行 `MainApp`，观察完整的输出，并分析每个步骤对应的生命周期阶段：

**预期输出：**
```
================== Spring 容器启动 ==================
【BeanFactoryPostProcessor】执行 >>>> 在所有 Bean 实例化之前，可以修改 Bean 定义
  - 修改 userService 的 name 属性值从 'Default User' 到 'Modified by BeanFactoryPostProcessor'
【InstantiationAwareBeanPostProcessor】1. postProcessBeforeInstantiation 执行 >>>> 在实例化之前，可返回代理对象
【1. 实例化】>>>> UserService 构造器被调用
【InstantiationAwareBeanPostProcessor】2. postProcessAfterInstantiation 执行 >>>> 在实例化之后，属性注入之前。返回 true 允许属性注入
  - 【属性注入】>>>> 设置 name 属性: Modified by BeanFactoryPostProcessor
【InstantiationAwareBeanPostProcessor】3. postProcessProperties 执行 >>>> 在属性注入之时，可修改属性值
【BeanPostProcessor】前置处理 - postProcessBeforeInitialization 执行
【Aware】>>>> BeanNameAware.setBeanName 被调用，beanName = userService
【Aware】>>>> BeanFactoryAware.setBeanFactory 被调用
【Aware】>>>> ApplicationContextAware.setApplicationContext 被调用
【Aware】>>>> EnvironmentAware.setEnvironment 被调用
【初始化】>>>> @PostConstruct 注解方法被调用
【初始化】>>>> InitializingBean.afterPropertiesSet 被调用
【初始化】>>>> 自定义 init-method (customInit) 被调用
【BeanPostProcessor】后置处理 - postProcessAfterInitialization 执行

================== Bean 使用阶段 ==================
【业务方法】>>>> UserService (userService) says: Hello, Modified by BeanFactoryPostProcessor!

================== Spring 容器关闭 ==================
【销毁】>>>> @PreDestroy 注解方法被调用
【销毁】>>>> DisposableBean.destroy 被调用
【销毁】>>>> 自定义 destroy-method (customDestroy) 被调用
================== 程序结束 ==================
```

**执行流程详细解析：**

1.  **容器启动**：
    *   `BeanFactoryPostProcessor.postProcessBeanFactory` 最先执行，它修改了 `userService` Bean 的定义，将 `name` 属性从 "Default User" 改为 "Modified by BeanFactoryPostProcessor"。

2.  **Bean 创建阶段**：
    *   **实例化前**：`InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation` 被调用，但我们返回了 `null`，所以继续标准流程。
    *   **实例化**：调用 `UserService` 的构造器，创建对象实例。
    *   **实例化后**：`InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation` 被调用，我们返回 `true`，允许后续属性注入。
    *   **属性注入**：Spring 根据修改后的 Bean 定义，将 `name` 属性注入。注入前后，`postProcessProperties` 方法被调用。
    *   **BeanPostProcessor 前置处理**：`postProcessBeforeInitialization` 被调用。
    *   **Aware 接口回调**：按顺序调用 `BeanNameAware` -> `BeanFactoryAware` -> `ApplicationContextAware` -> `EnvironmentAware` 的 setter 方法。
    *   **初始化方法**：按顺序执行：
        *   `@PostConstruct` 注解的方法。
        *   `InitializingBean.afterPropertiesSet` 方法。
        *   自定义的 `init-method`（即 `customInit`）。
    *   **BeanPostProcessor 后置处理**：`postProcessAfterInitialization` 被调用。此时 Bean 完全就绪。

3.  **Bean 使用阶段**：
    *   我们从容器中获取 `UserService` Bean 并调用其业务方法 `sayHello`。输出显示它成功使用了被 `BeanFactoryPostProcessor` 修改后的 `name` 属性。

4.  **容器关闭与 Bean 销毁**：
    *   当调用 `context.close()` 时，容器开始销毁单例 Bean。
    *   **销毁方法**：按顺序执行（与初始化顺序相反）：
        *   `@PreDestroy` 注解的方法。
        *   `DisposableBean.destroy` 方法。
        *   自定义的 `destroy-method`（即 `customDestroy`）。

---

- 总结

这个完整的示例清晰地展示了 Spring Bean 生命周期的每一个关键步骤，特别是各种增强接口的作用时机：

*   **`BeanFactoryPostProcessor`**：在 **Bean 实例化之前** 操作 Bean 的元数据（`BeanDefinition`）。
*   **`InstantiationAwareBeanPostProcessor`**：在 **实例化前后** 和 **属性注入之时** 进行干预，提供了最细粒度的控制。
*   **各种 `Aware` 接口**：在 **初始化阶段早期**（`BeanPostProcessor.postProcessBeforeInitialization` 之后）被调用，用于注入基础设施对象。
*   **初始化与销毁方法**：提供了三种方式（注解、接口、配置），执行顺序有明确规定。

通过这个示例，你应该能够非常透彻地理解 Spring 是如何精细地控制 Bean 的创建、初始化和销毁过程的，以及如何在适当的时机插入自定义逻辑。这正是 Spring 框架强大扩展性的基础。
### 9.7.3 Spring Bean生命周期案例2
> 我们通过一个例子来验证上面的整个流程

定义Bean（这里是User）, 并让它实现BeanNameAware,BeanFactoryAware,ApplicationContextAware接口和InitializingBean,DisposableBean接口：
```java
package tech.pdai.springframework.entity;

import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

/**
 * @author pdai
 */
@Slf4j
@ToString
public class User implements BeanFactoryAware, BeanNameAware, ApplicationContextAware,
        InitializingBean, DisposableBean {
    /**
     * user's name.
     */
    private String name;

    /**
     * user's age.
     */
    private int age;

    /**
     * bean factory.
     */
    private BeanFactory beanFactory;

    /**
     * application context.
     */
    private ApplicationContext applicationContext;

    /**
     * bean name.
     */
    private String beanName;

    public User() {
        log.info("execute User#new User()");
    }

    public void setName(String name) {
        log.info("execute User#setName({})", name);
        this.name = name;
    }

    public void setAge(int age) {
        log.info("execute User#setAge({})", age);
        this.age = age;
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        log.info("execute BeanFactoryAware#setBeanFactory");
        this.beanFactory = beanFactory;
    }

    @Override
    public void setBeanName(String s) {
        log.info("execute BeanNameAware#setBeanName");
        this.beanName = s;
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        log.info("execute ApplicationContextAware#setApplicationContext");
        this.applicationContext = applicationContext;
    }

    @Override
    public void destroy() throws Exception {
        log.info("execute DisposableBean#destroy");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        log.info("execute InitializingBean#afterPropertiesSet");
    }


    public void doInit() {
        log.info("execute User#doInit");
    }

    public void doDestroy() {
        log.info("execute User#doDestroy");
    }

}
```
- 定义BeanFactoryPostProcessor的实现类
```java
/**
 * @author pdai
 */
@Slf4j
@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {
        log.info("execute BeanFactoryPostProcessor#postProcessBeanFactory");
    }
}
```
- 定义InstantiationAwareBeanPostProcessor的实现类
```java
/**
 * @author pdai
 */
@Slf4j
@Component
public class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        log.info("execute InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation for {}", beanName);
        return InstantiationAwareBeanPostProcessor.super.postProcessBeforeInstantiation(beanClass, beanName);
    }

    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        log.info("execute InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation for {}", beanName);
        return InstantiationAwareBeanPostProcessor.super.postProcessAfterInstantiation(bean, beanName);
    }

    @Override
    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {
        log.info("execute InstantiationAwareBeanPostProcessor#postProcessProperties for {}", beanName);
        return InstantiationAwareBeanPostProcessor.super.postProcessProperties(pvs, bean, beanName);
    }
}
```
- 定义BeanPostProcessor的实现类
```java
/**
 * @author pdai
 */
@Slf4j
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        log.info("execute BeanPostProcessor#postProcessBeforeInitialization for {}", beanName);
        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        log.info("execute BeanPostProcessor#postProcessAfterInitialization for {}", beanName);
        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    }
}
```
- 通过Java配置方式初始化Bean
```java
/**
 * @author pdai
 */
@Configuration
public class BeansConfig {

    @Bean(name = "user", initMethod = "doInit", destroyMethod = "doDestroy")
    public User create() {
        User user = new User();
        user.setName("pdai");
        user.setAge(18);
        return user;
    }
}
```
- 测试的主方法
```java
/**
 * Cglib proxy demo.
 *
 * @author pdai
 */
@Slf4j
public class App {

    /**
     * main interface.
     *
     * @param args args
     */
    public static void main(String[] args) {
        log.info("Init application context");
        // create and configure beans
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
                "tech.pdai.springframework");

        // retrieve configured instance
        User user = (User) context.getBean("user");

        // print info from beans
        log.info(user.toString());

        log.info("Shutdown application context");
        context.registerShutdownHook();
    }
}
```
- 输出结果（剔除无关输出）：
```java
12:44:42.547 [main] INFO tech.pdai.springframework.App - Init application context
...
12:44:43.134 [main] INFO tech.pdai.springframework.processor.MyBeanFactoryPostProcessor - execute BeanFactoryPostProcessor#postProcessBeanFactory
...
12:44:43.216 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'user'
12:44:43.216 [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation for user
12:44:43.236 [main] INFO tech.pdai.springframework.entity.User - execute User#new User()
12:44:43.237 [main] INFO tech.pdai.springframework.entity.User - execute User#setName(pdai)
12:44:43.237 [main] INFO tech.pdai.springframework.entity.User - execute User#setAge(18)
12:44:43.237 [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation for user
12:44:43.237 [main] INFO tech.pdai.springframework.processor.MyInstantiationAwareBeanPostProcessor - execute InstantiationAwareBeanPostProcessor#postProcessProperties for user
12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute BeanNameAware#setBeanName
12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute BeanFactoryAware#setBeanFactory
12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute ApplicationContextAware#setApplicationContext
12:44:43.242 [main] INFO tech.pdai.springframework.processor.MyBeanPostProcessor - execute BeanPostProcessor#postProcessBeforeInitialization for user
12:44:43.242 [main] INFO tech.pdai.springframework.entity.User - execute InitializingBean#afterPropertiesSet
12:44:43.243 [main] INFO tech.pdai.springframework.entity.User - execute User#doInit
12:44:43.243 [main] INFO tech.pdai.springframework.processor.MyBeanPostProcessor - execute BeanPostProcessor#postProcessAfterInitialization for user
12:44:43.270 [main] INFO tech.pdai.springframework.App - User(name=pdai, age=18)
12:44:43.270 [main] INFO tech.pdai.springframework.App - Shutdown application context
12:44:43.276 [SpringContextShutdownHook] INFO tech.pdai.springframework.entity.User - execute DisposableBean#destroy
12:44:43.276 [SpringContextShutdownHook] INFO tech.pdai.springframework.entity.User - execute User#doDestroy
```
# 十、Spring进阶 - Spring AOP实现原理详解之AOP切面的实现
> 前文，我们分析了Spring IOC的初始化过程和Bean的生命周期等，而Spring AOP也是基于IOC的Bean加载来实现的。本文主要介绍Spring AOP原理解析的切面实现过程（将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor，为后续交给代理增强实现做准备的过程）。
## 10.1 引入
> 我们应该从哪里开始着手看Spring AOP的源码呢？和我们上文分析的IOC源码实现有什么关系呢？
1. 前文中我们写了AOP的Demo，根据其XML配置我们不难发现AOP是基于IOC的Bean加载来实现的；这便使我们的主要入口
![72.spring-springframework-aop-1.png](../../assets/images/04-主流框架/spring/72.spring-springframework-aop-1.png)

所以理解Spring AOP的初始化必须要先理解<a href ='#Spring IOC实现原理详解之IOC初始化流程'>Spring IOC的初始化</a>。
2. 然后我们就能找到如下**初始化的流程和aop对应的handler类**

即parseCustomElement方法找到`parse aop:aspectj-autoproxy`的handler(`org.springframework.aop.config.AopNamespaceHandler`)
![73.spring-springframework-aop-2.png](../../assets/images/04-主流框架/spring/73.spring-springframework-aop-2.png)
（PS：其实你会发现，最重要的是知识点的关联关系，而不是知识点本身，就后续代码而言不就是打个断点慢慢看的事了么。）

## 10.2 aop配置标签的解析
> 上文中，我们找到了AopNamespaceHandler，其实就是注册BeanDefinition的解析器

BeanDefinitionParser，将aop:xxxxxx配置标签交给指定的parser来处理。
```java
public class AopNamespaceHandler extends NamespaceHandlerSupport {

	/**
	 * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the
	 * '{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}'
	 * and '{@code scoped-proxy}' tags.
	 */
	@Override
	public void init() {
		// In 2.0 XSD as well as in 2.5+ XSDs
        // 注册解析<aop:config> 配置
		registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
        // 注册解析<aop:aspectj-autoproxy> 配置
		registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
		registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());

		// Only in 2.0 XSD: moved to context namespace in 2.5+
		registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
	}

}
```
### 10.2.1 config配置标签的解析
`<aop:config/>`由ConfigBeanDefinitionParser这个类处理，作为parser类最重要的就是parse方法
```java
@Override
@Nullable
public BeanDefinition parse(Element element, ParserContext parserContext) {
    CompositeComponentDefinition compositeDef =
            new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));
    parserContext.pushContainingComponent(compositeDef);

    configureAutoProxyCreator(parserContext, element);

    List<Element> childElts = DomUtils.getChildElements(element);
    for (Element elt: childElts) {
        String localName = parserContext.getDelegate().getLocalName(elt);
        if (POINTCUT.equals(localName)) {
            parsePointcut(elt, parserContext);
        }
        else if (ADVISOR.equals(localName)) {
            parseAdvisor(elt, parserContext);
        }
        else if (ASPECT.equals(localName)) {
            parseAspect(elt, parserContext);
        }
    }

    parserContext.popAndRegisterContainingComponent();
    return null;
}
```
打个断点看下
![74.spring-springframework-aop-7.png](../../assets/images/04-主流框架/spring/74.spring-springframework-aop-7.png)

parseAspect的方法如下, 处理方法不难，我这里就不展开了
```java
private void parseAspect(Element aspectElement, ParserContext parserContext) {
    String aspectId = aspectElement.getAttribute(ID);
    String aspectName = aspectElement.getAttribute(REF);

    try {
        this.parseState.push(new AspectEntry(aspectId, aspectName));
        List<BeanDefinition> beanDefinitions = new ArrayList<>();
        List<BeanReference> beanReferences = new ArrayList<>();

        List<Element> declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);
        for (int i = METHOD_INDEX; i < declareParents.size(); i++) {
            Element declareParentsElement = declareParents.get(i);
            beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));
        }

        // We have to parse "advice" and all the advice kinds in one loop, to get the
        // ordering semantics right.
        NodeList nodeList = aspectElement.getChildNodes();
        boolean adviceFoundAlready = false;
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node node = nodeList.item(i);
            if (isAdviceNode(node, parserContext)) {
                if (!adviceFoundAlready) {
                    adviceFoundAlready = true;
                    if (!StringUtils.hasText(aspectName)) {
                        parserContext.getReaderContext().error(
                                "<aspect> tag needs aspect bean reference via 'ref' attribute when declaring advices.",
                                aspectElement, this.parseState.snapshot());
                        return;
                    }
                    beanReferences.add(new RuntimeBeanReference(aspectName));
                }
                AbstractBeanDefinition advisorDefinition = parseAdvice(
                        aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);
                beanDefinitions.add(advisorDefinition);
            }
        }

        AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(
                aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);
        parserContext.pushContainingComponent(aspectComponentDefinition);

        List<Element> pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);
        for (Element pointcutElement : pointcuts) {
            parsePointcut(pointcutElement, parserContext);
        }

        parserContext.popAndRegisterContainingComponent();
    }
    finally {
        this.parseState.pop();
    }
}
```
### 10.2.2 aspectj-autoproxy配置标签的解析
`<aop:aspectj-autoproxy/>`则由AspectJAutoProxyBeanDefinitionParser这个类处理的，我们看下parse 方法
```java
@Override
@Nullable
public BeanDefinition parse(Element element, ParserContext parserContext) {
    // 注册AspectJAnnotationAutoProxyCreator
    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
    // 拓展BeanDefinition
    extendBeanDefinition(element, parserContext);
    return null;
}
```
AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary方法对应如下
```java
public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(
        ParserContext parserContext, Element sourceElement) {

    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(
            parserContext.getRegistry(), parserContext.extractSource(sourceElement));
    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
    registerComponentIfNecessary(beanDefinition, parserContext);
}
```
AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary对应如下
```java
@Nullable
public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(
        BeanDefinitionRegistry registry, @Nullable Object source) {

    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}
```
这里，我们发现AOP的创建工作是交给AnnotationAwareAspectJAutoProxyCreator来完成的。
## 10.3 注解切面代理创建类(AnnotationAwareAspectJAutoProxyCreator)
> AnnotationAwareAspectJAutoProxyCreator是如何工作的呢？这时候我们就要看AnnotationAwareAspectJAutoProxyCreator类结构关系了。

如下是类结构关系
![75.spring-springframework-aop-3.png](../../assets/images/04-主流框架/spring/75.spring-springframework-aop-3.png)

它实现了两类接口：

- BeanFactoryAware属于`Bean级生命周期接口方法`
- InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”，是`容器级生命周期接口方法`；

结合前文Spring Bean生命周期的流程
![76.spring-springframework-aop-4.png](../../assets/images/04-主流框架/spring/76.spring-springframework-aop-4.png)

我们就可以定位到核心的初始化方法肯定在postProcessBeforeInstantiation和postProcessAfterInitialization中。
### 10.3.1 postProcessBeforeInstantiation

如下是上述类结构中postProcessBeforeInstantiation的方法，读者在自己看代码的时候建议打个断点看，可以方便理解
![77.spring-springframework-aop-5.png](../../assets/images/04-主流框架/spring/77.spring-springframework-aop-5.png)
```java
@Override
public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {
    Object cacheKey = getCacheKey(beanClass, beanName);

    if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {
        // 如果已经在缓存中，则忽略
        if (this.advisedBeans.containsKey(cacheKey)) {
            return null;
        }
        // 是否是aop基础类？是否跳过？
        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return null;
        }
    }

    // Create proxy here if we have a custom TargetSource.
    // Suppresses unnecessary default instantiation of the target bean:
    // The TargetSource will handle target instances in a custom fashion.
    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
    if (targetSource != null) {
        if (StringUtils.hasLength(beanName)) {
            this.targetSourcedBeans.add(beanName);
        }
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    return null;
}
```
#### 10.3.1.1 判断是否是aop基础类
是否是aop基础类的判断方法 isInfrastructureClass 如下
```java
@Override
protected boolean isInfrastructureClass(Class<?> beanClass) {
    // Previously we setProxyTargetClass(true) in the constructor, but that has too
    // broad an impact. Instead we now override isInfrastructureClass to avoid proxying
    // aspects. I'm not entirely happy with that as there is no good reason not
    // to advise aspects, except that it causes advice invocation to go through a
    // proxy, and if the aspect implements e.g the Ordered interface it will be
    // proxied by that interface and fail at runtime as the advice method is not
    // defined on the interface. We could potentially relax the restriction about
    // not advising aspects in the future.
    // 父类判断它是aop基础类 or 使用@Aspect注解
    return (super.isInfrastructureClass(beanClass) ||
            (this.aspectJAdvisorFactory != null && this.aspectJAdvisorFactory.isAspect(beanClass)));
}
```
父类判断它是否是aop基础类的方法 super.isInfrastructureClass(beanClass), 本质上就是判断该类是否实现了Advice, Pointcut, Advisor或者AopInfrastructureBean接口。
```java
protected boolean isInfrastructureClass(Class<?> beanClass) {
    // 该类是否实现了Advice, Pointcut, Advisor或者AopInfrastructureBean接口
    boolean retVal = Advice.class.isAssignableFrom(beanClass) ||
            Pointcut.class.isAssignableFrom(beanClass) ||
            Advisor.class.isAssignableFrom(beanClass) ||
            AopInfrastructureBean.class.isAssignableFrom(beanClass);
    if (retVal && logger.isTraceEnabled()) {
        logger.trace("Did not attempt to auto-proxy infrastructure class [" + beanClass.getName() + "]");
    }
    return retVal;
}
```
#### 10.3.1.2 是否应该跳过shouldSkip
通过断点辅助，candidateAdvisors和xml配置的通知是对应的
![78.spring-springframework-aop-6.png](../../assets/images/04-主流框架/spring/78.spring-springframework-aop-6.png)

```java
@Override
protected boolean shouldSkip(Class<?> beanClass, String beanName) {
    // TODO: Consider optimization by caching the list of the aspect names
    List<Advisor> candidateAdvisors = findCandidateAdvisors();
    for (Advisor advisor : candidateAdvisors) {
        if (advisor instanceof AspectJPointcutAdvisor &&
                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
            return true;
        }
    }
    return super.shouldSkip(beanClass, beanName);
}
```
- 切面方法转成Advisor(findCandidateAdvisors()方法)
findCandidateAdvisors方法如下：
```java
@Override
protected List<Advisor> findCandidateAdvisors() {
    // 在父类中找到所有的advisor：基于xml配置的<aop:before/>生成的
    List<Advisor> advisors = super.findCandidateAdvisors();
    // 为bean Factory中AspectJ切面构建advistor：通过AspectJ注解的方式生成Advisor类
    if (this.aspectJAdvisorsBuilder != null) {
        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    }
    return advisors;
}
```
在当前的bean Factory中通过AspectJ注解的方式生成Advisor类，buildAspectJAdvisors方法如下
```java
/**
    * Look for AspectJ-annotated aspect beans in the current bean factory,
    * and return to a list of Spring AOP Advisors representing them.
    * <p>Creates a Spring Advisor for each AspectJ advice method.
    * @return the list of {@link org.springframework.aop.Advisor} beans
    * @see #isEligibleBean
    */
public List<Advisor> buildAspectJAdvisors() {
    List<String> aspectNames = this.aspectBeanNames;

    if (aspectNames == null) {
        synchronized (this) {
            aspectNames = this.aspectBeanNames;
            if (aspectNames == null) {
                List<Advisor> advisors = new ArrayList<>();
                aspectNames = new ArrayList<>();
                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                        this.beanFactory, Object.class, true, false);
                for (String beanName : beanNames) {
                    if (!isEligibleBean(beanName)) {
                        continue;
                    }
                    // We must be careful not to instantiate beans eagerly as in this case they
                    // would be cached by the Spring container but would not have been weaved.
                    Class<?> beanType = this.beanFactory.getType(beanName, false);
                    if (beanType == null) {
                        continue;
                    }
                    if (this.advisorFactory.isAspect(beanType)) {
                        aspectNames.add(beanName);
                        AspectMetadata amd = new AspectMetadata(beanType, beanName);
                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                            MetadataAwareAspectInstanceFactory factory =
                                    new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);
                            // 单例加到advisorsCache, 非单例加到aspectFactoryCache
                            if (this.beanFactory.isSingleton(beanName)) {
                                this.advisorsCache.put(beanName, classAdvisors);
                            }
                            else {
                                this.aspectFactoryCache.put(beanName, factory);
                            }
                            advisors.addAll(classAdvisors);
                        }
                        else {
                            // Per target or per this.
                            if (this.beanFactory.isSingleton(beanName)) {
                                throw new IllegalArgumentException("Bean with name '" + beanName +
                                        "' is a singleton, but aspect instantiation model is not singleton");
                            }
                            MetadataAwareAspectInstanceFactory factory =
                                    new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
                            this.aspectFactoryCache.put(beanName, factory);
                            // advisorFactory工厂获取advisors
                            advisors.addAll(this.advisorFactory.getAdvisors(factory));
                        }
                    }
                }
                this.aspectBeanNames = aspectNames;
                return advisors;
            }
        }
    }

    if (aspectNames.isEmpty()) {
        return Collections.emptyList();
    }
    List<Advisor> advisors = new ArrayList<>();
    for (String aspectName : aspectNames) {
        List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);
        if (cachedAdvisors != null) {
            advisors.addAll(cachedAdvisors);
        }
        else {
            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
            advisors.addAll(this.advisorFactory.getAdvisors(factory));
        }
    }
    return advisors;
}
```
上述方法本质上的思路是：用DCL双重锁的单例实现方式，拿到切面类里的切面方法，将其转换成advisor（并放入缓存中）。

转换的成advisor的方法是：this.advisorFactory.getAdvisors
```java
@Override
public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
    Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
    validate(aspectClass);

    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
    // so that it will only instantiate once.
    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
            new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

    List<Advisor> advisors = new ArrayList<>();
    for (Method method : getAdvisorMethods(aspectClass)) {
        // Prior to Spring Framework 5.2.7, advisors.size() was supplied as the declarationOrderInAspect
        // to getAdvisor(...) to represent the "current position" in the declared methods list.
        // However, since Java 7 the "current position" is not valid since the JDK no longer
        // returns declared methods in the order in which they are declared in the source code.
        // Thus, we now hard code the declarationOrderInAspect to 0 for all advice methods
        // discovered via reflection in order to support reliable advice ordering across JVM launches.
        // Specifically, a value of 0 aligns with the default value used in
        // AspectJPrecedenceComparator.getAspectDeclarationOrder(Advisor).
        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, 0, aspectName);
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

    // If it's a per target aspect, emit the dummy instantiating aspect.
    if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
        advisors.add(0, instantiationAdvisor);
    }

    // Find introduction fields.
    for (Field field : aspectClass.getDeclaredFields()) {
        Advisor advisor = getDeclareParentsAdvisor(field);
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

    return advisors;
}
```
getAdvisor方法如下
```java
@Override
@Nullable
public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
        int declarationOrderInAspect, String aspectName) {

    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());

    AspectJExpressionPointcut expressionPointcut = getPointcut(
            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
    if (expressionPointcut == null) {
        return null;
    }

    // 封装成advisor
    return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
            this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}
```
获取表达式的切点的方法getPointcut如下：
```java
@Nullable
private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {
    AspectJAnnotation<?> aspectJAnnotation =
            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
    if (aspectJAnnotation == null) {
        return null;
    }

    AspectJExpressionPointcut ajexp =
            new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);
    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
    if (this.beanFactory != null) {
        ajexp.setBeanFactory(this.beanFactory);
    }
    return ajexp;
}
```
AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod的方法如下
```java
private static final Class<?>[] ASPECTJ_ANNOTATION_CLASSES = new Class<?>[] {
        Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};

/**
    * Find and return the first AspectJ annotation on the given method
    * (there <i>should</i> only be one anyway...).
    */
@SuppressWarnings("unchecked")
@Nullable
protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {
    for (Class<?> clazz : ASPECTJ_ANNOTATION_CLASSES) {
        AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) clazz);
        if (foundAnnotation != null) {
            return foundAnnotation;
        }
    }
    return null;
}
```
findAnnotation方法如下
```java
@Nullable
private static <A extends Annotation> AspectJAnnotation<A> findAnnotation(Method method, Class<A> toLookFor) {
    A result = AnnotationUtils.findAnnotation(method, toLookFor);
    if (result != null) {
        return new AspectJAnnotation<>(result);
    }
    else {
        return null;
    }
}
```
AnnotationUtils.findAnnotation 获取注解方法如下
```java
/**
    * Find a single {@link Annotation} of {@code annotationType} on the supplied
    * {@link Method}, traversing its super methods (i.e. from superclasses and
    * interfaces) if the annotation is not <em>directly present</em> on the given
    * method itself.
    * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.
    * <p>Meta-annotations will be searched if the annotation is not
    * <em>directly present</em> on the method.
    * <p>Annotations on methods are not inherited by default, so we need to handle
    * this explicitly.
    * @param method the method to look for annotations on
    * @param annotationType the annotation type to look for
    * @return the first matching annotation, or {@code null} if not found
    * @see #getAnnotation(Method, Class)
    */
@Nullable
public static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {
    if (annotationType == null) {
        return null;
    }

    // Shortcut: directly present on the element, with no merging needed?
    if (AnnotationFilter.PLAIN.matches(annotationType) ||
            AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {
        return method.getDeclaredAnnotation(annotationType);
    }

    // Exhaustive retrieval of merged annotations...
    return MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())
            .get(annotationType).withNonMergedAttributes()
            .synthesize(MergedAnnotation::isPresent).orElse(null);
}
```
封装成Advisor

注：Advisor 是 advice的包装器，包含了advice及其它信息

由InstantiationModelAwarePointcutAdvisorImpl构造完成
```java
public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,
        Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,
        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

    this.declaredPointcut = declaredPointcut;
    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();
    this.methodName = aspectJAdviceMethod.getName();
    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();
    this.aspectJAdviceMethod = aspectJAdviceMethod;
    this.aspectJAdvisorFactory = aspectJAdvisorFactory;
    this.aspectInstanceFactory = aspectInstanceFactory;
    this.declarationOrder = declarationOrder;
    this.aspectName = aspectName;

    if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
        // Static part of the pointcut is a lazy type.
        Pointcut preInstantiationPointcut = Pointcuts.union(
                aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);

        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.
        // If it's not a dynamic pointcut, it may be optimized out
        // by the Spring AOP infrastructure after the first evaluation.
        this.pointcut = new PerTargetInstantiationModelPointcut(
                this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
        this.lazy = true;
    }
    else {
        // A singleton aspect.
        this.pointcut = this.declaredPointcut;
        this.lazy = false;
        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
    }
}
```
通过pointcut获取advice
```java
private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {
    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut,
            this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
    return (advice != null ? advice : EMPTY_ADVICE);
}
```
交给aspectJAdvisorFactory获取
```java
@Override
@Nullable
public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,
        MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

    // 获取切面类
    Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
    validate(candidateAspectClass);

    // 获取切面注解
    AspectJAnnotation<?> aspectJAnnotation =
            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
    if (aspectJAnnotation == null) {
        return null;
    }

    // If we get here, we know we have an AspectJ method.
    // Check that it's an AspectJ-annotated class
    if (!isAspect(candidateAspectClass)) {
        throw new AopConfigException("Advice must be declared inside an aspect type: " +
                "Offending method '" + candidateAdviceMethod + "' in class [" +
                candidateAspectClass.getName() + "]");
    }

    if (logger.isDebugEnabled()) {
        logger.debug("Found AspectJ method: " + candidateAdviceMethod);
    }

    // 切面注解转换成advice
    AbstractAspectJAdvice springAdvice;

    switch (aspectJAnnotation.getAnnotationType()) {
        case AtPointcut: // AtPointcut忽略
            if (logger.isDebugEnabled()) {
                logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");
            }
            return null;
        case AtAround:
            springAdvice = new AspectJAroundAdvice(
                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            break;
        case AtBefore:
            springAdvice = new AspectJMethodBeforeAdvice(
                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            break;
        case AtAfter:
            springAdvice = new AspectJAfterAdvice(
                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            break;
        case AtAfterReturning:
            springAdvice = new AspectJAfterReturningAdvice(
                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();
            if (StringUtils.hasText(afterReturningAnnotation.returning())) {
                springAdvice.setReturningName(afterReturningAnnotation.returning());
            }
            break;
        case AtAfterThrowing:
            springAdvice = new AspectJAfterThrowingAdvice(
                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();
            if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
            }
            break;
        default:
            throw new UnsupportedOperationException(
                    "Unsupported advice type on method: " + candidateAdviceMethod);
    }

    // 最后将其它切面信息配置到advice
    springAdvice.setAspectName(aspectName);
    springAdvice.setDeclarationOrder(declarationOrder);
    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
    if (argNames != null) {
        springAdvice.setArgumentNamesFromStringArray(argNames);
    }
    springAdvice.calculateArgumentBindings();

    return springAdvice;
}
```

#### 10.3.1.3 小结
回头看，主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor的过程。

- 各部分逻辑作用总结

1. **缓存键生成与检查（缓存机制）**
```java
Object cacheKey = getCacheKey(beanClass, beanName);
if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {
    if (this.advisedBeans.containsKey(cacheKey)) {
        return null; // 已处理过，直接跳过
    }
}
```
- **作用**：防止重复处理同一个 Bean，通过缓存机制优化性能
- **逻辑**：为每个 Bean 生成唯一缓存键，检查是否已经处理过

2. **基础类过滤（isInfrastructureClass）**
```java
if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return null;
}
```
- **作用**：排除 AOP 基础设施类，避免对 AOP 组件自身进行代理
- **过滤条件**：
  - 实现了 `Advice`、`Pointcut`、`Advisor`、`AopInfrastructureBean` 接口的类
  - 使用 `@Aspect` 注解的切面类本身

3. **跳过逻辑（shouldSkip）**
```java
protected boolean shouldSkip(Class<?> beanClass, String beanName) {
    List<Advisor> candidateAdvisors = findCandidateAdvisors();
    for (Advisor advisor : candidateAdvisors) {
        if (advisor instanceof AspectJPointcutAdvisor && 
            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
            return true; // 跳过切面类本身的代理
        }
    }
    return super.shouldSkip(beanClass, beanName);
}
```
- **作用**：确保切面类自身不会被代理
- **逻辑**：检查当前 Bean 是否是某个切面类，如果是则跳过代理

4. **切面方法扫描与 Advisor 构建（核心部分）**

4.1 **findCandidateAdvisors() - 双路径扫描**
```java
List<Advisor> advisors = super.findCandidateAdvisors(); // XML 配置的 Advisor
advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); // 注解配置的 Advisor
```
- **作用**：收集所有可用的 Advisor
- **来源**：
  - XML 配置的 `<aop:before/>` 等标签生成的 Advisor
  - `@Aspect` 注解类中的切面方法生成的 Advisor

4.2 **buildAspectJAdvisors() - 注解切面处理**
- **作用**：扫描所有 Bean，识别 `@Aspect` 注解的切面类
- **特点**：
  - 使用 DCL（双重检查锁）确保线程安全
  - 支持单例和原型作用域的切面
  - 使用缓存优化性能（`advisorsCache` 和 `aspectFactoryCache`）

4.3 **切面方法 → Advisor 的转换流程**
```
切面方法扫描 → 注解解析 → Pointcut 表达式提取 → Advisor 封装 → Advice 创建
```

**详细转换步骤：**
- 1. **方法扫描**：`getAdvisorMethods(aspectClass)` - 获取切面类中所有方法
- 2. **注解识别**：`findAspectJAnnotationOnMethod()` - 识别 `@Before`、`@After` 等切面注解
- 3. **表达式提取**：从注解中提取切点表达式，创建 `AspectJExpressionPointcut`
- 4. **Advisor 封装**：`InstantiationModelAwarePointcutAdvisorImpl` 封装 Pointcut 和 Advice
- 5. **Advice 创建**：根据注解类型创建对应的 Advice 实现类

5. **Advice 的具体创建**
```java
switch (aspectJAnnotation.getAnnotationType()) {
    case AtAround:    → AspectJAroundAdvice
    case AtBefore:    → AspectJMethodBeforeAdvice  
    case AtAfter:     → AspectJAfterAdvice
    case AtAfterReturning: → AspectJAfterReturningAdvice
    case AtAfterThrowing:  → AspectJAfterThrowingAdvice
}
```
- **作用**：将注解映射到具体的 Advice 实现类
- **特点**：每种注解类型对应不同的 Advice 实现，处理不同的拦截逻辑

- 整体任务总结

- **核心任务**
**在 Bean 实例化之前，完成所有切面相关的预处理工作，为后续的代理创建做好准备。**

- **具体要完成的任务**

1. **切面发现与注册**
   - 扫描所有 Bean，识别带有 `@Aspect` 注解的切面类
   - 将切面类中的切面方法转换为 Spring AOP 的 Advisor 结构

2. **切面元数据构建**
   - 解析切面注解中的切点表达式
   - 构建完整的切面配置信息（切点、通知类型、参数绑定等）

3. **缓存优化**
   - 对处理结果进行缓存，避免重复扫描和解析
   - 支持单例和原型作用域的切面处理

4. **基础设施过滤**
   - 确保 AOP 基础设施类不会被代理
   - 防止切面类自身被代理导致的循环依赖

5. **为代理创建做准备**
   - 收集所有可用的 Advisor
   - 为后续的代理创建（`createProxy`）提供必要的切面信息

- **最终产出**
- 一个完整的 **Advisor 列表**，每个 Advisor 包含：
  - **Pointcut**：切点表达式，定义在哪里拦截
  - **Advice**：具体的拦截逻辑（前置、后置、环绕等）
  - **切面实例工厂**：用于创建切面实例

这个处理过程是 Spring AOP 自动代理的核心，它确保了在 Bean 实例化时，所有必要的切面信息都已经准备就绪，为后续的代理创建奠定了坚实的基础。

#### 补充：
##### 1. 到底是哪些部分帮助完成的Spring AOP的动态代理
- 从接口层面完成动态代理主要用到的是如下两个接口的方法：
  - `InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation` - 特殊情况（自定义 TargetSource 处理）的提前代理+Advisor 预处理和基础设施类过滤（核心功能）
  - `BeanPostProcessor.postProcessAfterInitialization` - 标准情况的主要代理创建点

- 具体实现类层次结构
```java
AbstractAutoProxyCreator (抽象基类)
    ↑
AspectJAwareAdvisorAutoProxyCreator
    ↑
AnnotationAwareAspectJAutoProxyCreator (最常用的实现)
```
- postProcessBeforeInstantiation完整的类图调用流程
```mermaid
classDiagram
    class AbstractAutoProxyCreator {
        <<abstract>>
        +postProcessBeforeInstantiation()
        +getCacheKey()
        +getCustomTargetSource()
        +createProxy()
        #isInfrastructureClass()
        #shouldSkip()
        #getAdvicesAndAdvisorsForBean()*
    }
    
    class AspectJAwareAdvisorAutoProxyCreator {
        #shouldSkip() ✓
    }
    
    class AnnotationAwareAspectJAutoProxyCreator {
        #isInfrastructureClass() ✓
        #getAdvicesAndAdvisorsForBean() ✓
    }
    
    AbstractAutoProxyCreator <|-- AspectJAwareAdvisorAutoProxyCreator
    AspectJAwareAdvisorAutoProxyCreator <|-- AnnotationAwareAspectJAutoProxyCreator
```
-  postProcessBeforeInstantiation调用时序图
```mermaid
sequenceDiagram
    participant Container as Spring容器
    participant Annotation as AnnotationAwareAspectJAutoProxyCreator
    participant AspectJ as AspectJAwareAdvisorAutoProxyCreator
    participant Abstract as AbstractAutoProxyCreator
    
    Container->>Annotation: postProcessBeforeInstantiation()
    Annotation->>Abstract: getCacheKey()
    Annotation->>Annotation: isInfrastructureClass() ✓
    Annotation->>AspectJ: shouldSkip() ✓
    Annotation->>Abstract: getCustomTargetSource()
    Annotation->>Annotation: getAdvicesAndAdvisorsForBean() ✓
    Annotation->>Abstract: createProxy()
    Annotation-->>Container: 返回代理对象或null
```



##### 2. 什么是自定义 TargetSource
参考postProcessBeforeInstantiation可以发现如下逻辑
```java
TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
if (targetSource != null) {
    // 只有存在自定义 TargetSource 时才进入这里
    // 创建代理并返回
    return proxy;
}
return null; // 大多数情况返回 null
```
**TargetSource** 是 Spring AOP 中负责提供目标对象（被代理的对象）的接口。默认情况下，Spring 使用 `SingletonTargetSource`，它总是返回同一个目标对象实例。

```java
public interface TargetSource extends TargetClassAware {
    Class<?> getTargetClass();      // 目标对象的类型
    boolean isStatic();             // 是否总是返回同一个实例
    Object getTarget() throws Exception;  // 获取目标对象
    void releaseTarget(Object target) throws Exception;  // 释放目标对象
}
```

- 常见的 TargetSource 实现

1. **SingletonTargetSource（默认）**
```java
// 总是返回同一个目标对象实例
TargetSource targetSource = new SingletonTargetSource(targetObject);
```

2. **PrototypeTargetSource**
```java
// 每次调用 getTarget() 都返回一个新的原型实例
PrototypeTargetSource targetSource = new PrototypeTargetSource();
targetSource.setTargetBeanName("prototypeBean");
```

3. **CommonsPool2TargetSource（连接池）**
```java
// 类似数据库连接池，维护一个对象池
CommonsPool2TargetSource targetSource = new CommonsPool2TargetSource();
targetSource.setTargetBeanName("pooledBean");
targetSource.setMaxSize(10);
```

4. **ThreadLocalTargetSource**
```java
// 每个线程有自己的目标对象实例
ThreadLocalTargetSource targetSource = new ThreadLocalTargetSource();
targetSource.setTargetBeanName("threadScopedBean");
```

5. **HotSwappableTargetSource**
```java
// 支持热交换，运行时切换目标对象
HotSwappableTargetSource targetSource = new HotSwappableTargetSource(initialTarget);
// 运行时切换
targetSource.swap(newTarget);
```

- 自定义 TargetSource 的应用场景

场景 1：**对象池化**（类似数据库连接池）
```java
@Component
public class ExpensiveObjectPoolTargetSource extends AbstractBeanFactoryBasedTargetSource {
    private final List<Object> pool = Collections.synchronizedList(new ArrayList<>());
    
    @Override
    public Object getTarget() throws Exception {
        if (pool.isEmpty()) {
            return createNewInstance();
        }
        return pool.remove(0);
    }
    
    @Override
    public void releaseTarget(Object target) throws Exception {
        pool.add(target);
    }
}
```

场景 2：**负载均衡**
```java
@Component 
public class LoadBalancingTargetSource implements TargetSource {
    private final List<Object> targets = new ArrayList<>();
    private final AtomicInteger counter = new AtomicInteger();
    
    public void addTarget(Object target) {
        targets.add(target);
    }
    
    @Override
    public Object getTarget() throws Exception {
        if (targets.isEmpty()) {
            throw new IllegalStateException("No targets available");
        }
        int index = counter.getAndIncrement() % targets.size();
        return targets.get(index);
    }
}
```

场景 3：**热部署/热切换**
```java
@Configuration
public class HotSwapConfig {
    @Bean
    @Scope("prototype")
    public ServiceImpl serviceImpl() {
        return new ServiceImpl();
    }
    
    @Bean
    public HotSwappableTargetSource hotSwappableTargetSource() {
        return new HotSwappableTargetSource(serviceImpl());
    }
    
    @Bean
    public ProxyFactoryBean serviceProxy() {
        ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();
        proxyFactoryBean.setTargetSource(hotSwappableTargetSource());
        proxyFactoryBean.addAdvice(new LoggingAdvice());
        return proxyFactoryBean;
    }
}
```

- 为什么需要提前创建代理？

回到你原来的问题，当存在自定义 TargetSource 时，为什么要在 `postProcessBeforeInstantiation` 中提前返回代理？

**原因：性能优化和特殊需求**

1. **避免不必要的实例化**
   - 对于池化 TargetSource，可能不需要立即创建目标对象
   - 提前返回代理可以延迟目标对象的创建

2. **特殊的目标对象管理**
   - 自定义 TargetSource 可能有自己的生命周期管理
   - 不需要 Spring 容器进行标准的实例化、依赖注入等过程

3. **动态目标切换**
   - 热交换等场景需要代理在目标对象变化时保持稳定

- 配置示例

XML 配置方式：
```xml
<bean id="pooledTargetSource" 
      class="org.springframework.aop.target.CommonsPool2TargetSource">
    <property name="targetBeanName" value="myBusinessObject"/>
    <property name="maxSize" value="25"/>
</bean>

<bean id="pooledObject" 
      class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="targetSource" ref="pooledTargetSource"/>
    <property name="interceptorNames" value="myInterceptor"/>
</bean>
```

注解配置方式：
```java
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    
    @Bean
    @Scope("prototype")
    public MyService myService() {
        return new MyService();
    }
    
    @Bean
    public TargetSource poolingTargetSource() {
        CommonsPool2TargetSource pool = new CommonsPool2TargetSource();
        pool.setTargetBeanName("myService");
        pool.setMaxSize(10);
        return pool;
    }
}
```

- 总结

**自定义 TargetSource 的核心价值：**
- 🎯 **控制目标对象的获取方式**（单例、原型、池化等）
- ⚡ **性能优化**（对象池、延迟加载等）
- 🔄 **动态能力**（热交换、负载均衡等）
- 🎪 **特殊场景支持**（线程局部、事务管理等）

当 Spring 检测到自定义 TargetSource 时，它会提前创建代理，因为目标对象的管理已经交给了 TargetSource，不再需要标准的 Bean 生命周期管理。这就是为什么在 `postProcessBeforeInstantiation` 中会直接返回代理的原因。
## 10.4 postProcessAfterInitialization
有了Adisor, 注入到合适的位置并交给代理(cglib和jdk)实现了。
```java
/**
* Create a proxy with the configured interceptors if the bean is
* identified as one to proxy by the subclass.
* @see #getAdvicesAndAdvisorsForBean
*/
@Override
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (this.earlyProxyReferences.remove(cacheKey) != bean) {
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
```
后文中将分别介绍代理的创建和实现：
## 10.5 总结
通过上文的分析，我们做下小结：
- 由`IOC Bean加载`方法栈中找到parseCustomElement方法，找到parse `aop:aspectj-autoproxy`的handler(org.springframework.aop.config.AopNamespaceHandler)
- AopNamespaceHandler注册了`<aop:aspectj-autoproxy/>`的解析类是AspectJAutoProxyBeanDefinitionParser
- AspectJAutoProxyBeanDefinitionParser的parse 方法 通过AspectJAwareAdvisorAutoProxyCreator类去创建
- AspectJAwareAdvisorAutoProxyCreator实现了两类接口，BeanFactoryAware和BeanPostProcessor；根据Bean生命周期方法找到两个核心方法：postProcessBeforeInstantiation和postProcessAfterInitialization 
  - postProcessBeforeInstantiation：主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor
  - postProcessAfterInitialization：主要负责将Advisor注入到合适的位置，创建代理(cglib或jdk)，为后面给代理进行增强实现做准备。
# 十一、Spring进阶 - Spring AOP实现原理详解之AOP代理的创建
> 上文我们介绍了Spring AOP原理解析的切面实现过程(将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。本文在此基础上继续介绍，代理（cglib代理和JDK代理）的创建过程。
## 11.1 引入
> 前文主要Spring AOP原理解析的切面实现过程(加载配置，将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor)。

同时我们也总结了Spring AOP初始化的过程，具体如下：
- 由`IOC Bean加载`方法栈中找到parseCustomElement方法，找到parse `aop:aspectj-autoproxy`的handler(org.springframework.aop.config.AopNamespaceHandler)
- AopNamespaceHandler注册了`<aop:aspectj-autoproxy/>`的解析类是AspectJAutoProxyBeanDefinitionParser
- AspectJAutoProxyBeanDefinitionParser的parse 方法 通过AspectJAwareAdvisorAutoProxyCreator类去创建
- AspectJAwareAdvisorAutoProxyCreator实现了两类接口，BeanFactoryAware和BeanPostProcessor；根据Bean生命周期方法找到两个核心方法：postProcessBeforeInstantiation和postProcessAfterInitialization 
  - postProcessBeforeInstantiation：主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor
  - postProcessAfterInitialization：主要负责将Advisor注入到合适的位置，创建代理(cglib或jdk)，为后面给代理进行增强实现做准备。
> 本文接着介绍postProcessAfterInitialization的方法，即Spring AOP的代理（cglib或jdk）的创建过程。
## 11.2 代理的创建
创建代理的方法是postProcessAfterInitialization：如果bean被子类标识为代理，则使用配置的拦截器创建一个代理
```java
/**
  * Create a proxy with the configured interceptors if the bean is
  * identified as one to proxy by the subclass.
  * @see #getAdvicesAndAdvisorsForBean
  */
@Override
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
  if (bean != null) {
    Object cacheKey = getCacheKey(bean.getClass(), beanName);
    // 如果不是提前暴露的代理
    if (this.earlyProxyReferences.remove(cacheKey) != bean) {
      return wrapIfNecessary(bean, beanName, cacheKey);
    }
  }
  return bean;
}
```
wrapIfNecessary方法主要用于判断是否需要创建代理，如果Bean能够获取到advisor才需要创建代理
```java
/**
  * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.
  * @param bean the raw bean instance
  * @param beanName the name of the bean
  * @param cacheKey the cache key for metadata access
  * @return a proxy wrapping the bean, or the raw bean instance as-is
  */
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
   // 如果bean是通过TargetSource接口获取
   if (beanName != null && this.targetSourcedBeans.contains(beanName)) {
      return bean;
   }
   // 如果bean是切面类
   if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
      return bean;
   }
   // 如果是aop基础类？是否跳过？
   if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
      this.advisedBeans.put(cacheKey, Boolean.FALSE);
      return bean;
   }

  // 重点：获取所有advisor，如果没有获取到，那说明不要进行增强，也就不需要代理了。
  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
  if (specificInterceptors != DO_NOT_PROXY) {
    this.advisedBeans.put(cacheKey, Boolean.TRUE);
    // 重点：创建代理
    Object proxy = createProxy(
        bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
    this.proxyTypes.put(cacheKey, proxy.getClass());
    return proxy;
  }

  this.advisedBeans.put(cacheKey, Boolean.FALSE);
  return bean;
}
```
## 11.3 获取所有的Advisor
我们看下获取所有advisor的方法getAdvicesAndAdvisorsForBean
```java
@Override
@Nullable
protected Object[] getAdvicesAndAdvisorsForBean(
    Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {

  List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
  if (advisors.isEmpty()) {
    return DO_NOT_PROXY;
  }
  return advisors.toArray();
}
```
通过findEligibleAdvisors方法获取advisor， 如果获取不到返回DO_NOT_PROXY（null，不需要创建代理），findEligibleAdvisors方法如下
```java
/**
  * Find all eligible Advisors for auto-proxying this class.
  * @param beanClass the clazz to find advisors for
  * @param beanName the name of the currently proxied bean
  * @return the empty List, not {@code null},
  * if there are no pointcuts or interceptors
  * @see #findCandidateAdvisors
  * @see #sortAdvisors
  * @see #extendAdvisors
  */
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
  // 和上文一样，获取所有切面类的切面方法生成Advisor
  List<Advisor> candidateAdvisors = findCandidateAdvisors();
  // 找到这些Advisor中能够应用于beanClass的Advisor
  List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
  // 如果需要，交给子类拓展
  extendAdvisors(eligibleAdvisors);
  // 对Advisor排序
  if (!eligibleAdvisors.isEmpty()) {
    eligibleAdvisors = sortAdvisors(eligibleAdvisors);
  }
  return eligibleAdvisors;
}
```
找到这些Advisor中能够应用于beanClass的Advisor
```java
/**
  * Determine the sublist of the {@code candidateAdvisors} list
  * that is applicable to the given class.
  * @param candidateAdvisors the Advisors to evaluate
  * @param clazz the target class
  * @return sublist of Advisors that can apply to an object of the given class
  * (may be the incoming List as-is)
  */
public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
  if (candidateAdvisors.isEmpty()) {
    return candidateAdvisors;
  }
  List<Advisor> eligibleAdvisors = new ArrayList<>();
  for (Advisor candidate : candidateAdvisors) {
    // 通过Introduction实现的advice
    if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
      eligibleAdvisors.add(candidate);
    }
  }
  boolean hasIntroductions = !eligibleAdvisors.isEmpty();
  for (Advisor candidate : candidateAdvisors) {
    if (candidate instanceof IntroductionAdvisor) {
      // already processed
      continue;
    }
    // 是否能够应用于clazz的Advice
    if (canApply(candidate, clazz, hasIntroductions)) {
      eligibleAdvisors.add(candidate);
    }
  }
  return eligibleAdvisors;
}
```
## 11.4 创建代理的入口方法
获取所有advisor后，如果有advisor，则说明需要增强，即需要创建代理，创建代理的方法如下：
```java
/**
  * Create an AOP proxy for the given bean.
  * @param beanClass the class of the bean
  * @param beanName the name of the bean
  * @param specificInterceptors the set of interceptors that is
  * specific to this bean (may be empty, but not null)
  * @param targetSource the TargetSource for the proxy,
  * already pre-configured to access the bean
  * @return the AOP proxy for the bean
  * @see #buildAdvisors
  */
protected Object createProxy(Class<?> beanClass, @Nullable String beanName,
    @Nullable Object[] specificInterceptors, TargetSource targetSource) {

  if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
    AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
  }

  ProxyFactory proxyFactory = new ProxyFactory();
  proxyFactory.copyFrom(this);

  if (proxyFactory.isProxyTargetClass()) {
    // Explicit handling of JDK proxy targets (for introduction advice scenarios)
    if (Proxy.isProxyClass(beanClass)) {
      // Must allow for introductions; can't just set interfaces to the proxy's interfaces only.
      for (Class<?> ifc : beanClass.getInterfaces()) {
        proxyFactory.addInterface(ifc);
      }
    }
  }
  else {
    // No proxyTargetClass flag enforced, let's apply our default checks...
    if (shouldProxyTargetClass(beanClass, beanName)) {
      proxyFactory.setProxyTargetClass(true);
    }
    else {
      evaluateProxyInterfaces(beanClass, proxyFactory);
    }
  }

  Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
  proxyFactory.addAdvisors(advisors);
  proxyFactory.setTargetSource(targetSource);
  customizeProxyFactory(proxyFactory);

  proxyFactory.setFrozen(this.freezeProxy);
  if (advisorsPreFiltered()) {
    proxyFactory.setPreFiltered(true);
  }

  // Use original ClassLoader if bean class not locally loaded in overriding class loader
  ClassLoader classLoader = getProxyClassLoader();
  if (classLoader instanceof SmartClassLoader && classLoader != beanClass.getClassLoader()) {
    classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();
  }
  return proxyFactory.getProxy(classLoader);
}
```
proxyFactory.getProxy(classLoader)
![79.spring-springframework-aop-51.png](../../assets/images/04-主流框架/spring/79.spring-springframework-aop-51.png)
```java
/**
  * Create a new proxy according to the settings in this factory.
  * <p>Can be called repeatedly. Effect will vary if we've added
  * or removed interfaces. Can add and remove interceptors.
  * <p>Uses the given class loader (if necessary for proxy creation).
  * @param classLoader the class loader to create the proxy with
  * (or {@code null} for the low-level proxy facility's default)
  * @return the proxy object
  */
public Object getProxy(@Nullable ClassLoader classLoader) {
  return createAopProxy().getProxy(classLoader);
}

```
## 11.5 依据条件创建代理(jdk或cglib)
DefaultAopProxyFactory.createAopProxy
```java
@Override
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
  if (!NativeDetector.inNativeImage() &&
      (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
    Class<?> targetClass = config.getTargetClass();
    if (targetClass == null) {
      throw new AopConfigException("TargetSource cannot determine target class: " +
          "Either an interface or a target is required for proxy creation.");
    }
    if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
      return new JdkDynamicAopProxy(config);
    }
    return new ObjenesisCglibAopProxy(config);
  }
  else {
    return new JdkDynamicAopProxy(config);
  }
}
```
几个要点
- config.isOptimize() 是通过optimize设置，表示配置是自定义的，默认是false；
- config.isProxyTargetClass()是通过`<aop:config proxy-target-class="true" /> `来配置的，表示优先使用cglib代理，默认是false；
- hasNoUserSuppliedProxyInterfaces(config) 表示是否目标类实现了接口

由此我们可以知道：

Spring默认在目标类实现接口时是通过JDK代理实现的，只有非接口的是通过Cglib代理实现的。当设置proxy-target-class为true时在目标类不是接口或者代理类时优先使用cglib代理实现。
## 总结

### Spring AOP 代理创建过程详细总结

#### 一、代理创建的完整流程

##### 1.1 核心入口方法调用链
```
Spring容器Bean生命周期
    ↓
postProcessAfterInitialization()  ←─ 主要代理创建入口
    ↓
wrapIfNecessary()                ←─ 判断是否需要代理
    ↓
getAdvicesAndAdvisorsForBean()   ←─ 获取适用的Advisor
    ↓
createProxy()                    ←─ 创建代理工厂
    ↓
ProxyFactory.getProxy()          ←─ 实际代理创建
    ↓
DefaultAopProxyFactory.createAopProxy() ←─ 选择代理方式
    ↓
JdkDynamicAopProxy 或 ObjenesisCglibAopProxy
```

#### 二、关键方法详细分析

##### 2.1 `postProcessAfterInitialization` - 代理创建主入口
```java
@Override
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        // 防止重复代理（早期暴露的引用）
        if (!this.earlyProxyReferences.contains(cacheKey)) {
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
```

**作用**：Bean初始化后的标准代理创建点，处理大多数常规情况的代理创建。

##### 2.2 `wrapIfNecessary` - 代理必要性判断
```java
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
    // 三层过滤机制：
    
    // 1. TargetSource过滤
    if (beanName != null && this.targetSourcedBeans.contains(beanName)) {
        return bean;
    }
    
    // 2. 已处理Bean过滤
    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
        return bean;
    }
    
    // 3. 基础设施类过滤（重要！）
    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    }

    // 核心：获取适用的Advisor
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
    
    if (specificInterceptors != DO_NOT_PROXY) {
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
        // 创建代理
        Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, 
                                 new SingletonTargetSource(bean));
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return bean;
}
```

#### 三、Advisor匹配机制详解

##### 3.1 Advisor查找流程
```java
protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, 
                                              TargetSource targetSource) {
    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
    return advisors.isEmpty() ? DO_NOT_PROXY : advisors.toArray();
}
```

##### 3.2 `findEligibleAdvisors` - 合格Advisor筛选
```java
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
    // 1. 获取所有候选Advisor（包括@Aspect注解的切面）
    List<Advisor> candidateAdvisors = findCandidateAdvisors();
    
    // 2. 应用匹配规则筛选
    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    
    // 3. 扩展点（子类可重写）
    extendAdvisors(eligibleAdvisors);
    
    // 4. 排序（确保执行顺序）
    if (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    
    return eligibleAdvisors;
}
```

##### 3.3 Advisor匹配的核心逻辑
```java
// 在AopUtils.findAdvisorsThatCanApply中
public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
    if (candidateAdvisors.isEmpty()) return candidateAdvisors;
    
    List<Advisor> eligibleAdvisors = new ArrayList<>();
    
    // 1. 处理IntroductionAdvisor（引入接口）
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
            eligibleAdvisors.add(candidate);
        }
    }
    
    boolean hasIntroductions = !eligibleAdvisors.isEmpty();
    
    // 2. 处理普通Advisor
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor) continue;
        
        if (canApply(candidate, clazz, hasIntroductions)) {
            eligibleAdvisors.add(candidate);
        }
    }
    
    return eligibleAdvisors;
}
```

#### 四、代理创建的核心实现

##### 4.1 `createProxy` - 代理工厂配置
```java
protected Object createProxy(Class<?> beanClass, String beanName,
                           Object[] specificInterceptors, TargetSource targetSource) {
    
    ProxyFactory proxyFactory = new ProxyFactory();
    proxyFactory.copyFrom(this);  // 继承全局配置

    // 决定代理策略
    if (proxyFactory.isProxyTargetClass()) {
        // 强制使用CGLIB
        if (Proxy.isProxyClass(beanClass)) {
            // 处理JDK代理类的情况
            for (Class<?> ifc : beanClass.getInterfaces()) {
                proxyFactory.addInterface(ifc);
            }
        }
    } else {
        // 自动选择代理方式
        if (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(true);
        } else {
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }

    // 构建Advisor链
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    
    // 定制化扩展
    customizeProxyFactory(proxyFactory);

    // 设置冻结状态（优化性能）
    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) {
        proxyFactory.setPreFiltered(true);
    }

    return proxyFactory.getProxy(getProxyClassLoader());
}
```

##### 4.2 代理方式选择策略
```java
// DefaultAopProxyFactory.createAopProxy 的完整逻辑
@Override
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
    if (!NativeDetector.inNativeImage() &&
        (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
        
        Class<?> targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException("TargetSource cannot determine target class");
        }
        
        // CGLIB适用条件：
        // 1. 目标类是接口 -> 使用JDK代理
        // 2. 目标类是JDK代理类 -> 使用JDK代理  
        // 3. 其他情况 -> 使用CGLIB代理
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        return new ObjenesisCglibAopProxy(config);
    } else {
        // 默认使用JDK代理
        return new JdkDynamicAopProxy(config);
    }
}
```

#### 五、代理选择条件的详细分析

##### 5.1 代理决策条件表

| 条件 | 说明 | 默认值 | 影响 |
|------|------|--------|------|
| `config.isOptimize()` | 是否优化代理 | false | 优先CGLIB |
| `config.isProxyTargetClass()` | 是否代理目标类 | false | 强制CGLIB |
| `hasNoUserSuppliedProxyInterfaces()` | 是否有用户接口 | 自动判断 | 无接口时CGLIB |

##### 5.2 具体决策流程
```java
// 代理选择的完整决策树：
if (强制CGLIB条件满足) {
    if (目标类是接口 || 已经是JDK代理) {
        使用JDK代理  // 特殊情况
    } else {
        使用CGLIB代理
    }
} else {
    使用JDK代理  // 默认情况
}

// 强制CGLIB条件 = optimize为true OR proxyTargetClass为true OR 没有用户接口
```

#### 六、与`postProcessBeforeInstantiation`的协同工作

##### 6.1 两个代理创建点的分工
```java
// Bean生命周期中的AOP代理创建点：
1. postProcessBeforeInstantiation()  ←─ 特殊情况处理
   ├── 自定义TargetSource的提前代理
   ├── Advisor预处理和缓存
   └── 切面类过滤标记

2. 正常Bean实例化流程...
   ├── 构造函数
   ├── 依赖注入
   └── 初始化方法

3. postProcessAfterInitialization()  ←─ 标准代理创建
   ├── Advisor匹配筛选
   ├── 代理方式决策
   └── 实际代理创建
```

##### 6.2 类方法协作关系
```mermaid
graph TB
    A[AnnotationAwareAspectJAutoProxyCreator] --> B[postProcessBeforeInstantiation]
    A --> C[postProcessAfterInitialization]
    
    B --> D[shouldSkip - 切面类过滤]
    B --> E[getCustomTargetSource - 特殊代理]
    B --> F[标记advisedBeans缓存]
    
    C --> G[wrapIfNecessary - 代理判断]
    C --> H[getAdvicesAndAdvisorsForBean - Advisor匹配]
    C --> I[createProxy - 代理创建]
    
    D --> J[AspectJAwareAdvisorAutoProxyCreator.shouldSkip]
    H --> K[AbstractAutoProxyCreator.findEligibleAdvisors]
    
    style B fill:#e1f5fe
    style C fill:#f3e5f5
```

#### 七、性能优化机制

##### 7.1 缓存策略
```java
// 多层缓存避免重复计算：
1. advisedBeans缓存：标记Bean是否需要代理
2. proxyTypes缓存：存储代理类类型信息  
3. earlyProxyReferences：处理循环依赖的早期引用
4. cachedAdvisorBeanNames：Advisor Bean名称缓存
```

##### 7.2 延迟加载与预处理平衡
```java
// Advisor的加载策略：
- postProcessBeforeInstantiation: 预加载和缓存基础设施Advisor
- postProcessAfterInitialization: 按需加载和匹配业务Advisor
```

#### 八、总结

##### 8.1 代理创建的核心要点

1. **双重入口机制**：`postProcessBeforeInstantiation`处理特殊情况，`postProcessAfterInitialization`处理标准情况
2. **精细的过滤策略**：三层过滤确保只有合适的Bean被代理
3. **灵活的Advisor匹配**：支持引入接口和普通Advice的复杂匹配逻辑
4. **智能的代理选择**：基于配置和目标类特征自动选择最优代理方式
5. **完善的性能优化**：多级缓存和预处理机制保障性能

##### 8.2 与网上常见说法的区别

**正确理解**：
- 主要代理创建在`postProcessAfterInitialization`
- `postProcessBeforeInstantiation`承担预处理和特殊情况处理
- 代理选择基于多重条件而非简单接口判断

**错误说法纠正**：
- ❌ "代理在初始化前创建" → ✅ 主要在初始化后创建
- ❌ "有接口就用JDK代理" → ✅ 综合考虑多个配置因素
- ❌ "postProcessBeforeInstantiation只处理TargetSource" → ✅ 还承担重要的预处理工作

这种设计体现了Spring框架在复杂性管理、性能优化和扩展性方面的深度思考，确保了AOP代理创建既高效又灵活。
### 为什么需要两次调用 findCandidateAdvisors？



#### 1. **时机和目的不同**

```java
// 第一次：postProcessBeforeInstantiation 中（实例化前）
protected boolean shouldSkip(Class<?> beanClass, String beanName) {
    List<Advisor> candidateAdvisors = findCandidateAdvisors();  // 第一次调用
    // 主要目的：过滤切面类本身，避免对切面类进行代理
    for (Advisor advisor : candidateAdvisors) {
        if (advisor instanceof AspectJPointcutAdvisor && 
            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
            return true;  // 如果是切面类，跳过代理
        }
    }
    return super.shouldSkip(beanClass, beanName);
}

// 第二次：postProcessAfterInitialization 中（初始化后）
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
    List<Advisor> candidateAdvisors = findCandidateAdvisors();  // 第二次调用
    // 主要目的：为当前Bean找到匹配的Advisor，用于创建代理
    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    // 排序、扩展等后续处理
    return eligibleAdvisors;
}
```

#### 2. **缓存机制避免真正的重复工作**

实际上，`findCandidateAdvisors` 方法有**缓存机制**：

```java
// 在 AbstractAdvisorAutoProxyCreator 中
protected List<Advisor> findCandidateAdvisors() {
    // 使用缓存，避免重复扫描
    if (this.cachedAdvisorBeanNames == null) {
        // 第一次调用：扫描所有Advisor Bean
        this.cachedAdvisorBeanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
            this.beanFactory, Advisor.class, true, false);
    }
    
    List<Advisor> advisors = new ArrayList<>();
    for (String name : this.cachedAdvisorBeanNames) {
        // 从缓存中获取，不会重复扫描
        advisors.add(this.beanFactory.getBean(name, Advisor.class));
    }
    return advisors;
}
```

**关键点**：第二次调用时，`cachedAdvisorBeanNames` 已经缓存了结果，直接从缓存获取。

#### 3. **不同的处理逻辑**
时序图展示两次调用的不同处理路径
```mermaid
sequenceDiagram
    participant Container as Spring容器
    participant ProxyCreator as AutoProxyCreator
    participant AdvisorCache as Advisor缓存
    
    Note over Container,AdvisorCache: 第一次调用 (实例化前)
    Container->>ProxyCreator: postProcessBeforeInstantiation()
    ProxyCreator->>ProxyCreator: shouldSkip()
    ProxyCreator->>AdvisorCache: findCandidateAdvisors() - 初始化缓存
    AdvisorCache-->>ProxyCreator: 返回所有Advisor
    ProxyCreator->>ProxyCreator: 检查是否是切面类
    ProxyCreator->>ProxyCreator: 标记advisedBeans缓存
    
    Note over Container,AdvisorCache: 第二次调用 (初始化后)  
    Container->>ProxyCreator: postProcessAfterInitialization()
    ProxyCreator->>ProxyCreator: wrapIfNecessary()
    ProxyCreator->>ProxyCreator: getAdvicesAndAdvisorsForBean()
    ProxyCreator->>ProxyCreator: findEligibleAdvisors()
    ProxyCreator->>AdvisorCache: findCandidateAdvisors() - 从缓存获取
    AdvisorCache-->>ProxyCreator: 返回缓存的Advisor
    ProxyCreator->>ProxyCreator: findAdvisorsThatCanApply() - 匹配当前Bean
    ProxyCreator->>ProxyCreator: 排序、扩展Advisor
```

#### 4. **性能优化考虑**

```java
// 如果只在 postProcessBeforeInstantiation 中处理所有逻辑，会有问题：
public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {
    // 问题1：此时Bean还未实例化，无法进行精确的Advisor匹配
    // 问题2：如果提前为所有Bean计算匹配的Advisor，会造成大量不必要的计算
    
    // 正确的分阶段处理：
    // 阶段1：预处理（过滤切面类、缓存基础设施Advisor）
    // 阶段2：精确匹配（Bean实例化后，基于实际对象进行匹配）
}
```

#### 5. **实际验证示例**

```java
@Component
@Aspect
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() { /* ... */ }
}

@Component  
public class UserService {
    public void getUser() { /* ... */ }
}

@Component
public class OrderService {
    public void createOrder() { /* ... */ }
}
```

**处理过程**：
```java
// 处理 LoggingAspect Bean 时：
1. postProcessBeforeInstantiation 第一次调用 findCandidateAdvisors()
   - 发现这是切面类，标记为不代理
   - 缓存所有Advisor名称

// 处理 UserService Bean 时：  
2. postProcessBeforeInstantiation 不再调用 findCandidateAdvisors()（使用缓存）

// 处理 OrderService Bean 时：
3. postProcessAfterInitialization 第二次调用 findCandidateAdvisors()
   - 从缓存获取，不重复扫描
   - 为OrderService找到匹配的Advisor
   - 创建代理
```

#### 6.总结

**这不是重复工作，而是分阶段处理的优化设计：**

| 阶段 | 调用时机 | 主要目的 | 性能优化 |
|------|----------|----------|----------|
| **第一次调用** | `postProcessBeforeInstantiation` | 过滤切面类、初始化缓存 | 缓存Advisor名称，避免重复扫描 |
| **第二次调用** | `postProcessAfterInitialization` | 为具体Bean匹配Advisor | 从缓存获取，进行精确匹配 |

**设计优势：**
1. ✅ **避免重复扫描**：通过缓存机制确保只扫描一次
2. ✅ **职责分离**：实例化前处理基础设施，实例化后处理业务逻辑
3. ✅ **精确匹配**：在Bean完全初始化后进行更准确的Advisor匹配
4. ✅ **性能优化**：按需计算，避免为所有Bean提前计算匹配关系

这种"看似重复实则优化"的设计体现了Spring框架在性能和功能平衡方面的深度思考。
# 十二、Spring进阶 - Spring AOP实现原理详解之Cglib代理实现
## 12.1 引入
> 我们在前文中已经介绍了SpringAOP的切面实现和创建动态代理的过程，那么动态代理是如何工作的呢？本文主要介绍Cglib动态代理的案例和SpringAOP实现的原理。

要了解动态代理是如何工作的，首先需要了解

- 什么是代理模式？
- 什么是动态代理？
- 什么是Cglib？
- SpringAOP和Cglib是什么关系？
## 12.2 动态代理要解决什么问题？
### 12.2.1什么是代理？
**代理模式(Proxy pattern)**: 为另一个对象提供一个替身或占位符以控制对这个对象的访问
![80.代理模式.png](../../assets/images/04-主流框架/spring/80.代理模式.png)

举个简单的例子：

我(client)如果要买(doOperation)房，可以找中介(proxy)买房，中介直接和卖方(target)买房。中介和卖方都实现买卖(doOperation)的操作。中介就是代理(proxy)。
### 12.2.2 什么是动态代理？
> 动态代理就是，在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。

在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。
![81.spring-springframework-aop-61.png](../../assets/images/04-主流框架/spring/81.spring-springframework-aop-61.png)
### 12.2.3 什么是Cglib? SpringAOP和Cglib是什么关系？
> Cglib是一个强大的、高性能的代码生成包，它广泛被许多AOP框架使用，为他们提供方法的拦截。
![82.spring-springframework-aop-62.png](../../assets/images/04-主流框架/spring/82.spring-springframework-aop-62.png)
- 最底层是字节码，字节码相关的知识请参考 JVM基础 - 类字节码详解
- ASM是操作字节码的工具
- cglib基于ASM字节码工具操作字节码（即动态生成代理，对方法进行增强）
- SpringAOP基于cglib进行封装，实现cglib方式的动态代理
## 12.3 Cglib代理的案例
### 12.3.1 pom包依赖
引入cglib的依赖包
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>tech-pdai-spring-demos</artifactId>
        <groupId>tech.pdai</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>007-spring-framework-demo-aop-proxy-cglib</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- https://mvnrepository.com/artifact/cglib/cglib -->
        <dependency>
            <groupId>cglib</groupId>
            <artifactId>cglib</artifactId>
            <version>3.3.0</version>
        </dependency>
    </dependencies>

</project>
```
### 12.3.2 定义实体
- User
```java
package tech.pdai.springframework.entity;

/**
 * @author pdai
 */
public class User {

    /**
     * user's name.
     */
    private String name;

    /**
     * user's age.
     */
    private int age;

    /**
     * init.
     *
     * @param name name
     * @param age  age
     */
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
### 12.3.3 被代理的类
即目标类, 对被代理的类中的方法进行增强
```java
package tech.pdai.springframework.service;

import java.util.Collections;
import java.util.List;

import tech.pdai.springframework.entity.User;

/**
 * @author pdai
 */
public class UserServiceImpl {

    /**
     * find user list.
     *
     * @return user list
     */
    public List<User> findUserList() {
        return Collections.singletonList(new User("pdai", 18));
    }

    /**
     * add user
     */
    public void addUser() {
        // do something
    }

}
```
### 12.3.4 cglib代理
cglib代理类，需要实现MethodInterceptor接口，并指定代理目标类target
```java
package tech.pdai.springframework.proxy;

import java.lang.reflect.Method;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

/**
 * This class is for proxy demo.
 *
 * @author pdai
 */
public class UserLogProxy implements MethodInterceptor {

    /**
     * 业务类对象，供代理方法中进行真正的业务方法调用
     */
    private Object target;

    public Object getUserLogProxy(Object target) {
        //给业务对象赋值
        this.target = target;
        //创建加强器，用来创建动态代理类
        Enhancer enhancer = new Enhancer();
        //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）
        enhancer.setSuperclass(this.target.getClass());
        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦
        enhancer.setCallback(this);
        // 创建动态代理类对象并返回
        return enhancer.create();
    }

    // 实现回调方法
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // log - before method
        System.out.println("[before] execute method: " + method.getName());

        // call method
        Object result = proxy.invokeSuper(obj, args);

        // log - after method
        System.out.println("[after] execute method: " + method.getName() + ", return value: " + result);
        return null;
    }
}
```
### 12.3.5 使用代理
启动类中指定代理目标并执行。
```java
package tech.pdai.springframework;

import tech.pdai.springframework.proxy.UserLogProxy;
import tech.pdai.springframework.service.UserServiceImpl;

/**
 * Cglib proxy demo.
 *
 * @author pdai
 */
public class ProxyDemo {

    /**
     * main interface.
     *
     * @param args args
     */
    public static void main(String[] args) {
        // proxy
        UserServiceImpl userService = (UserServiceImpl) new UserLogProxy().getUserLogProxy(new UserServiceImpl());

        // call methods
        userService.findUserList();
        userService.addUser();
    }
}
```
### 12.3.6 简单测试
我们启动上述类main 函数，执行的结果如下：
```java
[before] execute method: findUserList
[after] execute method: findUserList, return value: [User{name='pdai', age=18}]
[before] execute method: addUser
[after] execute method: addUser, return value: null
```
## 12.4 Cglib代理的流程
我们把上述Demo的主要流程画出来，你便能很快理解
![83.spring-springframework-aop-63.png](../../assets/images/04-主流框架/spring/83.spring-springframework-aop-63.png)

更多细节：
- 在上图中，我们可以通过在Enhancer中配置更多的参数来控制代理的行为，比如如果只希望增强这个类中的一个方法（而不是所有方法），那就增加callbackFilter来对目标类中方法进行过滤；Enhancer可以有更多的参数类配置其行为，不过我们在学习上述主要的流程就够了。
- final方法为什么不能被代理？很显然final方法没法被子类覆盖，当然不能代理了。
- Mockito为什么不能mock静态方法？因为mockito也是基于cglib动态代理来实现的，static方法也不能被子类覆盖，所以显然不能mock。但PowerMock可以mock静态方法，因为它直接在bytecode上工作。
## 12.5 SpringAOP中Cglib代理的实现
> SpringAOP封装了cglib，通过其进行动态代理的创建。

我们看下CglibAopProxy的getProxy方法
```java
@Override
public Object getProxy() {
  return getProxy(null);
}

@Override
public Object getProxy(@Nullable ClassLoader classLoader) {
  if (logger.isTraceEnabled()) {
    logger.trace("Creating CGLIB proxy: " + this.advised.getTargetSource());
  }

  try {
    Class<?> rootClass = this.advised.getTargetClass();
    Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy");

    // 上面流程图中的目标类
    Class<?> proxySuperClass = rootClass;
    if (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
      proxySuperClass = rootClass.getSuperclass();
      Class<?>[] additionalInterfaces = rootClass.getInterfaces();
      for (Class<?> additionalInterface : additionalInterfaces) {
        this.advised.addInterface(additionalInterface);
      }
    }

    // Validate the class, writing log messages as necessary.
    validateClassIfNecessary(proxySuperClass, classLoader);

    // 重点看这里，就是上图的enhancer，设置各种参数来构建
    Enhancer enhancer = createEnhancer();
    if (classLoader != null) {
      enhancer.setClassLoader(classLoader);
      if (classLoader instanceof SmartClassLoader &&
          ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
        enhancer.setUseCache(false);
      }
    }
    enhancer.setSuperclass(proxySuperClass);
    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
    enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));

    // 设置callback回调接口，即方法的增强点
    Callback[] callbacks = getCallbacks(rootClass);
    Class<?>[] types = new Class<?>[callbacks.length];
    for (int x = 0; x < types.length; x++) {
      types[x] = callbacks[x].getClass();
    }
    // 上节说到的filter
    enhancer.setCallbackFilter(new ProxyCallbackFilter(
        this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
    enhancer.setCallbackTypes(types);

    // 重点：创建proxy和其实例
    return createProxyClassAndInstance(enhancer, callbacks);
  }
  catch (CodeGenerationException | IllegalArgumentException ex) {
    throw new AopConfigException("Could not generate CGLIB subclass of " + this.advised.getTargetClass() +
        ": Common causes of this problem include using a final class or a non-visible class",
        ex);
  }
  catch (Throwable ex) {
    // TargetSource.getTarget() failed
    throw new AopConfigException("Unexpected AOP exception", ex);
  }
}
```
获取callback的方法如下，提几个理解的要点吧，具体读者在学习的时候建议把我的例子跑一下，然后打一个断点进行理解。
- rootClass: 即目标代理类
- advised: 包含上文中我们获取到的advisor增强器的集合
- exposeProxy: 在xml配置文件中配置的，背景就是如果在事务A中使用了代理，事务A调用了目标类的的方法a，在方法a中又调用目标类的方法b，方法a，b同时都是要被增强的方法，如果不配置exposeProxy属性，方法b的增强将会失效，如果配置exposeProxy，方法b在方法a的执行中也会被增强了
- DynamicAdvisedInterceptor: 拦截器将advised(包含上文中我们获取到的advisor增强器)构建配置的AOP的callback(第一个callback)
- targetInterceptor: xml配置的optimize属性使用的(第二个callback)
- 最后连同其它5个默认的Interceptor 返回作为cglib的拦截器链，之后通过CallbackFilter的accpet方法返回的索引从这个集合中返回对应的拦截增强器执行增强操作。
```java
private Callback[] getCallbacks(Class<?> rootClass) throws Exception {
  // Parameters used for optimization choices...
  boolean exposeProxy = this.advised.isExposeProxy();
  boolean isFrozen = this.advised.isFrozen();
  boolean isStatic = this.advised.getTargetSource().isStatic();

  // Choose an "aop" interceptor (used for AOP calls).
  Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);

  // Choose a "straight to target" interceptor. (used for calls that are
  // unadvised but can return this). May be required to expose the proxy.
  Callback targetInterceptor;
  if (exposeProxy) {
    targetInterceptor = (isStatic ?
        new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
        new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource()));
  }
  else {
    targetInterceptor = (isStatic ?
        new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
        new DynamicUnadvisedInterceptor(this.advised.getTargetSource()));
  }

  // Choose a "direct to target" dispatcher (used for
  // unadvised calls to static targets that cannot return this).
  Callback targetDispatcher = (isStatic ?
      new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp());

  Callback[] mainCallbacks = new Callback[] {
      aopInterceptor,  // 
      targetInterceptor,  // invoke target without considering advice, if optimized
      new SerializableNoOp(),  // no override for methods mapped to this
      targetDispatcher, this.advisedDispatcher,
      new EqualsInterceptor(this.advised),
      new HashCodeInterceptor(this.advised)
  };

  Callback[] callbacks;

  // If the target is a static one and the advice chain is frozen,
  // then we can make some optimizations by sending the AOP calls
  // direct to the target using the fixed chain for that method.
  if (isStatic && isFrozen) {
    Method[] methods = rootClass.getMethods();
    Callback[] fixedCallbacks = new Callback[methods.length];
    this.fixedInterceptorMap = CollectionUtils.newHashMap(methods.length);

    // TODO: small memory optimization here (can skip creation for methods with no advice)
    for (int x = 0; x < methods.length; x++) {
      Method method = methods[x];
      List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, rootClass);
      fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(
          chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());
      this.fixedInterceptorMap.put(method, x);
    }

    // Now copy both the callbacks from mainCallbacks
    // and fixedCallbacks into the callbacks array.
    callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];
    System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);
    System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);
    this.fixedInterceptorOffset = mainCallbacks.length;
  }
  else {
    callbacks = mainCallbacks;
  }
  return callbacks;
}
```
可以结合调试，方便理解
![84.spring-springframework-aop-64.png](../../assets/images/04-主流框架/spring/84.spring-springframework-aop-64.png)
# 十三、Spring进阶 - Spring AOP实现原理详解之JDK代理实现
## 13.1 引入
> 上文我们学习了SpringAOP Cglib动态代理的实现，本文主要是SpringAOP JDK动态代理的案例和实现部分。

## 13.2 什么是JDK代理?
JDK动态代理是有JDK提供的工具类Proxy实现的，动态代理类是在运行时生成指定接口的代理类，每个代理实例（实现需要代理的接口）都有一个关联的调用处理程序对象，此对象实现了InvocationHandler，最终的业务逻辑是在InvocationHandler实现类的invoke方法上。
## 13.3 JDK代理的案例
### 13.3.1 不需要maven依赖
jdk代理不需要任何依赖。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>tech-pdai-spring-demos</artifactId>
        <groupId>tech.pdai</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>006-spring-framework-demo-aop-proxy-jdk</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <!--based on jdk proxy -->
    <dependencies>

    </dependencies>

</project>
```
### 13.3.2 定义实体
- User
```java
package tech.pdai.springframework.entity;

/**
 * @author pdai
 */
public class User {

    /**
     * user's name.
     */
    private String name;

    /**
     * user's age.
     */
    private int age;

    /**
     * init.
     *
     * @param name name
     * @param age  age
     */
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
### 13.3.3 被代理的类和接口
接口
```java
package tech.pdai.springframework.service;

import tech.pdai.springframework.entity.User;

import java.util.List;

/**
 * @author pdai
 */
public interface IUserService {

    /**
     * find user list.
     *
     * @return user list
     */
    List<User> findUserList();

    /**
     * add user
     */
    void addUser();
}
```
实现类如下：
```java
package tech.pdai.springframework.service;

import tech.pdai.springframework.entity.User;

import java.util.Collections;
import java.util.List;

/**
 * @author pdai
 */
public class UserServiceImpl implements IUserService {

    /**
     * find user list.
     *
     * @return user list
     */
    @Override
    public List<User> findUserList() {
        return Collections.singletonList(new User("pdai", 18));
    }

    /**
     * add user
     */
    @Override
    public void addUser() {
        // do something
    }

}
```
### 13.3.4 JDK代理类
代理类如下：
```java
package tech.pdai.springframework.proxy;

import tech.pdai.springframework.service.IUserService;
import tech.pdai.springframework.service.UserServiceImpl;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;

/**
 * This class is for proxy demo.
 *
 * @author pdai
 */
public class UserLogProxy {

    /**
     * proxy target
     */
    private IUserService target;

    /**
     * init.
     *
     * @param target target
     */
    public UserLogProxy(UserServiceImpl target) {
        super();
        this.target = target;
    }

    /**
     * get proxy.
     *
     * @return proxy target
     */
    public IUserService getLoggingProxy() {
        IUserService proxy;
        ClassLoader loader = target.getClass().getClassLoader();
        Class[] interfaces = new Class[]{IUserService.class};
        InvocationHandler h = new InvocationHandler() {
            /**
             * proxy: 代理对象。 一般不使用该对象 method: 正在被调用的方法 args: 调用方法传入的参数
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                String methodName = method.getName();
                // log - before method
                System.out.println("[before] execute method: " + methodName);

                // call method
                Object result = null;
                try {
                    // 前置通知
                    result = method.invoke(target, args);
                    // 返回通知, 可以访问到方法的返回值
                } catch (NullPointerException e) {
                    e.printStackTrace();
                    // 异常通知, 可以访问到方法出现的异常
                }
                // 后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值

                // log - after method
                System.out.println("[after] execute method: " + methodName + ", return value: " + result);
                return result;
            }
        };
        /**
         * loader: 代理对象使用的类加载器.
         * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法.
         * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法
         */
        proxy = (IUserService) Proxy.newProxyInstance(loader, interfaces, h);
        return proxy;
    }

}
```
### 13.3.4 使用代理
启动类中指定代理目标并执行。
```java
package tech.pdai.springframework;

import tech.pdai.springframework.proxy.UserLogProxy;
import tech.pdai.springframework.service.IUserService;
import tech.pdai.springframework.service.UserServiceImpl;

/**
 * Jdk proxy demo.
 *
 * @author pdai
 */
public class ProxyDemo {

    /**
     * main interface.
     *
     * @param args args
     */
    public static void main(String[] args) {
        // proxy
        IUserService userService = new UserLogProxy(new UserServiceImpl()).getLoggingProxy();

        // call methods
        userService.findUserList();
        userService.addUser();
    }
}
```
### 13.3.5 简单测试
我们启动上述类main 函数，执行的结果如下：
```java
[before] execute method: findUserList
[after] execute method: findUserList, return value: [User{name='pdai', age=18}]
[before] execute method: addUser
[after] execute method: addUser, return value: null
```
## 13.4 JDK代理的流程
> JDK代理自动生成的class是由sun.misc.ProxyGenerator来生成的。
### 13.4.1 ProxyGenerator生成代码
我们看下sun.misc.ProxyGenerator生成代码的逻辑：
```java
/**
    * Generate a proxy class given a name and a list of proxy interfaces.
    *
    * @param name        the class name of the proxy class
    * @param interfaces  proxy interfaces
    * @param accessFlags access flags of the proxy class
*/
public static byte[] generateProxyClass(final String name,
                                        Class<?>[] interfaces,
                                        int accessFlags)
{
    ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);
    final byte[] classFile = gen.generateClassFile();
    ...
}
```
generateClassFile方法如下：
```java
/**
    * Generate a class file for the proxy class.  This method drives the
    * class file generation process.
    */
private byte[] generateClassFile() {

    /* 第一步：将所有方法包装成ProxyMethod对象 */
    
    // 将Object类中hashCode、equals、toString方法包装成ProxyMethod对象
    addProxyMethod(hashCodeMethod, Object.class);
    addProxyMethod(equalsMethod, Object.class);
    addProxyMethod(toStringMethod, Object.class);

    // 将代理类接口方法包装成ProxyMethod对象
    for (Class<?> intf : interfaces) {
        for (Method m : intf.getMethods()) {
            addProxyMethod(m, intf);
        }
    }

    // 校验返回类型
    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {
        checkReturnTypes(sigmethods);
    }

    /* 第二步：为代理类组装字段，构造函数，方法，static初始化块等 */
    try {
        // 添加构造函数，参数是InvocationHandler
        methods.add(generateConstructor());

        // 代理方法
        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {
            for (ProxyMethod pm : sigmethods) {

                // 字段
                fields.add(new FieldInfo(pm.methodFieldName,
                    "Ljava/lang/reflect/Method;",
                        ACC_PRIVATE | ACC_STATIC));

                // 上述ProxyMethod中的方法
                methods.add(pm.generateMethod());
            }
        }

        // static初始化块
        methods.add(generateStaticInitializer());

    } catch (IOException e) {
        throw new InternalError("unexpected I/O Exception", e);
    }

    if (methods.size() > 65535) {
        throw new IllegalArgumentException("method limit exceeded");
    }
    if (fields.size() > 65535) {
        throw new IllegalArgumentException("field limit exceeded");
    }

    /* 第三步：写入class文件 */

    /*
        * Make sure that constant pool indexes are reserved for the
        * following items before starting to write the final class file.
        */
    cp.getClass(dotToSlash(className));
    cp.getClass(superclassName);
    for (Class<?> intf: interfaces) {
        cp.getClass(dotToSlash(intf.getName()));
    }

    /*
        * Disallow new constant pool additions beyond this point, since
        * we are about to write the final constant pool table.
        */
    cp.setReadOnly();

    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    DataOutputStream dout = new DataOutputStream(bout);

    try {
        /*
            * Write all the items of the "ClassFile" structure.
            * See JVMS section 4.1.
            */
                                    // u4 magic;
        dout.writeInt(0xCAFEBABE);
                                    // u2 minor_version;
        dout.writeShort(CLASSFILE_MINOR_VERSION);
                                    // u2 major_version;
        dout.writeShort(CLASSFILE_MAJOR_VERSION);

        cp.write(dout);             // (write constant pool)

                                    // u2 access_flags;
        dout.writeShort(accessFlags);
                                    // u2 this_class;
        dout.writeShort(cp.getClass(dotToSlash(className)));
                                    // u2 super_class;
        dout.writeShort(cp.getClass(superclassName));

                                    // u2 interfaces_count;
        dout.writeShort(interfaces.length);
                                    // u2 interfaces[interfaces_count];
        for (Class<?> intf : interfaces) {
            dout.writeShort(cp.getClass(
                dotToSlash(intf.getName())));
        }

                                    // u2 fields_count;
        dout.writeShort(fields.size());
                                    // field_info fields[fields_count];
        for (FieldInfo f : fields) {
            f.write(dout);
        }

                                    // u2 methods_count;
        dout.writeShort(methods.size());
                                    // method_info methods[methods_count];
        for (MethodInfo m : methods) {
            m.write(dout);
        }

                                        // u2 attributes_count;
        dout.writeShort(0); // (no ClassFile attributes for proxy classes)

    } catch (IOException e) {
        throw new InternalError("unexpected I/O Exception", e);
    }

    return bout.toByteArray();
}
```
一共三个步骤（把大象装进冰箱分几步？）：
- 第一步：（把冰箱门打开）准备工作，将所有方法包装成ProxyMethod对象，包括Object类中hashCode、equals、toString方法，以及被代理的接口中的方法
- 第二步：（把大象装进去）为代理类组装字段，构造函数，方法，static初始化块等
- 第三步：（把冰箱门带上）写入class文件
### 13.4.2 从生成的Proxy代码看执行流程
从上述sun.misc.ProxyGenerator类中可以看到，这个类里面有一个配置参数`sun.misc.ProxyGenerator.saveGeneratedFiles`，可以通过这个参数将生成的Proxy类保存在本地，比如设置为true 执行后，生成的文件如下：
![85.JDK代理类本地保存配置.png](../../assets/images/04-主流框架/spring/85.JDK代理类本地保存配置.png)
![86.spring-springframework-aop-71.png](../../assets/images/04-主流框架/spring/86.spring-springframework-aop-71.png)

我们看下生成后的代码：
```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.sun.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.List;
import tech.pdai.springframework.service.IUserService;

// 所有类和方法都是final类型的
public final class $Proxy0 extends Proxy implements IUserService {
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;
    private static Method m4;

    // 构造函数注入 InvocationHandler
    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final List findUserList() throws  {
        try {
            return (List)super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void addUser() throws  {
        try {
            super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            // 初始化 methods, 2个IUserService接口中的方法，3个Object中的接口
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m3 = Class.forName("tech.pdai.springframework.service.IUserService").getMethod("findUserList");
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m4 = Class.forName("tech.pdai.springframework.service.IUserService").getMethod("addUser");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```
上述代码是比较容易理解的，我就不画图了。

主要流程是：
- ProxyGenerator创建Proxy的具体类$Proxy0
- 由static初始化块初始化接口方法：2个IUserService接口中的方法，3个Object中的接口方法
- 由构造函数注入InvocationHandler
- 执行的时候，通过ProxyGenerator创建的Proxy，调用InvocationHandler的invoke方法，执行我们自定义的invoke方法

## 13.5 SpringAOP中JDK代理的实现
SpringAOP扮演的是JDK代理的创建和调用两个角色，我们通过这两个方向来看下SpringAOP的代码（JdkDynamicAopProxy类）

### 13.5.1 SpringAOP Jdk代理的创建
代理的创建比较简单，调用getProxy方法，然后直接调用JDK中Proxy.newProxyInstance()方法将classloader和被代理的接口方法传入即可。
```java
@Override
public Object getProxy() {
    return getProxy(ClassUtils.getDefaultClassLoader());
}

@Override
public Object getProxy(@Nullable ClassLoader classLoader) {
    if (logger.isTraceEnabled()) {
        logger.trace("Creating JDK dynamic proxy: " + this.advised.getTargetSource());
    }
    return Proxy.newProxyInstance(classLoader, this.proxiedInterfaces, this);
}
```
### 13.5.2 SpringAOP Jdk代理的执行
执行的方法如下：
```java
/**
    * Implementation of {@code InvocationHandler.invoke}.
    * <p>Callers will see exactly the exception thrown by the target,
    * unless a hook method throws an exception.
    */
@Override
@Nullable
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Object oldProxy = null;
    boolean setProxyContext = false;

    TargetSource targetSource = this.advised.targetSource;
    Object target = null;

    try {
        // 执行的是equal方法
        if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {
            // The target does not implement the equals(Object) method itself.
            return equals(args[0]);
        }
        // 执行的是hashcode方法
        else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {
            // The target does not implement the hashCode() method itself.
            return hashCode();
        }
        // 如果是包装类，则dispatch to proxy config
        else if (method.getDeclaringClass() == DecoratingProxy.class) {
            // There is only getDecoratedClass() declared -> dispatch to proxy config.
            return AopProxyUtils.ultimateTargetClass(this.advised);
        }
        // 用反射方式来执行切点
        else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&
                method.getDeclaringClass().isAssignableFrom(Advised.class)) {
            // Service invocations on ProxyConfig with the proxy config...
            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
        }

        Object retVal;

        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }

        // Get as late as possible to minimize the time we "own" the target,
        // in case it comes from a pool.
        target = targetSource.getTarget();
        Class<?> targetClass = (target != null ? target.getClass() : null);

        // 获取拦截链
        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // Check whether we have any advice. If we don't, we can fallback on direct
        // reflective invocation of the target, and avoid creating a MethodInvocation.
        if (chain.isEmpty()) {
            // We can skip creating a MethodInvocation: just invoke the target directly
            // Note that the final invoker must be an InvokerInterceptor so we know it does
            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        }
        else {
            // We need to create a method invocation...
            MethodInvocation invocation =
                    new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // Proceed to the joinpoint through the interceptor chain.
            retVal = invocation.proceed();
        }

        // Massage return value if necessary.
        Class<?> returnType = method.getReturnType();
        if (retVal != null && retVal == target &&
                returnType != Object.class && returnType.isInstance(proxy) &&
                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            // Special case: it returned "this" and the return type of the method
            // is type-compatible. Note that we can't help if the target sets
            // a reference to itself in another returned object.
            retVal = proxy;
        }
        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {
            throw new AopInvocationException(
                    "Null return value from advice does not match primitive return type for: " + method);
        }
        return retVal;
    }
    finally {
        if (target != null && !targetSource.isStatic()) {
            // Must have come from TargetSource.
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
```
# 十四、Spring进阶 - SpringMVC实现原理之DispatcherServlet的初始化过程
## 14.1 DispatcherServlet和ApplicationContext有何关系？
> DispatcherServlet 作为一个 Servlet，需要根据 Servlet 规范使用 Java 配置或 web.xml 声明和映射。反过来，DispatcherServlet 使用 Spring 配置来发现请求映射、视图解析、异常处理等等所需的委托组件。那它和ApplicationContext有和关系呢？如下内容可以参考<a href='https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html'>官网-SpringMVC文档</a>

DispatcherServlet 需要 WebApplicationContext（继承自 ApplicationContext） 来配置。WebApplicationContext 可以链接到ServletContext 和 Servlet。因为绑定了 ServletContext，这样应用程序就可以在需要的时候使用 RequestContextUtils 的静态方法访问 WebApplicationContext。

大多数应用程序只有一个WebApplicationContext，除此之外也可以一个Root WebApplicationContext 被多个 Servlet实例，然后各自拥有自己的Servlet WebApplicationContext 配置。

Root WebApplicationContext 包含需要共享给多个 Servlet 实例的数据源和业务服务基础 Bean。这些 Bean 可以在 Servlet 特定的范围被继承或覆盖。

（PS：官网上的这张图可以可以帮助你构建DispatcherServlet和ApplicationContext在设计上的认知，这一点对于理解DispatcherServlet的设计和初始化过程非常重要）
![87.spring-springframework-mvc-13.png](../../assets/images/04-主流框架/spring/87.spring-springframework-mvc-13.png)
## 14.2 DispatcherServlet是如何初始化的？
> DispatcherServlet首先是Sevlet，Servlet有自己的生命周期的方法（init,destory等），那么我们在看DispatcherServlet初始化时首先需要看源码中DispatcherServlet的类结构设计。

首先我们看DispatcherServlet的类结构关系，在这个类依赖结构中找到init的方法
![88.spring-springframework-mvc-11.png](../../assets/images/04-主流框架/spring/88.spring-springframework-mvc-11.png)

很容易找到init()的方法位于HttpServletBean中，然后跑Spring基础 - SpringMVC请求流程和案例中的代码，在init方法中打断点
![89.spring-springframework-mvc-23.png](../../assets/images/04-主流框架/spring/89.spring-springframework-mvc-23.png)
### 14.2.1 init
init()方法如下, 主要读取web.xml中servlet参数配置，并将交给子类方法initServletBean()继续初始化
```java
/**
  * Map config parameters onto bean properties of this servlet, and
  * invoke subclass initialization.
  * @throws ServletException if bean properties are invalid (or required
  * properties are missing), or if subclass initialization fails.
  */
@Override
public final void init() throws ServletException {

  // 读取web.xml中的servlet配置
  PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
  if (!pvs.isEmpty()) {
    try {
      // 转换成BeanWrapper，为了方便使用Spring的属性注入功能
      BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
      // 注入Resource类型需要依赖于ResourceEditor解析，所以注册Resource类关联到ResourceEditor解析器
      ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
      bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
      // 更多的初始化可以让子类去拓展
      initBeanWrapper(bw);
      // 让spring注入namespace,contextConfigLocation等属性
      bw.setPropertyValues(pvs, true);
    }
    catch (BeansException ex) {
      if (logger.isErrorEnabled()) {
        logger.error("Failed to set bean properties on servlet '" + getServletName() + "'", ex);
      }
      throw ex;
    }
  }

  // 让子类去拓展
  initServletBean();
}
```
读取配置可以从下图看出，正是初始化了我们web.xml中配置
![90.spring-springframework-mvc-24.png](../../assets/images/04-主流框架/spring/90.spring-springframework-mvc-24.png)

再看下initServletBean()方法，位于FrameworkServlet类中
```java
/**
  * Overridden method of {@link HttpServletBean}, invoked after any bean properties
  * have been set. Creates this servlet's WebApplicationContext.
  */
@Override
protected final void initServletBean() throws ServletException {
  getServletContext().log("Initializing Spring " + getClass().getSimpleName() + " '" + getServletName() + "'");
  if (logger.isInfoEnabled()) {
    logger.info("Initializing Servlet '" + getServletName() + "'");
  }
  long startTime = System.currentTimeMillis();

  try {
    // 最重要的是这个方法
    this.webApplicationContext = initWebApplicationContext();

    // 可以让子类进一步拓展
    initFrameworkServlet();
  }
  catch (ServletException | RuntimeException ex) {
    logger.error("Context initialization failed", ex);
    throw ex;
  }

  if (logger.isDebugEnabled()) {
    String value = this.enableLoggingRequestDetails ?
        "shown which may lead to unsafe logging of potentially sensitive data" :
        "masked to prevent unsafe logging of potentially sensitive data";
    logger.debug("enableLoggingRequestDetails='" + this.enableLoggingRequestDetails +
        "': request parameters and headers will be " + value);
  }

  if (logger.isInfoEnabled()) {
    logger.info("Completed initialization in " + (System.currentTimeMillis() - startTime) + " ms");
  }
}
```
### 14.2.2 initWebApplicationContext
initWebApplicationContext用来初始化和刷新WebApplicationContext。

initWebApplicationContext() 方法如下
```java
/**
  * Initialize and publish the WebApplicationContext for this servlet.
  * <p>Delegates to {@link #createWebApplicationContext} for actual creation
  * of the context. Can be overridden in subclasses.
  * @return the WebApplicationContext instance
  * @see #FrameworkServlet(WebApplicationContext)
  * @see #setContextClass
  * @see #setContextConfigLocation
  */
protected WebApplicationContext initWebApplicationContext() {
  WebApplicationContext rootContext =
      WebApplicationContextUtils.getWebApplicationContext(getServletContext());
  WebApplicationContext wac = null;

  // 如果在构造函数已经被初始化
  if (this.webApplicationContext != null) {
    // A context instance was injected at construction time -> use it
    wac = this.webApplicationContext;
    if (wac instanceof ConfigurableWebApplicationContext) {
      ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
      if (!cwac.isActive()) {
        // The context has not yet been refreshed -> provide services such as
        // setting the parent context, setting the application context id, etc
        if (cwac.getParent() == null) {
          // The context instance was injected without an explicit parent -> set
          // the root application context (if any; may be null) as the parent
          cwac.setParent(rootContext);
        }
        configureAndRefreshWebApplicationContext(cwac);
      }
    }
  }
  // 没有在构造函数中初始化，则尝试通过contextAttribute初始化
  if (wac == null) {
    // No context instance was injected at construction time -> see if one
    // has been registered in the servlet context. If one exists, it is assumed
    // that the parent context (if any) has already been set and that the
    // user has performed any initialization such as setting the context id
    wac = findWebApplicationContext();
  }

  // 还没有的话，只能重新创建了
  if (wac == null) {
    // No context instance is defined for this servlet -> create a local one
    wac = createWebApplicationContext(rootContext);
  }

  if (!this.refreshEventReceived) {
    // Either the context is not a ConfigurableApplicationContext with refresh
    // support or the context injected at construction time had already been
    // refreshed -> trigger initial onRefresh manually here.
    synchronized (this.onRefreshMonitor) {
      onRefresh(wac);
    }
  }

  if (this.publishContext) {
    // Publish the context as a servlet context attribute.
    String attrName = getServletContextAttributeName();
    getServletContext().setAttribute(attrName, wac);
  }

  return wac;
}
```
webApplicationContext只会初始化一次，依次尝试构造函数初始化，没有则通过contextAttribute初始化，仍没有则创建新的

创建的createWebApplicationContext方法如下
```java
/**
  * Instantiate the WebApplicationContext for this servlet, either a default
  * {@link org.springframework.web.context.support.XmlWebApplicationContext}
  * or a {@link #setContextClass custom context class}, if set.
  * <p>This implementation expects custom contexts to implement the
  * {@link org.springframework.web.context.ConfigurableWebApplicationContext}
  * interface. Can be overridden in subclasses.
  * <p>Do not forget to register this servlet instance as application listener on the
  * created context (for triggering its {@link #onRefresh callback}, and to call
  * {@link org.springframework.context.ConfigurableApplicationContext#refresh()}
  * before returning the context instance.
  * @param parent the parent ApplicationContext to use, or {@code null} if none
  * @return the WebApplicationContext for this servlet
  * @see org.springframework.web.context.support.XmlWebApplicationContext
  */
protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {
  Class<?> contextClass = getContextClass();
  if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
    throw new ApplicationContextException(
        "Fatal initialization error in servlet with name '" + getServletName() +
        "': custom WebApplicationContext class [" + contextClass.getName() +
        "] is not of type ConfigurableWebApplicationContext");
  }

  // 通过反射方式初始化
  ConfigurableWebApplicationContext wac =
      (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);

  wac.setEnvironment(getEnvironment());
  wac.setParent(parent);
  String configLocation = getContextConfigLocation(); // 就是前面Demo中的springmvc.xml
  if (configLocation != null) {
    wac.setConfigLocation(configLocation);
  }

  // 初始化Spring环境
  configureAndRefreshWebApplicationContext(wac);

  return wac;
}
```
configureAndRefreshWebApplicationContext方法初始化设置Spring环境
```java
protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
  // 设置context ID
  if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
    // The application context id is still set to its original default value
    // -> assign a more useful id based on available information
    if (this.contextId != null) {
      wac.setId(this.contextId);
    }
    else {
      // Generate default id...
      wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
          ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName());
    }
  }

  // 设置servletContext, servletConfig, namespace, listener...
  wac.setServletContext(getServletContext());
  wac.setServletConfig(getServletConfig());
  wac.setNamespace(getNamespace());
  wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));

  // The wac environment's #initPropertySources will be called in any case when the context
  // is refreshed; do it eagerly here to ensure servlet property sources are in place for
  // use in any post-processing or initialization that occurs below prior to #refresh
  ConfigurableEnvironment env = wac.getEnvironment();
  if (env instanceof ConfigurableWebEnvironment) {
    ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());
  }

  // 让子类去拓展
  postProcessWebApplicationContext(wac);
  applyInitializers(wac);

  // Spring环境初始化完了，就可以初始化DispatcherServlet处理流程中需要的组件了。
  wac.refresh();
}
```
### 14.2.3 refresh
有了webApplicationContext后，就开始刷新了（onRefresh()方法），这个方法是FrameworkServlet提供的模板方法，由子类DispatcherServlet来实现的。
```java
/**
  * This implementation calls {@link #initStrategies}.
  */
@Override
protected void onRefresh(ApplicationContext context) {
  initStrategies(context);
}
```
刷新主要是调用initStrategies(context)方法对DispatcherServlet中的组件进行初始化，这些组件就是在SpringMVC请求流程中包的主要组件。
```java
/**
  * Initialize the strategy objects that this servlet uses.
  * <p>May be overridden in subclasses in order to initialize further strategy objects.
  */
protected void initStrategies(ApplicationContext context) {
  initMultipartResolver(context);
  initLocaleResolver(context);
  initThemeResolver(context);

  // 主要看如下三个方法
  initHandlerMappings(context);
  initHandlerAdapters(context);
  initHandlerExceptionResolvers(context);

  initRequestToViewNameTranslator(context);
  initViewResolvers(context);
  initFlashMapManager(context);
}
```
### 14.2.4 initHanlderxxx
我们主要看initHandlerXXX相关的方法，它们之间的关系可以看SpringMVC的请求流程：
![91.spring-springframework-mvc-26.png](../../assets/images/04-主流框架/spring/91.spring-springframework-mvc-26.png)
- HandlerMapping是映射处理器
- HandlerAdpter是`处理适配器`，它用来找到你的Controller中的处理方法
- HandlerExceptionResolver是当遇到处理异常时的异常解析器

initHandlerMapping方法如下，无非就是获取按照优先级排序后的HanlderMappings, 将来匹配时按照优先级最高的HanderMapping进行处理。
![92.spring-springframework-mvc-25.png](../../assets/images/04-主流框架/spring/92.spring-springframework-mvc-25.png)

initHandlerAdapters方法和initHandlerExceptionResolvers方法也是类似的，如果没有找到，那就构建默认的。
```java
/**
  * Initialize the HandlerAdapters used by this class.
  * <p>If no HandlerAdapter beans are defined in the BeanFactory for this namespace,
  * we default to SimpleControllerHandlerAdapter.
  */
private void initHandlerAdapters(ApplicationContext context) {
  this.handlerAdapters = null;

  if (this.detectAllHandlerAdapters) {
    // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.
    Map<String, HandlerAdapter> matchingBeans =
        BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
    if (!matchingBeans.isEmpty()) {
      this.handlerAdapters = new ArrayList<>(matchingBeans.values());
      // We keep HandlerAdapters in sorted order.
      AnnotationAwareOrderComparator.sort(this.handlerAdapters);
    }
  }
  else {
    try {
      HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);
      this.handlerAdapters = Collections.singletonList(ha);
    }
    catch (NoSuchBeanDefinitionException ex) {
      // Ignore, we'll add a default HandlerAdapter later.
    }
  }

  // Ensure we have at least some HandlerAdapters, by registering
  // default HandlerAdapters if no other adapters are found.
  if (this.handlerAdapters == null) {
    this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);
    if (logger.isTraceEnabled()) {
      logger.trace("No HandlerAdapters declared for servlet '" + getServletName() +
          "': using default strategies from DispatcherServlet.properties");
    }
  }
}

/**
  * Initialize the HandlerExceptionResolver used by this class.
  * <p>If no bean is defined with the given name in the BeanFactory for this namespace,
  * we default to no exception resolver.
  */
private void initHandlerExceptionResolvers(ApplicationContext context) {
  this.handlerExceptionResolvers = null;

  if (this.detectAllHandlerExceptionResolvers) {
    // Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.
    Map<String, HandlerExceptionResolver> matchingBeans = BeanFactoryUtils
        .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);
    if (!matchingBeans.isEmpty()) {
      this.handlerExceptionResolvers = new ArrayList<>(matchingBeans.values());
      // We keep HandlerExceptionResolvers in sorted order.
      AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);
    }
  }
  else {
    try {
      HandlerExceptionResolver her =
          context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);
      this.handlerExceptionResolvers = Collections.singletonList(her);
    }
    catch (NoSuchBeanDefinitionException ex) {
      // Ignore, no HandlerExceptionResolver is fine too.
    }
  }

  // Ensure we have at least some HandlerExceptionResolvers, by registering
  // default HandlerExceptionResolvers if no other resolvers are found.
  if (this.handlerExceptionResolvers == null) {
    this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);
    if (logger.isTraceEnabled()) {
      logger.trace("No HandlerExceptionResolvers declared in servlet '" + getServletName() +
          "': using default strategies from DispatcherServlet.properties");
    }
  }
}
```
最后我们看下初始化的日志：
```sh
21:30:33.163 [RMI TCP Connection(2)-127.0.0.1] INFO org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'springmvc-demo'
21:30:38.242 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.context.support.XmlWebApplicationContext - Refreshing WebApplicationContext for namespace 'springmvc-demo-servlet'
21:30:39.256 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.context.annotation.ClassPathBeanDefinitionScanner - Identified candidate component class: file [/Users/pdai/pdai/www/tech-pdai-spring-demos/011-spring-framework-demo-springmvc/target/011-spring-framework-demo-springmvc-1.0-SNAPSHOT/WEB-INF/classes/tech/pdai/springframework/springmvc/controller/UserController.class]
21:30:39.261 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.context.annotation.ClassPathBeanDefinitionScanner - Identified candidate component class: file [/Users/pdai/pdai/www/tech-pdai-spring-demos/011-spring-framework-demo-springmvc/target/011-spring-framework-demo-springmvc-1.0-SNAPSHOT/WEB-INF/classes/tech/pdai/springframework/springmvc/dao/UserDaoImpl.class]
21:30:39.274 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.context.annotation.ClassPathBeanDefinitionScanner - Identified candidate component class: file [/Users/pdai/pdai/www/tech-pdai-spring-demos/011-spring-framework-demo-springmvc/target/011-spring-framework-demo-springmvc-1.0-SNAPSHOT/WEB-INF/classes/tech/pdai/springframework/springmvc/service/UserServiceImpl.class]
21:30:39.546 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 29 bean definitions from class path resource [springmvc.xml]
21:30:39.711 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
21:30:39.973 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
21:30:39.984 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
21:30:39.995 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
21:30:40.003 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
21:30:40.042 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.ui.context.support.UiApplicationContextUtils - Unable to locate ThemeSource with name 'themeSource': using default [org.springframework.ui.context.support.ResourceBundleThemeSource@791af912]
21:30:40.052 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'userController'
21:30:40.136 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'userServiceImpl'
21:30:40.140 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'userDaoImpl'
21:30:40.147 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler#0'
21:30:40.153 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0'
21:30:40.350 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.handler.MappedInterceptor#0'
21:30:40.356 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.format.support.FormattingConversionServiceFactoryBean#0'
21:30:40.741 [RMI TCP Connection(2)-127.0.0.1] DEBUG _org.springframework.web.servlet.HandlerMapping.Mappings - 'org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#0' {/**=org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler@216c0f1f}
21:30:40.742 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'mvcCorsConfigurations'
21:30:40.742 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping'
21:30:40.792 [RMI TCP Connection(2)-127.0.0.1] DEBUG _org.springframework.web.servlet.HandlerMapping.Mappings - 'org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping' {}
21:30:40.792 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter'
21:30:40.793 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter'
21:30:40.794 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'localeResolver'
21:30:40.796 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'themeResolver'
21:30:40.798 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'viewNameTranslator'
21:30:40.799 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'flashMapManager'
21:30:40.805 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'mvcContentNegotiationManager'
21:30:40.887 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping'
21:30:41.150 [RMI TCP Connection(2)-127.0.0.1] DEBUG _org.springframework.web.servlet.HandlerMapping.Mappings - 
	t.p.s.s.c.UserController:
	{ [/user]}: list(HttpServletRequest,HttpServletResponse)
21:30:41.202 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping - 1 mappings in 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping'
21:30:41.202 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter'
21:30:41.626 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter - ControllerAdvice beans: none
21:30:41.738 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'mvcUriComponentsContributor'
21:30:41.786 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter - ControllerAdvice beans: none
21:30:41.806 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#0'
21:30:41.919 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver - ControllerAdvice beans: none
21:30:41.920 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver#0'
21:30:41.949 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver#0'
21:30:41.967 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'jspViewResolver'
21:30:44.214 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected AcceptHeaderLocaleResolver
21:30:44.214 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected FixedThemeResolver
21:31:02.141 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator@d57bc91
21:31:03.483 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected org.springframework.web.servlet.support.SessionFlashMapManager@2b4e795e
21:44:08.180 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.jndi.JndiTemplate - Looking up JNDI object with name [java:comp/env/spring.liveBeansView.mbeanDomain]
21:44:08.185 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.jndi.JndiLocatorDelegate - Converted JNDI name [java:comp/env/spring.liveBeansView.mbeanDomain] not found - trying original name [spring.liveBeansView.mbeanDomain]. javax.naming.NameNotFoundException: 名称[spring.liveBeansView.mbeanDomain]未在此上下文中绑定。找不到[spring.liveBeansView.mbeanDomain]。
21:44:08.185 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.jndi.JndiTemplate - Looking up JNDI object with name [spring.liveBeansView.mbeanDomain]
21:44:08.185 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.jndi.JndiPropertySource - JNDI lookup for name [spring.liveBeansView.mbeanDomain] threw NamingException with message: 名称[spring.liveBeansView.mbeanDomain]未在此上下文中绑定。找不到[spring.liveBeansView.mbeanDomain]。. Returning null.
21:44:08.195 [RMI TCP Connection(2)-127.0.0.1] DEBUG org.springframework.web.servlet.DispatcherServlet - enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data
21:44:08.195 [RMI TCP Connection(2)-127.0.0.1] INFO org.springframework.web.servlet.DispatcherServlet - Completed initialization in 815032 ms
```
### 14.2.5 三大Handler的作用详解 

#### 核心概念：DispatcherServlet 的工作流程

你可以把 `DispatcherServlet` 想象成一个公司的**总调度中心（前端控制器）**。当一个HTTP请求到来时，它负责协调各个部门完成工作，但它自己并不处理具体业务。

1.  **收到请求**：DispatcherServlet 接收用户请求。
2.  **问路**：它问 **HandlerMapping**：“这个请求的URL（比如 `/user/1`）应该由哪个部门的哪位同事（哪个Controller的哪个方法）来处理？”
3.  **派活**：HandlerMapping 返回处理者的信息（例如，`UserController` 的 `getUserById` 方法）。DispatcherServlet 拿到这个信息后，需要找一个能驱动这位同事干活的人。
4.  **找适配器**：它问 **HandlerAdapter**：“你们谁擅长驱动 `UserController` 这种风格的同事干活？” Spring 提供了多种 Adapter，比如驱动 `@Controller` 注解的、驱动实现 `Controller` 接口的等。
5.  **执行任务**：合适的 HandlerAdapter 开始工作：它调用目标方法，解析参数，执行方法逻辑，最后封装返回结果（可能是 `ModelAndView`，也可能是 `@ResponseBody` 标注的对象）。
6.  **处理意外**：如果在第5步中出现了异常（比如数据库连接失败、参数校验失败），DispatcherServlet 就会启动 **HandlerExceptionResolver** 来处理这个“烂摊子”，最终返回一个友好的错误页面或JSON错误信息，而不是让用户看到一堆异常堆栈。
---

#### 一、HandlerMapping（映射处理器）

**作用**：建立请求URL与处理程序（Controller）之间的映射关系。

##### 1. 传统Spring项目（XML配置体现）

在Spring Boot出现之前，配置映射关系主要依赖于XML文件。你需要**显式地**在 `WEB-INF/web.xml` 和 `applicationContext.xml`（或类似的Spring配置文件）中定义。

**方式一：BeanNameUrlHandlerMapping（默认且常用）**
这种方式要求Bean的ID以 `/` 开头，URL会直接映射到同名的Bean上。

*   **web.xml**：配置 DispatcherServlet
    ```xml
    <!-- web.xml -->
    <web-app>
        <servlet>
            <servlet-name>dispatcher</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <!-- 指定Spring MVC配置文件的位置 -->
            <init-param>
                <param-name>contextConfigLocation</param-name>
                <param-value>/WEB-INF/spring-mvc-config.xml</param-value>
            </init-param>
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>dispatcher</servlet-name>
            <url-pattern>/</url-pattern>
        </servlet-mapping>
    </web-app>
    ```

*   **spring-mvc-config.xml**：配置Controller Bean和映射
    ```xml
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">

        <!-- 定义一个Controller，实现Controller接口 -->
        <bean id="/hello.do" class="com.example.HelloController"/>

        <!-- 实际上，BeanNameUrlHandlerMapping是默认的，通常无需显式配置 -->
        <!-- <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/> -->
    </beans>
    ```

*   **业务代码**：实现 `Controller` 接口
    ```java
    package com.example;
    import org.springframework.web.servlet.ModelAndView;
    import org.springframework.web.servlet.mvc.Controller;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    public class HelloController implements Controller {
        @Override
        public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
            ModelAndView mav = new ModelAndView();
            mav.addObject("message", "Hello from XML Config!");
            mav.setViewName("hello"); // 对应 /WEB-INF/views/hello.jsp
            return mav;
        }
    }
    ```
    **体现**：当访问 `/hello.do` 时，`BeanNameUrlHandlerMapping` 会将请求映射到ID为 `/hello.do` 的 `HelloController` Bean。

**方式二：SimpleUrlHandlerMapping**
可以更集中地配置URL映射，将多个URL映射到不同的Controller。

```xml
<!-- spring-mvc-config.xml -->
<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
    <property name="mappings">
        <props>
            <!-- key是URL，value是Bean的id -->
            <prop key="/user/list.do">userController</prop>
            <prop key="/order/detail.do">orderController</prop>
        </props>
    </property>
</bean>

<bean id="userController" class="com.example.UserController"/>
<bean id="orderController" class="com.example.OrderController"/>
```

##### 2. Spring Boot项目（代码体现）

Spring Boot通过自动配置完成了所有XML的配置工作。你**无需任何XML**，只需使用注解。

*   **业务代码**：使用 `@Controller` 和 `@RequestMapping` 注解
    ```java
    @Controller
    public class HelloController {

        @RequestMapping("/hello")
        public String hello(Model model) {
            model.addAttribute("message", "Hello from Spring Boot!");
            return "hello"; // 模板名称，由模板引擎解析
        }
    }
    ```
    **体现**：Spring Boot自动配置了 `RequestMappingHandlerMapping`，它会扫描所有 `@Controller` 类，并根据 `@RequestMapping` 注解自动建立映射关系。开发者完全感知不到配置过程。

---

#### 二、HandlerAdapter（处理适配器）

**作用**：作为适配层，让 `DispatcherServlet` 能够调用各种不同类型的处理器。

##### 1. 传统Spring项目（XML配置体现）

不同类型的Controller需要不同的Adapter来驱动。

*   **对于实现了 `Controller` 接口的类（如上例的 `HelloController`）**：
    需要 `SimpleControllerHandlerAdapter`。
    ```xml
    <!-- spring-mvc-config.xml -->
    <!-- 因为SimpleControllerHandlerAdapter是默认适配器之一，通常也无需显式配置 -->
    <!-- <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/> -->
    ```
    **体现**：当 `HandlerMapping` 返回一个 `HelloController`（实现了 `Controller` 接口）时，`DispatcherServlet` 会找到 `SimpleControllerHandlerAdapter`，由它来调用 `handleRequest` 方法。

*   **对于基于注解的Controller（即使在传统Spring中也可用）**：
    需要显式开启注解驱动，这会自动注册 `RequestMappingHandlerAdapter`。
    ```xml
    <!-- spring-mvc-config.xml -->
    <!-- 这行配置是关键！它注册了RequestMappingHandlerMapping和RequestMappingHandlerAdapter -->
    <mvc:annotation-driven/>
    ```
    配置后，你就可以编写现代风格的注解Controller了，其代码与Spring Boot中的写法一致。

##### 2. Spring Boot项目（代码体现）

Spring Boot的自动配置在检测到Classpath下的Spring MVC相关类后，会自动启用 `<mvc:annotation-driven/>` 的等效配置，即自动配置好 `RequestMappingHandlerAdapter`。

*   **业务代码**：你可以直接使用强大的参数绑定功能。
    ```java
    @RestController
    public class UserApiController {
        @GetMapping("/user/{id}")
        public User getUser(@PathVariable Long id) { // HandlerAdapter负责解析id参数
            // ... 业务逻辑
            return user;
        }
    }
    ```
    **体现**：你无需关心适配器，只需按约定写方法签名（使用 `@PathVariable`, `@RequestParam` 等），`RequestMappingHandlerAdapter` 会自动处理。

---

#### 三、HandlerExceptionResolver（异常解析器）

**作用**：统一处理Controller中抛出的异常。

##### 1. 传统Spring项目（XML配置体现）

**方式一：配置SimpleMappingExceptionResolver（XML方式）**
可以在XML中集中定义某种异常对应跳转到哪个错误页面。

```xml
<!-- spring-mvc-config.xml -->
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
            <!-- 当发生SQLException时，跳转到error-db页面 -->
            <prop key="java.sql.SQLException">error-db</prop>
            <!-- 当发生Exception时，跳转到error页面 -->
            <prop key="java.lang.Exception">error</prop>
        </props>
    </property>
    <!-- 默认错误页面 -->
    <property name="defaultErrorView" value="error"/>
</bean>
```

**方式二：使用@ExceptionHandler（注解方式，需结合注解驱动）**
在传统Spring中，也可以使用注解，但需要配合 `<mvc:annotation-driven/>` 和 `@ControllerAdvice`。

```xml
<!-- 1. 开启注解驱动 -->
<mvc:annotation-driven/>
<!-- 2. 开启组件扫描 -->
<context:component-scan base-package="com.example"/>
```

```java
// 2. 业务代码：编写异常处理器
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(UserNotFoundException.class)
    public ModelAndView handleUserNotFound(UserNotFoundException e) {
        ModelAndView mav = new ModelAndView("error");
        mav.addObject("message", e.getMessage());
        return mav;
    }
}
```

##### 2. Spring Boot项目（代码体现）

Spring Boot强烈推荐并简化了注解方式。你只需要编写异常处理类即可，无需任何XML配置。

*   **业务代码**：
    ```java
    @RestControllerAdvice // @ControllerAdvice + @ResponseBody
    public class GlobalApiExceptionHandler {

        @ExceptionHandler(UserNotFoundException.class)
        public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
            ErrorResponse error = new ErrorResponse(404, "User Not Found: " + e.getMessage());
            return ResponseEntity.status(404).body(error);
        }

        @ExceptionHandler(Exception.class)
        public ResponseEntity<ErrorResponse> handleGlobalException(Exception e) {
            ErrorResponse error = new ErrorResponse(500, "Internal Server Error");
            return ResponseEntity.status(500).body(error);
        }
    }
    ```
    **体现**：Spring Boot自动检测到 `@RestControllerAdvice` 注解的Bean，并将其注册到异常解析链中。

---

#### 总结对比表

| 组件 | 核心作用 | 传统Spring项目（XML配置体现） | Spring Boot项目（代码/自动配置体现） |
| :--- | :--- | :--- | :--- |
| **HandlerMapping** | **路由寻址** | **显式配置**：在XML中定义`<bean>`，通过ID或`SimpleUrlHandlerMapping`建立URL与Bean的映射。**核心差异**：映射关系在配置文件中定义。 | **隐式自动配置**：使用`@RequestMapping`等注解，`RequestMappingHandlerMapping`自动扫描并注册映射。**核心差异**：零配置，约定大于配置。 |
| **HandlerAdapter** | **适配执行** | **显式或隐式配置**：为不同类型的Controller（如`Controller`接口实现类）配置对应的Adapter（如`SimpleControllerHandlerAdapter`）。使用`<mvc:annotation-driven/>`来启用注解适配器。 | **完全自动配置**：自动配置好`RequestMappingHandlerAdapter`，开发者直接使用注解编写Controller即可。 |
| **HandlerExceptionResolver** | **统一异常处理** | **XML配置**：使用`SimpleMappingExceptionResolver`在XML中定义异常与视图的映射。**注解配置**：需先配置`<mvc:annotation-driven/>`，再使用`@ControllerAdvice`。 | **纯注解配置**：直接使用`@RestControllerAdvice`/`@ControllerAdvice`+`@ExceptionHandler`，无任何XML。 |

**根本区别**：
*   **传统Spring项目**：**组装式**。开发者是“装配工”，需要自己在XML配置文件中声明（或通过注解驱动开启）各个组件及其依赖关系，控制权大，但配置繁琐。
*   **Spring Boot项目**：**自动式**。开发者是“使用者”。Spring Boot是“智能装配工”，根据约定和类路径自动完成所有配置，简化了开发，开箱即用。
# 十五、Spring进阶 - SpringMVC实现原理之DispatcherServlet处理请求的过程
## 15.1 DispatcherServlet处理请求的过程？
> 一个请求发出，经过DispatcherServlet进行了什么样的处理，最后将内容返回的呢？
### 15.1.1 回顾整理处理流程
首先让我们整体看一下Spring Web MVC 处理请求的流程：
![5.spring-springframework-mvc-5.png](../../assets/images/04-主流框架/spring/5.spring-springframework-mvc-5.png)

**核心架构的具体流程**步骤如下：
- **首先用户发送请求——>DispatcherServlet**，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制；
- **DispatcherServlet——>HandlerMapping**， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一 个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新 的映射策略；
- **DispatcherServlet——>HandlerAdapter**，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；
- **HandlerAdapter——>处理器功能处理方法的调用**，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；
- **ModelAndView 的逻辑视图名——> ViewResolver**，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策 略模式，很容易更换其他视图技术；
- **View——>渲染**，View 会根据传进来的Model 模型数据进行渲染，此处的Model 实际是一个Map 数据结构，因此 很容易支持其他视图技术；
- **返回控制权给DispatcherServlet**，由DispatcherServlet 返回响应给用户，到此一个流程结束。
  
上述扩展点(HandlerMapping、HandlerAdapter、ExceptionResolver)可以通过<a href ='#WebMvcRegistrations'>WebMvcRegistrations</a>实现
### 15.1.2  doGet入口
> 我们以上个demo中这个GET请求为例，请求URL是http://localhost:8080/011_spring_framework_demo_springmvc_war_exploded/user

我们知道servlet处理get请求是doGet方法，所以我们去找DispatcherServlet类结构中的doGet方法。
```java
@Override
protected final void doGet(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {

  processRequest(request, response);
}
```
processRequest处理请求的方法如下：
```java
/**
  * Process this request, publishing an event regardless of the outcome.
  * <p>The actual event handling is performed by the abstract
  * {@link #doService} template method.
  */
protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {

  // 计算处理请求的时间
  long startTime = System.currentTimeMillis();
  Throwable failureCause = null;

  LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
  LocaleContext localeContext = buildLocaleContext(request);

  RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
  ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

  WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
  asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

  // 初始化context
  initContextHolders(request, localeContext, requestAttributes);

  try {
    // 看这里
    doService(request, response);
  }
  catch (ServletException | IOException ex) {
    failureCause = ex;
    throw ex;
  }
  catch (Throwable ex) {
    failureCause = ex;
    throw new NestedServletException("Request processing failed", ex);
  }

  finally {
    // 重置context
    resetContextHolders(request, previousLocaleContext, previousAttributes);
    if (requestAttributes != null) {
      requestAttributes.requestCompleted();
    }
    logResult(request, response, failureCause, asyncManager);
    publishRequestHandledEvent(request, response, startTime, failureCause);
  }
}
```
本质上就是调用doService方法，由DispatchServlet类实现
```java
/**
  * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}
  * for the actual dispatching.
  */
@Override
protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
  logRequest(request);

  // 保存下请求之前的参数.
  Map<String, Object> attributesSnapshot = null;
  if (WebUtils.isIncludeRequest(request)) {
    attributesSnapshot = new HashMap<>();
    Enumeration<?> attrNames = request.getAttributeNames();
    while (attrNames.hasMoreElements()) {
      String attrName = (String) attrNames.nextElement();
      if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
        attributesSnapshot.put(attrName, request.getAttribute(attrName));
      }
    }
  }

  // 方便后续 handlers 和 view 要使用它们.
  request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
  request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
  request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
  request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

  if (this.flashMapManager != null) {
    FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
    if (inputFlashMap != null) {
      request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
    }
    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
  }

  RequestPath previousRequestPath = null;
  if (this.parseRequestPath) {
    previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);
    ServletRequestPathUtils.parseAndCache(request);
  }

  try {
    // 看这里，终于将这个请求分发出去了
    doDispatch(request, response);
  }
  finally {
    if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
      // Restore the original attribute snapshot, in case of an include.
      if (attributesSnapshot != null) {
        restoreAttributesAfterInclude(request, attributesSnapshot);
      }
    }
    if (this.parseRequestPath) {
      ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);
    }
  }
}
```
### 15.1.3 请求分发(doDispatch)
doDispatch方法是真正处理请求的核心方法
```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
  HttpServletRequest processedRequest = request;
  HandlerExecutionChain mappedHandler = null;
  boolean multipartRequestParsed = false;

  WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

  try {
    ModelAndView mv = null;
    Exception dispatchException = null;

    try {
      // 判断是不是文件上传类型的request
      processedRequest = checkMultipart(request);
      multipartRequestParsed = (processedRequest != request);

      // 根据request获取匹配的handler.
      mappedHandler = getHandler(processedRequest);
      if (mappedHandler == null) {
        noHandlerFound(processedRequest, response);
        return;
      }

      // 根据handler获取匹配的handlerAdapter
      HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

      // 如果handler支持last-modified头处理
      String method = request.getMethod();
      boolean isGet = HttpMethod.GET.matches(method);
      if (isGet || HttpMethod.HEAD.matches(method)) {
        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
        if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
          return;
        }
      }

      if (!mappedHandler.applyPreHandle(processedRequest, response)) {
        return;
      }

      // 真正handle处理，并返回modelAndView
      mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

      if (asyncManager.isConcurrentHandlingStarted()) {
        return;
      }

      // 通过视图的prefix和postfix获取完整的视图名
      applyDefaultViewName(processedRequest, mv);

      // 应用后置的拦截器
      mappedHandler.applyPostHandle(processedRequest, response, mv);
    }
    catch (Exception ex) {
      dispatchException = ex;
    }
    catch (Throwable err) {
      // As of 4.3, we're processing Errors thrown from handler methods as well,
      // making them available for @ExceptionHandler methods and other scenarios.
      dispatchException = new NestedServletException("Handler dispatch failed", err);
    }

    // 处理handler处理的结果，显然就是对ModelAndView 或者 出现的Excpetion处理
    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
  }
  catch (Exception ex) {
    triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
  }
  catch (Throwable err) {
    triggerAfterCompletion(processedRequest, response, mappedHandler,
        new NestedServletException("Handler processing failed", err));
  }
  finally {
    if (asyncManager.isConcurrentHandlingStarted()) {
      // Instead of postHandle and afterCompletion
      if (mappedHandler != null) {
        mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
      }
    }
    else {
      // Clean up any resources used by a multipart request.
      if (multipartRequestParsed) {
        cleanupMultipart(processedRequest);
      }
    }
  }
}
```
### 15.1.4 映射和适配器处理
对于真正的handle方法，我们看下其处理流程
```java
/**
  * This implementation expects the handler to be an {@link HandlerMethod}.
  */
@Override
@Nullable
public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
    throws Exception {

  return handleInternal(request, response, (HandlerMethod) handler);
}

```
交给handleInternal方法处理，以RequestMappingHandlerAdapter这个HandlerAdapter中的处理方法为例
```java
@Override
protected ModelAndView handleInternal(HttpServletRequest request,
    HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

  ModelAndView mav;
  checkRequest(request);

  // Execute invokeHandlerMethod in synchronized block if required.
  if (this.synchronizeOnSession) {
    HttpSession session = request.getSession(false);
    if (session != null) {
      Object mutex = WebUtils.getSessionMutex(session);
      synchronized (mutex) {
        mav = invokeHandlerMethod(request, response, handlerMethod);
      }
    }
    else {
      // No HttpSession available -> no mutex necessary
      mav = invokeHandlerMethod(request, response, handlerMethod);
    }
  }
  else {
    // No synchronization on session demanded at all...
    mav = invokeHandlerMethod(request, response, handlerMethod);
  }

  if (!response.containsHeader(HEADER_CACHE_CONTROL)) {
    if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
      applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);
    }
    else {
      prepareResponse(response);
    }
  }

  return mav;
}
```
![93.spring-springframework-mvc-27.png](../../assets/images/04-主流框架/spring/93.spring-springframework-mvc-27.png)

然后执行invokeHandlerMethod这个方法，用来对RequestMapping（usercontroller中的list方法）进行处理
```java
/**
  * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}
  * if view resolution is required.
  * @since 4.2
  * @see #createInvocableHandlerMethod(HandlerMethod)
  */
@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
    HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

  ServletWebRequest webRequest = new ServletWebRequest(request, response);
  try {
    
    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

    // 重要：设置handler(controller#list)方法上的参数，返回值处理，绑定databinder等
    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
    if (this.argumentResolvers != null) {
      invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
    }
    if (this.returnValueHandlers != null) {
      invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
    }
    invocableMethod.setDataBinderFactory(binderFactory);
    invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);

    ModelAndViewContainer mavContainer = new ModelAndViewContainer();
    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
    modelFactory.initModel(webRequest, mavContainer, invocableMethod);
    mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

    
    AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
    asyncWebRequest.setTimeout(this.asyncRequestTimeout);

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.setTaskExecutor(this.taskExecutor);
    asyncManager.setAsyncWebRequest(asyncWebRequest);
    asyncManager.registerCallableInterceptors(this.callableInterceptors);
    asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

    if (asyncManager.hasConcurrentResult()) {
      Object result = asyncManager.getConcurrentResult();
      mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
      asyncManager.clearConcurrentResult();
      LogFormatUtils.traceDebug(logger, traceOn -> {
        String formatted = LogFormatUtils.formatValue(result, !traceOn);
        return "Resume with async result [" + formatted + "]";
      });
      invocableMethod = invocableMethod.wrapConcurrentResult(result);
    }

    // 执行controller中方法
    invocableMethod.invokeAndHandle(webRequest, mavContainer);
    if (asyncManager.isConcurrentHandlingStarted()) {
      return null;
    }

    return getModelAndView(mavContainer, modelFactory, webRequest);
  }
  finally {
    webRequest.requestCompleted();
  }
}
```
invokeAndHandle交给UserController中具体执行list方法执行
![94.spring-springframework-mvc-29.png](../../assets/images/04-主流框架/spring/94.spring-springframework-mvc-29.png)

后续invoke执行的方法，直接看整个请求流程的调用链即可
![95.spring-springframework-mvc-30.png](../../assets/images/04-主流框架/spring/95.spring-springframework-mvc-30.png)

执行后获得视图和Model
![96.spring-springframework-mvc-31.png](../../assets/images/04-主流框架/spring/96.spring-springframework-mvc-31.png)
### 15.1.5 视图渲染
接下来继续执行processDispatchResult方法，对视图和model（如果有异常则对异常处理）进行处理（显然就是渲染页面了）
```java
/**
  * Handle the result of handler selection and handler invocation, which is
  * either a ModelAndView or an Exception to be resolved to a ModelAndView.
  */
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
    @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
    @Nullable Exception exception) throws Exception {

  boolean errorView = false;

  // 如果处理过程有异常，则异常处理
  if (exception != null) {
    if (exception instanceof ModelAndViewDefiningException) {
      logger.debug("ModelAndViewDefiningException encountered", exception);
      mv = ((ModelAndViewDefiningException) exception).getModelAndView();
    }
    else {
      Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
      mv = processHandlerException(request, response, handler, exception);
      errorView = (mv != null);
    }
  }

  // 是否需要渲染视图
  if (mv != null && !mv.wasCleared()) {
    render(mv, request, response); // 渲染视图
    if (errorView) {
      WebUtils.clearErrorRequestAttributes(request);
    }
  }
  else {
    if (logger.isTraceEnabled()) {
      logger.trace("No view rendering, null ModelAndView returned.");
    }
  }

  if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
    // Concurrent handling started during a forward
    return;
  }

  if (mappedHandler != null) {
    // Exception (if any) is already handled..
    mappedHandler.triggerAfterCompletion(request, response, null);
  }
}
```
接下来显然就是渲染视图了, spring在initStrategies方法中初始化的组件（LocaleResovler等）就派上用场了。
```java
/**
  * Render the given ModelAndView.
  * <p>This is the last stage in handling a request. It may involve resolving the view by name.
  * @param mv the ModelAndView to render
  * @param request current HTTP servlet request
  * @param response current HTTP servlet response
  * @throws ServletException if view is missing or cannot be resolved
  * @throws Exception if there's a problem rendering the view
  */
protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
  // Determine locale for request and apply it to the response.
  Locale locale =
      (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());
  response.setLocale(locale);

  View view;
  String viewName = mv.getViewName();
  if (viewName != null) {
    // We need to resolve the view name.
    view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
    if (view == null) {
      throw new ServletException("Could not resolve view with name '" + mv.getViewName() +
          "' in servlet with name '" + getServletName() + "'");
    }
  }
  else {
    // No need to lookup: the ModelAndView object contains the actual View object.
    view = mv.getView();
    if (view == null) {
      throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " +
          "View object in servlet with name '" + getServletName() + "'");
    }
  }

  // Delegate to the View object for rendering.
  if (logger.isTraceEnabled()) {
    logger.trace("Rendering view [" + view + "] ");
  }
  try {
    if (mv.getStatus() != null) {
      response.setStatus(mv.getStatus().value());
    }
    view.render(mv.getModelInternal(), request, response);
  }
  catch (Exception ex) {
    if (logger.isDebugEnabled()) {
      logger.debug("Error rendering view [" + view + "]", ex);
    }
    throw ex;
  }
}
```
后续就是通过viewResolver进行解析了，这里就不再继续看代码了，上述流程基本上够帮助你构建相关的认知了。

最后无非是返回控制权给DispatcherServlet，由DispatcherServlet 返回响应给用户。

最后的最后我们看下请求的日志：
```sh
21:45:53.390 [http-nio-8080-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/011_spring_framework_demo_springmvc_war_exploded/user", parameters={}
21:45:53.400 [http-nio-8080-exec-6] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping - Mapped to tech.pdai.springframework.springmvc.controller.UserController#list(HttpServletRequest, HttpServletResponse)
22:51:14.504 [http-nio-8080-exec-6] DEBUG org.springframework.web.servlet.view.JstlView - View name 'userList', model {dateTime=Fri Apr 22 21:45:53 CST 2022, userList=[tech.pdai.springframework.springmvc.entity.User@7b8c8dc]}
22:51:14.550 [http-nio-8080-exec-6] DEBUG org.springframework.web.servlet.view.JstlView - Forwarding to [/WEB-INF/views/userList.jsp]
22:51:44.395 [http-nio-8080-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
```
# 十六 ♥SpringBoot 知识体系详解♥

提示：Spring，Spring Boot系列的章节在整理中... 包含实际业务开发中的方方面面...

# ♥SpringBoot 知识体系详解♥

## 相关文章

站在知识体系的视角，基于SpringBoot开发。

- SpringBoot入门(helloworld,banner,logback,分层设计)
- SpringBoot接口设计和实现(封装,校验,异常,加密,幂等)
- SpringBoot集成MySQL(JPA,MyBatis,MyBatis-Plus)
- SpringBoot集成ShardingJDBC(分表分库,读写分离,多租户)
- SpringBoot集成连接池(HikariCP,Druid)
- SpringBoot集成数据迁移(Liquibase,Flyway)
- SpringBoot集成PostgreSQL(JPA,MyBatis-Plus,Json)
- SpringBoot集成Redis(Jedis,Luttue,Redission)
- SpringBoot集成其它NoSQL数据库(MongoDB,ElasticSearch,Noe4J)
- SpringBoot集成Websocket(socket,netty)
- SpringBoot集成定时任务(springtask,quartz,elastic-job,xxl-job)
- SpringBoot集成视图解析(Thymeleaf,FreeMarker,Velocity,JSP,VueJS)
- SpringBoot集成缓存(Caffeine,EhCache,CouchBase)
- SpringBoot集成认证授权(SpringSecurity,Shiro,Oauth2,SA-Token,Keycloak)
- SpringBoot集成文档操作(上传,PDF,Excel,Word)
- SpringBoot集成消息队列(ActiveMQ,RabbitMQ,ZeroMQ,Kafka)
- SpringBoot集成通知(Email,短信,钉钉,微信)
- SpringBoot集成文件系统(minIO,aliyun,tencentCloud,FastDFS)
- SpringBoot集成工作流引擎(activi,jBPM,flowable)
- SpringBoot集成其它功能(支付,OPC-UA,JavaFX2)
- SpringBoot应用部署(jar,war,linux,docker,docker-compose)
- SpringBoot集成监控(actuator,springboot-admin,ELK,Grafana,APM)
- SpringBoot进阶(starter,自动装配原理,各类机制等)

## SpringBoot入门(helloworld,banner,logback,分层设计)

首先，在开始SpringBoot开发时，我们了解一些技术栈背景并通过Hello World级别应用程序开始延伸出SpringBoot入门应用的开发。

- [SpringBoot入门 - SpringBoot 简介]
  - 为什么有了SpringFramework还会诞生SpringBoot？简单而言，因为虽然Spring的组件代码是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过开箱即用和约定大于配置来解决配置重的问题的。
- [SpringBoot入门 - 创建第一个Hello world工程]
  - (我们了解了SpringBoot和SpringFramework的关系之后，我们可以开始创建一个Hello World级别的项目了。)
- [SpringBoot入门 - 对Hello world进行MVC分层]
  - (上文中我们创建一个简单的Hello Wold级别的web应用程序，但是存在一个问题，我们将所有代码都放在一个类中的, 这显然是不合理的，那么一个经典的CRUD项目如何分包呢？本文结合常见的MVC分层思路带你学习常见的包结构划分。)
- [SpringBoot入门 - 添加内存数据库H2]
  - (上文我们展示了通过学习经典的MVC分包结构展示了一个用户的增删查改项目，但是我们没有接入数据库；本文将在上文的基础上，增加一个H2内存数据库，并且通过Spring提供的数据访问包JPA进行数据查询。)
- [SpringBoot入门 - 定制自己的Banner](我们在启动Spring Boot程序时，有SpringBoot的Banner信息，那么如何自定义成自己项目的信息呢？)
- [SpringBoot入门 - 添加Logback日志]
  - (SpringBoot开发中如何选用日志框架呢？出于性能等原因，Logback目前是springboot应用日志的标配；当然有时候在生产环境中也会考虑和三方中间件采用统一处理方式。)
- [SpringBoot入门 - 配置热部署devtools工具]
  - (在SpringBoot开发调试中，如果我每行代码的修改都需要重启启动再调试，可能比较费时间；SpringBoot团队针对此问题提供了spring-boot-devtools（简称devtools）插件，它试图提升开发调试的效率。)
- [SpringBoot入门 - 开发中还有哪些常用注解]
  - (SpringBoot中常用的注解)

## SpringBoot接口设计和实现(封装,校验,异常,加密,幂等)

接着，站在接口设计和实现的角度，从实战开发中梳理出，关于接口开发的技术要点。

- [SpringBoot接口 - 如何统一接口封装]
  - (在以SpringBoot开发Restful接口时，统一返回方便前端进行开发和封装，以及出现时给出响应编码和信息。)
- [SpringBoot接口 - 如何对参数进行校验]
  - (在以SpringBoot开发Restful接口时,对于接口的查询参数后台也是要进行校验的，同时还需要给出校验的返回信息放到上文我们统一封装的结构中。那么如何优雅的进行参数的统一校验呢？)
- [SpringBoot接口 - 如何参数校验国际化]
  - (上文我们学习了如何对SpringBoot接口进行参数校验，但是如果需要有国际化的信息，应该如何优雅处理呢？)
- [SpringBoot接口 - 如何统一异常处理]
  - (SpringBoot接口如何对异常进行统一封装，并统一返回呢？以上文的参数校验为例，如何优雅的将参数校验的错误信息统一处理并封装返回呢？)
- [SpringBoot接口 - 如何提供多个版本接口]
  - (在以SpringBoot开发Restful接口时，由于模块，系统等业务的变化，需要对同一接口提供不同版本的参数实现（老的接口还有模块或者系统在用，不能直接改，所以需要不同版本）。如何更加优雅的实现多版本接口呢？)
- [SpringBoot接口 - 如何生成接口文档之Swagger技术栈]
  - (SpringBoot开发Restful接口，有什么API规范吗？如何快速生成API文档呢？Swagger是一个用于生成、描述和调用RESTful接口的Web服务。通俗的来讲，Swagger就是将项目中所有（想要暴露的）接口展现在页面上，并且可以进行接口调用和测试的服务。本文主要介绍OpenAPI规范，以及Swagger技术栈基于OpenAPI规范的集成方案。)
- [SpringBoot接口 - 如何生成接口文档之集成Smart-Doc]
  - (上文我们看到可以通过Swagger系列可以快速生成API文档，但是这种API文档生成是需要在接口上添加注解等，这表明这是一种侵入式方式；那么有没有非侵入式方式呢,比如通过注释生成文档？本文主要介绍非侵入式的方式及集成Smart-doc案例。我们构建知识体系时使用Smart-doc这类工具并不是目标，而是要了解非侵入方式能做到什么程度和技术思路,最后平衡下来多数情况下多数人还是会选择Swagger+openapi技术栈的。)
- [SpringBoot接口 - 如何访问外部接口]
  - (在SpringBoot接口开发中，存在着本模块的代码需要访问外面模块接口或外部url链接的需求,比如调用外部的地图API或者天气API。那么有哪些方式可以调用外部接口呢？)
- [SpringBoot接口 - 如何对接口进行加密]
  - (在以SpringBoot开发后台API接口时，会存在哪些接口不安全的因素呢？通常如何去解决的呢？本文主要介绍API接口有不安全的因素以及常见的保证接口安全的方式，重点实践如何对接口进行签名。)
- [SpringBoot接口 - 如何保证接口幂等]
  - (在以SpringBoot开发Restful接口时，如何防止接口的重复提交呢？本文主要介绍接口幂等相关的知识点，并实践常见基于Token实现接口幂等。)
- [SpringBoot接口 - 如何实现接口限流之单实例]
  - (在以SpringBoot开发Restful接口时，当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。在接口层如何做限流呢？本文主要回顾限流的知识点，并实践单实例限流的一种思路。)
- [SpringBoot接口 - 如何实现接口限流之分布式]
  - (上文中介绍了单实例下如何在业务接口层做限流，本文主要介绍分布式场景下限流的方案，以及什么样的分布式场景下需要在业务层加限流而不是接入层;并且结合kailing开源的ratelimiter-spring-boot-starter为例，学习思路+代码封装+starter封装。)

## SpringBoot集成MySQL(JPA,MyBatis,MyBatis-Plus)

接下来，我们学习SpringBoot如何集成数据库，比如MySQL数据库，常用的方式有JPA和MyBatis。

- [SpringBoot集成MySQL - 基于JPA的封装]
  - (在实际开发中，最为常见的是基于数据库的CRUD封装等，比如SpringBoot集成MySQL数据库，常用的方式有JPA和MyBatis；本文主要介绍基于JPA方式的基础封装思路。)
- [SpringBoot集成MySQL - MyBatis XML方式]
  - (上文介绍了用JPA方式的集成MySQL数据库，JPA方式在中国以外地区开发而言基本是标配，在国内MyBatis及其延伸框架较为主流。本文主要介绍MyBatis技栈的演化以及SpringBoot集成基础的MyBatisXML实现方式的实例。)
- [SpringBoot集成MySQL - MyBatis 注解方式]
  - (上文主要介绍了Spring集成MyBatis访问MySQL，采用的是XML配置方式；我们知道除了XML配置方式，MyBatis还支持注解方式。本文主要介绍SpringBoot+MyBatis注解方式。)
- [SpringBoot集成MySQL - MyBatis PageHelper分页]
  - (前文中，我们展示了SpringBoot与MyBatis的集成，但是没有展示分页实现。本文专门介绍分页相关知识体系和基于MyBatis的物理分页PageHelper。)
- [SpringBoot集成MySQL - MyBatis 多个数据源]
  - (前文介绍的SpringBoot集成单个MySQL数据库的情形，那么什么场景会使用多个数据源以及什么场景会需要多个数据源的动态切换呢？本文主要介绍上述场景及SpringBoot+MyBatis实现多个数据源的方案和示例。)
- [SpringBoot集成MySQL - MyBatis-Plus方式]
  - (MyBatis-Plus（简称MP）是一个MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为简化开发、提高效率而生。MyBatis-Plus在国内也有很多的用户，本文主要介绍MyBatis-Plus和SpringBoot的集成。)
- [SpringBoot集成MySQL - MyBatis-Plus代码自动生成]
  - (本文主要介绍MyBatis-Plus代码自动生成，以及产生此类代码生成工具的背景和此类工具的基本实现原理。)
- [SpringBoot集成MySQL - MyBatis-Plus基于字段隔离的多租户]
  - (本文主要介绍MyBatis-Plus的基于字段隔离的多租户实现，以及MyBatis-Plus的基于字段的隔离方式实践和原理。)

## SpringBoot集成ShardingJDBC(分表分库,读写分离,多租户)

随着数据量和业务的增长，我们还需要进行分库分表，这里主要围绕ShardingSphere中间件来实现分库分表，读写分离和多租户等。

- [SpringBoot集成ShardingJDBC - Sharding-JDBC简介和基于MyBatis的单库分表]
  - (本文主要介绍分表分库，以及SpringBoot集成基于ShardingJDBC的单库分表实践。)
- [SpringBoot集成ShardingJDBC - 基于JPA的单库分表]
  - (上文介绍SpringBoot集成基于ShardingJDBC的读写分离实践，本文在此基础上介绍SpringBoot集成基于ShardingJDBC+JPA的单库分表实践。)
- [SpringBoot集成ShardingJDBC - 基于JPA的读写分离]
  - (本文主要介绍分表分库，以及SpringBoot集成基于ShardingJDBC的读写分离实践。)
- [SpringBoot集成ShardingJDBC - 基于JPA的DB隔离多租户方案]
  - (本文主要介绍ShardingJDBC的分片算法和分片策略，并在此基础上通过SpringBoot集成ShardingJDBC的几种策略（标准分片策略，行表达式分片策略和hint分片策略）向你展示DB隔离的多租户方案。)

## SpringBoot集成连接池(HikariCP,Druid)

为了提高对数据库操作的性能，引出了数据库连接池，它负责分配、管理和释放数据库连接。历史舞台上出现了C3P0，DBCP，BoneCP等均已经被淘汰，目前最为常用（也是SpringBoot2标配的）是HikariCP，与此同时国内阿里Druid（定位为基于数据库连接池的监控）也有一些市场份额。

- [SpringBoot集成连接池 - 数据库连接池和默认连接池HikariCP]
  - (本文主要介绍数据库连接池，以及SpringBoot集成默认的HikariCP的实践。)
- [SpringBoot集成连接池 - 集成数据库Druid连接池]
  - (上文介绍默认数据库连接池HikariCP，本文主要介绍SpringBoot集成阿里的Druid连接池的实践;客观的来说，阿里Druid只能说是中文开源中功能全且广泛的连接池为基础的监控组件，但是（仅从连接池的角度）在生态，维护性，开源规范性，综合性能等方面和HikariCP比还是有很大差距。)

## SpringBoot集成数据迁移(Liquibase,Flyway)

在实际上线的应用中，随着版本的迭代，经常会遇到需要变更数据库表和字段，必然会遇到需要对这些变更进行记录和管理，以及回滚等等；同时只有脚本化且版本可管理，才能在让数据库实现真正的DevOps（自动化执行+回滚等）。在这样的场景下出现了Liquibase, Flyway等数据库迁移管理工具。

- [SpringBoot数据库管理 - 用Liquibase对数据库管理和迁移]
  - (Liquibase是一个用于用于跟踪、管理和应用数据库变化的开源工具，通过日志文件(changelog)的形式记录数据库的变更(changeset)，然后执行日志文件中的修改，将数据库更新或回滚(rollback)到一致的状态。它的目标是提供一种数据库类型无关的解决方案，通过执行schema类型的文件来达到迁移。本文主要介绍SpringBoot与Liquibase的集成。)
- [SpringBoot数据库管理 - 用flyway对数据库管理和迁移]
  - (上文介绍了Liquibase，以及和SpringBoot的集成。除了Liquibase之外，还有一个组件Flyway也是经常被使用到的类似的数据库版本管理中间件。本文主要介绍Flyway,以及SpringBoot集成Flyway。)

## SpringBoot集成PostgreSQL(JPA,MyBatis-Plus,Json)

在企业级应用场景下开源数据库PostgreSQL对标的是Oracle，它的市场份额稳步攀升，并且它在自定义函数，NoSQL等方面也支持，所以PostgreSQL也是需要重点掌握的。

- [SpringBoot集成PostgreSQL - 基于JPA封装基础数据操作]
  - (PostgreSQL在关系型数据库的稳定性和性能方面强于MySQL，所以它在实际项目中使用和占比越来越高。对开发而言最为常见的是基于数据库的CRUD封装等，本文主要介绍SpringBoot集成PostgreSQL数据库，以及基于JPA方式的基础封装思路。)
- [SpringBoot集成PostgreSQL - 基于MyBatis-Plus方式]
  - (前文介绍SpringBoot+MyBatis-Plus+MySQL的集成，本文主要介绍SpringBoot+MyBatis-Plus+PostgreSQL的集成。)
- [SpringBoot集成PostgreSQL - NoSQL特性JSONB及自定义函数的封装]

## SpringBoot集成Redis(Jedis,Luttue,Redission)

学习完SpringBoot和SQL数据库集成后，我们开始学习NoSQL数据库的开发和集成；最重要的是分布式的缓存库Redis，它是最为常用的key-value库。主要包括早前的Jedis集成，目前常见的Luttue和Redission的封装集成；还包括基于此的Redis分布式锁的实现等。

- [SpringBoot集成Redis - 基于RedisTemplate+Jedis的数据操作]
  - (Redis是最常用的KV数据库，Spring通过模板方式（RedisTemplate）提供了对Redis的数据查询和操作功能。本文主要介绍基于RedisTemplate+Jedis方式对Redis进行查询和操作的案例。)
- [SpringBoot集成Redis - 基于RedisTemplate+Lettuce数据操作]
  - (在SpringBoot2.x版本中Redis默认客户端是Lettuce，本文主要介绍SpringBoot和默认的Lettuce的整合案例。)
- [SpringBoot集成Redis - 基于RedisTemplate+Lettuce数据类封装]
  - (前两篇文章介绍了SpringBoot基于RedisTemplate的数据操作，那么如何对这些操作进行封装呢？本文主要介绍基于RedisTemplate的封装。)
- [SpringBoot集成Redis - Redis分布式锁的实现]
  - (Redis实际使用场景最为常用的还有通过Redis实现分布式锁。本文主要介绍Redis实现分布式锁。)

## SpringBoot集成其它NoSQL数据库(MongoDB,ElasticSearch,Noe4J)

- [SpringBoot集成MongoDB - 基于MongoTemplate的数据操作]
- [SpringBoot集成ElasticSearch - 基于ElasticSearchTemplate的数据操作]
- [SpringBoot集成Noe4J - 集成图数据Noe4J]

## SpringBoot集成Websocket(socket,netty)

进一步，我们看下SpringBoot集成Socket。

- [SpringBoot集成Socket - 基础的Websocket实现]
- [SpringBoot集成Socket - 用Netty实现socket]

## SpringBoot集成定时任务(springtask,quartz,elastic-job,xxl-job)

开发中常用的还有定时任务，我们看下SpringBoot集成定时任务,包括Timer，ScheduleExecutorService，HashedWheelTimer，Springtasks，quartz，elastic-job，xxl-job等。

- [SpringBoot集成定时任务 - Timer实现方式]
  - (定时任务在实际开发中有着广泛的用途，本文主要帮助你构建定时任务的知识体系，同时展示Timer的schedule和scheduleAtFixedRate例子；后续的文章中我们将逐一介绍其它常见的与SpringBoot的集成。)
- [SpringBoot集成定时任务 - ScheduleExecutorService实现方式]
  - (上文介绍的Timer在实际开发中很少被使用，因为Timer底层是使用一个单线程来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行。而ScheduledExecutorService是基于线程池的，可以开启多个线程进行执行多个任务，每个任务开启一个线程；这样任务的延迟和未处理异常就不会影响其它任务的执行了。)
- [SpringBoot集成定时任务 - Netty HashedWheelTimer方式]
  - (Timer和ScheduledExecutorService是JDK内置的定时任务方案，而业内还有一个经典的定时任务的设计叫时间轮(TimingWheel),Netty内部基于时间轮实现了一个HashedWheelTimer来优化百万量级I/O超时的检测，它是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。本文主要介绍时间轮(TimingWheel)及其使用。)
- [SpringBoot集成定时任务 - Spring tasks实现方式]
  - (前文我们介绍了Timer和ScheduledExecutorService是JDK内置的定时任务方案以及Netty内部基于时间轮实现的HashedWheelTimer；而主流的SpringBoot集成方案有两种，一种是SpringSechedule,另一种是Spring集成Quartz；本文主要介绍SpringSchedule实现方式。)
- [SpringBoot集成定时任务 - 基础quartz实现方式]
  - (除了SpringTask，最为常用的Quartz，并且Spring也集成了Quartz的框架。本文主要介绍Quartz和基础的Quartz的集成案例。)
- [SpringBoot集成定时任务 - 分布式quartz cluster方式]
  - (通常我们使用quartz只是实现job单实例运行，本例将展示quartz实现基于数据库的分布式任务管理，和控制job生命周期。)
- [SpringBoot集成定时任务 - 分布式elastic-job方式]
  - (前文展示quartz实现基于数据库的分布式任务管理和job生命周期的控制，那在分布式场景下如何解决弹性调度、资源管控、以及作业治理等呢？针对这些功能前当当团队开发了ElasticJob，2020年5月28日ElasticJob成为ApacheShardingSphere的子项目；本文介绍ElasticJob以及SpringBoot的集成。)
- [SpringBoot集成定时任务 - 分布式xxl-job方式]
  - (除了前文介绍的ElasticJob，xxl-job在很多中小公司有着应用（虽然其代码和设计等质量并不太高，License不够开放，有着个人主义色彩，但是其具体开箱使用的便捷性和功能相对完善性，这是中小团队采用的主要原因）；XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。本文介绍XXL-JOB以及SpringBoot的集成。)@pdai

## SpringBoot集成视图解析(Thymeleaf,FreeMarker,Velocity,JSP,VueJS)

SpringBoot集成视图解析，包括SpringBoot推荐的Thymeleaf，其它常用的FreeMarker,Velocity,Mustache，甚至JSP；还包括在后端视图的基础上采用主流的前端视图（比如VueJs)的兼容方案等。

- [SpringBoot集成视图 - 集成Thymeleaf视图解析]
- [SpringBoot集成视图 - 集成FreeMarker视图解析]
- [SpringBoot集成视图 - 集成Velocity视图解析]
- [SpringBoot集成视图 - 集成Mustache视图解析]
- [SpringBoot集成视图 - 集成JSP视图解析]
- [SpringBoot集成视图 - 集成后端视图+VueJS解析]

## SpringBoot集成缓存(Caffeine,EhCache,CouchBase)

- [SpringBoot + Spring Cache + ConcurrentMap]
- [SpringBoot + Spring Cache + EHCache]
- [SpringBoot + Spring Cache + Redis]
- [SpringBoot + Spring Cache + Caffeine]
- [SpringBoot + Spring Cache + CouchBase]

## SpringBoot集成认证授权(SpringSecurity,Shiro,Oauth2,SA-Token,Keycloak)

- [SpringBoot + Shiro]
- [SpringBoot + Spring Security 常规实现Oauth2]
- [SpringBoot + SA-Token]
- [SpringBoot + Keycloak]
- [SpringBoot + 登录验证码 AJ_Captcha]

## SpringBoot集成文档操作(上传,PDF,Excel,Word)

开发中常见的文档操作，包括文件的上传和下载，上传又包含大文件的处理；针对不同的文档类型又有些常见的工具，比如POI及衍生框架用来导出Excel,iText框架用来导出PDF等。

- [SpringBoot集成文件 - 基础的文件上传和下载]
  - (项目中常见的功能是需要将数据文件（比如Excel,csv)上传到服务器端进行处理，亦或是将服务器端的数据以某种文件形式（比如excel,pdf,csv,word)下载到客户端。本文主要介绍基于SpringBoot的对常规文件的上传和下载，以及常见的问题等。)
- [SpringBoot集成文件 - 大文件的上传(异步，分片，断点续传和秒传)]
  - (上文中介绍的是常规文件的上传和下载，而超大文件的上传技术手段和普通文件上传是有差异的，主要通过基于分片的断点续传和秒传和异步上传等技术手段解决。本文主要介绍SpringBoot集成大文件上传的案例。)
- [SpringBoot集成文件 - 集成POI之Excel导入导出]
  - (ApachePOI是用Java编写的免费开源的跨平台的JavaAPI，ApachePOI提供API给Java程序对MicrosoftOffice格式档案读和写的功能。本文主要介绍通过SpringBoot集成POI工具实现Excel的导入和导出功能。)
- [SpringBoot集成文件 - 集成EasyExcel之Excel导入导出]
  - (EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。它能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。它是基于POI来封装实现的，主要解决其易用性，封装性和性能问题。本文主要介绍通过SpringBoot集成EasyExcel实现Excel的导入，导出和填充模板等功能。)
- [SpringBoot集成文件 - 集成EasyPOI之Excel导入导出]
  - (除了POI和EasyExcel，国内还有一个EasyPOI框架较为常见，适用于没有使用过POI并希望快速操作Excel的入门项目，在中大型项目中并不推荐使用(为了保证知识体系的完整性，把EasyPOI也加了进来)。本文主要介绍SpringBoot集成EasyPOI实现Excel的导入，导出和填充模板等功能。)
- [SpringBoot集成文件 - 集成POI之Word导出]
  - (前文我们介绍了通过ApachePOI导出excel，而ApachePOI包含是操作OfficeOpenXML（OOXML）标准和微软的OLE2复合文档格式（OLE2）的JavaAPI。所以也是可以通过POI来导出word的。本文主要介绍通过SpringBoot集成POI工具实现Word的导出功能。)
- [SpringBoot集成文件 - 集成POI-tl之基于模板的Word导出]
  - (前文我们介绍了通过ApachePOI通过来导出word的例子；那如果是word模板方式，有没有开源库通过模板方式导出word呢？poi-tl是一个基于ApachePOI的Word模板引擎，也是一个免费开源的Java类库，你可以非常方便的加入到你的项目中，并且拥有着让人喜悦的特性。本文主要介绍通过SpringBoot集成poi-tl实现模板方式的Word导出功能。)
- [SpringBoot集成文件 - 集成itextpdf之导出PDF]
  - (除了处理word,excel等文件外，最为常见的就是PDF的导出了。在java技术栈中，PDF创建和操作最为常用的itext了，但是使用itext一定要了解其版本历史和License问题，在早前版本使用的是MPL和LGPL双许可协议，在5.x以上版本中使用的是AGPLv3(这个协议意味着，只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的)。本文主要介绍通过SpringBoot集成itextpdf实现PDF导出功能。)
- [SpringBoot + 集成PDFBox之PDF操作]()
- [SpringBoot + 集成OpenOffice之文档在线预览]
  - (https://blog.csdn.net/shipfei_csdn/article/details/105141487)
- [SpringBoot + 集成LibreOffice之文档在线预览]
- [SpringBoot + 集成kkfileview之文档在线预览]
  - (https://kkfileview.keking.cn)

## SpringBoot集成消息队列(ActiveMQ,RabbitMQ,ZeroMQ,Kafka)

- [SpringBoot + ActiveMQ]
- [SpringBoot + RabbitMQ]
- [SpringBoot + ZeroMQ]
- [SpringBoot + Kafka]

## SpringBoot集成通知(Email,短信,钉钉,微信)

- [SpringBoot + 邮件]
- [SpringBoot + 钉钉]
- [SpringBoot + 微信]
- [SpringBoot + 短信]

## SpringBoot集成文件系统(minIO,aliyun,tencentCloud,FastDFS)

- [SpringBoot + MinIO]
- [SpringBoot + aliyun]
- [SpringBoot + TecentCloud]
- [SpringBoot + FastDFS]

## SpringBoot集成工作流引擎(activi,jBPM,flowable)

- [SpringBoot + activi]
- [SpringBoot + jBPM]
- [SpringBoot + flowable]

## SpringBoot集成其它功能(支付,OPC-UA,JavaFX2)

除了上述的常见的业务上的集成功能外，还有哪些功能或者应用呢？

- [SpringBoot集成JavaFX2 - JavaFX 2.0应用]
  - (很多人对Java开发native程序第一反应还停留在暗灰色单一风格的JavaGUI界面，开发方式还停留在AWT或者Swing。本文主要基于SpringBoot和JavaFX开发一个Demo给你展示JavaNative应用可以做到什么样的程度。当然JavaFX2.0没有流行起来也是有原因的，而且目前native的选择很多，前端是个框架都会搞个native...)
- [SpringBoot + 支付]
- [SpringBoot + OPC-UA]

## SpringBoot应用部署(jar,war,linux,docker,docker-compose)

那么如何将SpringBoot应用打包并部署呢？打包主要有jar，war两种方式；部署包含在linux或者windows上制作成服务，以及制作成docker进行部署；此外也可以结合CI/CD环境进行部署。

- [SpringBoot应用部署 - 打包成jar部署]
  - (我们知道spring-boot-starter-web默认已经集成了web容器（tomcat)，在部署前只需要将项目打包成jar即可。那么怎么将springbootweb项目打包成jar呢？本文主要介绍常见的几种方式。)
- [SpringBoot应用部署 - 使用第三方JAR包]
  - (在项目中我们经常需要使用第三方的Jar，比如某些SDK，这些SDK没有直接发布到公开的maven仓库中，这种情况下如何使用这些三方JAR呢？本文提供最常用的两种方式。)
- [SpringBoot应用部署 - 打包成war部署]
  - (前文我们知道SpringBootweb项目默认打包成jar部署是非常方便的，那什么样的场景下还会打包成war呢？本文主要介绍SpringBoot应用打包成war包的示例。)
- [SpringBoot应用部署 - 替换tomcat为Jetty容器]
  - (前文我们知道spring-boot-starter-web默认集成tomcatservlet容器(被使用广泛）；而Jetty也是servlet容器，它具有易用性，轻量级，可拓展性等，有些场景（Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境）下会使用jetty容器。本文主要介绍SpringBoot使用Jetty容器。)
- [SpringBoot应用部署 - 替换tomcat为Undertow容器]
  - (前文我们了解到Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境；那么从性能的角度来看，更为优秀的servlet容器是Undertow。本文将介绍Undertow，以及SpringBoot集成Undertow的示例。)
- [SpringBoot应用部署 - 在linux环境将jar制作成service]
  - (前文我们将SpringBoot应用打包成jar，那么如何将jar封装成service呢？本文主要介绍将SpringBoot应用部署成linux的service。)
- [SpringBoot应用部署 - 在windows环境将jar制作成service]
  - (前文我们将SpringBoot应用打包成jar并在Linux上封装成service，那么在Windows环境下如何封装呢？本文主要介绍将SpringBoot应用部署成Windows的service。)
- [SpringBoot应用部署 - docker镜像打包,运行和管理]
  - (随着软虚拟化docker的流行，基于docker的devops技术栈也开始流行。本文主要介绍通过docker-maven-plugin将springboot应用打包成docker镜像，通过Docker桌面化管理工具或者IdeaDocker插件进行管理。)
- [SpringBoot应用部署 - 使用DockerCompose对容器编排管理]
  - (如果docker容器是相互依赖的（比如SpringBoot容器依赖另外一个MySQL的数据库容器），那就需要对容器进行编排。本文主要介绍基于DockerCompose的简单容器化编排SpringBoot应用。)

## SpringBoot集成监控(actuator,springboot-admin,ELK,Grafana,APM)

SpringBoot集成监控，包括SpringBoot自带的actuator，基于actuator的可视化工具springbootadmin。监控的日志体系技术栈ELK，监控状态和指标收集prometheus+Grafana，基于Agent的APM性能监控等。

- SpringBoot集成监控 - 集成actuator监控工具
  - 当SpringBoot的应用部署到生产环境中后，如何监控和管理呢？比如审计日志，监控状态，指标收集等。为了解决这个问题，SpringBoot提供了Actuator。本文主要介绍SpringBootActuator及实现案例。
- SpringBoot集成监控 - 集成springbootadmin监控工具
  - 上文中展示了SpringBoot提供了Actuator对应用进行监控和管理，而SpringBootAdmin能够将Actuator中的信息进行界面化的展示，也可以监控所有SpringBoot应用的健康状况，提供实时警报功能。本文主要介绍springbootadmin以及SpringBoot和springbootadmin的集成。
- SpringBoot集成监控 - 日志收集(ELK)
- SpringBoot集成监控 - 状态监控(Prometheus+Grafana)
- SpringBoot集成监控 - 性能监控(APMAgent)

## SpringBoot进阶(starter,自动装配原理,各类机制等)
- SpringBoot进阶 - 实现自动装配原理
- SpringBoot进阶 - 自定义starter
  - (如何将自己的模块封装成starter，并给其它springBoot项目使用呢？本文主要介绍在Springboot封装一个自定义的Starter的一个Demo，从创建一个模块->封装starter->使用)
- SpringBoot进阶 - 嵌入web容器Tomcat原理
- SpringBoot进阶 - 健康检查Actuator原理
# 十七、▶SpringBoot入门 - SpringBoot简介
> 为什么有了SpringFramework还会诞生SpringBoot？简单而言，因为虽然Spring的组件代码是轻量级的，但它的配置却是重量级的；所以SpringBoot的设计策略是通过**开箱即用和约定大于配置**来解决配置重的问题的。
## 17.1 SpringFramework解决了什么问题，没有解决什么问题？
> 需要概括性的理解 SpringFramework解决了什么问题，没有解决什么问题？
### 17.1.1 SpringFramework解决了什么问题？
Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的EnterpriseJavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。
- 1.使用Spring的IOC容器,将对象之间的依赖关系交给Spring,降低组件之间的耦合性,让我们更专注于应用逻辑 
- 2.可以提供众多服务,事务管理,WS等。 
- 3.AOP的很好支持,方便面向切面编程。 
- 4.对主流的框架提供了很好的集成支持,如Hibernate,Struts2,JPA等 
- 5.Spring DI机制降低了业务对象替换的复杂性。 
- 6.Spring属于低侵入,代码污染极低。 7
- .Spring的高度可开放性,并不强制依赖于Spring,开发者可以自由选择Spring部分或全部
### 17.1.2 SpringFramework没有解决了什么问题？
虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。

所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。

除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。
- 1.jsp中要写很多代码、控制器过于灵活,缺少一个公用控制器 
- 2.Spring不支持分布式,这也是EJB仍然在用的原因之一。
## 17.2 SringBoot的概述
### 17.2.1 SpringBoot解决上述Spring的缺点
SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。
### 17.2.2 SpringBoot的特点
- 为基于Spring的开发提供更快的入门体验
- 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求
- 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等

**SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式**

### 17.2.3SpringBoot的核心功能
- `起步依赖` 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。
- `自动配置` Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。
# 十八、SpringBoot入门 - SpringBoot HelloWorld
## 18.1 创建 SpringBoot Web 应用
> 为快速进行开发，推荐你使用IDEA这类开发工具，它将大大提升你学习和开发的效率。
- 选择 Spring Initialize

Spring提供的初始化项目的工具
![97.springboot-helloworld-1.png](../../assets/images/04-主流框架/spring/97.springboot-helloworld-1.png)

当然你可以在 https://start.spring.io/ 中初始化你项目工程
![98.springboot-hello-world-6.png](../../assets/images/04-主流框架/spring/98.springboot-hello-world-6.png)
- 填写 GAV三元组
    - Group: 是公司或者组织的名称，是一种命名空间的概念，比如网站，那么group可以是tech.pdai
    - Artifat: 当前项目的唯一标识
    - Version: 项目的版本号，一般xx-SNAPSHOT表示非稳定版
![99.springboot-helloworld-2.png](../../assets/images/04-主流框架/spring/99.springboot-helloworld-2.png)
- 选择初始化模块

Spring Initialize可以帮助你选择常见的功能模块的starter包
![100.springboot-helloworld-3.png](../../assets/images/04-主流框架/spring/100.springboot-helloworld-3.png)

- 项目名

最后我们输入我们项目的名称，既可以初始化项目
![101.springboot-helloworld-4.png](../../assets/images/04-主流框架/spring/101.springboot-helloworld-4.png)
## 18.2 初始化后内容
- README.md

README中可以添加这个项目的介绍，它将显示在github/gitlab/gitee等仓库托管中项目介绍的首页。
![102.springboot-helloworld-5.png](../../assets/images/04-主流框架/spring/102.springboot-helloworld-5.png)
- .gitignore

gitignore是git仓库，你可以将不需要提交到代码仓库的文件添加到这个文件（比如程序编译后生成的运行目录target等)，默认如下
```json
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**
!**/src/test/**

## STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

## IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

## NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/

## VS Code ###
.vscode/
```
- pom.xml

在Maven包管理pom.xml中添加依赖包
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>tech.pdai</groupId>
    <artifactId>101-springboot-demo-helloworld</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```
## 18.3 给你的第一个应用添加包和代码
我们添加如下的代码，启动即可启动一个WEB服务，通过浏览器访问/hello, 并返回Hello world.
- 添加代码
```java
package tech.pdai.springboot.helloworld;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author pdai
 */
@SpringBootApplication
@RestController
public class SpringBootHelloWorldApplication {

    /**
     * main interface.
     *
     * @param args args
     */
    public static void main(String[] args) {
        SpringApplication.run(SpringBootHelloWorldApplication.class, args);
    }

    /**
     * hello world.
     *
     * @return hello
     */
    @GetMapping("/hello")
    public ResponseEntity<String> hello() {
        return new ResponseEntity<>("hello world", HttpStatus.OK);
    }

}
```
## 18.4 运行你的第一个程序
点击SpringBootHelloWorldApplication入口的绿色按钮，运行程序
![103.springboot-hello-world-1.png](../../assets/images/04-主流框架/spring/103.springboot-hello-world-1.png)

运行后，你将看到如下的信息：表明我们启动程序成功（启动了一个内嵌的Tomcat容器，服务端口在8080）
![104.springboot-hello-world-2.png](../../assets/images/04-主流框架/spring/104.springboot-hello-world-2.png)

这时候我们便可以通过浏览器访问服务
![105.springboot-hello-world-3.png](../../assets/images/04-主流框架/spring/105.springboot-hello-world-3.png)
## 18.5 一些思考
> 到此，你会发现一个简单的web程序居然完成了。这里你需要一些思考：
### 18.5.1 为什么我们添加一个starter-web模块便可以了呢？

我们安装Maven Helper的插件，用来查看spring-boot-starter-web模块的依赖
![106.springboot-hello-world-7.png](../../assets/images/04-主流框架/spring/106.springboot-hello-world-7.png)

我们看下这个模块的依赖，你便能初步窥探出模块支撑
![107.springboot-hello-world-8.png](../../assets/images/04-主流框架/spring/107.springboot-hello-world-8.png)
### 18.5.2 我们如何更改更多Server的配置呢？比如Tomcat Server
为什么Tomcat默认端口是8080？ 如前文所述，SpringBoot最强大的地方在于约定大于配置，只要你引入某个模块的xx-start包，它将自动注入配置，提供了这个模块的功能；比如这里我们在POM中添加了如下的包
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```
它内嵌了Tomcat并且提供了默认的配置，比如默认端口是8080.

我们可以在application.properties或者application.yml中配置
![108.springboot-hello-world-4.png](../../assets/images/04-主流框架/spring/108.springboot-hello-world-4.png)

特别的，如果你添加了如下包
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```
主要功能：
1. **自动生成配置元数据文件**  
   - 当你在项目中定义自定义配置属性（例如使用 `@ConfigurationProperties` 注解）时，该处理器会在编译阶段自动生成一个 `META-INF/spring-configuration-metadata.json` 文件。
   - 这个文件包含了配置属性的详细信息，如属性名、类型、描述、默认值等。

2. **增强 IDE 支持**  
   - 生成的元数据文件使得 IDE（如 IntelliJ IDEA 或 Eclipse）能够提供智能提示、自动补全和验证功能。例如，在 `application.properties` 或 `application.yml` 中输入配置时，IDE 会显示可用的属性列表和文档，减少拼写错误和配置失误。

3. **支持自定义配置**  
   - 如果你在项目中创建了自定义的配置类（例如通过 `@ConfigurationProperties` 定义应用参数），但没有此依赖，IDE 可能无法识别这些属性。添加后，即可享受与 Spring Boot 内置配置相同的智能提示。
![109.springboot-hello-world-5.png](../../assets/images/04-主流框架/spring/109.springboot-hello-world-5.png)
### 18.5.3 SpringBoot还提供了哪些starter模块呢？
Spring Boot 推荐的基础 POM 文件

| 名称 | 说明 |
|------|------|
| spring-boot-starter | 核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持。 |
| spring-boot-starter-amqp | 通过 spring-rabbit 支持 AMQP。 |
| spring-boot-starter-aop | 包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。 |
| spring-boot-starter-batch | 支持 Spring Batch，包含 HSQLDB。 |
| spring-boot-starter-data-jpa | 包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 |
| spring-boot-starter-data-mongodb | 包含 spring-data-mongodb 来支持 MongoDB。 |
| spring-boot-starter-data-rest | 通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。 |
| spring-boot-starter-jdbc | 支持使用 JDBC 访问数据库。 |
| spring-boot-starter-security | 包含 spring-security。 |
| spring-boot-starter-test | 包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 |
| spring-boot-starter-velocity | 支持使用 Velocity 作为模板引擎。 |
| spring-boot-starter-web | 支持 Web 应用开发，包含 Tomcat 和 spring-mvc。 |
| spring-boot-starter-websocket | 支持使用 Tomcat 开发 WebSocket 应用。 |
| spring-boot-starter-ws | 支持 Spring Web Services。 |
| spring-boot-starter-actuator | 添加适用于生产环境的功能，如性能指标和监测等功能。 |
| spring-boot-starter-remote-shell | 添加远程 SSH 支持。 |
| spring-boot-starter-jetty | 使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 |
| spring-boot-starter-log4j | 添加 Log4j 的支持。 |
| spring-boot-starter-logging | 使用 Spring Boot 默认的日志框架 Logback。 |
| spring-boot-starter-tomcat | 使用 Spring Boot 默认的 Tomcat 作为应用服务器。 |

所有这些 POM 依赖的好处在于为开发 Spring 应用提供了一个良好的基础。Spring Boot 所选择的第三方库是经过考虑的，是比较适合产品开发的选择。但是 Spring Boot 也提供了不同的选项，比如日志框架可以用 Logback 或 Log4j，应用服务器可以用 Tomcat 或 Jetty。
# 十九、SpringBoot入门 - 对Hello world进行MVC分层

## 19.1 经典的MVC三层架构

三层架构（3-tier application）通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。

1. **表现层（UI）**：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。
2. **业务逻辑层（BLL）**：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。
3. **数据访问层（DAL）**：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。
![110.spring-framework-helloworld-2.png](../../assets/images/04-主流框架/spring/110.spring-framework-helloworld-2.png)
## 19.2 用Package解耦三层结构

我们这里设计一个常见的用户增删查改项目，通常来说对应的包结构如下：
![111.springboot-hello-mvc-1.png](../../assets/images/04-主流框架/spring/111.springboot-hello-mvc-1.png)
### 19.2.1 controller表示层

```java
package tech.pdai.springboot.helloworld.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.helloworld.entity.User;
import tech.pdai.springboot.helloworld.service.UserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * http://localhost:8080/user/add .
     *
     * @param user user param
     * @return user
     */
    @RequestMapping("add")
    public User add(User user) {
        userService.addUser(user);
        return user;
    }

    /**
     * http://localhost:8080/user/list .
     *
     * @return user list
     */
    @GetMapping("list")
    public List<User> list() {
        return userService.list();
    }
}
```

### 19.2.2 service业务逻辑层

```java
package tech.pdai.springboot.helloworld.service.impl;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.helloworld.dao.UserRepository;
import tech.pdai.springboot.helloworld.entity.User;
import tech.pdai.springboot.helloworld.service.UserService;

/**
 * user service impl.
 *
 * @author pdai
 */
@Service
public class UserServiceImpl implements UserService {

    /**
     * user dao.
     */
    @Autowired
    private UserRepository userDao;

    /**
     * @param user user
     */
    @Override
    public void addUser(User user) {
        userDao.save(user);
    }

    /**
     * @return user list
     */
    @Override
    public List<User> list() {
        return userDao.findAll();
    }

}
```

### 19.2.3 dao数据访问层（数据放在内存中）

```java
package tech.pdai.springboot.helloworld.dao;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.helloworld.entity.User;

/**
 * @author pdai
 */
@Repository
public class UserRepository {

    private List<User> userDemoList = new ArrayList<>();

    public void save(User user) {
        userDemoList.add(user);
    }

    public List<User> findAll() {
        return userDemoList;
    }
}
```

### 19.2.4 entity模型实体层

```java
package tech.pdai.springboot.helloworld.entity;

/**
 * User entity.
 *
 * @author pdai
 */
public class User {

    /**
     * user id
     */
    private int userId;

    /**
     * username.
     */
    private String userName;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}
```

## 19.3 运行测试

- **添加用户**：访问 `http://localhost:8080/user/add`，传入用户参数。
![112.springboot-hello-mvc-2.png](../../assets/images/04-主流框架/spring/112.springboot-hello-mvc-2.png)
- **查询用户列表**：访问 `http://localhost:8080/user/list`，返回用户列表。
![113.springboot-hello-mvc-3.png](../../assets/images/04-主流框架/spring/113.springboot-hello-mvc-3.png)
# 二十、pringBoot入门 - 添加内存数据库H2
## 20.1 什么是H2内存数据库
> H2是一个用Java开发的嵌入式数据库，它本身只是一个类库，可以直接嵌入到应用项目中。
<a href ='https://www.h2database.com/html/main.html'>官网</a>

- 有哪些用途？
  - H2最大的用途在于可以同应用程序打包在一起发布，这样可以非常方便地存储少量结构化数据。
  - 它的另一个用途是用于单元测试。启动速度快，而且可以关闭持久化功能，每一个用例执行完随即还原到初始状态。
  - H2的第三个用处是作为缓存，作为NoSQL的一个补充。当某些场景下数据模型必须为关系型，可以拿它当Memcached使，作为后端MySQL/Oracle的一个缓冲层，缓存一些不经常变化但需要频繁访问的数据，比如字典表、权限表。不过这样系统架构就会比较复杂了。
- H2的产品优势?
  - 纯Java编写，不受平台的限制；
  - 只有一个jar文件，适合作为嵌入式数据库使用；
  - h2提供了一个十分方便的web控制台用于操作和管理数据库内容；
  - 功能完整，支持标准SQL和JDBC。麻雀虽小五脏俱全；
  - 支持内嵌模式、服务器模式和集群。
## 20.2 什么是JPA，和JDBC是什么关系
> 什么是JDBC, ORM, JPA? 之间的关系是什么？
- 什么是JDBC

JDBC（JavaDataBase Connectivity）就是Java数据库连接，说白了就是用Java语言来操作数据库。原来我们操作数据库是在控制台使用SQL语句来操作数据库，JDBC是用Java语言向数据库发送SQL语句。
![114.project-b-4.png](../../assets/images/04-主流框架/spring/114.project-b-4.png)
- 什么是ORM

对象关系映射（Object Relational Mapping，简称ORM）， 简单的说，**ORM是通过使用描述对象和数据库之间映射的元数据，将java程序中的对象自动持久化到关系数据库中。**本质上就是将数据从一种形式转换到另外一种形式，具体如下：
![115.project-b-3.png](../../assets/images/04-主流框架/spring/115.project-b-3.png)

具体映射：
1. 数据库的表（table） --> 类（class）
2. 记录（record，行数据）--> 对象（object）
3. 字段（field）--> 对象的属性（attribute）
- 什么是JPA

JPA是Spring提供的一种ORM，首先让我们回顾下Spring runtime体系：
![116.mongo-x-usage-spring-4.png](../../assets/images/04-主流框架/spring/116.mongo-x-usage-spring-4.png)

Spring Data是基于Spring runtime体系的，JPA 属于Spring Data, 和JDBC的关系如下：
![117.mongo-x-usage-spring-5.png](../../assets/images/04-主流框架/spring/117.mongo-x-usage-spring-5.png)
## 20.3 案例
> 这里承接上文， 使用H2存放用户表，并通过JPA操作用户数据。
### 20.3.1 添加H2和JPA的依赖
```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

```
### 20.3.2 配置H2和JPA注入参数
```yml
spring:
  datasource:
    data: classpath:db/data.sql
    driverClassName: org.h2.Driver
    password: sa
    platform: h2
    schema: classpath:db/schema.sql
    url: jdbc:h2:mem:dbtest
    username: sa
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
```
其中资源下还需要配置数据库的表结构schema.sql
```sql
create table if not exists tb_user (
USER_ID int not null primary key auto_increment,
USER_NAME varchar(100)
);
```
以及数据文件 data.sql, 默认插入一条‘赵一’的数据
```sql
INSERT INTO tb_user (USER_ID,USER_NAME) VALUES(1,'赵一');
```
### 20.3.3 实体关联表
给User添加@Entity注解，和@Table注解
```java
package tech.pdai.springboot.h2.entity;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "tb_user")
public class User {

    @Id
    private int userId;
    private String userName;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}
```
### 20.3.4 Dao继承JpaRepository
```java
package tech.pdai.springboot.h2.dao;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import tech.pdai.springboot.h2.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {

}
```
(其它service,App启动类等代码和前文一致)

### 20.3.5 运行程序
![118.springboot-hello-mvc-4.png](../../assets/images/04-主流框架/spring/118.springboot-hello-mvc-4.png)
### 20.3.6 H2数据库通常如何使用？
- 嵌入式模式 （上文例子）

在嵌入式模式下，应用程序使用JDBC从同一JVM中打开数据库。这是最快也是最容易的连接方式。缺点是数据库可能只在任何时候在一个虚拟机（和类加载器）中打开。与所有模式一样，支持持久性和内存数据库。对并发打开数据库的数量或打开连接的数量没有限制。
![119.springboot-hello-h2-2.png](../../assets/images/04-主流框架/spring/119.springboot-hello-h2-2.png)
- 服务器模式

当使用服务器模式（有时称为远程模式或客户机/服务器模式）时，应用程序使用 JDBC 或 ODBC API 远程打开数据库。服务器需要在同一台或另一台虚拟机上启动，或者在另一台计算机上启动。许多应用程序可以通过连接到这个服务器同时连接到同一个数据库。在内部，服务器进程在嵌入式模式下打开数据库。

服务器模式比嵌入式模式慢，因为所有数据都通过TCP/IP传输。与所有模式一样，支持持久性和内存数据库。对每个服务器并发打开的数据库数量或打开连接的数量没有限制。
![120.springboot-hello-h2-3.png](../../assets/images/04-主流框架/spring/120.springboot-hello-h2-3.png)
- 混合模式

混合模式是嵌入式和服务器模式的结合。连接到数据库的第一个应用程序在嵌入式模式下运行，但也启动服务器，以便其他应用程序（在不同进程或虚拟机中运行）可以同时访问相同的数据。本地连接的速度与数据库在嵌入式模式中的使用速度一样快，而远程连接速度稍慢。

服务器可以从应用程序内（使用服务器API）启动或停止，或自动（自动混合模式）。当使用自动混合模式时，所有想要连接到数据库的客户端（无论是本地连接还是远程连接）都可以使用完全相同的数据库URL来实现
![121.springboot-hello-h2-4.png](../../assets/images/04-主流框架/spring/121.springboot-hello-h2-4.png)
以上不同的连接方式对应不同的 JDBC URL，可以参考如下附录表格中的连接格式。
# 二十一、SpringBoot入门 - 定制自己的Banner
## 21.1 什么是Banner
我们在启动Spring Boot程序时，有如下Banner信息：
![122.springboot-hello-banner-1.png](../../assets/images/04-主流框架/spring/122.springboot-hello-banner-1.png)

那么如何自定义成自己项目的名称呢？

## 21.2 如何更改Banner
> 更改Banner有如下几种方式：
- banner.txt配置（最常用）

在application.yml中添加配置
```yml
spring:
  banner:
    charset: UTF-8
    location: classpath:banner.txt
```
在resource下创建banner.txt，内容自定义：
```txt
----welcome----

---------------
```
- SpringApplication启动时设置参数
```java
SpringApplication application = new SpringApplication(App.class);
/**
* Banner.Mode.OFF:关闭;
* Banner.Mode.CONSOLE:控制台输出，默认方式;
* Banner.Mode.LOG:日志输出方式;
*/
application.setBannerMode(Banner.Mode.OFF); // here
application.run(args);
```
SpringApplication还可以设置自定义的Banner的接口类
![123.springboot-hello-banner-6.png](../../assets/images/04-主流框架/spring/123.springboot-hello-banner-6.png)

## 21.3 文字Banner的设计
> 如何设计上面的文字呢？
### 21.3.1 一些设计Banner的网站
可以通过这个网站进行设计：<a href='https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type+Something+&x=none&v=4&h=4&w=80&we=false'>patorjk Banner</a>
### 21.3.2 IDEA中Banner的插件
IDEA中也有插件，不过没有预览功能
![124.springboot-hello-banner-5.png](../../assets/images/04-主流框架/spring/124.springboot-hello-banner-5.png)
### 21.3.3 其它工具
- http://www.network-science.de/ascii/
- http://www.degraeve.com/img2txt.php
- http://www.bootschool.net/ascii
## 21.4 Banner中其它配置信息
> 除了文件信息，还有哪些信息可以配置呢？比如Spring默认还带有SpringBoot当前的版本号信息。

在banner.txt中，还可以进行一些设置：
```txt
# springboot的版本号 
${spring-boot.version}             
 
# springboot的版本号前面加v后上括号 
${spring-boot.formatted-version}

# MANIFEST.MF文件中的版本号 
${application.version}              
 
# MANIFEST.MF文件的版本号前面加v后上括号 
${application.formatted-version}

# MANIFEST.MF文件中的程序名称
${application.title}

# ANSI样色/样式等
${Ansi.NAME} (or ${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME})
```
简单的测试如下（`注意必须打包出Jar, 才会生成resources/META-INF/MANIFEST.MF`）：
![125.springboot-hello-banner-7.png](../../assets/images/04-主流框架/spring/125.springboot-hello-banner-7.png)
## 21.5 动画Banner的设计
SpringBoot2是支持图片形式的Banner，
```yml
spring:
  main:
    banner-mode: console
    show-banner: true
  banner:
    charset: UTF-8
    image:
      margin: 0
      height: 10
      invert: false
      location: classpath:pdai.png
```
效果如下（需要选择合适的照片，不然效果不好, 所以这种方式很少使用），
![126.springboot-hello-banner-8.png](../../assets/images/04-主流框架/spring/126.springboot-hello-banner-8.png)

注意： 格式不能太大，不然会报错
```sh
org.springframework.boot.ImageBanner     : Image banner not printable: class path resource [banner.gif] (class java.lang.ArrayIndexOutOfBoundsException: '4096')
```
## 21.6 图片Banner是如何起作用的？
> 发现 Springboot 可以把图片转换成 ASCII 图案，那么它是怎么做的呢？以此为例，我们看下Spring 的Banner是如何生成的呢？
- 获取Banner 
  - 优先级是环境变量中的Image优先,格式在IMAGE_EXTENSION中
  - 然后才是banner.txt
  - 没有的话就用SpringBootBanner
- 如果是图片 
  - 获取图片Banner（属性配置等）
  - 转换成ascii

**获取banner**
```java
class SpringApplicationBannerPrinter {
    static final String BANNER_LOCATION_PROPERTY = "spring.banner.location";
    static final String BANNER_IMAGE_LOCATION_PROPERTY = "spring.banner.image.location";
    static final String DEFAULT_BANNER_LOCATION = "banner.txt";
    static final String[] IMAGE_EXTENSION = new String[]{"gif", "jpg", "png"};
    private static final Banner DEFAULT_BANNER = new SpringBootBanner(); // 默认的Spring Banner
    private final ResourceLoader resourceLoader;
    private final Banner fallbackBanner;

    // 获取Banner，优先级是环境变量中的Image优先,格式在IMAGE_EXTENSION中，然后才是banner.txt
    private Banner getBanner(Environment environment) {
        SpringApplicationBannerPrinter.Banners banners = new SpringApplicationBannerPrinter.Banners();
        banners.addIfNotNull(this.getImageBanner(environment));
        banners.addIfNotNull(this.getTextBanner(environment));
        if (banners.hasAtLeastOneBanner()) {
            return banners;
        } else {
            return this.fallbackBanner != null ? this.fallbackBanner : DEFAULT_BANNER;
        }
    }
```
**获取图片Banner**
```java
private Banner getImageBanner(Environment environment) {
    String location = environment.getProperty("spring.banner.image.location");
    if (StringUtils.hasLength(location)) {
        Resource resource = this.resourceLoader.getResource(location);
        return resource.exists() ? new ImageBanner(resource) : null;
    } else {
        String[] var3 = IMAGE_EXTENSION;
        int var4 = var3.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            String ext = var3[var5];
            Resource resource = this.resourceLoader.getResource("banner." + ext);
            if (resource.exists()) {
                return new ImageBanner(resource);
            }
        }

        return null;
    }
}
```
**获取图片的配置等**
```java
private void printBanner(Environment environment, PrintStream out) throws IOException {
    int width = (Integer)this.getProperty(environment, "width", Integer.class, 76);
    int height = (Integer)this.getProperty(environment, "height", Integer.class, 0);
    int margin = (Integer)this.getProperty(environment, "margin", Integer.class, 2);
    boolean invert = (Boolean)this.getProperty(environment, "invert", Boolean.class, false); // 图片的属性
    BitDepth bitDepth = this.getBitDepthProperty(environment);
    ImageBanner.PixelMode pixelMode = this.getPixelModeProperty(environment);
    ImageBanner.Frame[] frames = this.readFrames(width, height); // 读取图片的帧

    for(int i = 0; i < frames.length; ++i) {
        if (i > 0) {
            this.resetCursor(frames[i - 1].getImage(), out);
        }

        this.printBanner(frames[i].getImage(), margin, invert, bitDepth, pixelMode, out);
        this.sleep(frames[i].getDelayTime());
    }

}
```
**转换成ascii**
```java
private void printBanner(BufferedImage image, int margin, boolean invert, BitDepth bitDepth, ImageBanner.PixelMode pixelMode, PrintStream out) {
    AnsiElement background = invert ? AnsiBackground.BLACK : AnsiBackground.DEFAULT;
    out.print(AnsiOutput.encode(AnsiColor.DEFAULT));
    out.print(AnsiOutput.encode(background));
    out.println();
    out.println();
    AnsiElement lastColor = AnsiColor.DEFAULT;
    AnsiColors colors = new AnsiColors(bitDepth);

    for(int y = 0; y < image.getHeight(); ++y) {
        int x;
        for(x = 0; x < margin; ++x) {
            out.print(" ");
        }

        for(x = 0; x < image.getWidth(); ++x) {
            Color color = new Color(image.getRGB(x, y), false);
            AnsiElement ansiColor = colors.findClosest(color);
            if (ansiColor != lastColor) {
                out.print(AnsiOutput.encode(ansiColor));
                lastColor = ansiColor;
            }

            out.print(this.getAsciiPixel(color, invert, pixelMode)); // // 像素点转换成字符输出
        }

        out.println();
    }

    out.print(AnsiOutput.encode(AnsiColor.DEFAULT));
    out.print(AnsiOutput.encode(AnsiBackground.DEFAULT));
    out.println();
}
```
# 二十二、SpringBoot入门 - 添加Logback日志
> SpringBoot开发中如何选用日志框架呢？ 出于性能等原因，Logback 目前是springboot应用日志的标配； 当然有时候在生产环境中也会考虑和三方中间件采用统一处理方式。
## 22.1 日志框架的基础
在学习这块时需要一些日志框架的发展和基础，同时了解日志配置时考虑的因素。

### 22.1.1 关于日志框架（日志门面）
> Java日志库是最能体现Java库在进化中的渊源关系的，在理解时重点理解**日志框架本身和日志门面**，以及比较好的实践等。要关注其历史渊源和设计（比如桥接），而具体在使用时查询接口即可， 否则会陷入JUL(Java Util Log), JCL(Commons Logging), Log4j, SLF4J, Logback，Log4j2傻傻分不清楚的境地。
**下面详细介绍一下日志框架（日志门面）**
### 22.1.2 日志库简介
- 最重要的一点是 区分**日志系统**和**日志门面**;
- 其次是日志库的使用, 包含配置与API使用；配置侧重于日志系统的配置，API使用侧重于日志门面；
- 最后是选型，改造和最佳实践等
#### 22.1.2.1 日志库之日志系统
##### java.util.logging (JUL)
JDK1.4 开始，通过 java.util.logging 提供日志功能。虽然是官方自带的log lib，JUL的使用确不广泛。主要原因:
- JUL从JDK1.4 才开始加入(2002年)，当时各种第三方log lib已经被广泛使用了
- JUL早期存在性能问题，到JDK1.5上才有了不错的进步，但现在和Logback/Log4j2相比还是有所不如
- JUL的功能不如Logback/Log4j2等完善，比如Output Handler就没有Logback/Log4j2的丰富，有时候需要自己来继承定制，又比如默认没有从ClassPath里加载配置文件的功能
##### Log4j
Log4j 是 apache 的一个开源项目，创始人 Ceki Gulcu。Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。

Log4j 中有三个主要组成部分：
- loggers - 负责捕获记录信息。
- appenders - 负责发布日志信息，以不同的首选目的地。
- layouts - 负责格式化不同风格的日志信息。

官网地址：http://logging.apache.org/log4j/2.x/

Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。

##### Logback
Logback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日志组件，是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。

logback 当前分成三个模块：logback-core、logback-classic 和 logback-access。

- logback-core - 是其它两个模块的基础模块。
- logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j 或 JDK14 Logging。（注：SLF4J是一个日志门面（抽象层），而Logback是一个具体的日志实现。）
- logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能。

官网地址: http://logback.qos.ch/

##### Log4j2
维护 Log4j 的人为了性能又搞出了 Log4j2。

Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。

Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。

官网地址: http://logging.apache.org/log4j/2.x/
#### 22.1.2.2 Log4j vs Logback vs Log4j2
> 从性能上Log4J2要强，但从生态上Logback+SLF4J优先。
##### 初步对比
> logback和log4j2都宣称自己是log4j的后代，一个是出于同一个作者，另一个则是在名字上根正苗红。

撇开血统不谈，比较一下log4j2和logback：

- log4j2比logback更新：log4j2的GA版在2014年底才推出，比logback晚了好几年，这期间log4j2确实吸收了slf4j和logback的一些优点（比如日志模板），同时应用了不少的新技术
- 由于采用了更先进的锁机制和LMAX Disruptor库，log4j2的性能优于logback，特别是在多线程环境下和使用异步日志的环境下
- 二者都支持Filter（应该说是log4j2借鉴了logback的Filter），能够实现灵活的日志记录规则（例如仅对一部分用户记录debug级别的日志）
- 二者都支持对配置文件的动态更新
- 二者都能够适配slf4j，logback与slf4j的适配应该会更好一些，毕竟省掉了一层适配库
- logback能够自动压缩/删除旧日志
- logback提供了对日志的HTTP访问功能
- log4j2实现了“无垃圾”和“低垃圾”模式。简单地说，log4j2在记录日志时，能够重用对象（如String等），尽可能避免实例化新的临时对象，减少因日志记录产生的垃圾对象，减少垃圾回收带来的性能下降
- log4j2和logback各有长处，总体来说，如果对性能要求比较高的话，log4j2相对还是较优的选择。
##### 性能对比
> 附上log4j2与logback性能对比的benchmark，这份benchmark是Apache Logging出的，有多大水分不知道，仅供参考

同步写文件日志的benchmark：
![127.dev-package-log-1.png](../../assets/images/04-主流框架/spring/127.dev-package-log-1.png)

异步写日志的benchmark：
![128.dev-package-log-2.png](../../assets/images/04-主流框架/spring/128.dev-package-log-2.png)

当然，这些benchmark都是在日志Pattern中不包含Location信息（如日志代码行号 ，调用者信息，Class名/源码文件名等）时测定的，如果输出Location信息的话，性能谁也拯救不了：
![129.dev-package-log-3.png](../../assets/images/04-主流框架/spring/129.dev-package-log-3.png)
#### 22.1.2.3 日志库之日志门面
##### common-logging
> common-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。

common-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。

官网地址: http://commons.apache.org/proper/commons-logging/

##### slf4j
> 全称为 Simple Logging Facade for Java，即 java 简单日志门面。

什么，作者又是 Ceki Gulcu！这位大神写了 Log4j、Logback 和 slf4j，专注日志组件开发五百年，一直只能超越自己。

类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。
![130.dev-package-log-6.png](../../assets/images/04-主流框架/spring/130.dev-package-log-6.png)
##### common-logging vs slf4j
> slf4j 库类似于 Apache Common-Logging。但是，他在编译时静态绑定真正的日志库。这点似乎很麻烦，其实也不过是导入桥接 jar 包而已。
- Common-Logging：运行时动态发现日志实现
- SLF4J：编译时静态绑定日志实现（通过引入相应的桥接jar包）

slf4j 一大亮点是提供了更方便的日志记录方式：

不需要使用logger.isDebugEnabled()来解决日志因为字符拼接产生的性能问题。slf4j 的方式是使用{}作为字符串替换符，形式如下：
```java
logger.debug("id: {}, name: {} ", id, name);
```
Common-Logging写法是：
```java
logger.debug("id: " + id + ", name: " + name);
```
**在这种写法中：**
- 无论DEBUG级别是否启用，**字符串拼接都会先执行**
- 然后才在`debug()`方法内部检查级别并决定是否记录
- 即使最终不记录日志，字符串拼接的开销也已经产生了

为了避免上面的情况，Common-Logging需要修改写法才能优化拼接-较为麻烦
```java
// 这是优化后的写法 - 性能良好
if (logger.isDebugEnabled()) {
    logger.debug("id: " + id + ", name: " + name);
}
```
slf4j解决方案：

```java
// 使用参数化日志（推荐）
logger.debug("id: {}, name: {}", id, name);
```

slf4j支持参数化日志，只有在需要记录时才会进行字符串拼接，既简洁又高效。
#### 22.1.2.4 日志库使用方案
使用日志解决方案基本可分为三步：
- 引入 jar 包
- 配置
- 使用 API

常见的各种日志解决方案的第 2 步和第 3 步基本一样，实施上的差别主要在第 1 步，也就是使用不同的库。

#### 22.1.2.5 日志库jar包
这里首选推荐使用 slf4j + logback 的组合。

如果你习惯了 common-logging，可以选择 common-logging+log4j。

强烈建议不要直接使用日志实现组件(logback、log4j、java.util.logging)，理由前面也说过，就是无法灵活替换日志库。

还有一种情况：你的老项目使用了 common-logging，或是直接使用日志实现组件。如果修改老的代码，工作量太大，需要兼容处理。在下文，都将看到各种应对方法。

注：据我所知，当前仍没有方法可以将 slf4j 桥接到 common-logging。如果我孤陋寡闻了，请不吝赐教。
##### slf4j 直接绑定日志组件
- slf4j + logback

添加依赖到 pom.xml 中即可。

logback-classic-1.0.13.jar 会自动将 slf4j-api-1.7.21.jar 和 logback-core-1.0.13.jar 也添加到你的项目中。
```xml
<dependency>
  <groupId>ch.qos.logback</groupId>
  <artifactId>logback-classic</artifactId>
  <version>1.0.13</version>
</dependency>
```
- slf4j + log4j

添加依赖到 pom.xml 中即可。

slf4j-log4j12-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 和 log4j-1.2.17.jar 也添加到你的项目中。
```xml
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
  <version>1.7.21</version>
</dependency>
```
- slf4j + java.util.logging

添加依赖到 pom.xml 中即可。

slf4j-jdk14-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 也添加到你的项目中。
```xml
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-jdk14</artifactId>
  <version>1.7.21</version>
</dependency>
```
##### slf4j 兼容非 slf4j 日志组件
在介绍解决方案前，先提一个概念——桥接
- 什么是桥接呢

假如你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：
![131.dev-package-log-5.png](../../assets/images/04-主流框架/spring/131.dev-package-log-5.png)

从图中应该可以看出，无论你的老项目中使用的是 common-logging 或是直接使用 log4j、java.util.logging，都可以使用对应的桥接 jar 包来解决兼容问题。
- slf4j 兼容 common-logging
```xml
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>jcl-over-slf4j</artifactId>
  <version>1.7.12</version>
</dependency>
```
- slf4j 兼容 log4j
```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>log4j-over-slf4j</artifactId>
    <version>1.7.12</version>
</dependency>
```
- slf4j 兼容 java.util.logging
```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jul-to-slf4j</artifactId>
    <version>1.7.12</version>
</dependency>
```
- spring 集成 slf4j

做 java web 开发，基本离不开 spring 框架。很遗憾，spring 使用的日志解决方案是 common-logging + log4j。

所以，你需要一个桥接 jar 包：logback-ext-spring。
```xml
<dependency>
  <groupId>ch.qos.logback</groupId>
  <artifactId>logback-classic</artifactId>
  <version>1.1.3</version>
</dependency>
<dependency>
  <groupId>org.logback-extensions</groupId>
  <artifactId>logback-ext-spring</artifactId>
  <version>0.1.2</version>
</dependency>
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>jcl-over-slf4j</artifactId>
  <version>1.7.12</version>
</dependency>
```
这里有一点需要注意，对于日志门面的话jcl 和slf4j之间互相转化桥接就好了，为什么还会对特定的日志系统例如log4j专门做一个桥接包呢？这是因为有些项目可能并没有用jcl门面接口而是直接用了log4j的原生接口。
- 1. 首先，澄清 Log4j 和 JCL 的关系
	- **JCL（Commons Logging）** 是一个日志门面（抽象层），它本身不实现日志功能，而是动态绑定到底层日志实现（如 Log4j、JDK Logging 等）。
	- **Log4j 1.x** 是一个具体的日志实现（日志库），它提供了自己的 API（如 `org.apache.log4j.Logger`）。项目可以直接使用 Log4j 的 API，而不通过 JCL。
	  - 示例：直接调用 Log4j 的代码：
		```java
		import org.apache.log4j.Logger; // 直接使用 Log4j API
		public class MyClass {
			private static final Logger logger = Logger.getLogger(MyClass.class);
			public void method() {
				logger.debug("This is a log message"); // 直接调用 Log4j
			}
		}
		```
	- 虽然 JCL 可以配置为使用 Log4j 作为底层实现，但很多老项目可能直接依赖 Log4j API，而不是通过 JCL 门面。这意味着：
	  - 如果代码直接使用 Log4j API，那么 JCL 门面根本不会被涉及，因此 `jcl-over-slf4j` 桥接包对这类代码无效。

- 2. 为什么需要专门的桥接包（如 `log4j-over-slf4j`）？
	- **目的**：为了将直接使用 Log4j API 的代码重定向到 SLF4J。
	  - `log4j-over-slf4j` 提供了一个“伪装”的 Log4j API（例如，它包含一个 `org.apache.log4j.Logger` 类），但这个类内部会调用 SLF4J API。这样，当老代码直接使用 Log4j API 时，实际日志操作会被 SLF4J 处理。
	  - 类似地，`jul-to-slf4j` 用于重定向直接使用 `java.util.logging` 的代码，而 `jcl-over-slf4j` 用于重定向使用 JCL 门面的代码。
	- **如果没有 `log4j-over-slf4j`**：直接使用 Log4j API 的代码会继续调用原始的 Log4j 库，导致：
	  - 日志无法统一通过 SLF4J 管理（例如，无法使用 SLF4J 的绑定机制切换到 Logback 或其他实现）。
	  - 可能产生依赖冲突或重复配置。

3. 举例说明桥接包的使用场景
	假设有一个老项目，混合使用了多种日志方式：
	- 部分代码直接使用 Log4j API（如 `import org.apache.log4j.Logger`）。
	- 部分代码使用 JCL 门面（如 `import org.apache.commons.logging.Log`）。
	- 您现在想统一迁移到 SLF4J + Logback（现代组合）。

	这时，您需要：
	1. **添加 SLF4J 门面和实现**（如 Logback）：
	   ```xml
	   <dependency>
		   <groupId>org.slf4j</groupId>
		   <artifactId>slf4j-api</artifactId>
		   <version>1.7.32</version>
	   </dependency>
	   <dependency>
		   <groupId>ch.qos.logback</groupId>
		   <artifactId>logback-classic</artifactId>
		   <version>1.2.6</version>
	   </dependency>
	   ```
	2. **添加桥接包来重定向旧日志调用**：
	   - 对于直接使用 Log4j 的代码：添加 `log4j-over-slf4j`。
	   - 对于使用 JCL 的代码：添加 `jcl-over-slf4j`。
	   - 对于使用 JUL 的代码：添加 `jul-to-slf4j`（并需配合 JVM 参数配置）。
	3. **移除原始的日志库依赖**（如 Log4j 1.x 的 JAR），避免冲突。

-4. 总结：为什么不能只靠 `jcl-over-slf4j`？
	- **`jcl-over-slf4j` 仅处理通过 JCL 门面的调用**：如果代码直接使用 Log4j API（不经过 JCL），这个桥接包不起作用。
	- **Log4j 有自己的独立生态**：许多项目（尤其是早期项目）直接使用 Log4j API，而不是通过 JCL。因此，需要专门的 `log4j-over-slf4j` 来覆盖这种情况。
	- **桥接包是“分层次”的**：每个桥接包针对特定的日志 API 层（JCL 门面、Log4j 实现层、JUL 实现层），确保所有旧代码都能统一到 SLF4J。

-实践建议
	- 在迁移时，检查项目代码中导入的日志类：
	  - 如果看到 `import org.apache.log4j.*`，就需要 `log4j-over-slf4j`。
	  - 如果看到 `import org.apache.commons.logging.*`，就需要 `jcl-over-slf4j`。
	- SLF4J 官方文档将这种模式称为“桥接”（bridging）或“重定向”（redirection），旨在解决遗留日志系统的兼容问题。
##### common-logging 绑定日志组件
- common-logging + log4j

添加依赖到 pom.xml 中即可。
```xml
<dependency>
  <groupId>commons-logging</groupId>
  <artifactId>commons-logging</artifactId>
  <version>1.2</version>
</dependency>
<dependency>
  <groupId>log4j</groupId>
  <artifactId>log4j</artifactId>
  <version>1.2.17</version>
</dependency>
```
#### 22.1.2.6 日志库配置 - 针对于日志框架
##### log4j2 配置
log4j2 基本配置形式如下：
```xml
<?xml version="1.0" encoding="UTF-8"?>;
<Configuration>
  <Properties>
    <Property name="name1">value</property>
    <Property name="name2" value="value2"/>
  </Properties>
  <Filter type="type" ... />
  <Appenders>
    <Appender type="type" name="name">
      <Filter type="type" ... />
    </Appender>
    ...
  </Appenders>
  <Loggers>
    <Logger name="name1">
      <Filter type="type" ... />
    </Logger>
    ...
    <Root level="level">
      <AppenderRef ref="name"/>
    </Root>
  </Loggers>
</Configuration>
```
配置示例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="debug" strict="true" name="XMLConfigTest"
               packages="org.apache.logging.log4j.test">
  <Properties>
    <Property name="filename">target/test.log</Property>
  </Properties>
  <Filter type="ThresholdFilter" level="trace"/>
 
  <Appenders>
    <Appender type="Console" name="STDOUT">
      <Layout type="PatternLayout" pattern="%m MDC%X%n"/>
      <Filters>
        <Filter type="MarkerFilter" marker="FLOW" onMatch="DENY" onMismatch="NEUTRAL"/>
        <Filter type="MarkerFilter" marker="EXCEPTION" onMatch="DENY" onMismatch="ACCEPT"/>
      </Filters>
    </Appender>
    <Appender type="Console" name="FLOW">
      <Layout type="PatternLayout" pattern="%C{1}.%M %m %ex%n"/><!-- class and line number -->
      <Filters>
        <Filter type="MarkerFilter" marker="FLOW" onMatch="ACCEPT" onMismatch="NEUTRAL"/>
        <Filter type="MarkerFilter" marker="EXCEPTION" onMatch="ACCEPT" onMismatch="DENY"/>
      </Filters>
    </Appender>
    <Appender type="File" name="File" fileName="${filename}">
      <Layout type="PatternLayout">
        <Pattern>%d %p %C{1.} [%t] %m%n</Pattern>
      </Layout>
    </Appender>
  </Appenders>
 
  <Loggers>
    <Logger name="org.apache.logging.log4j.test1" level="debug" additivity="false">
      <Filter type="ThreadContextMapFilter">
        <KeyValuePair key="test" value="123"/>
      </Filter>
      <AppenderRef ref="STDOUT"/>
    </Logger>
 
    <Logger name="org.apache.logging.log4j.test2" level="debug" additivity="false">
      <AppenderRef ref="File"/>
    </Logger>
 
    <Root level="trace">
      <AppenderRef ref="STDOUT"/>
    </Root>
  </Loggers>
 
</Configuration>
```
##### logback 配置
```xml
<?xml version="1.0" encoding="UTF-8" ?>
 
<!-- logback中一共有5种有效级别，分别是TRACE、DEBUG、INFO、WARN、ERROR，优先级依次从低到高 -->
<configuration scan="true" scanPeriod="60 seconds" debug="false">
 
  <property name="DIR_NAME" value="spring-helloworld"/>
 
  <!-- 将记录日志打印到控制台 -->
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <!-- RollingFileAppender begin -->
  <appender name="ALL" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/all.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>30MB</maxFileSize>
    </triggeringPolicy>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <appender name="ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/error.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>10MB</maxFileSize>
    </triggeringPolicy>
 
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
      <level>ERROR</level>
      <onMatch>ACCEPT</onMatch>
      <onMismatch>DENY</onMismatch>
    </filter>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <appender name="WARN" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/warn.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>10MB</maxFileSize>
    </triggeringPolicy>
 
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
      <level>WARN</level>
      <onMatch>ACCEPT</onMatch>
      <onMismatch>DENY</onMismatch>
    </filter>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <appender name="INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/info.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>10MB</maxFileSize>
    </triggeringPolicy>
 
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
      <level>INFO</level>
      <onMatch>ACCEPT</onMatch>
      <onMismatch>DENY</onMismatch>
    </filter>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <appender name="DEBUG" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/debug.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>10MB</maxFileSize>
    </triggeringPolicy>
 
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
      <level>DEBUG</level>
      <onMatch>ACCEPT</onMatch>
      <onMismatch>DENY</onMismatch>
    </filter>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <appender name="TRACE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/trace.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>10MB</maxFileSize>
    </triggeringPolicy>
 
    <filter class="ch.qos.logback.classic.filter.LevelFilter">
      <level>TRACE</level>
      <onMatch>ACCEPT</onMatch>
      <onMismatch>DENY</onMismatch>
    </filter>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
 
  <appender name="SPRING" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 根据时间来制定滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${user.dir}/logs/${DIR_NAME}/springframework.%d{yyyy-MM-dd}.log
      </fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
 
    <!-- 根据文件大小来制定滚动策略 -->
    <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
      <maxFileSize>10MB</maxFileSize>
    </triggeringPolicy>
 
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] [%-5p] %c{36}.%M - %m%n</pattern>
    </encoder>
  </appender>
  <!-- RollingFileAppender end -->
 
  <!-- logger begin -->
  <!-- 本项目的日志记录，分级打印 -->
  <logger name="org.zp.notes.spring" level="TRACE" additivity="false">
    <appender-ref ref="STDOUT"/>
    <appender-ref ref="ERROR"/>
    <appender-ref ref="WARN"/>
    <appender-ref ref="INFO"/>
    <appender-ref ref="DEBUG"/>
    <appender-ref ref="TRACE"/>
  </logger>
 
  <!-- SPRING框架日志 -->
  <logger name="org.springframework" level="WARN" additivity="false">
    <appender-ref ref="SPRING"/>
  </logger>
 
  <root level="TRACE">
    <appender-ref ref="ALL"/>
  </root>
  <!-- logger end -->
 
</configuration>
```
##### log4j 配置
完整的 log4j.xml 参考示例
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
 
<log4j:configuration xmlns:log4j='http://jakarta.apache.org/log4j/'>
 
  <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">
    <layout class="org.apache.log4j.PatternLayout">
      <param name="ConversionPattern"
             value="%d{yyyy-MM-dd HH:mm:ss,SSS\} [%-5p] [%t] %c{36\}.%M - %m%n"/>
    </layout>
 
    <!--过滤器设置输出的级别-->
    <filter class="org.apache.log4j.varia.LevelRangeFilter">
      <param name="levelMin" value="debug"/>
      <param name="levelMax" value="fatal"/>
      <param name="AcceptOnMatch" value="true"/>
    </filter>
  </appender>
 
 
  <appender name="ALL" class="org.apache.log4j.DailyRollingFileAppender">
    <param name="File" value="${user.dir}/logs/spring-common/jcl/all"/>
    <param name="Append" value="true"/>
    <!-- 每天重新生成日志文件 -->
    <param name="DatePattern" value="'-'yyyy-MM-dd'.log'"/>
    <!-- 每小时重新生成日志文件 -->
    <!--<param name="DatePattern" value="'-'yyyy-MM-dd-HH'.log'"/>-->
    <layout class="org.apache.log4j.PatternLayout">
      <param name="ConversionPattern"
             value="%d{yyyy-MM-dd HH:mm:ss,SSS\} [%-5p] [%t] %c{36\}.%M - %m%n"/>
    </layout>
  </appender>
 
  <!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制-->
  <logger name="org.zp.notes.spring" additivity="false">
    <level value="error"/>
    <appender-ref ref="STDOUT"/>
    <appender-ref ref="ALL"/>
  </logger>
 
  <!-- 根logger的设置-->
  <root>
    <level value="warn"/>
    <appender-ref ref="STDOUT"/>
  </root>
</log4j:configuration>
```
#### 22.1.2.7 日志库API - 针对于日志门面
##### slf4j 用法
使用 slf4j 的 API 很简单。使用LoggerFactory初始化一个Logger实例，然后调用 Logger 对应的打印等级函数就行了。
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 
public class App {
    private static final Logger log = LoggerFactory.getLogger(App.class);
    public static void main(String[] args) {
        String msg = "print log, current level: {}";
        log.trace(msg, "trace");
        log.debug(msg, "debug");
        log.info(msg, "info");
        log.warn(msg, "warn");
        log.error(msg, "error");
    }
}
```
##### common-logging 用法
common-logging 用法和 slf4j 几乎一样，但是支持的打印等级多了一个更高级别的：fatal。

此外，common-logging 不支持{}替换参数，你只能选择拼接字符串这种方式了。
```java
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
 
public class JclTest {
    private static final Log log = LogFactory.getLog(JclTest.class);
 
    public static void main(String[] args) {
        String msg = "print log, current level: ";
        log.trace(msg + "trace");
        log.debug(msg + "debug");
        log.info(msg + "info");
        log.warn(msg + "warn");
        log.error(msg + "error");
        log.fatal(msg + "fatal");
    }
}
```
#### 22.1.2.8 日志库选型与改造
##### 对Java日志组件选型的建议
slf4j已经成为了Java日志组件的明星选手，可以完美替代JCL，使用JCL桥接库也能完美兼容一切使用JCL作为日志门面的类库，现在的新系统已经没有不使用slf4j作为日志API的理由了。

日志记录服务方面，log4j在功能上输于logback和log4j2，在性能方面log4j2则全面超越log4j和logback。所以新系统应该在logback和log4j2中做出选择，对于性能有很高要求的系统，应优先考虑log4j2
##### 对日志架构使用比较好的实践
- 总是使用Log Facade（日志门面），而不是具体Log Implementation具体日志实现）

正如之前所说的，使用 Log Facade 可以方便的切换具体的日志实现。而且，如果依赖多个项目，使用了不同的Log Facade，还可以方便的通过 Adapter 转接到同一个实现上。如果依赖项目使用了多个不同的日志实现，就麻烦的多了。

具体来说，现在推荐使用 Log4j-API 或者 SLF4j，不推荐继续使用 JCL。
- 只添加一个 Log Implementation依赖

毫无疑问，项目中应该只使用一个具体的 Log Implementation，建议使用 Logback 或者Log4j2。如果有依赖的项目中，使用的 Log Facade不支持直接使用当前的 Log Implementation，就添加合适的桥接器依赖。具体的桥接关系可以看上一篇文章的图。

- <a id='具体的日志实现依赖应该设置为optional和使用runtime scope'>具体的日志实现依赖应该设置为optional和使用runtime scope</a>

在项目中，Log Implementation的依赖强烈建议设置为runtime scope，并且设置为optional。例如项目中使用了 SLF4J 作为 Log Facade，然后想使用 Log4j2 作为 Implementation，那么使用 maven 添加依赖的时候这样设置:
```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>${log4j.version}</version>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j-impl</artifactId>
    <version>${log4j.version}</version>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```
设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的Log Implementation 依赖；

Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不使用Log Facade中的类。
- 如果有必要, 排除依赖的第三方库中的Log Impementation依赖

这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为optional，然后你的项目继承了这些依赖——具体的日志实现未必是你想使用的，比如他依赖了Log4j，你想使用Logback，这时就很尴尬。另外，如果不同的第三方依赖使用了不同的桥接器和Log实现，也极容易形成环。

这种情况下，推荐的处理方法，是使用exclude来排除所有的这些Log实现和桥接器的依赖，只保留第三方库里面对Log Facade的依赖。

比如阿里的JStorm就没有很好的处理这个问题，依赖jstorm会引入对Logback和log4j-over-slf4j的依赖，如果你想在自己的项目中使用Log4j或其他Log实现的话，就需要加上excludes:
```xml
<dependency>
    <groupId>com.alibaba.jstorm</groupId>
    <artifactId>jstorm-core</artifactId>
    <version>2.1.1</version>
    <exclusions>
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>log4j-over-slf4j</artifactId>
        </exclusion>
        <exclusion>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```
- 避免为不会输出的log付出代价

Log库都可以灵活的设置输出界别，所以每一条程序中的log，都是有可能不会被输出的。这时候要注意不要额外的付出代价。

先看两个有问题的写法：
```java
logger.debug("start process request, url: " + url);
logger.debug("receive request: {}", toJson(request));
```
第一条是直接做了字符串拼接，所以即使日志级别高于debug也会做一个字符串连接操作；

第二条虽然用了SLF4J/Log4j2 中的懒求值方式来避免不必要的字符串拼接开销，但是toJson()这个函数却是都会被调用并且开销更大。

推荐的写法如下:
```java
logger.debug("start process request, url:{}", url); // SLF4J/LOG4J2
logger.debug("receive request: {}", () -> toJson(request)); // LOG4J2
logger.debug(() -> "receive request: " + toJson(request)); // LOG4J2
if (logger.isDebugEnabled()) { // SLF4J/LOG4J2
    logger.debug("receive request: " + toJson(request)); 
}
```
- 日志格式中最好不要使用行号，函数名等字段

原因是，为了获取语句所在的函数名，或者行号，log库的实现都是获取当前的stacktrace，然后分析取出这些信息，而获取stacktrace的代价是很昂贵的。如果有很多的日志输出，就会占用大量的CPU。在没有特殊需要的情况下，建议不要在日志中输出这些这些字段。

最后， log中不要输出稀奇古怪的字符！

部分开发人员为了方便看到自己的log，会在log语句中加上醒目的前缀，比如:
```java
logger.debug("========================start process request=============");
```
虽然对于自己来说是方便了，但是如果所有人都这样来做的话，那log输出就没法看了！正确的做法是使用grep 来看只自己关心的日志。
#### 22.1.2.9 对现有系统日志架构的改造建议

如果现有系统使用JCL作为日志门面，又确实面临着JCL的ClassLoader机制带来的问题，完全可以引入slf4j并通过桥接库将JCL api输出的日志桥接至slf4j，再通过适配库适配至现有的日志输出服务（如log4j），如下图：
![132.dev-package-log-4.png](../../assets/images/04-主流框架/spring/132.dev-package-log-4.png)

这样做不需要任何代码级的改造，就可以解决JCL的ClassLoader带来的问题，但没有办法享受日志模板等slf4j的api带来的优点。不过之后在现系统上开发的新功能就可以使用slf4j的api了，老代码也可以分批进行改造。

如果现有系统使用JCL作为日志门面，又头疼JCL不支持logback和log4j2等新的日志服务，也可以通过桥接库以slf4j替代JCL，但同样无法直接享受slf4j api的优点。

如果想要使用slf4j的api，那么就不得不进行代码改造了，当然改造也可以参考1中提到的方式逐步进行。

如果现系统面临着log4j的性能问题，可以使用Apache Logging提供的log4j到log4j2的桥接库log4j-1.2-api，把通过log4j api输出的日志桥接至log4j2。这样可以最快地使用上log4j2的先进性能，但组件中缺失了slf4j，对后续进行日志架构改造的灵活性有影响。另一种办法是先把log4j桥接至slf4j，再使用slf4j到log4j2的适配库。这样做稍微麻烦了一点，但可以逐步将系统中的日志输出标准化为使用slf4j的api，为后面的工作打好基础。
#### 22.1.10 对于<a href='#具体的日志实现依赖应该设置为optional和使用runtime scope'>具体的日志实现依赖应该设置为optional和使用runtime scope</a>这一点的补充说明

##### 1. Maven Scope（作用域）详解

###### 主要的Scope类型：

| Scope | 编译期可用 | 测试期可用 | 运行期可用 | 是否传递 | 典型用途 |
|-------|-----------|-----------|-----------|----------|----------|
| **compile** | ✅ | ✅ | ✅ | ✅ | 默认值，项目核心依赖 |
| **provided** | ✅ | ✅ | ❌ | ❌ | 容器/环境提供的依赖（如Servlet API） |
| **runtime** | ❌ | ✅ | ✅ | ✅ | 运行期需要但编译期不需要（如JDBC驱动） |
| **test** | ❌ | ✅ | ❌ | ❌ | 仅测试使用 |

###### 为什么日志实现建议用`runtime` scope？

```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>${log4j.version}</version>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

**背后的逻辑：**
1. **防止直接使用具体实现类**：如果设置为`compile`，开发人员可能会错误地导入`org.apache.log4j.Logger`而不是`org.slf4j.Logger`
2. **符合"面向接口编程"原则**：编译期只依赖门面API（SLF4J），运行期才绑定具体实现
3. **强制使用门面**：编译时无法访问具体实现类，只能使用门面API

##### 2. Optional（可选依赖）详解

###### Optional的作用：
- **阻止依赖传递**：当你的项目被其他项目依赖时，标记为`optional=true`的依赖**不会传递**给依赖你的项目
- **避免污染依赖树**：防止强制下游项目使用你选择的日志实现

###### 为什么日志实现要用`optional`？

**场景示例：**
- 项目A（库项目）依赖SLF4J + Log4j2
- 项目B（应用项目）依赖项目A，但想使用Logback

如果项目A中Log4j2没有设为optional：
```
项目B → 项目A → Log4j2（强制传递）
```
项目B被迫使用Log4j2，即使它想用Logback

如果项目A中Log4j2设为optional：
```
项目B → 项目A（不传递Log4j2）
项目B可以自由选择Logback
```

##### 3. 分析Spring Boot Starter Logging的配置

您观察到的Spring Boot配置确实使用了`compile` scope，这与"最佳实践"似乎矛盾。让我解释原因：

###### Spring Boot的特殊情况：

```xml
<dependency>
  <groupId>ch.qos.logback</groupId>
  <artifactId>logback-classic</artifactId>
  <version>1.2.11</version>
  <scope>compile</scope>  <!-- 注意：这里是compile -->
</dependency>
```

**为什么Spring Boot使用compile scope？**

1. **Spring Boot是应用框架，不是库**：
   - 您的项目是**最终应用**，不是要被其他项目依赖的库
   - 应用项目可以自由选择具体的日志实现，不需要考虑依赖传递问题

2. **Spring Boot的"约定优于配置"理念**：
   - Spring Boot为应用提供了默认的、完整的日志解决方案
   - 它假设大多数应用会使用这个默认配置（Logback）

3. **桥接包的特殊性**：
   - `log4j-to-slf4j`、`jul-to-slf4j`这些桥接包需要在编译期就介入
   - 它们需要重定向其他日志系统的调用，所以编译期就必须可用

###### 什么时候应该用runtime/optional？

| 项目类型 | Scope建议 | Optional建议 | 原因 |
|---------|-----------|-------------|------|
| **库项目（Library）** | runtime | true | 避免强制下游使用特定实现 |
| **应用项目（Application）** | compile | false | 最终应用需要完整的运行时依赖 |
| **框架（如Spring Boot）** | compile | false | 提供完整的默认解决方案 |

##### 4. 实践建议总结

###### 对于库项目（会被其他项目依赖）：
```xml
<!-- 门面API - 必须传递 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.32</version>
    <!-- 默认compile scope，需要传递 -->
</dependency>

<!-- 具体实现 - 不传递 -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.6</version>
    <scope>runtime</scope>
    <optional>true</optional>  <!-- 关键：不传递 -->
</dependency>
```

###### 对于应用项目（最终部署）：
```xml
<!-- 可以使用compile scope，因为不会被其他项目依赖 -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.6</version>
    <scope>compile</scope>  <!-- 或省略（默认compile） -->
</dependency>
```

##### 5. 验证依赖传递的方法

您可以使用Maven命令查看依赖树：
```bash
mvn dependency:tree
```

观察：
- 标记为`optional=true`的依赖是否出现在依赖树中
- 不同scope的依赖在什么阶段可用

**总结：** Spring Boot使用`compile` scope是因为它面向的是最终应用开发者，提供"开箱即用"的体验。而"最佳实践"中建议的`runtime` + `optional`更多适用于会被其他项目依赖的库项目。两者并不矛盾，只是适用场景不同。
## 22.2 配置时考虑点
> 在配置日志时需要考虑哪些因素？

- 支持日志路径，日志level等配置
- 日志控制配置通过application.yml下发
- 按天生成日志，当天的日志>50MB回滚
- 最多保存10天日志
- 生成的日志中Pattern自定义
- Pattern中添加用户自定义的MDC字段，比如用户信息(当前日志是由哪个用户的请求产生)，request信息。此种方式可以通过AOP切面控制，在MDC中添加requestID，在spring-logback.xml中配置Pattern。
- 根据不同的运行环境设置Profile - dev，test，product
- 对控制台，Err和全量日志分别配置
- 对第三方包路径日志控制
## 22.3 实现范例
> 如下两个例子基本包含了上述的考虑点:

### 22.3.1 综合范例
- application.yml
```yml
logging:
  level:
    root: debug
  path: C:/data/logs/springboot-logback-demo
server:
  port: 8080
spring:
  application:
    name: springboot-logback-demo
debug: false
```
- Spring-logback.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <!-- 日志根目录-->
    <springProperty scope="context" name="LOG_HOME" source="logging.path" defaultValue="/data/logs/springboot-logback-demo"/>

    <!-- 日志级别 -->
    <springProperty scope="context" name="LOG_ROOT_LEVEL" source="logging.level.root" defaultValue="DEBUG"/>

    <!--  标识这个"STDOUT" 将会添加到这个logger -->
    <springProperty scope="context" name="STDOUT" source="log.stdout" defaultValue="STDOUT"/>

    <!-- 日志文件名称-->
    <property name="LOG_PREFIX" value="spring-boot-logback" />

    <!-- 日志文件编码-->
    <property name="LOG_CHARSET" value="UTF-8" />

    <!-- 日志文件路径+日期-->
    <property name="LOG_DIR" value="${LOG_HOME}/%d{yyyyMMdd}" />

    <!--对日志进行格式化-->
    <property name="LOG_MSG" value="- | [%X{requestUUID}] | [%d{yyyyMMdd HH:mm:ss.SSS}] | [%level] | [${HOSTNAME}] | [%thread] | [%logger{36}] | --> %msg|%n "/>

    <!--文件大小，默认10MB-->
    <property name="MAX_FILE_SIZE" value="50MB" />

    <!-- 配置日志的滚动时间 ，表示只保留最近 10 天的日志-->
    <property name="MAX_HISTORY" value="10"/>

    <!--输出到控制台-->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <!-- 输出的日志内容格式化-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>${LOG_MSG}</pattern>
        </layout>
    </appender>

    <!--输出到文件-->
    <appender name="0" class="ch.qos.logback.core.rolling.RollingFileAppender">
    </appender>

    <!-- 定义 ALL 日志的输出方式:-->
    <appender name="FILE_ALL" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--日志文件路径，日志文件名称-->
        <File>${LOG_HOME}/all_${LOG_PREFIX}.log</File>

        <!-- 设置滚动策略，当天的日志大小超过 ${MAX_FILE_SIZE} 文件大小时候，新的内容写入新的文件， 默认10MB -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">

            <!--日志文件路径，新的 ALL 日志文件名称，“ i ” 是个变量 -->
            <FileNamePattern>${LOG_DIR}/all_${LOG_PREFIX}%i.log</FileNamePattern>

            <!-- 配置日志的滚动时间 ，表示只保留最近 10 天的日志-->
            <MaxHistory>${MAX_HISTORY}</MaxHistory>

            <!--当天的日志大小超过 ${MAX_FILE_SIZE} 文件大小时候，新的内容写入新的文件， 默认10MB-->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>${MAX_FILE_SIZE}</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>

        </rollingPolicy>

        <!-- 输出的日志内容格式化-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>${LOG_MSG}</pattern>
        </layout>
    </appender>

    <!-- 定义 ERROR 日志的输出方式:-->
    <appender name="FILE_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 下面为配置只输出error级别的日志 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <OnMismatch>DENY</OnMismatch>
            <OnMatch>ACCEPT</OnMatch>
        </filter>
        <!--日志文件路径，日志文件名称-->
        <File>${LOG_HOME}/err_${LOG_PREFIX}.log</File>

        <!-- 设置滚动策略，当天的日志大小超过 ${MAX_FILE_SIZE} 文件大小时候，新的内容写入新的文件， 默认10MB -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">

            <!--日志文件路径，新的 ERR 日志文件名称，“ i ” 是个变量 -->
            <FileNamePattern>${LOG_DIR}/err_${LOG_PREFIX}%i.log</FileNamePattern>

            <!-- 配置日志的滚动时间 ，表示只保留最近 10 天的日志-->
            <MaxHistory>${MAX_HISTORY}</MaxHistory>

            <!--当天的日志大小超过 ${MAX_FILE_SIZE} 文件大小时候，新的内容写入新的文件， 默认10MB-->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>${MAX_FILE_SIZE}</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>

        <!-- 输出的日志内容格式化-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <Pattern>${LOG_MSG}</Pattern>
        </layout>
    </appender>

    <!-- additivity 设为false,则logger内容不附加至root ，配置以配置包下的所有类的日志的打印，级别是 ERROR-->
    <logger name="org.springframework"     level="ERROR" />
    <logger name="org.apache.commons"      level="ERROR" />
    <logger name="org.apache.zookeeper"    level="ERROR"  />
    <logger name="com.alibaba.dubbo.monitor" level="ERROR"/>
    <logger name="com.alibaba.dubbo.remoting" level="ERROR" />

    <!-- ${LOG_ROOT_LEVEL} 日志级别 -->
    <root level="${LOG_ROOT_LEVEL}">

        <!-- 标识这个"${STDOUT}"将会添加到这个logger -->
        <appender-ref ref="${STDOUT}"/>

        <!-- FILE_ALL 日志输出添加到 logger -->
        <appender-ref ref="FILE_ALL"/>

        <!-- FILE_ERROR 日志输出添加到 logger -->
        <appender-ref ref="FILE_ERROR"/>
    </root>

</configuration>
```
- Profile 相关的配置可以参考:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/base.xml" />
    
     <!-- roll by day -->
     <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">   
    	<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">   
      		<fileNamePattern>logs/springboot-logback-demo.%d{yyyy-MM-dd}.log</fileNamePattern>   
      		<maxHistory>30</maxHistory>  
    	</rollingPolicy>   
    	<encoder>   
      		<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{35} - %msg%n</pattern>   
    	</encoder>  
  	</appender> 
   
    <!-- dev -->
	<logger name="org.springframework.web" level="INFO"/>
		<root level="INFO">
		<appender-ref ref="FILE" />
	</root>

    <!-- test or production -->
    <springProfile name="test,prod">
        <logger name="org.springframework.web" level="INFO"/>
        <logger name="com.pdai.springboot" level="INFO"/>
        <root level="INFO">
        	<appender-ref ref="FILE" />
        </root>
    </springProfile>
  	 
</configuration>
```
### 22.3.2 在配置前可以参考如下文章
https://www.cnblogs.com/warking/p/5710303.html

### 22.3.3 我们有两个配置：一个是Spring-logback.xml，另一个是Profile相关的配置。它们都是Logback的配置文件，但是它们之间的关系需要明确。

这两个配置示例展示了**两种不同的Logback配置方式**，它们之间是**替代关系**而不是同时使用的关系。让我详细解释：

#### 1. 两种配置方式的区别

##### 第一种：`Spring-logback.xml`（完整的自定义配置）
- **特点**：完全自定义所有配置，从零开始定义所有appender、logger等
- **适用场景**：需要高度定制化日志行为，不依赖Spring Boot默认配置
- **配置方式**：独立完整的配置文件

##### 第二种：Profile相关配置（基于Spring Boot默认配置的扩展）
- **特点**：基于Spring Boot默认配置，只做局部修改和扩展
- **关键代码**：
  ```xml
  <include resource="org/springframework/boot/logging/logback/base.xml" />
  ```
- **适用场景**：大部分使用Spring Boot默认配置，只需要针对不同环境做调整

#### 2. 为什么是替代关系？

在实际项目中，**你只会选择其中一种方式**，原因如下：

##### 第一种方式的优缺点：
**优点**：
- 完全控制日志行为
- 可以定义复杂的滚动策略、过滤规则等
- 适合有特殊日志需求的项目

**缺点**：
- 配置复杂，需要自己处理所有细节
- 失去了Spring Boot的"约定优于配置"优势

##### 第二种方式的优缺点：
**优点**：
- 简单，基于Spring Boot的成熟默认配置
- 支持Profile，不同环境不同配置
- 维护成本低

**缺点**：
- 定制能力相对有限

#### 3. 具体配置对比分析

##### 第一种方式的核心配置：
```xml
<!-- 完全自定义，没有使用Spring Boot默认配置 -->
<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
<appender name="FILE_ALL" class="ch.qos.logback.core.rolling.RollingFileAppender">
<appender name="FILE_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
```

##### 第二种方式的核心配置：
```xml
<!-- 继承Spring Boot默认配置 -->
<include resource="org/springframework/boot/logging/logback/base.xml" />

<!-- 只添加或覆盖需要的部分 -->
<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 基于默认配置进行扩展 -->
</appender>
```

#### 4. Spring Boot的日志配置加载机制

Spring Boot按以下顺序查找日志配置：
1. `logback-spring.xml`（推荐，支持Spring Profile）
2. `logback.xml`
3. 如果都没找到，使用Spring Boot默认配置

##### 推荐的文件命名：
```bash
# 支持Spring Profile的配置（推荐）
src/main/resources/logback-spring.xml

# 或不支持Profile的配置
src/main/resources/logback.xml
```

#### 5. 如何选择？

##### 选择第一种方式（完全自定义）的情况：
- 项目有特殊的日志需求（如按模块分文件、复杂的过滤规则）
- 团队有成熟的日志配置规范
- 需要与现有系统日志格式保持一致

##### 选择第二种方式（基于默认配置扩展）的情况：
- 新项目，希望快速上手
- 不同环境（dev/test/prod）需要不同的日志级别
- 大部分默认配置已满足需求，只需要小调整

#### 6. 实际应用示例

##### 如果你选择第二种方式（推荐大多数Spring Boot项目）：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 引入Spring Boot默认配置 -->
    <include resource="org/springframework/boot/logging/logback/base.xml"/>
    
    <!-- 开发环境：详细日志 -->
    <springProfile name="dev">
        <logger name="com.yourpackage" level="DEBUG"/>
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
    
    <!-- 生产环境：关键日志 -->
    <springProfile name="prod">
        <logger name="com.yourpackage" level="INFO"/>
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

#### 总结

这两个配置示例展示了**两种不同的设计哲学**：
- **第一个**：完全控制，适合有特殊需求的场景
- **第二个**：约定优于配置，适合大多数标准Spring Boot项目

在实际项目中，你应该根据具体需求选择其中一种，而不是同时使用。对于大多数Spring Boot项目，**第二种方式（基于默认配置+Profile）是更推荐的做法**，因为它更简单、更符合Spring Boot的设计理念。
## 22.4 Pattern中配置MDC（Mapped Diagnostic Context）

### 1. 什么是MDC？

MDC是**线程本地存储**，可以在同一个请求的整个调用链中传递上下文信息，他是Slf4J提供的一个类。比如：
- 请求ID（Request ID）
- 用户ID
- 会话信息
- 业务关键参数

### 2. Pattern中配置MDC字段

在您的`spring-logback.xml`中，已经可以看到MDC的使用：

```xml
<property name="LOG_MSG" 
          value="- | [%X{requestUUID}] | [%d{yyyyMMdd HH:mm:ss.SSS}] | [%level] | [${HOSTNAME}] | [%thread] | [%logger{36}] | --> %msg|%n "/>
```

**关键点：`%X{requestUUID}`** 就是读取MDC中`requestUUID`这个key的值。

#### 可用的MDC Pattern表达式：
- `%X{key}` - 获取指定key的MDC值
- `%X` - 获取所有MDC键值对
- `%mdc{key}` - 同上，另一种写法

### 3. 可以添加哪些自定义MDC字段？

**几乎任何与请求相关的上下文信息都可以**：

| 字段类型 | 示例key | 用途 |
|---------|---------|------|
| **请求追踪** | `requestId`, `traceId`, `spanId` | 分布式追踪 |
| **用户信息** | `userId`, `username`, `tenantId` | 用户身份识别 |
| **请求上下文** | `clientIp`, `userAgent`, `requestURI` | 请求来源分析 |
| **业务参数** | `orderId`, `productId`, `actionType` | 业务操作追踪 |
| **环境信息** | `appName`, `env`, `version` | 环境标识 |

### 4. 如何在代码中设置MDC字段？

#### 方式一：使用拦截器/过滤器（推荐）

```java
@Component
public class LoggingInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, Object handler) {
        // 生成请求ID
        String requestId = UUID.randomUUID().toString();
        String userId = getUserIdFromRequest(request); // 从token等获取用户ID
        
        // 设置MDC
        MDC.put("requestUUID", requestId);
        MDC.put("userId", userId);
        MDC.put("clientIp", request.getRemoteAddr());
        MDC.put("requestURI", request.getRequestURI());
        MDC.put("userAgent", request.getHeader("User-Agent"));
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request,
                              HttpServletResponse response, Object handler, Exception ex) {
        // 请求完成后清理MDC，防止内存泄漏
        MDC.clear();
    }
    
    private String getUserIdFromRequest(HttpServletRequest request) {
        // 实际项目中从JWT token或session中获取
        return "user123";
    }
}
```

#### 方式二：使用AOP切面

```java
@Aspect
@Component
public class LoggingAspect {
    
    @Around("execution(* com.yourpackage.controller..*(..))")
    public Object logMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        // 方法执行前设置业务相关的MDC
        MDC.put("method", joinPoint.getSignature().getName());
        MDC.put("className", joinPoint.getTarget().getClass().getSimpleName());
        
        try {
            return joinPoint.proceed();
        } finally {
            // 清理业务相关的MDC字段，但保留请求级别的字段
            MDC.remove("method");
            MDC.remove("className");
        }
    }
}
```

#### 方式三：在业务代码中动态设置

```java
@Service
public class OrderService {
    
    public void createOrder(OrderDTO order) {
        // 设置业务相关的MDC
        MDC.put("orderId", order.getId());
        MDC.put("customerId", order.getCustomerId());
        
        try {
            // 业务逻辑
            logger.info("创建订单");
        } finally {
            // 清理业务MDC
            MDC.remove("orderId");
            MDC.remove("customerId");
        }
    }
}
```

### 5. 完整的Pattern配置示例

```xml
<property name="LOG_MSG" 
          value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%X{requestUUID}] [%X{userId}] [%X{clientIp}] [%thread] %-5level %logger{36} - %msg%n"/>

<!-- 或者更详细的版本 -->
<property name="DETAILED_LOG_MSG" 
          value="%d{yyyy-MM-dd HH:mm:ss.SSS} | %X{requestUUID} | %X{userId} | %X{tenantId} | %X{clientIp} | %-5level | %thread | %logger{50} | %msg%n"/>
```

### 6. 注册拦截器配置

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoggingInterceptor loggingInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loggingInterceptor)
                .addPathPatterns("/**");
    }
}
```

### 7. 生成的日志效果

配置后，你的日志会显示类似这样的格式：
```
2024-01-15 14:30:25.123 | abc-request-123 | user456 | tenant01 | 192.168.1.100 | INFO | http-nio-8080-exec-1 | com.example.OrderController | 用户下单成功
```

### 8. 重要注意事项

#### 必须清理MDC！
```java
// 在finally块中清理，或使用try-with-resources模式
try {
    MDC.put("key", "value");
    // 业务逻辑
} finally {
    MDC.remove("key"); // 或者 MDC.clear()
}
```

#### 异步场景处理：
如果使用线程池，MDC不会自动传递，需要手动处理：

```java
// 包装Runnable传递MDC
public class MDCRunnable implements Runnable {
    private final Map<String, String> context = MDC.getCopyOfContextMap();
    private final Runnable delegate;
    
    public MDCRunnable(Runnable delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public void run() {
        if (context != null) {
            MDC.setContextMap(context);
        }
        try {
            delegate.run();
        } finally {
            MDC.clear();
        }
    }
}

// 使用
executor.execute(new MDCRunnable(() -> {
    // 异步任务，可以访问MDC
}));
```

### 总结

通过MDC，你可以：
1. **在Pattern中配置**：使用`%X{key}`格式
2. **设置丰富的信息**：请求ID、用户信息、业务参数等
3. **实现请求链路追踪**：同一个请求的所有日志都有相同的requestId
4. **便于日志分析**：可以按用户、请求等维度筛选日志

这种配置让日志从"发生了什么"升级到"谁在什么情况下发生了什么"，极大提升了日志的实用价值。
# 二十三、SpringBoot入门 - 配置热部署devtools工具
## 23.1 准备知识点
### 23.1.1 什么是热部署和热加载？
> 热部署和热加载是在应用正在运行的时候，自动更新（重新加载或者替换class等）应用的一种能力。（PS：spring-boot-devtools提供的方案也是要重启的，只是无需手动重启能实现自动加载而已。）

严格意义上，我们需要区分下热部署和热加载, 对于Java项目而言：
- 热部署
  - 在服务器运行时重新部署项目
  - 它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。
- 热加载
    - 在运行时重新加载class，从而升级应用。
    - 热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。
    - 对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。
### 23.1.2 什么是LiveLoad？
LiveLoad是提供浏览器客户端自动加载更新的工具，分为LiveLoad服务器和Liveload浏览器插件两部分； devtools中已经集成了LiveLoad服务器，所以如果我们开发的是web应用，并且期望浏览器自动刷新， 这时候可以考虑LiveLoad.
![133.springboot-hello-devtool-1.png](../../assets/images/04-主流框架/spring/133.springboot-hello-devtool-1.png)

同一时间只能运行一个LiveReload服务器。 开始应用程序之前，请确保没有其他LiveReload服务器正在运行。如果从IDE启动多个应用程序，则只有第一个应用程序将支持LiveReload。
## 23.2 配置devtools实现热部署
> 我们通过如下配置来实现自动重启方式的热部署。
### 23.2.1 POM配置
添加spring-boot-devtools的依赖
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional> <!-- 可以防止将devtools依赖传递到其他模块中 -->
    </dependency>
</dependencies>
```
### 23.2.2 IDEA配置
> 如果你使用IDEA开发工具，通常有如下两种方式：
- 方式一： **无任何配置时，手动触发重启更新（Ctrl+F9）**
![134.springboot-hello-devtool-5.png](../../assets/images/04-主流框架/spring/134.springboot-hello-devtool-5.png)

（也可以用mvn compile编译触发重启更新）
- 方式二： **IDEA需开启运行时编译，自动重启更新**

设置1：

File->Setting->Build,Execution,Deployment->Compile

勾选：Make project automatically
![135.springboot-hello-devtool-7.png](../../assets/images/04-主流框架/spring/135.springboot-hello-devtool-7.png)

设置2：快捷键：ctrl+alt+shift+/

选择：Registry

勾选：compiler.automake.allow.when.app.running

新版本的IDEA可以在File->setting->Advanced Setttings里面的第一个设置：
![136.springboot-hello-devtool-8.png](../../assets/images/04-主流框架/spring/136.springboot-hello-devtool-8.png)
### 23.2.3 application.yml配置
```yml
spring:
  devtools:
    restart:
      enabled: true  #设置开启热部署
      additional-paths: src/main/java #重启目录
      exclude: WEB-INF/**
  thymeleaf:
    cache: false #使用Thymeleaf模板引擎，关闭缓存
```
### 23.2.4 使用LiveLoad
spring-boot-devtools模块包含嵌入式LiveReload服务器，可以在资源更改时用于触发浏览器刷新。 LiveReload浏览器扩展程序支持Chrome，Firefox和Safari，你可以从livereload.com免费下载。
![137.springboot-hello-devtool-3.png](../../assets/images/04-主流框架/spring/137.springboot-hello-devtool-3.png)

或者从浏览器插件中心下载，比如firefox:
![138.springboot-hello-devtool-2.png](../../assets/images/04-主流框架/spring/138.springboot-hello-devtool-2.png)

安装完之后，可以通过如下图标管理
![139.springboot-hello-devtool-4.png](../../assets/images/04-主流框架/spring/139.springboot-hello-devtool-4.png)

如果你不想在应用程序运行时启动LiveReload服务器，则可以将spring.devtools.livereload.enabled属性设置为false 。

同一时间只能运行一个LiveReload服务器。 开始应用程序之前，请确保没有其他LiveReload服务器正在运行。如果从IDE启动多个应用程序，则只有第一个应用程序将支持LiveReload。
## 23.3 进一步理解
### 23.3.1 devtool的原理？为何会自动重启？
> 为什么同样是重启应用，为什么不手动重启，而是建议使用spring-boot-devtools进行热部署重启？

spring-boot-devtools使用了两个类加载器ClassLoader，一个ClassLoader加载不会发生更改的类（第三方jar包），另一个ClassLoader（restart ClassLoader）加载会更改的类（自定义的类）。

后台启动一个**文件监听线程（File Watcher），监测的目录中的文件发生变动时， 原来的restart ClassLoader被丢弃，将会重新加载新的restart ClassLoader。**

因为文件变动后，第三方jar包不再重新加载，只加载自定义的类，加载的类比较少，所以重启比较快。

这也是为什么，同样是重启应用，为什么不手动重启，建议使用spring-boot-devtools进行热部署重启。

在自动重启中有几点需要注意:
- 自动重启会记录日志的

（记录在什么情况下重启的日志）

可以通过如下关闭
```yml
spring:
  devtools:
    restart:
      log-condition-evaluation-delta: false
```
- 排除一些不需要自动重启的资源

某些资源在更改时不一定需要触发重新启动。默认情况下，改变资源/META-INF/maven，/META-INF/resources，/resources，/static，/public，或/templates不触发重新启动，但确会触发现场重装。如果要自定义这些排除项，可以使用该spring.devtools.restart.exclude属性。例如，要仅排除/static，/public你将设置以下属性：
```yml
spring:
  devtools:
    restart:
      exclude: "static/**,public/**"
```
如果要保留这些默认值并添加其他排除项，请改用该spring.devtools.restart.additional-exclude属性。
- 自定义重启类加载器

重启功能是通过使用两个类加载器来实现的。对于大多数应用程序，这种方法效果很好。但是，它有时会导致类加载问题。

默认情况下，IDE 中的任何打开项目都使用“重启”类加载器加载，任何常规.jar文件都使用“基本”类加载器加载。如果你处理一个多模块项目，并且不是每个模块都导入到你的 IDE 中，你可能需要自定义一些东西。为此，你可以创建一个META-INF/spring-devtools.properties文件。

该spring-devtools.properties文件可以包含以restart.exclude和为前缀的属性restart.include。该include元素是应该被push到“重启”的类加载器的项目，以及exclude要素是应该向下poll到“Base”类加载器的项目。该属性的值是应用于类路径的正则表达式模式，如以下示例所示：
```yml
restart:
  exclude:
    companycommonlibs: "/mycorp-common-[\\w\\d-\\.]+\\.jar"
  include:
    projectcommon: "/mycorp-myproj-[\\w\\d-\\.]+\\.jar"
```
更多相关的信息可以在<a href='https://docs.spring.io/spring-boot/reference/using/devtools.html#using.devtools'>这里</a>查看。
### 23.3.2 devtool是否会被打包进Jar？
> devtool原则上来说应该是只在开发调试的时候使用，而在生产环境运行jar包时是不需要的，所以Spring打包会不会把它打进JAR吗？
- 默认情况下，不会被打包进JAR

运行打包的应用程序时，开发人员工具会**自动禁用**。如果你通过 java -jar或者其他特殊的类加载器进行启动时，都会被认为是“生产环境的应用”。
- 如果我们期望远程调试应用
（生产环境勿用，只有在受信任的网络上运行或使用 SSL 进行保护时，才应启用它）

在这种情况下，devtool也具备远程调试的能力：远程客户端应用程序旨在从你的 IDE 中运行。你需要org.springframework.boot.devtools.RemoteSpringApplication使用与你连接的远程项目相同的类路径运行。应用程序的唯一必需参数是它连接到的远程 URL。

例如，如果使用 Eclipse 或 Spring Tools，并且你有一个my-app已部署到 Cloud Foundry 的名为的项目，执行以下操作：
1. 选择Run Configurations…​从Run菜单。
2. 创建一个新的Java Application“启动配置”。
3. 浏览my-app项目。
4. 使用org.springframework.boot.devtools.RemoteSpringApplication作为主类。
5. 添加https://myapp.cfapps.io到Program arguments（或任何你的远程 URL）。

正在运行的远程客户端可能类似于以下列表：
```java
  .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 2.5.4

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)
```
### 23.3.3 devtool为何会默认禁用缓存选项？
> Spring Boot 支持的**一些库使用缓存来提高性能**。例如，模板引擎缓存已编译的模板以避免重复解析模板文件。此外，Spring MVC 可以在提供静态资源时向响应添加 HTTP 缓存标头。

虽然缓存在**生产中非常有益，但在开发过程中可能会适得其反**，使你无法看到刚刚在应用程序中所做的更改。出于这个原因， spring-boot-devtools 默认禁用缓存选项。

比如Thymeleaf 提供了spring.thymeleaf.cache来设置模板引擎的缓存，使用spring-boot-devtools模块时是不需要手动设置这些属性的，因为spring-boot-devtools会自动进行设置。

那么会自动设置哪些配置呢？你可以在DevToolsPropertyDefaultsPostProcessor类找到对应的默认配置。
```java
public class DevToolsPropertyDefaultsPostProcessor implements EnvironmentPostProcessor {

	static {
		Map<String, Object> properties = new HashMap<>();
		properties.put("spring.thymeleaf.cache", "false");
		properties.put("spring.freemarker.cache", "false");
		properties.put("spring.groovy.template.cache", "false");
		properties.put("spring.mustache.cache", "false");
		properties.put("server.servlet.session.persistent", "true");
		properties.put("spring.h2.console.enabled", "true");
		properties.put("spring.web.resources.cache.period", "0");
		properties.put("spring.web.resources.chain.cache", "false");
		properties.put("spring.template.provider.cache", "false");
		properties.put("spring.mvc.log-resolved-exception", "true");
		properties.put("server.error.include-binding-errors", "ALWAYS");
		properties.put("server.error.include-message", "ALWAYS");
		properties.put("server.error.include-stacktrace", "ALWAYS");
		properties.put("server.servlet.jsp.init-parameters.development", "true");
		properties.put("spring.reactor.debug", "true");
		PROPERTIES = Collections.unmodifiableMap(properties);
	}
```
当然如果你不想被应用属性被spring-boot-devtools默认设置， 可以通过spring.devtools.add-properties到false你application.yml中。
### 23.3.4 devtool是否可以给所有Springboot应用做全局的配置？
> 可以通过将spring-boot-devtools.yml文件添加到$HOME/.config/spring-boot目录来**配置全局 devtools 设置。**

添加到这些文件的任何属性都适用于你机器上使用 devtools 的所有Spring Boot 应用程序。例如，要将重新启动配置为始终使用触发器文件，你需要将以下属性添加到你的spring-boot-devtools文件中：

```yml
spring:
  devtools:
    restart:
      trigger-file: ".reloadtrigger"
```
### 23.3.5 如果我不用devtool，还有什么选择？
> 如果我不用devtool，还有什么选择？

在实际的开发过程中，我也不会去使用devtool工具, 因为：
- devtool本身基于重启方式，这种仍然不是真正的热替换方案，JRebel才是（它是收费的）
- 开发调试最重要的还是一种权衡
  - 自动重启的开销如果和手动重启没有什么太大差别，那么还不如手动重启（按需重启）
  - 多数情况下，如果是**方法内部的修改或者静态资源的修改**，在IDEA中是可以通过ReCompile（Ctrl + Shift + F9）进行热更的
![140.springboot-hello-devtool-6.png](../../assets/images/04-主流框架/spring/140.springboot-hello-devtool-6.png)
- 此外还有一个工具spring loaded， 可实现修改类文件的热部署，具体可看其<a href='https://github.com/spring-projects/spring-loaded'>github地址</a>上的说明。
# 二十四、SpringBoot入门 - 开发中还有哪些常用注解
### @SpringBootApplication

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Configuration
@EnableAutoConfiguration
@ComponentScan
public @interface SpringBootApplication {
    /**
     * Exclude specific auto-configuration classes such that they will never be applied.
     * @return the classes to exclude
     */
    Class<?>[] exclude() default {};
}
```

- 定义在main方法入口类处，用于启动Spring Boot应用项目

### @EnableAutoConfiguration

- 让Spring Boot根据类路径中的jar包依赖当前项目进行自动配置
- 在`src/main/resources`的`META-INF/spring.factories`中配置：

```
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration
```

- 若有多个自动配置，用","隔开

#### 这里值得注意的是这个自动加载的顺序问题：

Spring Boot会按从高到低的优先级加载配置文件，**高优先级的配置会覆盖低优先期的配置**
```java
# 1. 命令行参数（最高优先级）
java -jar app.jar --server.port=8081 --spring.profiles.active=prod

# 2. Java系统属性（System.getProperties()）
-Dserver.port=8082

# 3. 操作系统环境变量
export SERVER_PORT=8083

# 4. 打包在jar包外部的特定profile的配置文件
file:./config/application-{profile}.properties(注意还有yml格式，同级别的properties优先于yml)

# 5. 打包在jar包内部的特定profile的配置文件
classpath:/config/application-{profile}.properties(注意还有yml格式，同级别的properties优先于yml)

# 6. 打包在jar包外部的application.properties(注意还有yml格式，同级别的properties优先于yml)
file:./config/application.properties

# 7. 打包在jar包内部的application.properties(注意还有yml格式，同级别的properties优先于yml)
classpath:/config/application.properties

# 8. 打包在jar包外部的application.properties(注意还有yml格式，同级别的properties优先于yml)
file:./application.properties

# 9. 打包在jar包内部的application.properties(注意还有yml格式，同级别的properties优先于yml)
classpath:/application.properties

# 10. @PropertySource注解指定的文件（最低优先级）
```
**配置加载的三大层级**：
1. **启动参数层级**：命令行参数、系统属性、环境变量（最高优先级，应用启动前决定）
2. **配置文件层级**：bootstrap.properties、application.properties等（应用上下文初始化时加载）
3. **自动配置层级**：@EnableAutoConfiguration、@Configuration等（Bean创建阶段，受代码注解控制）


**这里值得注意的是，如果达成jar包的META-INF文件夹下面的MAINFEST.MF文件中指定了外部的路径(和启动jar同级别下)。这个路径会添加到 JAR 的 classpath 中。由于是当前目录，优先级高于classpath，所以优先级更高。**

这里是因为我的一个项目工程里面再打包的时候配置了
```xml
<manifestEntries>
    <Class-Path>conf/</Class-Path>
</manifestEntries>
```
这个配置再生成MAINFEST.MF文件中指定了外部的路径conf/。然后我再打出完整包的时候conf/目录下放置了application.properties/applicaition-dev.properties。但是我的启动jar的classpath中也有这两个文件，但是还是我的conf/目录下的优先级更高。
#### 自动配置类的顺序控制

自动配置类可以通过以下注解控制顺序：

```java
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)  // 最高优先级
@AutoConfigureBefore(DataSourceAutoConfiguration.class)  // 在某个配置之前
@AutoConfigureAfter(JacksonAutoConfiguration.class)      // 在某个配置之后
public class MyAutoConfiguration {
    // 配置内容
}
```
#### springCloud也有类似的配置方式(@BootstrapConfiguration注解)
- 同样在`src/main/resources`的`META-INF/spring.factories`中配置：
```
# Bootstrap components
org.springframework.cloud.bootstrap.BootstrapConfiguration=\
com.test.modules.middleware.rmq.config.RabbitMQConfiguration
```
这里配置的执行优先级要高于ApplicaitionContext的创建的
```java
// 1. 启动SpringApplication
SpringApplication.run(MyApplication.class, args);

// 2. 初始化Bootstrap Context（如果使用了Spring Cloud）
//    - 加载bootstrap.properties
//    - 执行@BootstrapConfiguration标注的配置类

// 3. 创建Main Application Context
//    - 加载application.properties（按优先级顺序）
//    - 执行@Configuration标注的配置类

// 4. 执行自动配置 (@EnableAutoConfiguration)
//    - 从spring.factories加载自动配置类
//    - 按@AutoConfigureOrder、@AutoConfigureBefore/After排序
//    - 应用条件注解(@ConditionalOnXxx)过滤

// 5. 启动完成，应用Ready
```
#### @BootstrapConfiguration 和 @EnableAutoConfiguration 的关系

1. 上下文层级关系

```java
// Spring Cloud应用的上下文结构：
Bootstrap Context (父上下文)
    ↓ 包含 @BootstrapConfiguration 配置类
    ↓ 加载 bootstrap.properties
Application Context (子上下文, 继承父上下文)  
    ↓ 包含 @EnableAutoConfiguration 配置类
    ↓ 加载 application.properties
```

2. 配置文件的共存方式

虽然它们使用相似的配置文件名称，但**加载时机和用途不同**：

```properties
# bootstrap.properties - 用于Bootstrap Context
spring.application.name=my-service
spring.cloud.config.uri=http://config-server:8888
# 这些配置在应用启动最早阶段加载

# application.properties - 用于Application Context  
server.port=8080
spring.datasource.url=jdbc:mysql://localhost/db
# 这些配置在Bootstrap Context之后加载
```
#### 配置覆盖
相同类型比较 properties 优先级高

当同一个配置属性在 bootstrap.properties 和 bootstrap.yml 文件中都存在时，那么 properties 中的配置会被加载，而忽略 yml 文件中的配置（即优先级高的配置覆盖优先级低的配置），不同配置相互互补。此处 application(.properties/yml) 同理。

不同类型比较 applicatioin 覆盖 bootstrap
 但当同一配置在 bootstrap 和 application 中都存在时，那么虽然优先加载 bootstrap 但是会被 applicatioin 中的配置覆盖，此时则变成了低优先级覆盖高优先的配置

原文参考：https://blog.csdn.net/m0_53428367/article/details/135004826

### @ImportResource

- 加载xml配置，一般是放在启动main类上

```java
@ImportResource("classpath*:/spring/*.xml")   // 单个文件

@ImportResource({"classpath*:/spring/1.xml","classpath*:/spring/2.xml"})   // 多个文件
```

### @Value

- `application.properties`定义属性，直接使用@Value注入即可

```java
public class A{
    @Value("${push.start:0}")    // 如果缺失，默认值为0
    private Long id;
}
```

### @ConfigurationProperties(prefix="person")

- @ConfigurationProperties` 是 Spring Boot 中非常重要的一个注解，它的主要作用是**将配置文件中的属性值批量绑定到 Java Bean 上**。

```java
@ConfigurationProperties(prefix="person")
public class PersonProperties {
    private String name;
    private int age;
}
```
```yml
person:
  name: "test"
  age: 18
```

| 特性 | @ConfigurationProperties | @Value |
|------|--------------------------|---------|
| 批量绑定 | ✅ 支持 | ❌ 单个属性 |
| 类型安全 | ✅ 强类型 | ⚠️ 需要类型转换 |
| 嵌套属性 | ✅ 支持 | ❌ 不支持 |
| 松绑定 | ✅ 支持 | ❌ 严格匹配 |
| 数据校验 | ✅ 支持JSR-303 | ❌ 不支持 |
| 默认值 | ✅ 类字段默认值 | ✅ SpEL表达式 |

### @EnableConfigurationProperties

- 用`@EnableConfigurationProperties`注解使`@ConfigurationProperties`生效，并从IOC容器中获取bean
- 参考：[详细说明](https://blog.csdn.net/u010502101/article/details/78758330)
```java
package com.example.demo;
import org.springframework.boot.SpringApplication;
import 
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.ComponentScan;

//@SpringBootApplication
@ComponentScan
/*@EnableConfigurationProperties注解是用来开启对@ConfigurationProperties注解配置Bean的支持。
也就是@EnableConfigurationProperties注解告诉Spring Boot 使能支持@ConfigurationProperties*/
@EnableConfigurationProperties
public class Springboot3Application {

    public static void main(String[] args) throws Exception {

        ConfigurableApplicationContext context = SpringApplication.run(Springboot3Application.class, args);
        /*@ConfigurationProperties注解和@EnableConfigurationProperties配合使用*/
        System.out.println(context.getBean(ComponentProperties.class));
        context.close();
    }
}
```
### @RestController

- 组合`@Controller`和`@ResponseBody`，当你开发一个和页面交互数据的控制时，比如bbs-web的api接口需要此注解

### @RequestMapping("/api2/copper")

- 用来映射web请求（访问路径和参数）、处理类和方法，可以注解在类或方法上
- 注解在方法上的路径会继承注解在类上的路径
- `produces`属性：定制返回的response的媒体类型和字符集，或需返回值是json对象

```java
@RequestMapping(value="/api2/copper", produces="application/json;charset=UTF-8", method = RequestMethod.POST)
```

### @RequestParam

- 获取request请求的参数值

```java
public List<CopperVO> getOpList(HttpServletRequest request,
                                @RequestParam(value = "pageIndex", required = false) Integer pageIndex,
                                @RequestParam(value = "pageSize", required = false) Integer pageSize) {
}
```

### @ResponseBody

- 支持将返回值放在response体内，而不是返回一个页面
- 比如Ajax接口，可以用此注解返回数据而不是页面
- 此注解可以放置在返回值前或方法前

**另一个玩法**：可以不用`@ResponseBody`，继承`FastJsonHttpMessageConverter`类并对`writeInternal`方法扩展，在spring响应结果时，再次拦截、加工结果

```java
// stringResult: json返回结果
// HttpOutputMessage outputMessage

byte[] payload = stringResult.getBytes();
outputMessage.getHeaders().setContentType(META_TYPE);
outputMessage.getHeaders().setContentLength(payload.length);
outputMessage.getBody().write(payload);
outputMessage.getBody().flush();
```

### @Bean

- `@Bean(name="bean的名字", initMethod="初始化时调用方法名字", destroyMethod="close")`
- 定义在方法上，在容器内初始化一个bean实例类

```java
@Bean(destroyMethod="close")
@ConditionalOnMissingBean
public PersonService registryService() {
    return new PersonService();
}
```

### @Service

- 用于标注业务层组件

### @Controller

- 用于标注控制层组件（如struts中的action）

### @Repository

- 用于标注数据访问组件，即DAO组件

### @Component

- 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注

### @PostConstruct

- spring容器初始化时，要执行该方法

```java
@PostConstruct  
public void init() {   
}
```

### @PathVariable

- 用来获得请求url中的动态参数

```java
@Controller  
public class TestController {  
    @RequestMapping(value="/user/{userId}/roles/{roleId}", method = RequestMethod.GET)  
    public String getLogin(@PathVariable("userId") String userId,  
                         @PathVariable("roleId") String roleId) {
        System.out.println("User Id : " + userId);  
        System.out.println("Role Id : " + roleId);  
        return "hello";  
    }  
}
```

### @ComponentScan

- 注解会告知Spring扫描指定的包来初始化Spring

```java
@ComponentScan(basePackages = "com.bbs.xx")
```

### @EnableZuulProxy

- 路由网关的主要目的是为了让所有的微服务对外只有一个接口，我们只需访问一个网关地址，即可由网关将所有的请求代理到不同的服务中
- Spring Cloud是通过Zuul来实现的，支持自动路由映射到在Eureka Server上注册的服务
- Spring Cloud提供了注解`@EnableZuulProxy`来启用路由代理

### @Autowired

- 在默认情况下使用`@Autowired`注释进行自动注入时，Spring容器中匹配的候选Bean数目必须有且仅有一个
- 当找不到一个匹配的Bean时，Spring容器将抛出`BeanCreationException`异常，并指出必须至少拥有一个匹配的Bean
- 当不能确定Spring容器中一定拥有某个类的Bean时，可以在需要自动注入该类Bean的地方可以使用`@Autowired(required = false)`，这等于告诉Spring：在找不到匹配Bean时也不报错
- `@Autowired`注解注入map、list与`@Qualifier`：

对于不唯一的Bean，使用@Autowired时可以用List和Map等进行接收
1. 用数组接收
```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}
```
2. 用Set接收
```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```
3. 用Map接收（即使是类型化的 Map 实例也可以被自动注入，只要预期的key类型是 String。map的值包含所有预期类型的Bean，而key则包含相应的Bean名称，正如下面的例子所示。）
```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```
下面结合我项目代码做一个例子：(caffeine进行缓存配置，存在多个配置)
```java
@Configuration
@EnableCaching
public class CacheConfig {

    //写入后5分钟过期
    @Bean("fiveMinutesTermCache")
    @Primary
    public CacheManager fiveMinutesTermCache() {
        CaffeineCacheManager manager = new CaffeineCacheManager();
        manager.setCaffeine(Caffeine.newBuilder()
                .recordStats() // 开启统计
                .expireAfterWrite(5, TimeUnit.MINUTES));
        return manager;
    }

    // 定义2小时缓存
    @Bean("twoHoursTermCache")
    public CacheManager twoHoursTermCache() {
        CaffeineCacheManager manager = new CaffeineCacheManager();
        manager.setCaffeine(Caffeine.newBuilder()
                .recordStats() // 开启统计
                .expireAfterWrite(2, TimeUnit.HOURS));
        return manager;
    }

    // 定义5天的缓存
    @Bean("fiveDaysTermCache")
    public CacheManager fiveDaysTermCache() {
        CaffeineCacheManager manager = new CaffeineCacheManager();
        manager.setCaffeine(Caffeine.newBuilder()
                .recordStats() // 开启统计
                .expireAfterWrite(5, TimeUnit.DAYS));
        return manager;
    }

}
```
接口进行缓存监控：
```java
@RestController
@RequestMapping("/cache")
@Api(tags = "caffeine缓存管理", value = "caffeine缓存管理相关接口", protocols = "http", hidden = true)
@ApiIgnore
public class CacheMonitorController {

    @Resource //用map接收
    private Map<String, CacheManager> cacheManagerMap;

    @GetMapping("/stats")
    public Map<String, Object> getCacheStats() {
        Map<String, Object> result = new LinkedHashMap<>();
        if (MapUtils.isNotEmpty(cacheManagerMap)) {
            for (Map.Entry<String, CacheManager> cacheManager : cacheManagerMap.entrySet()) {
                result.put(cacheManager.getKey(), buildCacheInfo(cacheManager.getValue()));
            }
        }
        return result;
    }

    private Map<String, Object> buildCacheInfo(CacheManager manager) {
        Map<String, Object> cacheInfo = new LinkedHashMap<>();
        manager.getCacheNames().forEach(name -> {
            Cache cache = manager.getCache(name);
            com.github.benmanes.caffeine.cache.Cache<Object, Object> caffeineCache =
                    (com.github.benmanes.caffeine.cache.Cache<Object, Object>) cache.getNativeCache();

            Map<String, Object> stats = new LinkedHashMap<>();
            stats.put("size", caffeineCache.estimatedSize());

            List<Map<String, Object>> entries = new ArrayList<>();
            caffeineCache.asMap().forEach((key, value) -> {
                Map<String, Object> entry = new LinkedHashMap<>();
                entry.put("key", key);
                entry.put("value", value);
                // 剩余时间获取
                caffeineCache.policy().expireAfterWrite().ifPresent(policy -> {
                    Optional<Duration> durationOpt = policy.ageOf(key);
                    if (durationOpt.isPresent()) {
                        //1.查询当前设置的过期时间
                        Duration expiresDuration = policy.getExpiresAfter();
                        //2.获取当前key已经存活的时间
                        Duration survivalDuration = durationOpt.get();
                        //3.获取剩余时间
                        Duration remainDuration = expiresDuration.minus(survivalDuration);
                        //4.剩余时间计算
                        entry.put("ttlMillis", remainDuration.toMillis());
                        //5.剩余时间格式化
                        entry.put("ttlHuman", formatDuration(remainDuration));
                    }
                });

                entries.add(entry);
            });
            stats.put("entries", entries);

            cacheInfo.put(name, stats);
        });
        return cacheInfo;
    }

    // 辅助方法：格式化时间显示
    private String formatDuration(Duration duration) {
        return String.format("%d天 %02d:%02d:%02d",
                duration.toDays(),
                duration.toHours() % 24,
                duration.toMinutes() % 60,
                duration.getSeconds() % 60);
    }
}
```

[详细说明](https://blog.csdn.net/ethunsex/article/details/66475792)

### @Configuration

```java
@Configuration("name") // 表示这是一个配置信息类,可以给这个配置类也起一个名称
@ComponentScan("spring4") // 类似于xml中的<context:component-scan base-package="spring4"/>
public class Config {
    @Autowired // 自动注入，如果容器中有多个符合的bean时，需要进一步明确
    @Qualifier("compent") // 进一步指明注入bean名称为compent的bean
    private Compent compent;

    @Bean // 类似于xml中的<bean id="newbean" class="spring4.Compent"/>
    public Compent newbean(){
        return new Compent();
    }   
}
```

### @Import(Config1.class)

- 导入Config1配置类里实例化的bean

```java
@Configuration
public class CDConfig {
    @Bean   // 将SgtPeppers注册为 SpringContext中的bean
    public CompactDisc compactDisc() {
        return new CompactDisc();  // CompactDisc类型的
    }
}

@Configuration
@Import(CDConfig.class)  // 导入CDConfig的配置
public class CDPlayerConfig {
    @Bean(name = "cDPlayer")
    public CDPlayer cdPlayer(CompactDisc compactDisc) {  
        // 这里会注入CompactDisc类型的bean
        // 这里注入的这个bean是CDConfig.class中的CompactDisc类型的那个bean
        return new CDPlayer(compactDisc);
    }
}
```

### @Order

- `@Order(1)`，值越小优先级超高，越先运行

### @ConditionalOnExpression

```java
@Configuration
@ConditionalOnExpression("${enabled:false}")
public class BigpipeConfiguration {
    @Bean
    public OrderMessageMonitor orderMessageMonitor(ConfigContext configContext) {
        return new OrderMessageMonitor(configContext);
    }
}
```

- 开关为true的时候才实例化bean

### @ConditionalOnProperty

- 这个注解能够控制某个`@Configuration`是否生效
- 具体操作是通过其两个属性`name`以及`havingValue`来实现的，其中`name`用来从`application.properties`中读取某个属性值，如果该值为空，则返回false；如果值不为空，则将该值与`havingValue`指定的值进行比较，如果一样则返回true；否则返回false
- 如果返回值为false，则该configuration不生效；为true则生效
- 参考：[详细说明](https://blog.csdn.net/dalangzhonghangxing/article/details/78420057)

### @ConditionalOnClass

- 该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类

```java
@Configuration
@ConditionalOnClass({Gson.class})
public class GsonAutoConfiguration {
    public GsonAutoConfiguration() {
    }

    @Bean
    @ConditionalOnMissingBean
    public Gson gson() {
        return new Gson();
    }
}
```

### @ConditionalOnMissingClass({ApplicationManager.class})

- 如果存在它修饰的类的bean，则不需要再创建这个bean

### @ConditionalOnMissingBean(name = "example")

- 表示如果name为"example"的bean存在，该注解修饰的代码块不执行
# 二十五、▶SpringBoot接口 - 如何统一接口封装
## 25.1 RESTful API接口?
- 什么是 REST？

Representational State Transfer，翻译是“表现层状态转化”。可以总结为一句话：**REST 是所有 Web 应用都应该遵守的架构设计指导原则。**

面向资源是 REST 最明显的特征，对于同一个资源的一组不同的操作。资源是服务器上一个可命名的抽象概念，资源是以名词为核心来组织的，首先关注的是名词。REST 要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。
- 什么是 RESTful API？

**符合 REST 设计标准的 API**，即 RESTful API。REST 架构设计，遵循的各项标准和准则，就是 HTTP 协议的表现，换句话说，HTTP 协议就是属于 REST 架构的设计模式。比如，无状态，请求-响应。

Restful相关文档可以参考 https://restfulapi.net/
## 25.2 为什么要统一封装接口
> 现在大多数项目采用前后分离的模式进行开发，统一返回方便前端进行开发和封装，以及出现时给出响应编码和信息

以查询某个用户接口而言，如果没有封装, 返回结果如下
```json
{
  "userId": 1,
  "userName": "赵一"
}
```
如果封装了，返回正常的结果如下：
```json
{
  "timestamp": 11111111111,
  "status": 200,
  "message": "success",
  "data": {
    "userId": 1,
    "userName": "赵一"
  }
}
```
异常返回结果如下：
```json
{
  "timestamp": 11111111111,
  "status": 10001,
  "message": "User not exist",
  "data": null
}
```
## 25.3 实现案例
> 如何实现上面的封装呢？
### 25.3.1 状态码封装

这里以常见的状态码为例，包含responseCode 和 description两个属性。

如果还有其它业务状态码，也可以放到这个类中。
```java

@Getter
@AllArgsConstructor
public enum ResponseStatus {

    SUCCESS("200", "success"),
    FAIL("500", "failed"),

    HTTP_STATUS_200("200", "ok"),
    HTTP_STATUS_400("400", "request error"),
    HTTP_STATUS_401("401", "no authentication"),
    HTTP_STATUS_403("403", "no authorities"),
    HTTP_STATUS_500("500", "server error");

    public static final List<ResponseStatus> HTTP_STATUS_ALL = Collections.unmodifiableList(
            Arrays.asList(HTTP_STATUS_200, HTTP_STATUS_400, HTTP_STATUS_401, HTTP_STATUS_403, HTTP_STATUS_500
            ));

    /**
     * response code
     */
    private final String responseCode;

    /**
     * description.
     */
    private final String description;

}
```
### 25.3.2 返回内容封装
包含公共的接口返回时间，状态status, 消息message， 以及数据data。

考虑到数据的序列化（比如在网络上传输），这里data有时候还会extends Serializable。
```java
@Data
@Builder
public class ResponseResult<T> {

    /**
     * response timestamp.
     */
    private long timestamp;

    /**
     * response code, 200 -> OK.
     */
    private String status;

    /**
     * response message.
     */
    private String message;

    /**
     * response data.
     */
    private T data;

    /**
     * response success result wrapper.
     *
     * @param <T> type of data class
     * @return response result
     */
    public static <T> ResponseResult<T> success() {
        return success(null);
    }

    /**
     * response success result wrapper.
     *
     * @param data response data
     * @param <T>  type of data class
     * @return response result
     */
    public static <T> ResponseResult<T> success(T data) {
        return ResponseResult.<T>builder().data(data)
                .message(ResponseStatus.SUCCESS.getDescription())
                .status(ResponseStatus.SUCCESS.getResponseCode())
                .timestamp(System.currentTimeMillis())
                .build();
    }

    /**
     * response error result wrapper.
     *
     * @param message error message
     * @param <T>     type of data class
     * @return response result
     */
    public static <T extends Serializable> ResponseResult<T> fail(String message) {
        return fail(null, message);
    }

    /**
     * response error result wrapper.
     *
     * @param data    response data
     * @param message error message
     * @param <T>     type of data class
     * @return response result
     */
    public static <T> ResponseResult<T> fail(T data, String message) {
        return ResponseResult.<T>builder().data(data)
                .message(message)
                .status(ResponseStatus.FAIL.getResponseCode())
                .timestamp(System.currentTimeMillis())
                .build();
    }

}
```
### 25.3.3 接口返回时调用
在接口返回时调用, 以用户接口为例
```java
/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId()==null || !userService.exists(user.getId())) {
            user.setCreateTime(LocalDateTime.now());
            user.setUpdateTime(LocalDateTime.now());
            userService.save(user);
        } else {
            user.setUpdateTime(LocalDateTime.now());
            userService.update(user);
        }
        return ResponseResult.success(userService.find(user.getId()));
    }


    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.find(userId));
    }
}
```
### 25.3.4：优化(使用@RestControllerAdvice统一处理返回值进行封装)
```java
@RestControllerAdvice
public class ResponseWrapperHandler implements ResponseBodyAdvice<Object> {
    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        //对于swagger资源为静态资源，不进行统一封装处理
        //1.获取当前Controller类的包名
        String packageName = returnType.getContainingClass().getPackage().getName();
        //2.排除Swagger/actuator相关Controller（springfox.documentation为swagger2，org.springdoc.web为swagger3）
        boolean isExclusion =
                packageName.startsWith("springfox.documentation") ||  // SpringFox
                        packageName.startsWith("org.springdoc.web") ||          // SpringDoc
                        packageName.startsWith("org.springframework.boot.actuate")//actuator
                ;
        return !isExclusion && !returnType.getParameterType().isAssignableFrom(BaseResponse.class)
                && !returnType.hasMethodAnnotation(IgnoreResponseWrapper.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {
        //响应体需要返回字符串类型时转化为json
        if (body instanceof String) {
            response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
            return JacksonTool.object2Json(new BaseResponse<>(body));
        }

        // 已经包装的响应-避免重复包装
        if (body instanceof BaseResponse) {
            return body;
        }

        return new BaseResponse<>(body);
    }
}
```
### 25.3.5 优化：统一异常拦截
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * 捕获和处理参数验证中的方法参数无效异常MethodArgumentNotValidException case: JSON格式的包装类异常，如@ResponsBody @Valid User user
     *
     * @param e 异常对象
     * @return 基础返回类型，增加了解析后的错误信息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler({MethodArgumentNotValidException.class})
    public BaseResponse<Map<String, String>> methodArgumentNotValidExceptionHandler(
            MethodArgumentNotValidException e) {
        BindingResult result = e.getBindingResult();
        Map<String, String> errorMap = new HashMap<>();
        setErrorMap(result, errorMap);
        logger.error(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode() + ":" + I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode()), e);
        return new BaseResponse<>(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode(),
                I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode()) + e.getMessage());
    }

    /**
     * 捕获和处理参数验证中的异常BindException case：表单格式的包装类异常，如@Valid User user
     *
     * @param e 异常对象
     * @return 基础返回类型，增加了解析后的错误信息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler({BindException.class})
    public BaseResponse<Map<String, String>> bindExceptionHandler(BindException e) {
        BindingResult result = e.getBindingResult();
        Map<String, String> errorMap = new HashMap<>();
        setErrorMap(result, errorMap);
        logger.error(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode() + ":" + I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode()), e);
        return new BaseResponse<>(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode(),
                I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode()));
    }


    /**
     * 捕获运行时的异常BusinessException
     *
     * @param e 异常对象
     * @return 基础返回类型，增加了解析后的错误信息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler({BaseException.class})
    public BaseResponse<?> bindExceptionHandler(BaseException e) {
        logger.error(e.getCode() + ":" + e.getMsg(), e);
        return new BaseResponse<>(e.getCode(), e.getMsg());
    }

    /**
     * 捕获和处理参数验证中的违反实体定义的约束异常ConstraintViolationException case：@RequestParam的原生注解异常
     *
     * @param e 异常对象
     * @return 基础返回类型，增加了解析后的错误信息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(value = {ConstraintViolationException.class})
    public BaseResponse<Map<String, String>> constraintViolationExceptionHandler(
            ConstraintViolationException e) {
        logger.error(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode() + ":" + I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode()), e);
        return new BaseResponse<>(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode(),
                I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_PARAMS_IS_ILLEGAL.getCode()));
    }

    /**
     * 处理请求方法不支持异常
     *
     * @param ex 异常对象
     * @return 标准化错误响应
     */
    @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public BaseResponse<?> handleHttpRequestMethodNotSupported(
            HttpRequestMethodNotSupportedException ex,
            HttpServletRequest request) {

        // 构建错误信息明细
        Map<String, Object> details = new LinkedHashMap<>();
        details.put("path", request.getRequestURI());
        details.put("attemptedMethod", ex.getMethod());
        details.put("supportedMethods", ex.getSupportedHttpMethods());
        logger.error(BaseErrorCode.ERR_METHOD_NOT_ALLOWED.getCode() + ":" + I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_METHOD_NOT_ALLOWED.getCode()) + JacksonTool.object2Json(details), ex);
        return new BaseResponse<>(
                BaseErrorCode.ERR_METHOD_NOT_ALLOWED.getCode(),
                I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_METHOD_NOT_ALLOWED.getCode(), JacksonTool.object2Json(details))
        );
    }

    /**
     * 捕获未处理的系统级异常
     */
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(value = Exception.class)
    public BaseResponse<?> systemExceptionHandler(Exception e) {
        logger.error(BaseErrorCode.ERR_SYSTEM_ERROR.getCode() + ":" + I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_SYSTEM_ERROR.getCode()), e);
        return new BaseResponse<>(
                BaseErrorCode.ERR_SYSTEM_ERROR.getCode(),
                I18nUtil.getI18nValueByErrorCode(BaseErrorCode.ERR_SYSTEM_ERROR.getCode()) + CommonConstant.COLON + e.getMessage()
        );
    }


    private void setErrorMap(BindingResult result, Map<String, String> errorMap) {
        for (ObjectError error : result.getAllErrors()) {
            String msg = error.getDefaultMessage();
            String objectName = StringUtils.trim(error.getObjectName());
            if (StringUtils.isNotBlank(objectName)) {
                objectName += ".";
            }
            if (error instanceof FieldError) {
                // fieldError
                String field = StringUtils.trim(((FieldError) error).getField());
                if (StringUtils.isNotBlank(field)) {
                    field += ".";
                }
                errorMap.put(objectName + field, msg);
            } else {
                // 普通Error
                String code = error.getCode();
                errorMap.put(objectName + code, msg);
            }
        }
    }


}
```
# 二十六、SpringBoot接口 - 如何对参数进行校验
## 26.1 什么是不优雅的参数校验
后端对前端传过来的参数也是需要进行校验的，如果在controller中直接校验需要用大量的if else做判断

以添加用户的接口为例，需要对前端传过来的参数进行校验， 如下的校验就是不优雅的：
```java
@RestController
@RequestMapping("/user")
public class UserController {

    @PostMapping("add")
    public ResponseEntity<String> add(User user) {
        if(user.getName()==null) {
            return ResponseResult.fail("user name should not be empty");
        } else if(user.getName().length()<5 || user.getName().length()>50){
            return ResponseResult.fail("user name length should between 5-50");
        }
        if(user.getAge()< 1 || user.getAge()> 150) {
            return ResponseResult.fail("invalid age");
        }
        // ...
        return ResponseEntity.ok("success");
    }
}
```
针对这个普遍的问题，Java开发者在Java API规范 (JSR303) 定义了Bean校验的标准validation-api，但没有提供实现。

hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。

Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。

接下来，我们以springboot项目为例，介绍Spring Validation的使用。

## 26.2 实现案例
> 本例子采用 spring validation 对参数绑定进行校验，主要给你提供参数校验的思路。针对接口统一的错误信息（比如绑定参数检查的错误）封装请看SpringBoot接口 - 如何统一异常处理。
### 26.2.1 POM
添加pom依赖
```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```
### 26.2.2 请求参数封装
单一职责，所以将查询用户的参数封装到UserParam中， 而不是User（数据库实体）本身。

对每个参数字段添加validation注解约束和message。
```java
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "could not be empty")
    private String userId;

    @NotEmpty(message = "could not be empty")
    @Email(message = "invalid email")
    private String email;

    @NotEmpty(message = "could not be empty")
    @Pattern(regexp = "^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$", message = "invalid ID")
    private String cardNo;

    @NotEmpty(message = "could not be empty")
    @Length(min = 1, max = 10, message = "nick name should be 1-10")
    private String nickName;

    @NotEmpty(message = "could not be empty")
    @Range(min = 0, max = 1, message = "sex should be 0-1")
    private int sex;

    @Max(value = 100, message = "Please input valid age")
    private int age;

    @Valid
    private AddressParam address;

}
```
### 26.2.3 Controller中获取参数绑定结果
使用@Valid或者@Validated注解，参数校验的值放在BindingResult中
```java
@Slf4j
@Api(value = "User Interfaces", tags = "User Interfaces")
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("add")
    public ResponseEntity<String> add(@Valid @RequestBody UserParam userParam, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            List<ObjectError> errors = bindingResult.getAllErrors();
            errors.forEach(p -> {
                FieldError fieldError = (FieldError) p;
                log.error("Invalid Parameter : object - {},field - {},errorMessage - {}", fieldError.getObjectName(), fieldError.getField(), fieldError.getDefaultMessage());
            });
            return ResponseEntity.badRequest().body("invalid parameter");
        }
        return ResponseEntity.ok("success");
    }
}
```
### 26.2.4 校验结果
POST访问添加User的请求 后台输出参数绑定错误信息：（包含哪个对象，哪个字段，什么样的错误描述）
```java
2021-09-16 10:37:05.173 ERROR 21216 --- [nio-8080-exec-8] t.p.s.v.controller.UserController        : Invalid Parameter : object - userParam,field - nickName,errorMessage - could not be empty
2021-09-16 10:37:05.176 ERROR 21216 --- [nio-8080-exec-8] t.p.s.v.controller.UserController        : Invalid Parameter : object - userParam,field - email,errorMessage - could not be empty
2021-09-16 10:37:05.176 ERROR 21216 --- [nio-8080-exec-8] t.p.s.v.controller.UserController        : Invalid Parameter : object - userParam,field - cardNo,errorMessage - could not be empty
```
## 26.3 进一步理解
### 26.3.1 Validation分组校验？
> 上面的例子中，其实存在一个问题，UserParam既可以作为addUser的参数（id为空），又可以作为updateUser的参数（id不能为空），这时候怎么办呢？分组校验登场。
```java
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "could not be empty") // 这里定为空，对于addUser时是不合适的
    private String userId;

}
```
这时候可以使用Validation分组
- 先定义分组（无需实现接口）
```java
public interface AddValidationGroup {
}
public interface EditValidationGroup {
}
```
- 在UserParam的userId字段添加分组
```java
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "{user.msg.userId.notEmpty}", groups = {EditValidationGroup.class}) // 这里
    private String userId;

}
```
- controller中的接口使用校验时使用分组

PS:**需要使用@Validated注解**
```java
@Slf4j
@Api(value = "User Interfaces", tags = "User Interfaces")
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("add")
    public ResponseEntity<UserParam> add(@Validated(AddValidationGroup.class) @RequestBody UserParam userParam) {
        return ResponseEntity.ok(userParam);
    }

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Edit User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("edit")
    public ResponseEntity<UserParam> edit(@Validated(EditValidationGroup.class) @RequestBody UserParam userParam) {
        return ResponseEntity.ok(userParam);
    }
}
```
### 26.3.2 @Validated和@Valid什么区别？
> 细心的你会发现，上个例子中用的是@Validated, 而不是@Valid，那它们之间的区别是什么呢？

在检验Controller的入参是否符合规范时，使用@Validated或者@Valid在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：

- 分组
  - @Validated：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制，这个网上也有资料，不详述。
  - @Valid：作为标准JSR-303规范，还没有吸收分组的功能。
- 注解地方
  - @Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上
  - @Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上
- 嵌套类型
  - 比如本文例子中的address是user的一个嵌套属性, 只能用@Valid
```java
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @Valid // 这里只能用@Valid
    private AddressParam address;

}
```
### 26.3.3 有哪些常用的校验？
> 从以下三类理解。
- JSR303/JSR-349: JSR303是一项标准,只提供规范不提供实现，规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，位于javax.validation.constraints包下。JSR-349是其的升级版本，添加了一些新特性。
```java
@AssertFalse            被注释的元素只能为false
@AssertTrue             被注释的元素只能为true
@DecimalMax             被注释的元素必须小于或等于{value}
@DecimalMin             被注释的元素必须大于或等于{value}
@Digits                 被注释的元素数字的值超出了允许范围(只允许在{integer}位整数和{fraction}位小数范围内)
@Email                  被注释的元素不是一个合法的电子邮件地址
@Future                 被注释的元素需要是一个将来的时间
@FutureOrPresent        被注释的元素需要是一个将来或现在的时间
@Max                    被注释的元素最大不能超过{value}
@Min                    被注释的元素最小不能小于{value}
@Negative               被注释的元素必须是负数
@NegativeOrZero         被注释的元素必须是负数或零
@NotBlank               被注释的元素不能为空
@NotEmpty               被注释的元素不能为空
@NotNull                被注释的元素不能为null
@Null                   被注释的元素必须为null
@Past                   被注释的元素需要是一个过去的时间
@PastOrPresent          被注释的元素需要是一个过去或现在的时间
@Pattern                被注释的元素需要匹配正则表达式"{regexp}"
@Positive               被注释的元素必须是正数
@PositiveOrZero         被注释的元素必须是正数或零
@Size                   被注释的元素个数必须在{min}和{max}之间
```
- hibernate validation：hibernate validation是对这个规范的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等
```java
@CreditCardNumber       被注释的元素不合法的信用卡号码
@Currency               被注释的元素不合法的货币 (必须是{value}其中之一)
@EAN                    被注释的元素不合法的{type}条形码
@Email                  被注释的元素不是一个合法的电子邮件地址  (已过期)
@Length                 被注释的元素长度需要在{min}和{max}之间
@CodePointLength        被注释的元素长度需要在{min}和{max}之间
@LuhnCheck              被注释的元素${validatedValue}的校验码不合法, Luhn模10校验和不匹配
@Mod10Check             被注释的元素${validatedValue}的校验码不合法, 模10校验和不匹配
@Mod11Check             被注释的元素${validatedValue}的校验码不合法, 模11校验和不匹配
@ModCheck               被注释的元素${validatedValue}的校验码不合法, ${modType}校验和不匹配  (已过期)
@NotBlank               被注释的元素不能为空  (已过期)
@NotEmpty               被注释的元素不能为空  (已过期)
@ParametersScriptAssert 被注释的元素执行脚本表达式"{script}"没有返回期望结果
@Range                  被注释的元素需要在{min}和{max}之间
@SafeHtml               被注释的元素可能有不安全的HTML内容
@ScriptAssert           被注释的元素执行脚本表达式"{script}"没有返回期望结果
@URL                    被注释的元素需要是一个合法的URL
@DurationMax            被注释的元素必须小于${inclusive == true ? '或等于' : ''}${days == 0 ? '' : days += '天'}${hours == 0 ? '' : hours += '小时'}${minutes == 0 ? '' : minutes += '分钟'}${seconds == 0 ? '' : seconds += '秒'}${millis == 0 ? '' : millis += '毫秒'}${nanos == 0 ? '' : nanos += '纳秒'}
@DurationMin            被注释的元素必须大于${inclusive == true ? '或等于' : ''}${days == 0 ? '' : days += '天'}${hours == 0 ? '' : hours += '小时'}${minutes == 0 ? '' : minutes += '分钟'}${seconds == 0 ? '' : seconds += '秒'}${millis == 0 ? '' : millis += '毫秒'}${nanos == 0 ? '' : nanos += '纳秒'}
```
- spring validation：spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中
### 26.3.4 自定义validation？
> 如果上面的注解不能满足我们检验参数的要求，我们能不能自定义校验规则呢？ 可以。
- 定义注解
```java
package tech.pdai.springboot.validation.group.validation.custom;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {TelephoneNumberValidator.class}) // 指定校验器
public @interface TelephoneNumber {
    String message() default "Invalid telephone number";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };
}
```
| 参数 | 作用 | 使用频率 |
|------|------|----------|
| `message` | 定义校验失败的错误消息 | ⭐⭐⭐⭐⭐（必用） |
| `groups` | 实现不同场景的校验规则 | ⭐⭐⭐⭐（常用） |
| `payload` | 携带校验的元数据信息 | ⭐（较少使用） |

**核心理解**：
1. `message`：告诉用户"哪里错了"
2. `groups`：告诉框架"什么时候校验"  
3. `payload`：告诉程序"如何处理这个错误"

- 定义校验器
```java
public class TelephoneNumberValidator implements ConstraintValidator<TelephoneNumber, String> {
    private static final String REGEX_TEL = "0\\d{2,3}[-]?\\d{7,8}|0\\d{2,3}\\s?\\d{7,8}|13[0-9]\\d{8}|15[1089]\\d{8}";

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        try {
            return Pattern.matches(REGEX_TEL, s);
        } catch (Exception e) {
            return false;
        }
    }

}
```
- 使用
```java
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "{user.msg.userId.notEmpty}", groups = {EditValidationGroup.class})
    private String userId;

    @TelephoneNumber(message = "invalid telephone number") // 这里
    private String telephone;

}
```
# 二十七、SpringBoot接口 - 如何参数校验国际化
## 27.1 什么是国际化
软件的国际化：软件开发时，要使它能同时应对世界不同地区和国家的访问，并针对不同地区和国家的访问，提供相应的、符合来访者阅读习惯的页面或数据。国际化又称为 i18n：internationalization
## 27.2 实现案例
> 这里实现一个案例: 语言切换和国际化（中英文）验证信息。
### 27.2.1 定义资源文件
在Resources下添加如下：
![141.springboot-interface-param-4.png](../../assets/images/04-主流框架/spring/141.springboot-interface-param-4.png)
填写名称和资源语言类型
![142.springboot-interface-param-3.png](../../assets/images/04-主流框架/spring/142.springboot-interface-param-3.png)
添加中英文对应的message
![143.springboot-interface-param-5.png](../../assets/images/04-主流框架/spring/143.springboot-interface-param-5.png)
### 27.2.2 使用message
```java
@Data
@Builder
@ApiModel(value = "User", subTypes = {AddressParam.class})
public class UserParam implements Serializable {

    private static final long serialVersionUID = 1L;

    @NotEmpty(message = "{user.msg.userId.notEmpty}") // 这里
    private String userId;
```
### 27.2.3 中英文切换拦截
由于默认是拦截request参数获取locale参数来实现的切换语言，这里我们可以改下，优先从header中获取，如果没有获取到再从request参数中获取（LocaleChangeInterceptor默认是从请求参数中获取的，子类CustomLocaleChangeInterceptor从请求头中获取）。
```java
package tech.pdai.springboot.validation.i18n.config;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import lombok.extern.slf4j.Slf4j;
import org.springframework.lang.NonNull;
import org.springframework.util.ObjectUtils;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
import org.springframework.web.servlet.support.RequestContextUtils;

/**
 * custom locale change interceptor.
 *
 * @author pdai
 */
@Slf4j
public class CustomLocaleChangeInterceptor extends LocaleChangeInterceptor {

    /**
     * try to get locale from header, if not exist then get it from request parameter.
     *
     * @param request  request
     * @param response response
     * @param handler  handler
     * @return bool
     * @throws ServletException ServletException
     */
    @Override
    public boolean preHandle(HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull Object handler) throws ServletException {
        //从请求头中获取参数(getParamName()为该类属性，通过拦截器实现设置)
        String newLocale = request.getHeader(getParamName());
        if (newLocale!=null) {
            if (checkHttpMethods(request.getMethod())) {
                LocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);
                if (localeResolver==null) {
                    throw new IllegalStateException("No LocaleResolver found: not in a DispatcherServlet request?");
                }
                try {
                    localeResolver.setLocale(request, response, parseLocaleValue(newLocale));
                } catch (IllegalArgumentException ex) {
                    if (isIgnoreInvalidLocale()) {
                        log.debug("Ignoring invalid locale value [" + newLocale + "]: " + ex.getMessage());
                    } else {
                        throw ex;
                    }
                }
            }
            return true;
        } else {
            return super.preHandle(request, response, handler);
        }
    }

    private boolean checkHttpMethods(String currentMethod) {
        String[] configuredMethods = getHttpMethods();
        if (ObjectUtils.isEmpty(configuredMethods)) {
            return true;
        }
        for (String configuredMethod : configuredMethods) {
            if (configuredMethod.equalsIgnoreCase(currentMethod)) {
                return true;
            }
        }
        return false;
    }
}
```
初始化相关配置
```java
package tech.pdai.springboot.validation.i18n.config;

import java.util.Locale;

import lombok.RequiredArgsConstructor;
import org.springframework.boot.validation.MessageInterpolatorFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ResourceBundleMessageSource;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
import org.springframework.web.servlet.i18n.SessionLocaleResolver;

/**
 * This class is for web config.
 *
 * @author pdai
 */
@Configuration
@RequiredArgsConstructor
public class WebConfig implements WebMvcConfigurer {

    /**
     * lang param name in header, default to 'locale'.
     */
    // 设置默认请求参数locale，后续携带该字符的请求头或者请求参数
    private static final String LANGUAGE_PARAM_NAME = LocaleChangeInterceptor.DEFAULT_PARAM_NAME;

    /**
     * message source.
     */
    private final ResourceBundleMessageSource resourceBundleMessageSource;

    /**
     * default locale.
     *
     * @return locale resolver
     */
    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver localeResolver = new SessionLocaleResolver();
        localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);
        return localeResolver;
    }

    /**
     * local validator factory bean.
     *
     * @return LocalValidatorFactoryBean
     */
    @Bean
    public LocalValidatorFactoryBean localValidatorFactoryBean() {
        LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
        MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory();
        factoryBean.setMessageInterpolator(interpolatorFactory.getObject());
        factoryBean.setValidationMessageSource(resourceBundleMessageSource);
        return factoryBean;
    }

    /**
     * locale change interceptor.
     *
     * @return LocaleChangeInterceptor
     */
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new CustomLocaleChangeInterceptor();
        interceptor.setParamName(LANGUAGE_PARAM_NAME);
        return interceptor;
    }

    /**
     * register locale change interceptor.
     *
     * @param registry registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}
```
## 27.3 校验
- 设置语言是中文
![144.springboot-interface-param-7.png](../../assets/images/04-主流框架/spring/144.springboot-interface-param-7.png)

查看校验结果
![145.springboot-interface-param-6.png](../../assets/images/04-主流框架/spring/145.springboot-interface-param-6.png)

## 扩展：我在项目中如何实现的多语言
由于特殊情况，我需要将多语言实现在指定目录下，按照规范来说，例如在zh_CN文件夹下的properties文件就是中文多语言，en_US文件夹下的properties文件就是英文。所以这里涉及自定义多语言文件的解析规则。下面是我的实现方式
### 1.继承ReloadableResourceBundleMessageSource，重写calculateAllFilenames方法
```java
public class TransReloadableResourceBundleMessageSource extends ReloadableResourceBundleMessageSource {

    private static final Logger logger = LoggerFactory.getLogger(TransReloadableResourceBundleMessageSource.class);

    @Value("${i18n.back-end.location}")
    private String i18nPath;

    private final ConcurrentMap<String, List<String>> cachedFilenamesMap = new ConcurrentHashMap<>();

    //自定义多语言文件读取逻辑
    @Override
    protected List<String> calculateAllFilenames(String basename, Locale locale) {
        String language = locale.getLanguage();
        String country = locale.getCountry();
        String variant = locale.getVariant();
        String cacheFilenamesKey;
        if (country.length() > 0 && variant.length() > 0) {
            cacheFilenamesKey = language + "_" + country + "_" + variant;
        } else if (country.length() > 0) {
            cacheFilenamesKey = language + "_" + country;
        } else {
            cacheFilenamesKey = language;
        }
        List<String> cachedFilenames = this.cachedFilenamesMap.get(cacheFilenamesKey);
        if (cachedFilenames != null) {
            return cachedFilenames;
        }
        List<String> filenames = new LinkedList<>();
        Resource resource = new FileSystemResource(i18nPath);
        if (resource.exists()) {
            try {
                if (resource.getFile().isDirectory()) {
                    File[] localeDirs = resource.getFile().listFiles();
                    if (localeDirs == null || localeDirs.length == 0) {
                        return filenames;
                    }
                    Arrays.stream(localeDirs).forEach(localeDir -> {
                        String localeDirName = localeDir.getName();
                        String[] parts = localeDirName.split("_");
                        Locale currentDirLocale;
                        if (parts.length == 1) {
                            currentDirLocale = new Locale(parts[0]);
                        } else if (parts.length == 2) {
                            currentDirLocale = new Locale(parts[0], parts[1]);
                        } else {
                            currentDirLocale = new Locale(parts[0], parts[1], parts[2]);
                        }

                        if (localeDirName.equals(cacheFilenamesKey)) {
                            filenames.addAll(0, getLocaleFilenames(localeDir, currentDirLocale));
                        } else if (parts[0].equals("en")) {
                            filenames.addAll(filenames.size(), getLocaleFilenames(localeDir, currentDirLocale));
                        }
                    });
                }
            } catch (IOException e) {
                logger.debug("file error:", e);
            }
        }

        if (filenames.size() == 1 && filenames.get(0).contains("en_US") && !"en".equals(language)) {
            return filenames;
        }
        if (filenames.size() > 0) {
            cachedFilenamesMap.put(cacheFilenamesKey, filenames);
        }
        return filenames;
    }

    private List<String> getLocaleFilenames(File localeDir, Locale locale) {
        List<String> filenames = new LinkedList<>();
        File[] languageFiles = localeDir.listFiles();
        if (languageFiles != null && languageFiles.length > 0) {
            for (File languageFile : languageFiles) {
                String realBasename = languageFile.toURI().toString().replace(".properties", "");
                List<String> calculatedFileNames = super.calculateAllFilenames(realBasename, locale);
                filenames.addAll(calculatedFileNames);
            }
        }
        return filenames;
    }

    @Override
    protected List<String> calculateFilenamesForLocale(String basename, Locale locale) {
        return Collections.emptyList();
    }
}
```
### 2.自定义LocaleResolver
```java
public class HeaderLocaleResolver implements LocaleResolver {
    private static final Logger logger = LoggerFactory.getLogger(HeaderLocaleResolver.class);

    private static final String LANGUAGE_HEADER = "X-Locale";
    private static final Locale DEFAULT_LOCALE = Locale.US;

    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        logger.debug("=== Resolving locale for " + request.getRequestURI() + "===");
        Locale currentLanguage = DEFAULT_LOCALE;
        String language = request.getHeader(LANGUAGE_HEADER);
        if (StringUtils.isNotEmpty(language)) {
            try {
                currentLanguage = LocaleUtils.parseLocale(language);
            } catch (Exception ignored) {
                logger.info("=== Can't resolving locale for " + request.getRequestURI() + " Use default locale en_US ===");
            }
        }
        LocaleContextHolder.setLocale(currentLanguage);
        return currentLanguage;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {
    }
}
```
### 3.装配自定义的MessageSource和LocaleResolver
```java
@Configuration
public class I18nConfig {

    @Value("${i18n.back-end.location}")
    private String backEndLocation;

    @Bean
    public MessageSource messageSource() {

        TransReloadableResourceBundleMessageSource messageSource = new TransReloadableResourceBundleMessageSource();
        messageSource.setBasename("file:" + backEndLocation + "/messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setDefaultLocale(Locale.US);
        messageSource.setCacheSeconds(3600);
        return messageSource;
    }

    @Bean
    public LocaleResolver localeResolver() {
        return new HeaderLocaleResolver();
    }
}
```
### 4.实现多语言类型的ThreadLocal
```java
public class LocaleContextHolder {
    private static final ThreadLocal<Locale> localeHolder = new ThreadLocal<>();

    public static void setLocale(Locale locale) {
        if (locale == null) {
            localeHolder.remove();
        } else {
            localeHolder.set(locale);
        }
    }

    public static Locale getLocale() {
        Locale locale = localeHolder.get();
        return locale != null ? locale : Locale.US; // 默认英文
    }

    public static void clear() {
        localeHolder.remove();
    }
}
```
### 5.自定义拦截器
```java
public class LocaleInterceptor implements HandlerInterceptor {

    private static HeaderLocaleResolver headerLocaleResolver;


    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {

        if (headerLocaleResolver == null) {
            headerLocaleResolver = SpringContextHolder.getBean(HeaderLocaleResolver.class);
        }
        headerLocaleResolver.resolveLocale(request);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) {
        LocaleContextHolder.clear();
    }
}
```
### 6.注册连接器
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LocaleInterceptor()).order(Ordered.HIGHEST_PRECEDENCE);
    }
}
```
上述代码我并没有使用spring提供的LocaleChangeInterceptor 去处理多语言类型缓存。而由于我们已经重写了MessageSource，天然的就能够实现vaild按照我们指定的多语言规则实现
# 二十八、SpringBoot接口 - 如何统一异常处理
## 28.1 为什么要优雅的处理异常
如果我们不统一的处理异常，经常会在controller层有大量的异常处理的代码， 比如：
```java
@Slf4j
@Api(value = "User Interfaces", tags = "User Interfaces")
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("add")
    public ResponseEntity<String> add(@Valid @RequestBody UserParam userParam) {
        // 每个接口充斥着大量的异常处理
        try {
            // do something
        } catch(Exception e) {
            return ResponseEntity.fail("error");
        }
        return ResponseEntity.ok("success");
    }
}
```
那怎么实现统一的异常处理，特别是结合参数校验等封装？

## 28.2 实现案例
简单展示通过@ControllerAdvice进行统一异常处理。

### 28.2.1 @ControllerAdvice异常统一处理
对于400参数错误异常
```java
/**
 * Global exception handler.
 *
 * @author pdai
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * exception handler for bad request.
     *
     * @param e
     *            exception
     * @return ResponseResult
     */
    @ResponseBody
    @ResponseStatus(code = HttpStatus.BAD_REQUEST)
    @ExceptionHandler(value = { BindException.class, ValidationException.class, MethodArgumentNotValidException.class })
    public ResponseResult<ExceptionData> handleParameterVerificationException(@NonNull Exception e) {
        ExceptionData.ExceptionDataBuilder exceptionDataBuilder = ExceptionData.builder();
        log.warn("Exception: {}", e.getMessage());
        if (e instanceof BindException) {
            BindingResult bindingResult = ((MethodArgumentNotValidException) e).getBindingResult();
            bindingResult.getAllErrors().stream().map(DefaultMessageSourceResolvable::getDefaultMessage)
                    .forEach(exceptionDataBuilder::error);
        } else if (e instanceof ConstraintViolationException) {
            if (e.getMessage() != null) {
                exceptionDataBuilder.error(e.getMessage());
            }
        } else {
            exceptionDataBuilder.error("invalid parameter");
        }
        return ResponseResultEntity.fail(exceptionDataBuilder.build(), "invalid parameter");
    }

}
```
对于自定义异常
```java
/**
 * handle business exception.
 *
 * @param businessException
 *            business exception
 * @return ResponseResult
 */
@ResponseBody
@ExceptionHandler(BusinessException.class)
public ResponseResult<BusinessException> processBusinessException(BusinessException businessException) {
    log.error(businessException.getLocalizedMessage(), businessException);
    // 这里可以屏蔽掉后台的异常栈信息，直接返回"business error"
    return ResponseResultEntity.fail(businessException, businessException.getLocalizedMessage());
}
```
对于其它异常
```java
/**
 * handle other exception.
 *
 * @param exception
 *            exception
 * @return ResponseResult
 */
@ResponseBody
@ExceptionHandler(Exception.class)
public ResponseResult<Exception> processException(Exception exception) {
    log.error(exception.getLocalizedMessage(), exception);
    // 这里可以屏蔽掉后台的异常栈信息，直接返回"server error"
    return ResponseResultEntity.fail(exception, exception.getLocalizedMessage());
}
```
### 28.2.2 Controller接口
（接口中无需处理异常）
```java
@Slf4j
@Api(value = "User Interfaces", tags = "User Interfaces")
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    @PostMapping("add")
    public ResponseEntity<UserParam> add(@Valid @RequestBody UserParam userParam) {
        return ResponseEntity.ok(userParam);
    }
}
```
### 28.2.3 运行测试
这里用postman测试下
![146.springboot-exception-1.png](../../assets/images/04-主流框架/spring/146.springboot-exception-1.png)
## 28.3 进一步理解
### 28.3.1 @ControllerAdvice还可以怎么用？
除了通过@ExceptionHandler注解用于全局异常的处理之外，@ControllerAdvice还有两个用法：
#### 28.3.1.1 @InitBinder注解（定制 Web 数据绑定和验证）
`@InitBinder` 注解是 Spring MVC 框架中的一个重要注解，主要用于**定制 Web 数据绑定和验证**。它的主要作用如下：

1. **自定义数据绑定规则**
- **字段限制**：允许指定哪些字段可以被绑定（白名单），或哪些字段禁止绑定（黑名单）。
  ```java
  @InitBinder
  public void initBinder(WebDataBinder binder) {
      binder.setAllowedFields("id", "name");  // 只允许绑定 id 和 name 字段
      // binder.setDisallowedFields("password"); // 禁止绑定 password 字段
  }
  ```
- **防止恶意攻击**：避免前端传递非法字段（如 `admin=true`）篡改后端数据。

---

2. **注册自定义属性编辑器（PropertyEditor）**
用于处理特定类型的参数转换，例如：
- **日期格式转换**：
  ```java
  @InitBinder
  public void initBinder(WebDataBinder binder) {
      SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
      binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));
  }
  ```
  此时前端传递的字符串（如 `"2023-10-01"`）会自动转换为 `Date` 类型。
    ```java
    @GetMapping("testDate")
    public Date processApi(Date date) {//直接用Date对象接收即可
        return date;
    }
    ```
    单独定义 `Advice` 类实现上面的日期格式转换就可以全局的实现对 Controller 中RequestMapping标识的方法中的所有Date类型的参数都会被作相应的处理。
---

1. **自定义验证器（Validator）**
可以为特定控制器方法绑定自定义验证逻辑：
```java
@InitBinder
public void initBinder(WebDataBinder binder) {
    binder.setValidator(new UserValidator()); // 绑定 User 对象的自定义验证器
}
```

---

4. **作用范围**
- **控制器级别**：仅对当前控制器中的请求处理方法生效。
- **方法级别**：可通过 `@RequestMapping` 方法单独配置不同的绑定规则。

---

5. **适用场景**
- 需要限制前端传递的字段（如更新用户信息时只允许修改昵称，而非权限字段）。
- 处理复杂类型参数（如日期、枚举、自定义对象）的转换。
- 为特定控制器定制验证逻辑。

---

6. **注意事项**
- `@InitBinder` 方法会在每次请求到达控制器时被调用，**不宜包含耗时逻辑**。
- 对于全局数据绑定配置，推荐使用 `@ControllerAdvice` 结合 `@InitBinder`
--- 

7. **使用方式**
- 我们通常将@InitBinder注解的方法放在控制器（Controller）中，这样它就会对该控制器中的所有请求处理方法生效。
```java
@Controller
public class UserController {

    @InitBinder
    public void initBinder(WebDataBinder binder, WebRequest request) {
        binder.setAllowedFields("id", "name");
    }

    @PostMapping("/updateUser")
    public String updateUser(@ModelAttribute User user) {
        // 只有id和name会被绑定
        return "success";
    }

    @PostMapping("/createUser")
    public String createUser(@ModelAttribute User user) {
        // 只有name和email会被绑定
        return "success";
    }
}
```
- 如果我们想要针对某个controller中的一些特定的请求生效的话可以采取以下方式

  - 1. **方法级别控制（推荐）**

    - 方式一：通过方法名判断
    ```java
    @Controller
    public class UserController {
        
        @InitBinder
        public void initBinder(WebDataBinder binder, WebRequest request) {
            // 获取当前请求的处理器方法
            HandlerMethod handlerMethod = (HandlerMethod) RequestContextHolder.currentRequestAttributes()
                    .getAttribute("org.springframework.web.servlet.HandlerMapping.bestMatchingHandler", 
                                 RequestAttributes.SCOPE_REQUEST);
            
            String methodName = handlerMethod.getMethod().getName();
            
            // 只对特定方法应用绑定规则
            if ("updateUser".equals(methodName)) {
                binder.setAllowedFields("id", "name");
            }
            // 对其他方法不限制或应用不同规则
        }
        
        @PostMapping("/updateUser")
        public String updateUser(@ModelAttribute User user) {
            // 这里只会绑定 id 和 name 字段
            return "success";
        }
        
        @PostMapping("/createUser")
        public String createUser(@ModelAttribute User user) {
            // 这里不受限制，所有字段都能绑定
            return "success";
        }
    }
    ```

    - 方式二：使用请求参数判断
    ```java
    @InitBinder
    public void initBinder(WebDataBinder binder, WebRequest request) {
        // 根据请求路径判断
        String requestUri = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes())
                .getRequest().getRequestURI();
        
        if (requestUri.contains("/update")) {
            binder.setAllowedFields("id", "name");
        }
    }
    ```

  ---

  - 2. **使用自定义注解（更优雅）**

  通过 `value` 属性指定不同的 binder 名称：
  ```java
    // 自定义注解
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface AllowedFields {
        String[] value();
    }

    // 控制器
    @Controller
    public class UserController {
        
        @InitBinder
        public void initBinder(WebDataBinder binder, WebRequest request) {
            HandlerMethod handlerMethod = (HandlerMethod) request.getAttribute(
                HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);
            
            if (handlerMethod != null) {
                Method method = handlerMethod.getMethod();
                if (method.isAnnotationPresent(AllowedFields.class)) {
                    AllowedFields annotation = method.getAnnotation(AllowedFields.class);
                    binder.setAllowedFields(annotation.value());
                }
            }
        }
        
        @PostMapping("/updateUser")
        @AllowedFields({"id", "name"})
        public String updateUser(@ModelAttribute User user) {
            return "success";
        }
        
        @PostMapping("/createUser")
        @AllowedFields({"name", "email", "age"})
        public String createUser(@ModelAttribute User user) {
            return "success";
        }
    }

  ```
- 使用 @ControllerAdvice 实现更灵活的控制

创建专门的 Advice 类：
```java
@ControllerAdvice(assignableTypes = UserController.class)  // 只对 UserController 生效
public class UserControllerAdvice {
    
    @InitBinder
    public void initBinder(WebDataBinder binder, WebRequest request) {
        // 通过注解标记特定方法
        HandlerMethod handlerMethod = (HandlerMethod) RequestContextHolder.currentRequestAttributes()
                .getAttribute("org.springframework.web.servlet.HandlerMapping.bestMatchingHandler", 
                             RequestAttributes.SCOPE_REQUEST);
        
        // 检查方法上是否有特定注解
        if (handlerMethod.getMethod().isAnnotationPresent(AllowOnlyIdAndName.class)) {
            binder.setAllowedFields("id", "name");
        }
    }
}

// 自定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AllowOnlyIdAndName {
}

// 在控制器中使用
@Controller
public class UserController {
    
    @PostMapping("/updateUser")
    @AllowOnlyIdAndName  // 标记此方法使用特定绑定规则
    public String updateUser(@ModelAttribute User user) {
        return "success";
    }
}
```
#### 28.3.1.2 @ModelAttribute注解
用来预设全局参数，比如最典型的使用Spring Security时将添加当前登录的用户信息（UserDetails）作为参数。
```java
@ModelAttribute("currentUser")
public UserDetails modelAttribute() {
    return (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
}
```
所有controller类中requestMapping方法都可以直接获取并使用currentUser
```java
@PostMapping("saveSomething")
public ResponseEntity<String> saveSomeObj(@ModelAttribute("currentUser") UserDetails operator) {
    // 保存操作，并设置当前操作人员的ID（从UserDetails中获得）
    return ResponseEntity.success("ok");
}
```
### 28.3.2 @ControllerAdvice是如何起作用的（原理）？
我们在`Spring基础 - SpringMVC案例和机制`的基础上来看@ControllerAdvice的源码实现。

DispatcherServlet中onRefresh方法是初始化ApplicationContext后的回调方法，它会调用initStrategies方法，主要更新一些servlet需要使用的对象，包括国际化处理，requestMapping，视图解析等等。
```java
/**
    * This implementation calls {@link #initStrategies}.
    */
@Override
protected void onRefresh(ApplicationContext context) {
    initStrategies(context);
}

/**
    * Initialize the strategy objects that this servlet uses.
    * <p>May be overridden in subclasses in order to initialize further strategy objects.
    */
protected void initStrategies(ApplicationContext context) {
    initMultipartResolver(context); // 文件上传
    initLocaleResolver(context); // i18n国际化
    initThemeResolver(context); // 主题
    initHandlerMappings(context); // requestMapping
    initHandlerAdapters(context); // adapters
    initHandlerExceptionResolvers(context); // 异常处理
    initRequestToViewNameTranslator(context);
    initViewResolvers(context);
    initFlashMapManager(context);
}
```
从上述代码看，如果要提供@ControllerAdvice提供的三种注解功能，从设计和实现的角度肯定是实现的代码需要放在initStrategies方法中。
- @ModelAttribute和@InitBinder处理

具体来看，如果你是设计者，很显然容易想到：对于@ModelAttribute提供的参数预置和@InitBinder注解提供的预处理方法应该是放在一个方法中的，因为它们都是在进入requestMapping方法前做的操作。

如下方法是获取所有的HandlerAdapter，无非就是从BeanFactory中获取(BeanFactory相关知识请参考 Spring进阶- Spring IOC实现原理详解之IOC体系结构设计)
```java
private void initHandlerAdapters(ApplicationContext context) {
    this.handlerAdapters = null;

    if (this.detectAllHandlerAdapters) {
        // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.
        Map<String, HandlerAdapter> matchingBeans =
                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
        if (!matchingBeans.isEmpty()) {
            this.handlerAdapters = new ArrayList<>(matchingBeans.values());
            // We keep HandlerAdapters in sorted order.
            AnnotationAwareOrderComparator.sort(this.handlerAdapters);
        }
    }
    else {
        try {
            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);
            this.handlerAdapters = Collections.singletonList(ha);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Ignore, we'll add a default HandlerAdapter later.
        }
    }

    // Ensure we have at least some HandlerAdapters, by registering
    // default HandlerAdapters if no other adapters are found.
    if (this.handlerAdapters == null) {
        this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);
        if (logger.isTraceEnabled()) {
            logger.trace("No HandlerAdapters declared for servlet '" + getServletName() +
                    "': using default strategies from DispatcherServlet.properties");
        }
    }
}
```
我们要处理的是requestMapping的handlerResolver，作为设计者，就很容易出如下的结构
![147.springboot-exception-10.png](../../assets/images/04-主流框架/spring/147.springboot-exception-10.png)

在RequestMappingHandlerAdapter中的afterPropertiesSet去处理advice
```java
@Override
public void afterPropertiesSet() {
    // Do this first, it may add ResponseBody advice beans
    initControllerAdviceCache();

    if (this.argumentResolvers == null) {
        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();
        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.initBinderArgumentResolvers == null) {
        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();
        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.returnValueHandlers == null) {
        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
    }
}

private void initControllerAdviceCache() {
    if (getApplicationContext() == null) {
        return;
    }

    List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());

    List<Object> requestResponseBodyAdviceBeans = new ArrayList<>();

    for (ControllerAdviceBean adviceBean : adviceBeans) {
        Class<?> beanType = adviceBean.getBeanType();
        if (beanType == null) {
            throw new IllegalStateException("Unresolvable type for ControllerAdviceBean: " + adviceBean);
        }
        // 缓存所有modelAttribute注解方法
        Set<Method> attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);
        if (!attrMethods.isEmpty()) {
            this.modelAttributeAdviceCache.put(adviceBean, attrMethods);
        }
        // 缓存所有initBinder注解方法
        Set<Method> binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);
        if (!binderMethods.isEmpty()) {
            this.initBinderAdviceCache.put(adviceBean, binderMethods);
        }
        if (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) {
            requestResponseBodyAdviceBeans.add(adviceBean);
        }
    }

    if (!requestResponseBodyAdviceBeans.isEmpty()) {
        this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans);
    }
}
```
- @ExceptionHandler处理

@ExceptionHandler显然是在上述initHandlerExceptionResolvers(context)方法中。

同样的，从BeanFactory中获取HandlerExceptionResolver
```java
/**
    * Initialize the HandlerExceptionResolver used by this class.
    * <p>If no bean is defined with the given name in the BeanFactory for this namespace,
    * we default to no exception resolver.
    */
private void initHandlerExceptionResolvers(ApplicationContext context) {
    this.handlerExceptionResolvers = null;

    if (this.detectAllHandlerExceptionResolvers) {
        // Find all HandlerExceptionResolvers in the ApplicationContext, including ancestor contexts.
        Map<String, HandlerExceptionResolver> matchingBeans = BeanFactoryUtils
                .beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, true, false);
        if (!matchingBeans.isEmpty()) {
            this.handlerExceptionResolvers = new ArrayList<>(matchingBeans.values());
            // We keep HandlerExceptionResolvers in sorted order.
            AnnotationAwareOrderComparator.sort(this.handlerExceptionResolvers);
        }
    }
    else {
        try {
            HandlerExceptionResolver her =
                    context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);
            this.handlerExceptionResolvers = Collections.singletonList(her);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Ignore, no HandlerExceptionResolver is fine too.
        }
    }

    // Ensure we have at least some HandlerExceptionResolvers, by registering
    // default HandlerExceptionResolvers if no other resolvers are found.
    if (this.handlerExceptionResolvers == null) {
        this.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);
        if (logger.isTraceEnabled()) {
            logger.trace("No HandlerExceptionResolvers declared in servlet '" + getServletName() +
                    "': using default strategies from DispatcherServlet.properties");
        }
    }
}
```
我们很容易找到ExceptionHandlerExceptionResolver
![148.springboot-exception-11.png](../../assets/images/04-主流框架/spring/148.springboot-exception-11.png)

同样的在afterPropertiesSet去处理advice
```java
@Override
public void afterPropertiesSet() {
    // Do this first, it may add ResponseBodyAdvice beans
    initExceptionHandlerAdviceCache();

    if (this.argumentResolvers == null) {
        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();
        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
    }
    if (this.returnValueHandlers == null) {
        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
    }
}

private void initExceptionHandlerAdviceCache() {
    if (getApplicationContext() == null) {
        return;
    }

    List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());
    for (ControllerAdviceBean adviceBean : adviceBeans) {
        Class<?> beanType = adviceBean.getBeanType();
        if (beanType == null) {
            throw new IllegalStateException("Unresolvable type for ControllerAdviceBean: " + adviceBean);
        }
        ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType);
        if (resolver.hasExceptionMappings()) {
            this.exceptionHandlerAdviceCache.put(adviceBean, resolver);
        }
        if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) {
            this.responseBodyAdvice.add(adviceBean);
        }
    }
}
```
# 二十九、SpringBoot接口 - 如何提供多个版本接口
> 在以SpringBoot开发Restful接口时，由于模块，系统等业务的变化，需要对同一接口提供不同版本的参数实现（老的接口还有模块或者系统在用，不能直接改，所以需要不同版本）。如何更加优雅的实现多版本接口呢？
## 29.1 为什么接口会出现多个版本？
> 为什么接口会出现多个版本？

一般来说，Restful API接口是提供给其它模块，系统或是其他公司使用，不能随意频繁的变更。然而，需求和业务不断变化，接口和参数也会发生相应的变化。如果直接对原来的接口进行修改，势必会影响线其他系统的正常运行。这就必须对api 接口进行有效的版本控制。
### 29.1.1 有哪些控制接口多版本的方式？
- 相同URL，用**不同的版本参数**区分
  - api.pdai.tech/user?version=v1 表示 v1版本的接口, 保持原有接口不动
  - api.pdai.tech/user?version=v2 表示 v2版本的接口，更新新的接口
- 区分**不同的接口域名**，不同的版本有不同的子域名, 路由到不同的实例:
  - v1.api.pdai.tech/user 表示 v1版本的接口, 保持原有接口不动, 路由到instance1
  - v2.api.pdai.tech/user 表示 v2版本的接口，更新新的接口, 路由到instance2
- 网关路由不同子目录到**不同的实例**（不同package也可以）
  - api.pdai.tech/v1/user 表示 v1版本的接口, 保持原有接口不动, 路由到instance1api.
  - pdai.tech/v2/user 表示 v2版本的接口，更新新的接口, 路由到instance2
- **同一实例**，用注解隔离不同版本控制
  - api.pdai.tech/v1/user 表示 v1版本的接口, 保持原有接口不动，匹配@ApiVersion("1")的handlerMapping
  - api.pdai.tech/v2/user 表示 v2版本的接口，更新新的接口，匹配@ApiVersion("2")的handlerMapping

这里主要展示第四种单一实例中如何优雅的控制接口的版本。
## 29.2 实现案例
> 这个例子基于SpringBoot封装了@ApiVersion注解方式控制接口版本。
### 29.2.1 自定义@ApiVersion注解
```java
package tech.pdai.springboot.api.version.config.version;

import org.springframework.web.bind.annotation.Mapping;

import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface ApiVersion {
    String value();
}
```
### 29.2.2 定义版本匹配RequestCondition
版本匹配支持三层版本
- v1.1.1 （大版本.小版本.补丁版本）
- v1.1 (等同于v1.1.0)
- v1 (等同于v1.0.0)
```java
package tech.pdai.springboot.api.version.config.version;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.servlet.mvc.condition.RequestCondition;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {

    /**
     * support v1.1.1, v1.1, v1; three levels .
     */
    private static final Pattern VERSION_PREFIX_PATTERN_1 = Pattern.compile("/v\\d\\.\\d\\.\\d/");
    private static final Pattern VERSION_PREFIX_PATTERN_2 = Pattern.compile("/v\\d\\.\\d/");
    private static final Pattern VERSION_PREFIX_PATTERN_3 = Pattern.compile("/v\\d/");
    private static final List<Pattern> VERSION_LIST = Collections.unmodifiableList(
            Arrays.asList(VERSION_PREFIX_PATTERN_1, VERSION_PREFIX_PATTERN_2, VERSION_PREFIX_PATTERN_3)
    );

    @Getter
    private final String apiVersion;

    public ApiVersionCondition(String apiVersion) {
        this.apiVersion = apiVersion;
    }

    /**
     * method priority is higher then class.
     *
     * @param other other
     * @return ApiVersionCondition
     */
    @Override
    public ApiVersionCondition combine(ApiVersionCondition other) {
        return new ApiVersionCondition(other.apiVersion);
    }

    @Override
    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {
        for (int vIndex = 0; vIndex < VERSION_LIST.size(); vIndex++) {
            Matcher m = VERSION_LIST.get(vIndex).matcher(request.getRequestURI());
            if (m.find()) {
                String version = m.group(0).replace("/v", "").replace("/", "");
                if (vIndex == 1) {
                    version = version + ".0";
                } else if (vIndex == 2) {
                    version = version + ".0.0";
                }
                if (compareVersion(version, this.apiVersion) >= 0) {
                    log.info("version={}, apiVersion={}", version, this.apiVersion);
                    return this;
                }
            }
        }
        return null;
    }

    @Override
    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {
        return compareVersion(other.getApiVersion(), this.apiVersion);
    }

    private int compareVersion(String version1, String version2) {
        if (version1 == null || version2 == null) {
            throw new RuntimeException("compareVersion error:illegal params.");
        }
        String[] versionArray1 = version1.split("\\.");
        String[] versionArray2 = version2.split("\\.");
        int idx = 0;
        int minLength = Math.min(versionArray1.length, versionArray2.length);
        int diff = 0;
        while (idx < minLength
                && (diff = versionArray1[idx].length() - versionArray2[idx].length()) == 0
                && (diff = versionArray1[idx].compareTo(versionArray2[idx])) == 0) {
            ++idx;
        }
        diff = (diff != 0) ? diff : versionArray1.length - versionArray2.length;
        return diff;
    }
}
```
### 29.2.3 自定义HandlerMapping
```java
package tech.pdai.springboot.api.version.config.version;

import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.lang.NonNull;
import org.springframework.web.servlet.mvc.condition.RequestCondition;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

import java.lang.reflect.Method;

public class ApiVersionRequestMappingHandlerMapping extends RequestMappingHandlerMapping {

    /**
     * add @ApiVersion to controller class.
     *
     * @param handlerType handlerType
     * @return RequestCondition
     */
    @Override
    protected RequestCondition<?> getCustomTypeCondition(@NonNull Class<?> handlerType) {
        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class);
        return null == apiVersion ? super.getCustomTypeCondition(handlerType) : new ApiVersionCondition(apiVersion.value());
    }

    /**
     * add @ApiVersion to controller method.
     *
     * @param method method
     * @return RequestCondition
     */
    @Override
    protected RequestCondition<?> getCustomMethodCondition(@NonNull Method method) {
        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);
        return null == apiVersion ? super.getCustomMethodCondition(method) : new ApiVersionCondition(apiVersion.value());
    }

}
```
### 29.2.4 配置注册HandlerMapping
继承WebMvcConfigurationSupport(不推荐该方法，会影响到Springboot的自动配置WebMvcAutoConfiguration)
```java
package tech.pdai.springboot.api.version.config.version;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

@Configuration
public class CustomWebMvcConfiguration extends WebMvcConfigurationSupport {

    @Override
    public RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```
或者实现WebMvcRegistrations的接口
```java
@Configuration
@RequiredArgsConstructor
public class WebConfig implements WebMvcConfigurer, WebMvcRegistrations {
    //...

    @Override
    @NonNull
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }

}
```
### 29.2.5 测试运行
controller
```java
package tech.pdai.springboot.api.version.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.api.version.config.version.ApiVersion;
import tech.pdai.springboot.api.version.entity.User;

/**
 * @author pdai
 */
@RestController
@RequestMapping("api/{v}/user")
public class UserController {

    @RequestMapping("get")
    public User getUser() {
        return User.builder().age(18).name("pdai, default").build();
    }

    @ApiVersion("1.0.0")
    @RequestMapping("get")
    public User getUserV1() {
        return User.builder().age(18).name("pdai, v1.0.0").build();
    }

    @ApiVersion("1.1.0")
    @RequestMapping("get")
    public User getUserV11() {
        return User.builder().age(19).name("pdai, v1.1.0").build();
    }

    @ApiVersion("1.1.2")
    @RequestMapping("get")
    public User getUserV112() {
        return User.builder().age(19).name("pdai2, v1.1.2").build();
    }
}
```
输出
```java
http://localhost:8080/api/v1/user/get
// {"name":"pdai, v1.0.0","age":18}

http://localhost:8080/api/v1.1/user/get
// {"name":"pdai, v1.1.0","age":19}

http://localhost:8080/api/v1.1.1/user/get
// {"name":"pdai, v1.1.0","age":19} 匹配比1.1.1小的中最大的一个版本号

http://localhost:8080/api/v1.1.2/user/get
// {"name":"pdai2, v1.1.2","age":19}

http://localhost:8080/api/v1.2/user/get
// {"name":"pdai2, v1.1.2","age":19} 匹配最大的版本号，v1.1.2
```
这样，如果我们向另外一个模块提供v1版本的接口，新的需求中只变动了一个接口方法，这时候我们只需要增加一个接口添加版本号v1.1即可用v1.1版本访问所有接口。
> 此外，这种方式可能会导致v3版本接口没有发布，但是是可以通过v3访问接口的；这种情况下可以添加一些限制版本的逻辑，比如最大版本，版本集合等。
## 29.3 实现原理

### 29.3.1. Spring MVC的请求映射核心机制

#### 9.3.1.1 HandlerMapping的作用
```java
// Spring MVC通过HandlerMapping将请求映射到对应的处理器
public interface HandlerMapping {
    HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;
}
```

#### 9.3.1.2 RequestMappingHandlerMapping的工作流程
1. **初始化阶段**：扫描所有`@Controller`和`@RequestMapping`注解
2. **注册阶段**：为每个方法创建`RequestMappingInfo`（包含路径、方法、参数等条件）
3. **匹配阶段**：收到请求时，通过`RequestCondition`进行条件匹配

### 29.3.2. 自定义版本控制的实现原理

#### 29.3.2.1 自定义RequestCondition
```java
public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {
    // 核心方法：判断当前条件是否匹配请求
    @Override
    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {
        // 从URL中提取版本号：/api/v1.1.2/user/get → "1.1.2"
        // 与注解中的版本号进行比较
    }
    
    // 多个条件匹配时的优先级比较
    @Override
    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {
        // 版本号大的优先级更高
    }
}
```

#### 29.3.2.2 自定义HandlerMapping
```java
public class ApiVersionRequestMappingHandlerMapping extends RequestMappingHandlerMapping {
    
    // 处理类级别的@ApiVersion注解
    @Override
    protected RequestCondition<?> getCustomTypeCondition(Class<?> handlerType) {
        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class);
        return new ApiVersionCondition(apiVersion.value());
    }
    
    // 处理方法级别的@ApiVersion注解
    @Override
    protected RequestCondition<?> getCustomMethodCondition(Method method) {
        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);
        return new ApiVersionCondition(apiVersion.value());
    }
}
```

### 29.3.3. Spring Boot的自动配置机制

#### 29.3.3.1 WebMvcConfigurationSupport
```java
@Configuration
public class CustomWebMvcConfiguration extends WebMvcConfigurationSupport {
    
    // 重写此方法替换默认的HandlerMapping
    @Override
    public RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```

#### 29.3.3.2 替代方案：WebMvcRegistrations
```java
@Configuration
public class WebConfig implements WebMvcRegistrations {
    
    // Spring Boot 2.1+ 推荐的扩展方式
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```

### 29.3.4. 版本匹配的详细流程

#### 29.3.4.1 请求处理流程
```
HTTP请求 → DispatcherServlet → HandlerMapping → 匹配条件 → 执行对应方法
```

#### 29.3.4.2 版本匹配算法
```java
// 匹配逻辑：选择小于等于请求版本的最大版本
if (compareVersion(version, this.apiVersion) >= 0) {
    return this; // 匹配成功
}

// 比较版本号：1.1.1 vs 1.1.0 → 返回1（大于）
private int compareVersion(String version1, String version2) {
    // 逐级比较主版本、次版本、修订版本
}
```

#### 29.3.4.3 具体匹配示例
```
请求: /api/v1.1.1/user/get
可用版本: 1.0.0, 1.1.0, 1.1.2

匹配过程：
1. 1.1.1 >= 1.0.0 ✓
2. 1.1.1 >= 1.1.0 ✓  
3. 1.1.1 >= 1.1.2 ✗

结果：选择1.1.0（最接近且不大于请求版本）
```

### 29.3.5. Spring Boot的底层扩展点

#### 29.3.5.1 条件匹配的扩展点
- **RequestCondition**: 自定义匹配条件
- **HandlerMapping**: 自定义映射逻辑  
- **WebMvcConfigurer**: 配置MVC组件

#### 29.3.5.2 Spring Boot的自动配置类
```java
// Spring Boot自动配置MVC
@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class CustomWebMvcConfiguration {
    // 自定义配置会覆盖默认配置
}
```

### 29.3.6. 潜在问题与解决方案

#### 29.3.6.1 版本号泄露问题
```java
// 解决方案：添加版本范围检查
private boolean isVersionAllowed(String requestVersion) {
    // 检查请求版本是否在已发布的版本范围内
    return publishedVersions.contains(requestVersion);
}
```

#### 29.3.6.2 性能优化
```java
// 使用缓存提高匹配性能
private static final Map<String, String> VERSION_CACHE = new ConcurrentHashMap<>();

public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {
    String uri = request.getRequestURI();
    return VERSION_CACHE.computeIfAbsent(uri, this::doMatch);
}
```

### 29.3.7 总结

这个实现利用了Spring MVC的**扩展性设计**：
1. **面向接口编程**：通过实现`RequestCondition`接口添加自定义条件
2. **模板方法模式**：通过继承`RequestMappingHandlerMapping`重写关键方法
3. **配置覆盖机制**：Spring Boot允许通过配置类覆盖默认组件
4. **条件匹配算法**：实现了语义化版本的前向兼容匹配

这种设计体现了Spring框架的**开闭原则**：对扩展开放，对修改关闭，使得开发者可以在不修改框架源码的情况下实现复杂的功能扩展。
## <a href id = 'WebMvcRegistrations'>29.4 扩展：WebMvcRegistrations</a> 
`WebMvcRegistrations` 是 **Spring Boot 提供的一个接口**，用于**自定义 Spring MVC 核心组件的注册行为**。

### 29.4.1. 接口定义和作用

```java
public interface WebMvcRegistrations {
    
    // 自定义 RequestMappingHandlerMapping
    RequestMappingHandlerMapping getRequestMappingHandlerMapping();
    
    // 自定义 RequestMappingHandlerAdapter  
    RequestMappingHandlerAdapter getRequestMappingHandlerAdapter();
    
    // 自定义 ExceptionHandlerExceptionResolver
    ExceptionHandlerExceptionResolver getExceptionHandlerExceptionResolver();
}
```

### 29.4.2. 使用场景对比

#### 29.4.2.1 传统方式：继承 WebMvcConfigurationSupport
```java
@Configuration
public class CustomWebMvcConfiguration extends WebMvcConfigurationSupport {
    
    @Override
    public RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```
**缺点**：继承 `WebMvcConfigurationSupport` 会**完全禁用 Spring Boot 的自动配置**

#### 29.4.2.2 推荐方式：实现 WebMvcRegistrations
```java
@Configuration
public class WebConfig implements WebMvcRegistrations {
    
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```
**优点**：只**替换特定组件**，保留 Spring Boot 的其他自动配置

### 29.4.3. 工作原理

#### 29.4.3.1 Spring Boot 的自动配置流程
```java
// WebMvcAutoConfiguration 中的关键代码
@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class WebMvcAutoConfiguration {
    
    @Bean
    @ConditionalOnBean(WebMvcRegistrations.class)
    public RequestMappingHandlerMapping requestMappingHandlerMapping(
        WebMvcRegistrations registrations) {
        // 如果存在WebMvcRegistrations Bean，使用自定义的HandlerMapping
        return registrations.getRequestMappingHandlerMapping();
    }
}
```

#### 29.4.3.2 执行顺序
```
1. Spring Boot 启动
2. WebMvcAutoConfiguration 自动配置MVC组件
3. 检查是否存在 WebMvcRegistrations Bean
4. 如果存在，使用自定义组件替换默认组件
5. 如果不存在，使用默认配置
```

### 29.4.4. 三个核心组件的作用

#### 29.4.4.1 RequestMappingHandlerMapping
```java
// 负责将HTTP请求映射到对应的Controller方法
public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMapping {
    // 处理 @RequestMapping 注解的映射
}
```

#### 29.4.4.2 RequestMappingHandlerAdapter
```java
// 负责调用匹配的Controller方法
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter {
    // 处理参数绑定、返回值处理等(@InitBinder、@ModelAttribute 的处理机制在此实现)
}
```

#### 29.4.4.3 ExceptionHandlerExceptionResolver
```java
// 负责处理Controller方法的异常
public class ExceptionHandlerExceptionResolver implements HandlerExceptionResolver {
    // 处理 @ExceptionHandler 注解
}
```

### 29.4.5. 实际应用示例

#### 29.4.5.1 版本控制（如你的例子）
```java
@Configuration
public class ApiVersionConfig implements WebMvcRegistrations {
    
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```

#### 29.4.5.2 自定义参数解析器
```java
@Configuration
public class CustomMvcConfig implements WebMvcRegistrations {
    
    @Override
    public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
        RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
        // 添加自定义参数解析器
        adapter.setCustomArgumentResolvers(Arrays.asList(new UserArgumentResolver()));
        return adapter;
    }
}
```

#### 29.4.5.3 全局异常处理
```java
@Configuration
public class ExceptionConfig implements WebMvcRegistrations {
    
    @Override
    public ExceptionHandlerExceptionResolver getExceptionHandlerExceptionResolver() {
        ExceptionHandlerExceptionResolver resolver = new ExceptionHandlerExceptionResolver();
        // 配置自定义异常处理器
        resolver.setExceptionHandlerAdviceCache(new HashMap<>());
        return resolver;
    }
}
```

### 29.4.6. 与相关接口的区别

#### 29.4.6.1 WebMvcRegistrations vs WebMvcConfigurer
```java
// WebMvcRegistrations：替换核心组件
public interface WebMvcRegistrations {
    RequestMappingHandlerMapping getRequestMappingHandlerMapping();
}

// WebMvcConfigurer：配置MVC行为（不替换组件）
public interface WebMvcConfigurer {
    void addInterceptors(InterceptorRegistry registry);
    void addCorsMappings(CorsRegistry registry);
}
```

#### 29.4.6.2 可以同时使用
```java
@Configuration
public class CompleteMvcConfig implements WebMvcRegistrations, WebMvcConfigurer {
    
    // 替换核心组件
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new CustomHandlerMapping();
    }
    
    // 配置MVC行为
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LogInterceptor());
    }
}
```

### 29.4.7. 最佳实践建议

#### 29.4.7.1 使用场景判断
- **需要完全替换组件行为** → 使用 `WebMvcRegistrations`
- **只需要添加配置** → 使用 `WebMvcConfigurer`
- **两者都需要** → 同时实现两个接口

#### 29.4.7.2 你的例子中的选择
```java
// 推荐方式：只替换HandlerMapping，保留其他自动配置
@Configuration
public class WebConfig implements WebMvcRegistrations {
    
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
}
```

### 29.4.8 总结

`WebMvcRegistrations` 是 **Spring Boot 提供的精细化扩展点**，它允许你：

1. **选择性替换** Spring MVC 核心组件
2. **保留 Spring Boot 的自动配置优势**
3. **避免完全重写 MVC 配置**
4. **实现更优雅的框架集成**

在你的版本控制例子中，使用 `WebMvcRegistrations` 是比继承 `WebMvcConfigurationSupport` 更推荐的方式，因为它保持了 Spring Boot 的便利性。
## 29.5 扩展：andlerMapping，HandlerAdapter，ExceptionResolver应该不只有WebMvcRegistrations 提供的三种，那为什么springboot决定把WebMvcRegistrations 里面的三种作为扩展点呢？而不是其他的？
这涉及到 Spring Boot 的设计哲学和实际应用场景的权衡。

### 29.5.1. Spring MVC 完整的组件体系

#### 29.5.1.1 完整的 HandlerMapping 类型
```java
// Spring MVC 内置的多种 HandlerMapping
HandlerMapping
├── RequestMappingHandlerMapping    // 处理 @RequestMapping（最常用）
├── BeanNameUrlHandlerMapping       // 根据Bean名称映射  
├── SimpleUrlHandlerMapping         // 简单URL模式映射
├── RouterFunctionMapping          // WebFlux 风格的路由
└── WelcomePageHandlerMapping      // 欢迎页面映射
```

#### 29.5.1.2 完整的 HandlerAdapter 类型
```java
HandlerAdapter
├── RequestMappingHandlerAdapter    // 处理 @Controller 方法
├── HttpRequestHandlerAdapter       // 处理 HttpRequestHandler
├── SimpleControllerHandlerAdapter  // 处理 Controller 接口
└── HandlerFunctionAdapter         // WebFlux 风格适配器
```

#### 29.5.1.3 完整的 ExceptionResolver 类型
```java
HandlerExceptionResolver
├── ExceptionHandlerExceptionResolver  // @ExceptionHandler
├── ResponseStatusExceptionResolver    // @ResponseStatus  
├── DefaultHandlerExceptionResolver    // 默认异常处理
└── SimpleMappingExceptionResolver     // 简单异常映射
```

### 29.5.2. 为什么选择这三个作为扩展点？

#### 29.5.2.1 应用频率最高
```java
// 实际项目中的使用统计
@Controller          // 99% 的项目使用
@RequestMapping      // 99% 的项目使用  
@ExceptionHandler    // 90% 的项目使用

// 相比之下
HttpRequestHandler   // 较少使用（静态资源处理等）
SimpleController     // 几乎不再使用（旧式Controller接口）
```

#### 29.5.2.2 扩展需求最强烈
```java
// 常见的扩展场景
// 1. 版本控制 → 需要扩展 RequestMappingHandlerMapping
// 2. 参数解析 → 需要扩展 RequestMappingHandlerAdapter  
// 3. 统一异常处理 → 需要扩展 ExceptionHandlerExceptionResolver

// 其他组件的扩展需求相对较少
```

#### 29.5.2.3 Spring Boot 的"约定优于配置"哲学
```java
// Spring Boot 的设计原则：为最常用的场景提供便利
public class WebMvcAutoConfiguration {
    
    // 自动配置最常见的三个组件
    @Bean
    public RequestMappingHandlerMapping requestMappingHandlerMapping() {
        // 默认配置
    }
    
    @Bean  
    public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
        // 默认配置
    }
    
    @Bean
    public ExceptionHandlerExceptionResolver exceptionHandlerExceptionResolver() {
        // 默认配置
    }
}
```

### 29.5.3. 其他组件的配置方式

#### 29.5.3.1 通过 WebMvcConfigurer 配置
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    // 配置其他 HandlerMapping
    @Override
    public void configureHandlerMappings(HandlerMappingConfigurer configurer) {
        // 可以配置其他类型的 HandlerMapping
    }
    
    // 添加简单的 URL 映射
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/home").setViewName("home");
    }
}
```

#### 29.5.3.2 直接声明 @Bean
```java
@Configuration
public class AdditionalHandlerConfig {
    
    // 直接声明其他类型的 HandlerMapping
    @Bean
    public SimpleUrlHandlerMapping simpleUrlHandlerMapping() {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        mapping.setUrlMap(Collections.singletonMap("/static/**", httpRequestHandler()));
        return mapping;
    }
    
    @Bean  
    public HttpRequestHandler httpRequestHandler() {
        return new CustomHttpRequestHandler();
    }
}
```

### 29.5.4. 实际设计考量

#### 29.5.4.1 避免过度设计
```java
// 如果提供所有组件的扩展点，接口会变得臃肿
public interface OverDesignedWebMvcRegistrations {
    RequestMappingHandlerMapping getRequestMappingHandlerMapping();
    BeanNameUrlHandlerMapping getBeanNameUrlHandlerMapping();
    SimpleUrlHandlerMapping getSimpleUrlHandlerMapping();
    RouterFunctionMapping getRouterFunctionMapping();
    WelcomePageHandlerMapping getWelcomePageHandlerMapping();
    
    RequestMappingHandlerAdapter getRequestMappingHandlerAdapter();
    HttpRequestHandlerAdapter getHttpRequestHandlerAdapter();
    SimpleControllerHandlerAdapter getSimpleControllerHandlerAdapter();
    
    // ... 还有更多
}
```

#### 29.5.4.2 遵循二八原则
```java
// 20% 的组件满足了 80% 的扩展需求
public class WebMvcRegistrationsDesign {
    // 最常用的三个扩展点覆盖了大部分高级定制需求
    // 其他需求可以通过更简单的方式满足
}
```

#### 29.5.4.3 保持向后兼容
```java
// Spring Boot 需要保持接口稳定
// 选择最核心、最稳定的三个组件作为扩展点，减少未来变更的影响
```

### 29.5.5. 实际项目中的扩展模式

#### 29.5.5.1 常见扩展场景分析
```java
// 场景1：REST API 项目 → 主要扩展 RequestMapping 相关组件
// 场景2：传统 Web 项目 → 可能还需要扩展 ViewResolver 等
// 场景3：混合项目 → 组合使用多种配置方式

// Spring Boot 的选择覆盖了最广泛的场景
```

#### 29.5.5.2 组合使用各种配置方式
```java
@Configuration
public class ComprehensiveWebConfig implements WebMvcRegistrations, WebMvcConfigurer {
    
    // 1. 替换核心组件（通过 WebMvcRegistrations）
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new CustomHandlerMapping();
    }
    
    // 2. 配置其他行为（通过 WebMvcConfigurer）
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LogInterceptor());
    }
    
    // 3. 直接声明其他组件（通过 @Bean）
    @Bean
    public ViewResolver customViewResolver() {
        return new CustomViewResolver();
    }
}
```

### 29.5.6. 与其他框架的对比

#### 29.5.6.1 Spring Boot vs 传统 Spring MVC
```java
// 传统 Spring MVC：需要手动配置所有组件
@Configuration
@EnableWebMvc
public class TraditionalWebConfig implements WebMvcConfigurer {
    
    // 需要手动声明所有 Bean
    @Bean
    public RequestMappingHandlerMapping handlerMapping() {
        // 详细配置...
    }
    
    // 繁琐但灵活
}

// Spring Boot：自动配置 + 选择性扩展
```

#### 29.5.6.2 设计哲学的体现
```java
// Spring Boot 的设计目标：
// 1. 开箱即用（覆盖90%的场景）
// 2. 易于扩展（为10%的特殊场景提供出口）
// 3. 保持简洁（避免接口过于复杂）

// WebMvcRegistrations 完美体现了这一哲学
```

### 29.5.7 总结

Spring Boot 选择这三个组件作为 `WebMvcRegistrations` 的扩展点，是基于：

1. **使用频率**：这三个是现代化 Web 开发中最常用的组件
2. **扩展需求**：它们对应的扩展场景最为丰富和强烈  
3. **设计简洁**：避免接口过度复杂，遵循"约定优于配置"
4. **实际效用**：覆盖了绝大部分高级定制需求

对于其他组件的定制，Spring Boot 提供了更简单的方式（如 `WebMvcConfigurer` 或直接声明 `@Bean`），这种分层设计既保证了常用场景的便利性，又为特殊需求提供了出口。

这是一个典型的**工程权衡**：在灵活性、易用性和接口简洁性之间找到最佳平衡点。
## 29.6 扩展：WebMvcConfigurer，WebMvcRegistrations，WebMvcConfigurationSupport 区别
**这三者的区别主要体现在扩展层级、影响范围和配置方式上。** 让我用一个清晰的表格来对比：

### 29.6.1. 三者的核心区别对比

| 特性 | WebMvcConfigurer | WebMvcRegistrations | WebMvcConfigurationSupport |
|------|------------------|---------------------|----------------------------|
| **扩展层级** | 配置级别（Configuration） | 组件级别（Component） | 框架级别（Framework） |
| **影响范围** | 局部配置，添加行为 | 替换特定核心组件 | 完全接管MVC配置 |
| **自动配置** | ✅ 完全保留 | ✅ 选择性保留 | ❌ 完全禁用 |
| **使用方式** | 实现接口，回调方法 | 实现接口，返回组件实例 | 继承类，重写方法 |
| **侵入性** | 低 | 中 | 高 |

### 29.6.2. 详细的技术区别

#### 29.6.2.1 WebMvcConfigurer（配置扩展）
```java
// 作用：在现有组件基础上添加配置
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 添加拦截器（不替换现有拦截器）
        registry.addInterceptor(new LogInterceptor());
    }
    
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 添加消息转换器（保留默认转换器）
        converters.add(new CustomMessageConverter());
    }
}
```
**特点**：**增量配置**，不会影响现有组件

#### 29.6.2.2 WebMvcRegistrations（组件替换）
```java
// 作用：替换特定的核心组件
@Configuration
public class MyWebMvcRegistrations implements WebMvcRegistrations {
    
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        // 完全替换默认的HandlerMapping
        return new CustomRequestMappingHandlerMapping();
    }
    
    @Override
    public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
        // 完全替换默认的HandlerAdapter
        CustomHandlerAdapter adapter = new CustomHandlerAdapter();
        adapter.setCustomArgumentResolvers(...);
        return adapter;
    }
}
```
**特点**：**组件替换**，但保留其他自动配置

#### 29.6.2.3 WebMvcConfigurationSupport（框架接管）
```java
// 作用：完全控制MVC配置
@Configuration
@EnableWebMvc
public class MyWebMvcConfig extends WebMvcConfigurationSupport {
    
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        // 必须手动配置所有拦截器（默认的会丢失）
        registry.addInterceptor(new LogInterceptor());
    }
    
    @Override
    @Bean
    public RequestMappingHandlerMapping requestMappingHandlerMapping() {
        // 必须手动创建并配置所有组件
        RequestMappingHandlerMapping mapping = new RequestMappingHandlerMapping();
        mapping.setOrder(0);
        mapping.setInterceptors(getInterceptors());
        return mapping;
    }
    
    @Override
    @Bean
    public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
        // 必须手动配置HandlerAdapter的所有细节
        RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
        adapter.setMessageConverters(getMessageConverters());
        adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());
        return adapter;
    }
}
```
**特点**：**完全掌控**，但失去Spring Boot的便利性

### 29.6.3. 实际执行流程对比

#### 29.6.3.1 WebMvcConfigurer 的执行流程
```java
// Spring Boot 自动配置 + WebMvcConfigurer 回调
1. Spring Boot 创建默认的MVC组件
2. 调用所有 WebMvcConfigurer 的配置方法
3. 将自定义配置应用到默认组件上
4. 完成配置，保留所有自动配置特性
```

#### 29.6.3.2 WebMvcRegistrations 的执行流程  
```java
// 选择性组件替换
1. Spring Boot 检查是否存在 WebMvcRegistrations Bean
2. 如果存在，使用自定义组件替换对应的默认组件
3. 其他组件继续使用自动配置
4. 应用所有 WebMvcConfigurer 的配置
```

#### 29.6.3.3 WebMvcConfigurationSupport 的执行流程
```java
// 完全手动配置
1. Spring Boot 检测到 WebMvcConfigurationSupport 子类
2. 禁用所有MVC自动配置（WebMvcAutoConfiguration）
3. 完全依赖子类中的手动配置
4. 需要手动配置所有必要的组件
```

### 29.6.4. 代码示例对比

#### 29.6.4.1 相同的需求，不同的实现方式

**需求**：添加自定义参数解析器

##### 29.6.4.1.1  方式一：WebMvcConfigurer（推荐）
```java
@Configuration
public class ConfigurerConfig implements WebMvcConfigurer {
    
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        // 添加自定义解析器（保留默认解析器）
        resolvers.add(new UserArgumentResolver());
    }
}
```

##### 29.6.4.1.2 方式二：WebMvcRegistrations
```java
@Configuration
public class RegistrationsConfig implements WebMvcRegistrations {
    
    @Override
    public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
        RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
        // 必须手动设置所有解析器（默认的会丢失）
        adapter.setCustomArgumentResolvers(Arrays.asList(
            new RequestParamMethodArgumentResolver(), // 手动添加默认解析器
            new ModelAttributeMethodProcessor(),      // 手动添加默认解析器  
            new UserArgumentResolver()                // 添加自定义解析器
        ));
        return adapter;
    }
}
```

##### 29.6.4.1.3 方式三：WebMvcConfigurationSupport（不推荐）
```java
@Configuration
@EnableWebMvc
public class SupportConfig extends WebMvcConfigurationSupport {
    
    @Override
    @Bean
    public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
        RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
        // 必须完全手动配置所有组件
        adapter.setCustomArgumentResolvers(getArgumentResolvers());
        adapter.setMessageConverters(getMessageConverters());
        adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());
        return adapter;
    }
    
    private List<HandlerMethodArgumentResolver> getArgumentResolvers() {
        // 需要手动组合所有需要的解析器
        return Arrays.asList(
            new RequestParamMethodArgumentResolver(getBeanFactory(), false),
            new ModelAttributeMethodProcessor(false),
            new UserArgumentResolver()
            // ... 还有很多需要手动添加
        );
    }
}
```

### 29.6.5. 选择指南

#### 29.6.5.1 什么时候用 WebMvcConfigurer？
```java
// 场景：添加功能，不改变现有组件
✅ 添加拦截器、参数解析器、消息转换器
✅ 配置视图控制器、资源处理器
✅ 配置CORS、路径匹配等行为

// 示例：90%的日常需求
@Configuration
public class CommonConfig implements WebMvcConfigurer {
    // 添加各种配置，保留所有自动配置
}
```

#### 29.6.5.2 什么时候用 WebMvcRegistrations？
```java
// 场景：需要深度定制核心组件
✅ 自定义URL映射逻辑（如版本控制）
✅ 替换HandlerAdapter以改变请求处理流程  
✅ 定制异常解析器实现特殊异常处理

// 示例：高级定制需求
@Configuration
public class AdvancedConfig implements WebMvcRegistrations {
    // 替换特定组件，保留其他自动配置
}
```

#### 29.6.5.3 什么时候用 WebMvcConfigurationSupport？
```java
// 场景：需要完全控制MVC配置（很少使用）
⚠️  迁移传统Spring MVC项目
⚠️  需要与第三方框架深度集成
⚠️  有特殊的性能优化需求

// 示例：特殊情况（一般不推荐）
@Configuration
@EnableWebMvc  
public class LegacyConfig extends WebMvcConfigurationSupport {
    // 完全手动配置，失去Spring Boot便利性
}
```

### 29.6.6. 组合使用的最佳实践

#### 29.6.6.1 常见组合模式
```java
// 场景：既需要添加配置，又需要替换组件
@Configuration
public class ComprehensiveConfig implements WebMvcRegistrations, WebMvcConfigurer {
    
    // 替换核心组件
    @Override
    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
        return new CustomHandlerMapping();
    }
    
    // 添加配置
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LogInterceptor());
    }
}
```

#### 29.6.6.2 执行顺序
```java
// 组合使用时的执行顺序：
1. WebMvcRegistrations 替换核心组件
2. Spring Boot 应用其他自动配置
3. WebMvcConfigurer 进行增量配置
4. 完成整个MVC配置
```
### 29.6.7 WebMvcConfigurationSupport实现方式影响到自动配置的一个详细例子
- Spring Boot 的自动配置条件
```java
// WebMvcAutoConfiguration 的关键条件
@Configuration
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)  // 重要！
public class WebMvcAutoConfiguration {
    
    // 这个配置类包含了默认的静态资源配置
    @Configuration
    @EnableConfigurationProperties(WebMvcProperties.class)
    public static class EnableWebMvcConfiguration extends WebMvcConfigurationSupport {
        
        @Override
        protected void addResourceHandlers(ResourceHandlerRegistry registry) {
            // 这里配置了默认的静态资源路径：
            // - "/static/**"
            // - "/public/**" 
            // - "/resources/**"
            // - "/META-INF/resources/**"
        }
    }
}
```
- 当你继承 WebMvcConfigurationSupport 时
```java
@Configuration
public class CustomWebMvcConfiguration extends WebMvcConfigurationSupport {
    // 即使你只重写一个方法...
    
    @Override
    public RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
        return new ApiVersionRequestMappingHandlerMapping();
    }
    
    // 但父类的 addResourceHandlers 是空的！
    // WebMvcConfigurationSupport 中的默认实现：
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 空方法！没有任何资源映射
    }
}
```
- 执行流程对比
  - 正常情况（使用 WebMvcRegistrations）
    ```java
    // 1. Spring Boot 检测到没有 WebMvcConfigurationSupport Bean
    // 2. WebMvcAutoConfiguration 生效
    // 3. 创建 EnableWebMvcConfiguration（继承 WebMvcConfigurationSupport）
    // 4. 调用其 addResourceHandlers 方法配置静态资源
    // 5. ✅ 静态资源正常映射
    ```
  - 继承 WebMvcConfigurationSupport 的情况
    ```java
    // 1. Spring Boot 检测到你的 CustomWebMvcConfiguration Bean
    // 2. WebMvcAutoConfiguration 被禁用（条件不满足）
    // 3. 不再创建 EnableWebMvcConfiguration
    // 4. 使用你的 CustomWebMvcConfiguration 实例
    // 5. 调用你的 addResourceHandlers 方法（但你没重写，所以调用父类的空方法）
    // 6. ❌ 没有任何静态资源映射
    ```
### 29.6.8 总结

**三者的本质区别：**

- **WebMvcConfigurer**：`配置扩展` - 在现有基础上"添砖加瓦"
- **WebMvcRegistrations**：`组件替换` - 替换特定"发动机零件"  
- **WebMvcConfigurationSupport**：`框架接管` - 自己"造一辆车"

**选择建议：**
- 优先使用 `WebMvcConfigurer`（覆盖90%场景）
- 特殊需求使用 `WebMvcRegistrations`（高级定制）
- 尽量避免使用 `WebMvcConfigurationSupport`（除非有充分理由）

这种分层设计体现了 Spring Boot 的"渐进式复杂度"理念：从简单配置到深度定制，让开发者根据实际需求选择合适的技术方案。
# 三十、SpringBoot接口 - 如何生成接口文档之Swagger技术栈
## 30.1 准备知识点
> 在生成文档前，你需要了解下OpenAPI规范，Swagger，SpringFox，Knife4J，Swagger UI等之间的关系。
### 30.1.1 什么是OpenAPI规范(OAS)？

<a href ='https://fishead.gitbook.io/openapi-specification-zhcn-translation/3.0.0.zhcn#revisionHistory'>OpenAPI 规范（OAS）</a>定义了一个标准的、语言无关的 RESTful API 接口规范，它可以同时允许开发人员和操作系统查看并理解某个服务的功能，而无需访问源代码，文档或网络流量检查（既方便人类学习和阅读，也方便机器阅读）。正确定义 OAS 后，开发者可以使用最少的实现逻辑来理解远程服务并与之交互。

此外，文档生成工具可以使用 OpenAPI 规范来生成 API 文档，代码生成工具可以生成各种编程语言下的服务端和客户端代码，测试代码和其他用例。

官方GitHub地址： <a href = 'https://github.com/OAI/OpenAPI-Specification'>OpenAPI-Specification</a>

### 30.1.2 什么是Swagger？
Swagger 是一个用于生成、描述和调用 RESTful 接口的 Web 服务。通俗的来讲，Swagger 就是将项目中所有（想要暴露的）接口展现在页面上，并且可以进行接口调用和测试的服务。

从上述 Swagger 定义我们不难看出 Swagger 有以下 3 个重要的作用：
- 将项目中所有的接口展现在页面上，这样后端程序员就不需要专门为前端使用者编写专门的接口文档；
- 当接口更新之后，只需要修改代码中的 Swagger 描述就可以实时生成新的接口文档了，从而规避了接口文档老旧不能使用的问题；
- 通过 Swagger 页面，我们可以直接进行接口调用，降低了项目开发阶段的调试成本。

Swagger3完全遵循了 OpenAPI 规范。Swagger 官网地址：https://swagger.io/。

### 30.1.3 Swagger和SpringFox有啥关系？
Swagger 可以看作是一个遵循了 OpenAPI 规范的一项技术，而 springfox 则是这项技术的具体实现。 就好比 Spring 中的 IOC 和 DI 的关系 一样，前者是思想，而后者是实现。
### 30.1.4 什么是Knife4J? 和Swagger什么关系？
> 本质是Swagger的增强解决方案，前身只是一个SwaggerUI（swagger-bootstrap-ui）

Knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案, 前身是swagger-bootstrap-ui,取名kni4j是希望她能像一把匕首一样小巧,轻量,并且功能强悍!

Knife4j的前身是swagger-bootstrap-ui，为了契合微服务的架构发展,由于原来swagger-bootstrap-ui采用的是后端Java代码+前端Ui混合打包的方式,在微服务架构下显的很臃肿,因此项目正式更名为knife4j

更名后主要专注的方面
- 前后端Java代码以及前端Ui模块进行分离,在微服务架构下使用更加灵活
- 提供专注于Swagger的增强解决方案,不同于只是改善增强前端Ui部分

相关文档请参考：https://doc.xiaominfo.com/knife4j/documentation/

## 30.2 实现案例之Swagger3
> 我们先看下最新Swagger3 如何配置和实现接口。
### 30.2.1 POM
根据上文介绍，我们引入springfox依赖包，最新的是3.x.x版本。和之前的版本比，只需要引入如下的starter包即可。
```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-boot-starter</artifactId>
    <version>3.0.0</version>
</dependency>
```
### 30.2.2 Swagger Config
我们在配置中还增加了一些全局的配置，比如全局参数等
```java
package tech.pdai.springboot.swagger.config;

import io.swagger.annotations.ApiOperation;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import springfox.documentation.builders.*;
import springfox.documentation.oas.annotations.EnableOpenApi;
import springfox.documentation.schema.ScalarType;
import springfox.documentation.service.*;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import tech.pdai.springboot.swagger.constant.ResponseStatus;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * swagger config for open api.
 *
 * @author pdai
 */
@Configuration
@EnableOpenApi
public class SwaggerConfig {

    /**
     * @return swagger config
     */
    @Bean
    public Docket openApi() {
        return new Docket(DocumentationType.OAS_30)
                .groupName("Test group")
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
                .paths(PathSelectors.any())
                .build()
                .globalRequestParameters(getGlobalRequestParameters())
                .globalResponses(HttpMethod.GET, getGlobalResponse());
    }

    /**
     * @return global response code->description
     */
    private List<Response> getGlobalResponse() {
        return ResponseStatus.HTTP_STATUS_ALL.stream().map(
                a -> new ResponseBuilder().code(a.getResponseCode()).description(a.getDescription()).build())
                .collect(Collectors.toList());
    }

    /**
     * @return global request parameters
     */
    private List<RequestParameter> getGlobalRequestParameters() {
        List<RequestParameter> parameters = new ArrayList<>();
        parameters.add(new RequestParameterBuilder()
                .name("AppKey")
                .description("App Key")
                .required(false)
                .in(ParameterType.QUERY)
                .query(q -> q.model(m -> m.scalarModel(ScalarType.STRING)))
                .required(false)
                .build());
        return parameters;
    }

    /**
     * @return api info
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("Swagger API")
                .description("test api")
                .contact(new Contact("pdai", "http://pdai.tech", "suzhou.daipeng@gmail.com"))
                .termsOfServiceUrl("http://xxxxxx.com/")
                .version("1.0")
                .build();
    }
}
```
### 30.2.3 controller接口
```java
package tech.pdai.springboot.swagger.controller;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiOperation;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.swagger.entity.param.UserParam;
import tech.pdai.springboot.swagger.entity.vo.AddressVo;
import tech.pdai.springboot.swagger.entity.vo.UserVo;

import java.util.Collections;
import java.util.List;

/**
 * @author pdai
 */
@Api
@RestController
@RequestMapping("/user")
public class UserController {

    /**
     * http://localhost:8080/user/add .
     *
     * @param userParam user param
     * @return user
     */
    @ApiOperation("Add User")
    @PostMapping("add")
    @ApiImplicitParam(name = "userParam", type = "body", dataTypeClass = UserParam.class, required = true)
    public ResponseEntity<String> add(@RequestBody UserParam userParam) {
        return ResponseEntity.ok("success");
    }

    /**
     * http://localhost:8080/user/list .
     *
     * @return user list
     */
    @ApiOperation("Query User List")
    @GetMapping("list")
    public ResponseEntity<List<UserVo>> list() {
        List<UserVo> userVoList = Collections.singletonList(UserVo.builder().name("dai").age(18)
                .address(AddressVo.builder().city("SZ").zipcode("10001").build()).build());
        return ResponseEntity.ok(userVoList);
    }
}
```
### 30.2.4 运行测试
打开文档API网页
![149.springboot-hello-doc-1.png](../../assets/images/04-主流框架/spring/149.springboot-hello-doc-1.png)

测试添加一个用户
![150.springboot-hello-doc-2.png](../../assets/images/04-主流框架/spring/150.springboot-hello-doc-2.png)

查询用户列表
![151.springboot-hello-doc-3.png](../../assets/images/04-主流框架/spring/151.springboot-hello-doc-3.png)
## 30.3 实现案例之Knife4J
> 这里展示目前使用Java生成接口文档的最佳实现: SwaggerV3(OpenAPI)+ Knife4J。
### 30.3.1 POM
```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>3.0.3</version>
</dependency>
```
### 30.3.2 yml配置
```yml
server:
  port: 8080
knife4j:
  enable: true
  documents:
    - group: Test Group
      name: My Documents
      locations: classpath:wiki/*
  setting:
    # default lang
    language: en-US
    # footer
    enableFooter: false
    enableFooterCustom: true
    footerCustomContent: MIT | [Java 全栈]()
    # header
    enableHomeCustom: true
    homeCustomLocation: classpath:wiki/README.md
    # models
    enableSwaggerModels: true
    swaggerModelName: My Models
```
### 30.3.3 注入配置
```java
package tech.pdai.springboot.knife4j.config;

import com.github.xiaoymin.knife4j.spring.extension.OpenApiExtensionResolver;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import springfox.documentation.builders.*;
import springfox.documentation.oas.annotations.EnableOpenApi;
import springfox.documentation.schema.ScalarType;
import springfox.documentation.service.*;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import tech.pdai.springboot.knife4j.constant.ResponseStatus;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * swagger config for open api.
 *
 * @author pdai
 */
@Configuration
@EnableOpenApi
public class OpenApiConfig {

    /**
     * open api extension by knife4j.
     */
    private final OpenApiExtensionResolver openApiExtensionResolver;

    @Autowired
    public OpenApiConfig(OpenApiExtensionResolver openApiExtensionResolver) {
        this.openApiExtensionResolver = openApiExtensionResolver;
    }

    /**
     * @return swagger config
     */
    @Bean
    public Docket openApi() {
        String groupName = "Test Group";
        return new Docket(DocumentationType.OAS_30)
                .groupName(groupName)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
                .paths(PathSelectors.any())
                .build()
                .globalRequestParameters(getGlobalRequestParameters())
                .globalResponses(HttpMethod.GET, getGlobalResponse())
                .extensions(openApiExtensionResolver.buildExtensions(groupName))
                .extensions(openApiExtensionResolver.buildSettingExtensions());
    }

    /**
     * @return global response code->description
     */
    private List<Response> getGlobalResponse() {
        return ResponseStatus.HTTP_STATUS_ALL.stream().map(
                a -> new ResponseBuilder().code(a.getResponseCode()).description(a.getDescription()).build())
                .collect(Collectors.toList());
    }

    /**
     * @return global request parameters
     */
    private List<RequestParameter> getGlobalRequestParameters() {
        List<RequestParameter> parameters = new ArrayList<>();
        parameters.add(new RequestParameterBuilder()
                .name("AppKey")
                .description("App Key")
                .required(false)
                .in(ParameterType.QUERY)
                .query(q -> q.model(m -> m.scalarModel(ScalarType.STRING)))
                .required(false)
                .build());
        return parameters;
    }

    /**
     * @return api info
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("My API")
                .description("test api")
                .contact(new Contact("pdai", "http://pdai.tech", "suzhou.daipeng@gmail.com"))
                .termsOfServiceUrl("http://xxxxxx.com/")
                .version("1.0")
                .build();
    }
}
```
其中ResponseStatus封装
```java
package tech.pdai.springboot.knife4j.constant;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * @author pdai
 */
@Getter
@AllArgsConstructor
public enum ResponseStatus {

    SUCCESS("200", "success"),
    FAIL("500", "failed"),

    HTTP_STATUS_200("200", "ok"),
    HTTP_STATUS_400("400", "request error"),
    HTTP_STATUS_401("401", "no authentication"),
    HTTP_STATUS_403("403", "no authorities"),
    HTTP_STATUS_500("500", "server error");

    public static final List<ResponseStatus> HTTP_STATUS_ALL = Collections.unmodifiableList(
            Arrays.asList(HTTP_STATUS_200, HTTP_STATUS_400, HTTP_STATUS_401, HTTP_STATUS_403, HTTP_STATUS_500
            ));

    /**
     * response code
     */
    private final String responseCode;

    /**
     * description.
     */
    private final String description;

}
```
### 30.3.4 Controller接口
```java
package tech.pdai.springboot.knife4j.controller;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.knife4j.entity.param.AddressParam;

/**
 * Address controller test demo.
 *
 * @author pdai
 */
@Api(value = "Address Interfaces", tags = "Address Interfaces")
@RestController
@RequestMapping("/address")
public class AddressController {
    /**
     * http://localhost:8080/address/add .
     *
     * @param addressParam param
     * @return address
     */
    @ApiOperation("Add Address")
    @PostMapping("add")
    @ApiImplicitParams({
            @ApiImplicitParam(name = "city", type = "query", dataTypeClass = String.class, required = true),
            @ApiImplicitParam(name = "zipcode", type = "query", dataTypeClass = String.class, required = true)
    })
    public ResponseEntity<String> add(AddressParam addressParam) {
        return ResponseEntity.ok("success");
    }

}
```
### 30.3.5 运行测试
自定义用户主页
![152.springboot-hello-doc-4.png](../../assets/images/04-主流框架/spring/152.springboot-hello-doc-4.png)

model模型
![153.springboot-hello-doc-5.png](../../assets/images/04-主流框架/spring/153.springboot-hello-doc-5.png)

全局参数 和配置
![154.springboot-hello-doc-6.png](../../assets/images/04-主流框架/spring/154.springboot-hello-doc-6.png)

自定义文档
![155.springboot-hello-doc-7.png](../../assets/images/04-主流框架/spring/155.springboot-hello-doc-7.png)

接口文档和测试接口
![156.springboot-hello-doc-8.png](../../assets/images/04-主流框架/spring/156.springboot-hello-doc-8.png)

# 三十一、SpringBoot接口 - 如何生成接口文档之集成Smart-Doc
> 上文我们看到可以通过Swagger系列可以快速生成API文档， 但是这种API文档生成是需要在接口上添加注解等，这表明这是一种侵入式方式； 那么有没有非侵入式方式呢, 比如通过注释生成文档？ 本文主要介绍非侵入式的方式及集成Smart-doc案例。我们构建知识体系时使用Smart-doc这类工具并不是目标，而是要了解非侵入方式能做到什么程度和技术思路, 最后平衡下来多数情况下多数人还是会选择Swagger+openapi技术栈的。
## 31.1 准备知识点
> 需要了解Swagger侵入性和依赖性， 以及Smart-Doc这类工具如何解决这些问题, 部分内容来自<a href='https://gitee.com/smart-doc-team/smart-doc'>官方网站</a>
### 31.1.1 为什么会产生Smart-Doc这类工具？
> 既然有了Swagger， 为何还会产生Smart-Doc这类工具呢？ 本质上是Swagger侵入性和依赖性。

我们来看下目前主流的技术文档工具存在什么问题：
- **侵入性强**，需要编写大量注解，代表工具如：swagger，还有一些公司自研的文档工具
- **强依赖性**，如果项目不想使用该工具，业务代码无法编译通过。
- 代码解析能力弱，使用文档不齐全，主要代表为国内众多开源的相关工具。
- 众多基于注释分析的工具无法解析jar包里面的注释(sources jar包)，需要人工配置源码路径，无法满足DevOps构建场景。
- 部分工具无法支持多模块复杂项目代码分析。
### 31.1.2 什么是Smart-Doc？有哪些特性？
> smart-doc是一款同时支持JAVA REST API和Apache Dubbo RPC接口文档生成的工具，smart-doc在业内率先提出基于JAVA泛型定义推导的理念， 完全基于接口源码来分析生成接口文档，不采用任何注解侵入到业务代码中。你只需要按照java-doc标准编写注释， smart-doc就能帮你生成一个简易明了的Markdown、HTML5、Postman Collection2.0+、OpenAPI 3.0+的文档。
- 零注解、零学习成本、只需要写标准JAVA注释。
- 基于源代码接口定义自动推导，强大的返回结构推导。
- 支持Spring MVC、Spring Boot、Spring Boot Web Flux(controller书写方式)、Feign。
- 支持Callable、Future、CompletableFuture等异步接口返回的推导。
- 支持JavaBean上的JSR303参数校验规范，包括分组验证。
- 对JSON请求参数的接口能够自动生成模拟JSON参数。
- 对一些常用字段定义能够生成有效的模拟值。
- 支持生成JSON返回值示例。
- 支持从项目外部加载源代码来生成字段注释(包括标准规范发布的jar包)。
- 支持生成多种格式文档：Markdown、HTML5、Asciidoctor、Postman Collection、OpenAPI 3.0。 Up- 开放文档数据，可自由实现接入文档管理系统。
- 支持导出错误码和定义在代码中的各种字典码到接口文档。
- 支持Maven、Gradle插件式轻松集成。
- 支持Apache Dubbo RPC接口文档生成。
- debug接口调试html5页面完全支持文件上传，下载(@download tag标记下载方法)测试
## 31.2 实现案例
> 从smart-doc 1.7.9开始官方提供了Maven插件，可以通过在项目中集成smart-doc的Maven插件，然后运行插件直接生成文档。 我们的案例基于smart-doc-maven-plugin，生成文档。示例参考<a href ='https://smart-doc-group.github.io/#/zh-cn/plugins/maven_plugin'>官方配置文档而写。</a>
### 31.2.1 配置
添加maven的插件
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        <plugin>
            <groupId>com.github.shalousun</groupId>
            <artifactId>smart-doc-maven-plugin</artifactId>
            <version>2.4.8</version>
            <configuration>
                <!--指定生成文档的使用的配置文件,配置文件放在自己的项目中-->
                <configFile>./src/main/resources/smart-doc.json</configFile>
                <!--指定项目名称，推荐使用动态参数，例如${project.description}-->
                <!--如果smart-doc.json中和此处都未设置projectName，2.3.4开始，插件自动采用pom中的projectName作为设置-->
                <!--<projectName>${project.description}</projectName>-->
                <!--smart-doc实现自动分析依赖树加载第三方依赖的源码，如果一些框架依赖库加载不到导致报错，这时请使用excludes排除掉-->
                <excludes>
                    <!--格式为：groupId:artifactId;参考如下-->
                    <!--也可以支持正则式如：com.alibaba:.* -->
                    <exclude>com.alibaba:fastjson</exclude>
                </excludes>
                <!--includes配置用于配置加载外部依赖源码,配置后插件会按照配置项加载外部源代码而不是自动加载所有，因此使用时需要注意-->
                <!--smart-doc能自动分析依赖树加载所有依赖源码，原则上会影响文档构建效率，因此你可以使用includes来让插件加载你配置的组件-->
                <includes>
                    <!--格式为：groupId:artifactId;参考如下-->
                    <!--也可以支持正则式如：com.alibaba:.* -->
                    <include>com.alibaba:fastjson</include>
                </includes>
            </configuration>
            <executions>
                <execution>
                    <!--如果不需要在执行编译时启动smart-doc，则将phase注释掉-->
                    <phase>compile</phase>
                    <goals>
                        <!--smart-doc提供了html、openapi、markdown等goal，可按需配置-->
                        <goal>html</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```
其中./src/main/resources/smart-doc.json是配置文件。
```json
{
  "serverUrl": "http://127.0.0.1", //服务器地址,非必须。导出postman建议设置成http://{{server}}方便直接在postman直接设置环境变量
  "pathPrefix": "", //设置path前缀,非必须。如配置Servlet ContextPath 。@since 2.2.3
  "isStrict": false, //是否开启严格模式
  "allInOne": true,  //是否将文档合并到一个文件中，一般推荐为true
  "outPath": "D://md2", //指定文档的输出路径
  "coverOld": true,  //是否覆盖旧的文件，主要用于markdown文件覆盖
  "createDebugPage": true,//@since 2.0.0 smart-doc支持创建可以测试的html页面，仅在AllInOne模式中起作用。
  "packageFilters": "",//controller包过滤，多个包用英文逗号隔开，2.2.2开始需要采用正则：com.test.controller.*
  "md5EncryptedHtmlName": false,//只有每个controller生成一个html文件时才使用
  "style":"xt256", //基于highlight.js的代码高设置,可选值很多可查看码云wiki，喜欢配色统一简洁的同学可以不设置
  "projectName": "pdai-springboot-demo-smart-doc",//配置自己的项目名称，不设置则插件自动获取pom中的projectName
  "skipTransientField": true,//目前未实现
  "sortByTitle":false,//接口标题排序，默认为false,@since 1.8.7版本开始
  "showAuthor":true,//是否显示接口作者名称，默认是true,不想显示可关闭
  "requestFieldToUnderline":true,//自动将驼峰入参字段在文档中转为下划线格式,//@since 1.8.7版本开始
  "responseFieldToUnderline":true,//自动将驼峰入参字段在文档中转为下划线格式,//@since 1.8.7版本开始
  "inlineEnum":true,//设置为true会将枚举详情展示到参数表中，默认关闭，//@since 1.8.8版本开始
  "recursionLimit":7,//设置允许递归执行的次数用于避免一些对象解析卡主，默认是7，正常为3次以内，//@since 1.8.8版本开始
  "allInOneDocFileName":"index.html",//自定义设置输出文档名称, @since 1.9.0
  "requestExample":"true",//是否将请求示例展示在文档中，默认true，@since 1.9.0
  "responseExample":"true",//是否将响应示例展示在文档中，默认为true，@since 1.9.0

  "ignoreRequestParams":[ //忽略请求参数对象，把不想生成文档的参数对象屏蔽掉，@since 1.9.2
    "org.springframework.ui.ModelMap"
  ],
  "dataDictionaries": [{ //配置数据字典，没有需求可以不设置
    "title": "http状态码字典", //数据字典的名称
    "enumClassName": "tech.pdai.springboot.smartdoc.constant.ResponseStatus", //数据字典枚举类名称
    "codeField": "responseCode",//数据字典字典码对应的字段名称
    "descField": "description"//数据字典对象的描述信息字典
  }],
  "errorCodeDictionaries": [{ //错误码列表，没有需求可以不设置
    "title": "title",
    "enumClassName": "tech.pdai.springboot.smartdoc.constant.ResponseStatus", //错误码枚举类
    "codeField": "responseCode",//错误码的code码字段名称
    "descField": "description"//错误码的描述信息对应的字段名
  }],
  "revisionLogs": [{ //文档变更记录，非必须
    "version": "1.1", //文档版本号
    "revisionTime": "2022-07-01 22:12:01", //文档修订时间
    "status": "update", //变更操作状态，一般为：创建、更新等
    "author": "pdai", //文档变更作者
    "remarks": "init user api" //变更描述
  },{ //文档变更记录，非必须
    "version": "1.2", //文档版本号
    "revisionTime": "2022-07-01 22:12:02", //文档修订时间
    "status": "update", //变更操作状态，一般为：创建、更新等
    "author": "pdai", //文档变更作者
    "remarks": "add address api" //变更描述
  }
  ],
  "customResponseFields": [{ //自定义添加字段和注释，一般用户处理第三方jar包库，非必须
    "name": "code",//覆盖响应码字段
    "desc": "响应代码",//覆盖响应码的字段注释
    "ownerClassName": "org.springframework.data.domain.Pageable", //指定你要添加注释的类名
    "ignore":true, //设置true会被自动忽略掉不会出现在文档中
    "value": "00000"//设置响应码的值
  }],
  "requestHeaders": [{ //设置请求头，没有需求可以不设置
    "name": "token",//请求头名称
    "type": "string",//请求头类型
    "desc": "desc",//请求头描述信息
    "value":"token请求头的值",//不设置默认null
    "required": false,//是否必须
    "since": "-",//什么版本添加的改请求头
    "pathPatterns": "/app/test/**",//请看https://gitee.com/smart-doc-team/smart-doc/wikis/请求头高级配置?sort_id=4178978
    "excludePathPatterns":"/app/page/**"//请看https://gitee.com/smart-doc-team/smart-doc/wikis/请求头高级配置?sort_id=4178978
  },{
    "name": "appkey",//请求头
    "type": "string",//请求头类型
    "desc": "desc",//请求头描述信息
    "value":"appkey请求头的值",//不设置默认null
    "required": false,//是否必须
    "pathPatterns": "/test/add,/testConstants/1.0",//正则表达式过滤请求头,url匹配上才会添加该请求头，多个正则用分号隔开
    "since": "-"//什么版本添加的改请求头
  }],
  "requestParams": [ //设置公共参数，没有需求可以不设置
    {
      "name": "configPathParam",//请求名称
      "type": "string",//请求类型
      "desc": "desc",//请求描述信息
      "paramIn": "path", // 参数所在位置 header-请求头, path-路径参数, query-参数
      "value":"testPath",//不设置默认null
      "required": false,//是否必须
      "since": "2.2.3",//什么版本添加的该请求
      "pathPatterns": "/app/test/**",//请看https://gitee.com/smart-doc-team/smart-doc/wikis/请求高级配置?sort_id=4178978
      "excludePathPatterns":"/app/page/**"//请看https://gitee.com/smart-doc-team/smart-doc/wikis/请求高级配置?sort_id=4178978
    }],
  "responseBodyAdvice":{ //自smart-doc 1.9.8起，非必须项，ResponseBodyAdvice统一返回设置(不要随便配置根据项目的技术来配置)，可用ignoreResponseBodyAdvice tag来忽略
    "className":"tech.pdai.springboot.smartdoc.entity.ResponseResult" //通用响应体
  }
}
```
## 31.3 运行测试
可以通过Maven命令生成文档
```sh
//生成html
mvn -Dfile.encoding=UTF-8 smart-doc:html
```
在IDEA中，也可以通过maven插件构建
![157.springboot-api-smart-doc-1.png](../../assets/images/04-主流框架/spring/157.springboot-api-smart-doc-1.png)

maven构建日志如下

```sh
[INFO] Scanning for projects...
[INFO] 
[INFO] --------------< tech.pdai:115-springboot-demo-smart-doc >---------------
[INFO] Building 115-springboot-demo-smart-doc 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] >>> smart-doc-maven-plugin:2.4.8:html (default-cli) > compile @ 115-springboot-demo-smart-doc >>>
[INFO] 
[INFO] --- maven-resources-plugin:3.2.0:resources (default-resources) @ 115-springboot-demo-smart-doc ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Using 'UTF-8' encoding to copy filtered properties files.
[INFO] Copying 0 resource
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ 115-springboot-demo-smart-doc ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] <<< smart-doc-maven-plugin:2.4.8:html (default-cli) < compile @ 115-springboot-demo-smart-doc <<<
[INFO] 
[INFO] 
[INFO] --- smart-doc-maven-plugin:2.4.8:html (default-cli) @ 115-springboot-demo-smart-doc ---
[INFO] ------------------------------------------------------------------------
[INFO] Smart-doc Start preparing sources at: 2022-07-01 22:43:54
[INFO] Artifacts that the current project depends on: ["org.springframework.boot:spring-boot-starter-web","org.springframework.boot:spring-boot-configuration-processor","org.projectlombok:lombok"]
[INFO] Smart-doc has loaded the source code path: [{"path":"D:/git/tech-pdai-spring-demos/115-springboot-demo-smart-doc/src/main/java"}]
[INFO] Smart-doc Starting Create API Documentation at: 2022-07-01 22:43:54
[INFO] API documentation is output to => D://md2
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  2.196 s
[INFO] Finished at: 2022-07-01T22:43:55+08:00
[INFO] ------------------------------------------------------------------------
```
构建后的html如下：
![158.springboot-api-smart-doc-2.png](../../assets/images/04-主流框架/spring/158.springboot-api-smart-doc-2.png)

也可以看到还自动提供了mock的数据，以及测试接口的按钮。还包含自定义的返回枚举类型等。
![159.springboot-api-smart-doc-3.png](../../assets/images/04-主流框架/spring/159.springboot-api-smart-doc-3.png)
## 31.4 生成更多类型的文档
mart-doc 还支持生成如下类型的文档：
```sh
//生成markdown
mvn -Dfile.encoding=UTF-8 smart-doc:markdown
//生成adoc
mvn -Dfile.encoding=UTF-8 smart-doc:adoc
//生成postman json数据
mvn -Dfile.encoding=UTF-8 smart-doc:postman
// 生成 Open Api 3.0+, Since smart-doc-maven-plugin 1.1.5
mvn -Dfile.encoding=UTF-8 smart-doc:openapi
```
## 31.5 进一步理解
### 31.5.1 注释信息是有限的，smart-doc如何从注释拓展文档内容呢？
一方面`smart-doc`的实现初衷是通过使用`javadoc`文档注释来去除注解式的侵入，因此`smart-doc`每增加一个功能首先都是去考虑`javadoc`原生的`tag`,

下面对`smart-doc`使用的一些`javadoc`的注释`tag`做介绍。

| Tag名称     | 描述                                                                                   |
|-------------|----------------------------------------------------------------------------------------|
| @param      | 对于在 Spring Boot 接口层，对于简单类型的参数必须在使用 @param 时写上注释描述，对于 Entity 类型，smart-doc 则不会检查。 |
| @deprecated | 可以在注释中用于标记接口已经废弃，作用同 @Deprecated 注解。                                 |
| @apiNote    | @apiNote 是 JAVA 新增的文档 tag，smart-doc 使用 @apiNote 的注释作为方法的详细描述，因此可以使用 @apiNote 来写一段长注释。如果一个方法不写 @apiNote 注释说明，smart-doc 直接使用方法默认注释填充。 |


另一方面，原生的tag是不够的，所以smart-doc又通过自定义tag来支持更多功能的拓展

| Tag名称                   | 描述                                                                                     |
|---------------------------|------------------------------------------------------------------------------------------|
| @ignore                   | 用于过滤请求参数对象上的字段，设置后不输出到文档；也可用于方法或Controller上忽略文档输出；还可忽略请求参数。 |
| @required                 | 标注请求参数字段为必需，设置文档中显示为true（适用于非JSR303验证的场景）。                   |
| @mock                     | 用于设置基本类型字段的自定义文档值，代替随机值，方便输出交付文档。                           |
| @dubbo                    | 用于Dubbo API接口类，让smart-doc扫描生成Dubbo RPC接口文档。                               |
| @restApi                  | 用于Spring Cloud Feign接口，支持smart-doc扫描生成文档。                                   |
| @order                    | 设置Controller或API入口的自定义排序序号（例如@order 1）。                                  |
| @ignoreResponseBodyAdvice | 忽略ResponseBodyAdvice设置的包装类。                                                      |
| @download                 | 标注文件下载方法，生成debug页面时支持文件下载测试（包括请求头参数）。                       |
| @page                     | 标注渲染静态页面的方法，测试时自动在新浏览器标签显示页面。                                 |
| @ignoreParams             | 标注方法上忽略特定参数（多个参数用空格隔开），不显示在文档中。                             |
| @response                 | 标注方法上自定义返回json示例（适用于基础类型响应，如Result<String>）。                     |
| @tag                      | 用于方法分类，将不同Controller的方法指定到多个分类（从2.2.5版本开始）。                    |
### 31.5.2 Maven多模块中使用插件有没有比较好的实践？
> 在独立的Maven项目中使用smart-doc，当前可以说是如丝般爽滑。但是在Maven的多模块项目中使用smart-doc-maven-plugin时，很多同学就有疑问了， smart-doc插件我到底是放在什么地方合适？是放在Maven的根pom.xml中？还是说各个需要生成API接口文档的模块中呢？ 下面就来说说根据不同的项目结构应该怎么放插件。

完全的父子级关系的maven项目：
```sh
├─parent
├──common
│   pom.xml
├──web1
│   pom.xml
├──web2
│   pom.xml
└─pom.xml
```
上面的maven结构假设是严格按照父子级来配置的，然后web1和web2都依赖于common， 这种情况下如果跑到web1下或者web2目录下直接执行mvn命令来编译 都是无法完成的。需要在根目录上去执行命令编译命令才能通过，而smart-doc插件会通过类加载器去加载用户配置的一些类，因此是需要调用编译的和执行命令 是一样的。这种情况下建议你建smart-doc-maven-plugin放到根pom.xml中，在web1和web2中放置各自的smart-doc.json配置。 然后通过-pl去指定让smart-doc生成指定 模块的文档。操作命令如下：
```sh
# 生成web1模块的api文档
mvn smart-doc:markdown -Dfile.encoding=UTF-8  -pl :web1 -am
# 生成web2模块的api文档
mvn smart-doc:markdown -Dfile.encoding=UTF-8  -pl :web2 -am
```
如果不是按照严格父子级构建的项目，还是以上面的结构例子来说。common模块放在类parent中，但是common的pom.xml并没有定义parent。 common模块也很少变更，很多公司内部可能就直接把common单独depoly上传到了公司的Nexus仓库中，这种情况下web1和web2虽然依赖于common， 但是web1和web2都可以在web1和web2目录下用命令编译，这种情况下直接将smart-doc-maven-plugin单独放到web1和web2中是可以做构建生成文档的。

【<a href ='https://gitee.com/smart-doc-team/spring-boot-maven-multiple-module'>多模块测试用例参考</a>】

注意： 怎么去使用插件并没有固定的模式，最重要的是熟练Maven的一些列操作，然后根据自己的项目情况来调整。技巧娴熟就能应对自如。 对于插件的使用，从smart-doc-maven-plugin 1.2.0开始，插件是能够自动分析生成模块的依赖来加载必要的源码，并不会将所有模块的接口文档合并到一个文档中。
### 31.5.3 如果生成文档时遇到问题，该如何调试？
> 在使用smart-doc-maven-plugin插件来构建生成API文档的过程中可能会出现一些错误问题。官方文档中提供了调试的方案：
1. 添加smart-doc依赖

因为smart-doc-maven-plugin最终是使用smart-doc来完成项目的源码分析和文档生成的， 通常情况下真正的调试的代码是smart-doc。但这个过程主要通过smart-doc-maven-plugin来排查。
```xml
<dependency>
     <groupId>com.github.shalousun</groupId>
     <artifactId>smart-doc</artifactId>
     <version>[最新版本]</version>
     <scope>test</scope>
</dependency>

```
注意： 使用smart-doc的版本最好和插件依赖的smart-doc版本一致。
2. 添加断点

添加断点如图所示
![160.springboot-api-smart-doc-4.png](../../assets/images/04-主流框架/spring/160.springboot-api-smart-doc-4.png)

3. Debug模式运行构建目标

maven插件在idea中运行debug非常简单，操作如下图。
![161.springboot-api-smart-doc-6.png](../../assets/images/04-主流框架/spring/161.springboot-api-smart-doc-6.png)

这样就可以直接进入断点了。

提示： 上面是通过插件去作为入口调试smart-doc的源码，如果你想调试插件本身的源码执行过程，则将插件的依赖添加到项目依赖中,如下：
```xml
<dependency>
    <groupId>com.github.shalousun</groupId>
    <artifactId>smart-doc-maven-plugin</artifactId>
    <version>【maven仓库最新版本】</version>
</dependency>
```
然后通过上面的类似步骤调试smart-doc-maven-plugin的源码
# 三十二、SpringBoot接口 - 如何访问外部接口
> 在SpringBoot接口开发中，存在着本模块的代码需要访问外面模块接口或外部url链接的需求, 比如调用外部的地图API或者天气API。那么有哪些方式可以调用外部接口呢？
## 32.1 什么样的场景需要访问外部接口
调用其它模块的API，或者其它三方服务，比如调用外部的地图API或者天气API等。

## 32.2 访问外部接口的常见方案
主要有如下几种方案，其中RestTemplate需要重点掌握。
### 32.2.1 方案一: 采用原生的Http请求
在代码中采用原生的http请求，代码参考如下:
```java
RequestMapping("/doPostGetJson")
public String doPostGetJson() throws ParseException {
   //此处将要发送的数据转换为json格式字符串
   String jsonText = "{id: 1}";
   JSONObject json = (JSONObject) JSONObject.parse(jsonText);
   JSONObject sr = this.doPost(json);
   System.out.println("返回参数: " + sr);
   return sr.toString();
}

public static JSONObject doPost(JSONObject date) {
   HttpClient client = HttpClients.createDefault();
   // 要调用的接口方法
   String url = "http://192.168.1.101:8080/getJson";
   HttpPost post = new HttpPost(url);
   JSONObject jsonObject = null;
   try {
      StringEntity s = new StringEntity(date.toString());
      s.setContentEncoding("UTF-8");
      s.setContentType("application/json");
      post.setEntity(s);
      post.addHeader("content-type", "text/xml");
      HttpResponse res = client.execute(post);
      String response1 = EntityUtils.toString(res.getEntity());
      System.out.println(response1);
      if (res.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
         String result = EntityUtils.toString(res.getEntity());// 返回json格式: 
         jsonObject = JSONObject.parseObject(result);
      }
   } catch (Exception e) {
      throw new RuntimeException(e);
   }
   return jsonObject;
}
```
### 32.2.2 方案二: 采用Feign进行消费
1. 在maven项目中添加依赖
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-feign</artifactId>
    <version>1.2.2.RELEASE</version>
</dependency>
```
2. 编写接口，放置在service层

这里的decisionEngine.url 是配置在properties中的 是ip地址和端口号 decisionEngine.url=http://10.2.1.148:3333 , /decision/person 是接口名字
```java
@FeignClient(url = "${decisionEngine.url}",name="engine")
public interface DecisionEngineService {
　　@RequestMapping(value="/decision/person",method= RequestMethod.POST)
　　public JSONObject getEngineMesasge(@RequestParam("uid") String uid,@RequestParam("productCode") String productCode);

}
```
3. 在Java的启动类上加上@EnableFeignClients
```java
@EnableFeignClients //参见此处
@EnableDiscoveryClient
@SpringBootApplication
@EnableResourceServer
public class Application   implements CommandLineRunner {
    private static final Logger LOGGER = LoggerFactory.getLogger(Application.class);
    @Autowired
    private AppMetricsExporter appMetricsExporter;

    @Autowired
    private AddMonitorUnitService addMonitorUnitService;

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }    
}
```
4. 在代码中调用接口即可
```java
@Autowired
private DecisionEngineService decisionEngineService ;
// ...
decisionEngineService.getEngineMesasge("uid" ,  "productCode");
```
5. Feign的主要原理

 Feign 是一个**声明式的 HTTP 客户端**，它通过注解和动态代理技术自动处理 HTTP 请求的细节。下面我逐步解释其工作原理：

-  **Feign 的核心机制：动态代理和注解解析**
   - 当您使用 `@FeignClient` 注解定义接口（如 `DecisionEngineService`）时，Spring 在启动时会通过 `@EnableFeignClients` 扫描这些接口。
   - Feign 在运行时**动态生成该接口的实现类**（代理对象）。当您调用 `decisionEngineService.getEngineMesasge(...)` 时，实际上是在调用这个代理对象的方法。
   - 代理方法会根据接口上的注解（如 `@RequestMapping`、`@RequestParam`）自动构建 HTTP 请求：
     - **URL 拼接**：`@FeignClient(url = "${decisionEngine.url}")` 从配置文件（如 `application.properties`）中读取 `decisionEngine.url` 的值（例如 `http://10.2.1.148:3333/decision/person`），并与 `@RequestMapping` 中的路径组合成完整 URL。
     - **参数映射**：`@RequestParam` 将方法参数（如 `uid`）转换为 HTTP 请求参数（如 `?uid=value&productCode=value`）。
     - **HTTP 方法**：`method = RequestMethod.POST` 指定使用 POST 请求。

- 2. **简化了 HTTP 调用流程**
  - 传统方式需要手动使用 `RestTemplate` 或 `HttpClient` 编写代码来设置 URL、参数、请求头等。Feign 将这些细节封装起来，您只需像调用本地方法一样定义接口，无需关心底层 HTTP 实现。
  - 示例中，您直接注入 `DecisionEngineService` 并调用方法，Feign 自动完成以下步骤：
    - 解析注解信息。
    - 构造 HTTP 请求（包括 URL、参数、方法类型）。
    - 发送请求到第三方服务（如 `http://10.2.1.148:3333/decision/person`）。
    - 处理响应并返回结果（这里返回 `JSONObject`）。
- 3. **Spring 集成提供便利**
  - `@EnableFeignClients` 启用 Feign 客户端的自动配置，让 Spring 管理这些接口的 Bean 生命周期。
  - `@Autowired` 依赖注入使得 Feign 客户端像普通 Spring Bean 一样被使用，简化了代码。
6. 如果请求需要携带cookie/token等信息怎么办?

在 Feign 中传递认证信息（如 Cookie、Token、JWT）有几种标准且优雅的方式。您可以根据不同的场景选择最合适的一种。

下面我为您详细介绍三种最常用的方法，从简单到复杂。

---

- 方法一：使用 `@RequestHeader` 注解（适用于参数明确、固定的场景）

这是最直接的方法，在 Feign 客户端接口的方法参数上直接使用 `@RequestHeader` 注解。

**适用场景**：调用方明确知道 Token 的值，并且能直接作为参数传入。

**代码示例**：
```java
@FeignClient(url = "${decisionEngine.url}", name = "engine")
public interface DecisionEngineService {
    
    @RequestMapping(value = "", method = RequestMethod.POST)
    public JSONObject getEngineMesasge(
            @RequestHeader("Authorization") String authorizationToken, // 传递 JWT Token
            @RequestHeader("Cookie") String cookie,                    // 传递 Cookie
            @RequestParam("uid") String uid,
            @RequestParam("productCode") String productCode
    );
}
```

**调用方式**：
```java
// 在调用处，手动获取并传入 Token 和 Cookie
String jwtToken = "Bearer eyJhbGciOiJ...";
String cookie = "sessionId=abc123; user=john";
decisionEngineService.getEngineMesasge(jwtToken, cookie, "uid", "productCode");
```

**优点**：简单直观。
**缺点**：每个需要认证的方法都要重复添加这些参数，调用方每次都要手动获取并传入，代码冗余。

---

- 方法二：实现 `RequestInterceptor` 接口（最推荐、最通用的方式）

这是 **生产环境中最常用、最优雅** 的解决方案。通过实现一个全局的请求拦截器，自动为所有 Feign 请求添加统一的认证头。

**适用场景**：绝大多数情况，特别是认证信息（如 Token）来自当前用户会话或统一的安全上下文（如 Spring Security）。

**实现步骤**：

1.  **创建拦截器类**：创建一个实现了 `feign.RequestInterceptor` 接口的类，并加上 `@Component` 注解，让其被 Spring 管理。

```java
import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import javax.servlet.http.HttpServletRequest;

@Component
public class FeignAuthRequestInterceptor implements RequestInterceptor {

    @Override
    public void apply(RequestTemplate template) {
        // 1. 从当前请求上下文中获取 HttpServletRequest
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes != null) {
            HttpServletRequest request = attributes.getRequest();

            // 2. 从当前请求中获取认证信息（例如从请求头中获取）
            String authorizationHeader = request.getHeader("Authorization");
            String cookieHeader = request.getHeader("Cookie");

            // 3. 将认证信息设置到新的 Feign 请求头中
            if (authorizationHeader != null) {
                template.header("Authorization", authorizationHeader);
            }
            if (cookieHeader != null) {
                template.header("Cookie", cookieHeader);
            }

            // 或者，如果您使用固定的 Token（例如从配置中心读取）
            // template.header("Authorization", "Bearer " + yourFixedToken);
        }
    }
}
```

2.  **修改 Feign 客户端接口**：**移除方法参数中的 `@RequestHeader`**，拦截器会自动处理。

```java
@FeignClient(url = "${decisionEngine.url}", name = "engine")
public interface DecisionEngineService {
    // 方法签名变得非常干净，只关注业务参数
    @RequestMapping(value = "", method = RequestMethod.POST)
    public JSONObject getEngineMesasge(@RequestParam("uid") String uid, @RequestParam("productCode") String productCode);
}
```

3.  **调用方式保持不变**：
```java
// 拦截器会自动工作，无需手动传递 header
decisionEngineService.getEngineMesasge("uid", "productCode");
```

**工作原理**：当您的应用（比如一个 Controller）接收到一个带有 `Authorization: Bearer xxx` 头部的请求时，这个头部信息会保存在当前线程的请求上下文中。当在这个线程内调用 Feign 客户端时，拦截器会从上下文中取出这个头部，并自动添加到即将发起的 Feign 请求中。

**优点**：
- **代码干净**：Feign 接口只关注业务逻辑。
- **自动传递**：无需手动处理，避免遗漏。
- **集中管理**：所有认证逻辑在一个地方维护。

---

- 方法三：使用 `@Headers` 注解（适用于固定 Token 的场景）

如果某个 Feign 客户端始终使用一个固定的、不随用户变化的 Token（例如调用某个第三方 API 的通用密钥），可以使用 `@Headers` 注解。

**适用场景**：调用不需要用户级认证的第三方 API，使用统一的 API Key 或静态 Token。

**代码示例**：
```java
// 注意：这里用的是 feign 包下的 Headers，不是 Spring 的
import feign.Headers;

@FeignClient(url = "${decisionEngine.url}", name = "engine")
@Headers("Authorization: Bearer {staticToken}") // 使用占位符
public interface DecisionEngineService {
    
    @RequestMapping(value = "", method = RequestMethod.POST)
    public JSONObject getEngineMesasge(@RequestParam("uid") String uid, @RequestParam("productCode") String productCode);
}
```

**配置**：在 `application.properties` 中配置静态 Token。
```properties
decisionEngine.url=http://10.2.1.148:3333/decision/person
feign.client.config.engine.staticToken=your-static-token-here
```

**优点**：配置简单。
**缺点**：灵活性差，不能根据当前用户动态变化。

---

- 总结与推荐

| 方法 | 优点 | 缺点 | 推荐场景 |
| :--- | :--- | :--- | :--- |
| **方法二：`RequestInterceptor`** | **代码干净，自动传递，集中管理** | 需要理解请求上下文 | **生产环境首选**，特别是基于会话或 JWT 的用户级认证 |
| **方法一：`@RequestHeader`** | 简单直观 | 代码冗余，需手动传递 | 快速原型，或 Token 由调用方显式提供 |
| **方法三：`@Headers`** | 配置简单 | 不灵活，Token 固定 | 调用使用固定 API Key 的第三方服务 |

**强烈推荐您使用 `RequestInterceptor` 的方式（方法二）**，这是最符合 Spring Boot 设计哲学、最能保证代码质量和可维护性的做法。它能优雅地解决权限令牌的传递问题。

### 32.2.3 方案三: 采用RestTemplate方法
> 在Spring-Boot开发中，RestTemplate同样提供了对外访问的接口API，这里主要介绍Get和Post方法的使用。Get请求提供了两种方式的接口getForObject 和 getForEntity，getForEntity提供如下三种方法的实现。

#### 32.2.3.1 Get请求之——getForEntity(String url,Class responseType,Object…urlVariables)
该方法提供了三个参数，其中url为请求的地址，responseType为请求响应body的包装类型，urlVariables为url中的参数绑定，该方法的参考调用如下:
```java
// http://USER-SERVICE/user?name={name)
RestTemplate restTemplate=new RestTemplate();
Map<String,String> params=new HashMap<>();
params.put("name","dada");  //
ResponseEntity<String> responseEntity=restTemplate.getForEntity("http://USERSERVICE/user?name={name}",String.class,params);
```
#### 32.2.3.2 Get请求之——getForEntity(URI url,Class responseType)
该方法使用URI对象来替代之前的url和urlVariables参数来指定访问地址和参数绑定。URI是JDK java.net包下的一个类，表示一个统一资源标识符(Uniform Resource Identifier)引用。参考如下:
```java
RestTemplate restTemplate=new RestTemplate();
UriComponents uriComponents=UriComponentsBuilder.fromUriString("http://USER-SERVICE/user?name={name}")
    .build()
    .expand("dodo")
    .encode();
URI uri=uriComponents.toUri();
ResponseEntity<String> responseEntity=restTemplate.getForEntity(uri,String.class).getBody();
```
### 32.2.3.3 Get请求之——getForObject
getForObject方法可以理解为对getForEntity的进一步封装，它通过HttpMessageConverterExtractor对HTTP的请求响应体body内容进行对象转换，实现请求直接返回包装好的对象内容。getForObject方法有如下:
```java
getForObject(String url,Class responseType,Object...urlVariables)
getForObject(String url,Class responseType,Map urlVariables)
getForObject(URI url,Class responseType)
```
### 32.2.3.4 Post 请求

Post请求提供有三种方法，postForEntity、postForObject和postForLocation。其中每种方法都存在三种方法，postForEntity方法使用如下:
```java
RestTemplate restTemplate=new RestTemplate();
User user=newUser("didi",30);
ResponseEntity<String> responseEntity=restTemplate.postForEntity("http://USER-SERVICE/user",user,String.class); //提交的body内容为user对象，请求的返回的body类型为String
String body=responseEntity.getBody();
```
postForEntity存在如下三种方法的重载
```java
postForEntity(String url,Object request,Class responseType,Object... uriVariables)
postForEntity(String url,Object request,Class responseType,Map uriVariables)
postForEntity(URI url,Object request，Class responseType)
```
postForEntity中的其它参数和getForEntity的参数大体相同在此不做介绍。

## 32.3 进一步理解
在接口调用中需要注意什么?

需要注意两点：

- 需要设置超时时间
- 需要自行处理异常

介绍一下feign如何设置超时时间：

Feign 支持设置两种主要的超时时间：

1. **连接超时（Connect Timeout）**：建立 TCP 连接的最大等待时间
2. **读取超时（Read Timeout）**：从连接建立到接收到完整响应的最大等待时间

---

- 配置方式

1. 方式一：通过配置文件（推荐）

在 `application.yml` 或 `application.properties` 中配置：

**YAML 格式：**
```yaml
feign:
  client:
    config:
      # 为特定 Feign 客户端(一个@FeignClient注解声明的接口就是一个Feign客户端)配置（name 对应 @FeignClient 的 name 属性）
      decision-engine: # 您的 Feign 客户端名称
        connectTimeout: 5000    # 连接超时：5秒
        readTimeout: 30000      # 读取超时：30秒
        loggerLevel: full       # 日志级别，便于调试
      
      # 默认配置（对所有 Feign 客户端生效）
      default:
        connectTimeout: 3000    # 默认连接超时：3秒
        readTimeout: 10000      # 默认读取超时：10秒
```

**Properties 格式：**
```properties
# 特定客户端配置
feign.client.config.decision-engine.connectTimeout=5000
feign.client.config.decision-engine.readTimeout=30000
feign.client.config.decision-engine.loggerLevel=full

# 默认配置
feign.client.config.default.connectTimeout=3000
feign.client.config.default.readTimeout=10000
```

2. 方式二：通过代码配置

创建一个配置类，使用 `@Configuration` 注解：

```java
import feign.Request;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {
    
    @Bean
    public Request.Options options() {
        // 连接超时5秒，读取超时30秒
        return new Request.Options(5000, 30000);
    }
}
```

如果要为特定客户端单独配置，可以在 `@FeignClient` 注解中指定配置类：

```java
@FeignClient(
    url = "${decisionEngine.url}", 
    name = "decision-engine",
    configuration = DecisionEngineFeignConfig.class  // 指定专用配置类
)
public interface DecisionEngineService {
    // ... 接口方法
}
```

专用配置类：
```java
public class DecisionEngineFeignConfig {
    @Bean
    public Request.Options feignOptions() {
        return new Request.Options(5000, 30000); // 5秒连接，30秒读取
    }
}
```

---

- 超时异常处理

当超时发生时，Feign 会抛出 `feign.RetryableException`。您应该添加适当的异常处理：

1. 使用 Fallback 机制（推荐）

Feign 支持降级处理，当调用失败（包括超时）时执行备用逻辑。

**启用 Fallback：**
```yaml
feign:
  circuitbreaker:
    enabled: true  # 需要 spring-cloud-starter-circuitbreaker-resilience4j 依赖
```

**实现 Fallback 类：**
```java
@Component
public class DecisionEngineServiceFallback implements DecisionEngineService {
    
    @Override
    public JSONObject getEngineMesasge(String uid, String productCode) {
        // 超时或失败时的备用逻辑
        JSONObject fallbackResult = new JSONObject();
        fallbackResult.put("code", "TIMEOUT");
        fallbackResult.put("message", "决策引擎调用超时，使用默认决策");
        // 返回默认业务逻辑结果
        return fallbackResult;
    }
}
```

**在 Feign 客户端中指定 Fallback：**
```java
@FeignClient(
    url = "${decisionEngine.url}", 
    name = "decision-engine",
    fallback = DecisionEngineServiceFallback.class  // 指定降级类
)
public interface DecisionEngineService {
    @RequestMapping(value = "", method = RequestMethod.POST)
    public JSONObject getEngineMesasge(@RequestParam("uid") String uid, 
                                      @RequestParam("productCode") String productCode);
}
```

2. 使用 Try-Catch 包装调用

```java
@Service
public class BusinessService {
    
    @Autowired
    private DecisionEngineService decisionEngineService;
    
    public JSONObject callEngineWithTimeoutHandling(String uid, String productCode) {
        try {
            return decisionEngineService.getEngineMesasge(uid, productCode);
        } catch (feign.RetryableException e) {
            // 处理超时异常
            logger.warn("决策引擎调用超时: {}", e.getMessage());
            // 返回默认结果或重试逻辑
            return getDefaultResult();
        } catch (Exception e) {
            // 处理其他异常
            logger.error("决策引擎调用失败: {}", e.getMessage());
            return getDefaultResult();
        }
    }
    
    private JSONObject getDefaultResult() {
        JSONObject result = new JSONObject();
        result.put("code", "FALLBACK");
        result.put("message", "使用备用逻辑");
        return result;
    }
}
```

---
# 三十三、SpringBoot接口 - 如何保证接口幂等
> 在以SpringBoot开发Restful接口时，如何防止接口的重复提交呢？ 本文主要介绍接口幂等相关的知识点，并实践常见基于Token实现接口幂等。
## 33.1 准备知识点
> 从幂等和防止重复提交，接口幂等和常见的保证幂等的方式等知识点构筑知识体系。
### 33.1.1 什么是幂等？
> 幂等原先是数学中的一个概念，表示进行1次变换和进行N次变换产生的效果相同。

当我们讨论接口的幂等性时一般是在说：以相同的请求调用这个接口一次和调用这个接口多次，对系统产生的影响是相同的。如果一个接口满足这个特性，那么我们就说这个 接口是一个幂等接口。
- **接口幂等和防止重复提交是一回事吗？**

严格来说，并不是。

1. **幂等**: 更多的是在重复请求已经发生，或是无法避免的情况下，采取一定的技术手段让这些重复请求不给系统带来副作用。
2. **防止重复**: 提交更多的是不让用户发起多次一样的请求。比如说用户在线购物下单时点了提交订单按钮，但是由于网络原因响应很慢，此时用户比较心急多次点击了订单提交按钮。 这种情况下就可能会造成多次下单。一般防止重复提交的方案有：将订单按钮置灰，跳转到结果页等。主要还是从客户端的角度来解决这个问题。
- **哪些情况下客户端是防止不了重复提交的？**

虽然我们可在客户端做一些防止接口重复提交的事（比如将订单按钮置灰，跳转到结果页等）， 但是如下情况依然客户端是很难控制接口重复提交到后台的，这也进一步表明了接口幂等和防止重复提交不是一回事以及**后端接口保证接口幂等的必要性**所在。

1. **接口超时重试**：接口可能会因为某些原因而调用失败，出于容错性考虑会加上失败重试的机制。如果接口调用一半，再次调用就会因为脏数据的存在而出现异常。
2. **消息重复消费**：在使用消息中间件来处理消息队列，且手动ack确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。被其他消费者重新消费时就会导致结果异常，如数据库重复数据，数据库数据冲突，资源重复等。
3. **请求重发**：网络抖动引发的nginx重发请求，造成重复调用；
### 33.1.2 什么是接口幂等？
在HTTP/1.1中，对幂等性进行了定义。

在HTTP/1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。

这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

- **对哪些类型的接口需要保证接口幂等？**

我们看下标准的restful请求，幂等情况是怎么样的：
1. **SELECT查询操作**
   1. GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。H
   2. EAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。
   3. OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。
2. **DELETE删除操作**
   1. 删除的操作，如果从删除的一次和删除多次的角度看，数据并不会变化，这个角度看它是幂等的
   2. 但是如果，从另外一个角度，删除数据一般是返回受影响的行数，删除一次和多次删除返回的受影响行数是不一样的，所以从这个角度它需要保证幂等。（折中而言DELETE操作通常也会被纳入保证接口幂等的要求）
3. **ADD/EDIT操作**
   1. PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。
## 33.2 常见的保证幂等的方式？
### 33.2.1 数据库层面
#### 33.2.1.1 悲观锁
> 典型的数据库悲观锁：for update
> 
> 在执行这个查询时，MySQL 会对符合条件的行加上排他锁，确保在当前事务结束前，其他事务无法修改或读取这些行的最新数据（取决于隔离级别）。
```sql
select * from t_order where order_id = trade_no for update;
```
为什么加for update就可以?
- 当线程A执行for update，数据会对当前记录加锁，其他线程执行到此行代码的时候，会等待线程A释放锁之后，才可以获取锁，继续后续操作。
- 事物提交时，for update获取的锁会自动释放。

具体效果：

 1. **防止并发修改**
```sql
-- 事务A
BEGIN;
SELECT * FROM t_order WHERE order_id = '123' FOR UPDATE;  -- 对订单123加锁
-- 在此期间，其他事务无法修改订单123

-- 事务B（会被阻塞）
UPDATE t_order SET amount = 100 WHERE order_id = '123';  -- 等待事务A提交
```

 2. **保证数据一致性**

常用于需要**先查询后更新**的场景：
```sql
-- 典型的扣减库存场景
BEGIN;
-- 1. 锁定要操作的行
SELECT stock FROM products WHERE product_id = 1 FOR UPDATE;

-- 2. 基于查询结果进行业务逻辑
-- 3. 更新数据
UPDATE products SET stock = stock - 1 WHERE product_id = 1;
COMMIT;
```


PS：这种方式很少被使用，因为如果业务处理比较耗时，并发情况下，后面线程会长期处于等待状态，占用了很多线程，让这些线程处于无效等待状态，我们的web服务中的线程数量一般都是有限的，如果大量线程由于获取for update锁处于等待状态，不利于系统并发操作。
#### 33.2.1.2 唯一ID/索引
> 针对的是插入操作。

数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。
- 去重表

去重表本质上也是一种唯一索引方案。

这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。
#### 33.2.1.3 乐观锁（基于版本号或者时间戳）
> 针对更新操作。
- 使用版本号或者时间戳

这种方法适合在更新的场景中，比如我们要更新商品的名字，这时我们就可以在更新的接口中增加一个版本号，来做幂等
```java
boolean updateGoodsName(int id,String newName,int version);
```
在实现时可以如下
```sql
update goods set name=#{newName},version=#{version} where id=#{id} and version<${version}
```
- 状态机

本质上也是乐观锁，这种方法适合在有状态机流转的情况下，比如就会订单的创建和付款，订单的付款肯定是在之前，这时我们可以通过在设计状态字段时，使用int类型，并且通过值类型的大小来做幂等，比如订单的创建为0，付款成功为100。付款失败为99

在做状态机更新时，我们就这可以这样控制
```sql
update `order` set status=#{status} where id=#{id} and status<#{status}
```
### 33.2.2 分布式锁
分布式锁实现幂等性的逻辑是，在每次执行方法之前判断，是否可以获取到分布式锁，如果可以，则表示为第一次执行方法，否则直接舍弃请求即可。

需要注意的是分布式锁的key必须为业务的唯一标识，通常用redis分布式锁或者zookeeper来实现分布式锁。
### 33.2.3 Token机制

Token机制是保证接口幂等性的一种常用且有效的方式，特别适用于需要用户交互的场景。

#### 33.2.3.1 Token机制核心思想

Token机制的核心流程是：**服务端生成一个唯一Token，客户端在请求时必须携带这个Token，服务端验证Token的有效性并防止重复使用**。(一个token只能用一次，用不了第二次)

#### 33.2.3.2 Token机制实现流程

```mermaid
graph TD
    A[客户端] --> B[请求获取Token]
    B --> C[服务端生成Token并存储]
    C --> D[返回Token给客户端]
    D --> E[客户端携带Token请求业务接口]
    E --> F{服务端验证Token}
    F -->|Token有效| G[删除Token并执行业务]
    F -->|Token无效| H[返回错误提示]
    G --> I[返回业务结果]
    H --> J[提示重复提交]
```

#### 33.2.3.3 Token机制详细实现

##### 1. Token生成与验证服务

```java
@Service
public class IdempotentTokenService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String IDEMPOTENT_TOKEN_PREFIX = "idempotent:token:";
    private static final long TOKEN_EXPIRE_TIME = 30 * 60; // 30分钟
    
    /**
     * 生成幂等Token
     * @param businessKey 业务唯一标识，如：userId + 业务类型
     * @return 生成的Token
     */
    public String generateToken(String businessKey) {
        // 生成唯一Token
        String token = UUID.randomUUID().toString().replace("-", "");
        String redisKey = IDEMPOTENT_TOKEN_PREFIX + businessKey + ":" + token;
        
        // 存储到Redis，设置过期时间
        redisTemplate.opsForValue().set(redisKey, "1", Duration.ofSeconds(TOKEN_EXPIRE_TIME));
        
        return token;
    }
    
    /**
     * 验证并消费Token（原子操作）
     * @param businessKey 业务唯一标识
     * @param token 客户端传递的Token
     * @return 是否验证成功
     */
    public boolean verifyAndConsumeToken(String businessKey, String token) {
        String redisKey = IDEMPOTENT_TOKEN_PREFIX + businessKey + ":" + token;
        
        // 使用Lua脚本保证原子性：验证Token存在后立即删除
        String luaScript = 
            "if redis.call('get', KEYS[1]) == '1' then " +
            "   return redis.call('del', KEYS[1]) " +
            "else " +
            "   return 0 " +
            "end";
        
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(luaScript, Long.class),
            Collections.singletonList(redisKey)
        );
        
        return result != null && result == 1;
    }
    
    /**
     * 检查Token是否存在（不消费）
     */
    public boolean checkTokenExists(String businessKey, String token) {
        String redisKey = IDEMPOTENT_TOKEN_PREFIX + businessKey + ":" + token;
        return Boolean.TRUE.equals(redisTemplate.hasKey(redisKey));
    }
}
```

##### 2. 控制器实现

```java
@RestController
@RequestMapping("/api/token")
public class TokenController {
    
    @Autowired
    private IdempotentTokenService tokenService;
    
    /**
     * 获取幂等Token接口
     */
    @GetMapping("/generate")
    public ApiResponse<String> generateToken(@RequestParam String businessType,
                                           HttpServletRequest request) {
        // 构建业务唯一键：用户ID + 业务类型
        String userId = getCurrentUserId(request); // 从Session或JWT中获取
        String businessKey = userId + ":" + businessType;
        
        String token = tokenService.generateToken(businessKey);
        
        return ApiResponse.success("Token生成成功", token);
    }
    
    /**
     * 订单创建接口（使用Token幂等）
     */
    @PostMapping("/orders")
    public ApiResponse<Order> createOrder(@RequestBody @Valid OrderCreateRequest request,
                                        @RequestHeader("X-Idempotent-Token") String token,
                                        HttpServletRequest httpRequest) {
        
        // 1. 验证Token
        String userId = getCurrentUserId(httpRequest);
        String businessKey = userId + ":order_create";
        
        if (!tokenService.verifyAndConsumeToken(businessKey, token)) {
            return ApiResponse.error(ErrorCode.REPEAT_SUBMIT, "请勿重复提交订单");
        }
        
        // 2. 执行业务逻辑
        Order order = orderService.createOrder(request);
        
        return ApiResponse.success("订单创建成功", order);
    }
    
    private String getCurrentUserId(HttpServletRequest request) {
        // 从JWT Token或Session中获取用户ID
        // 这里简化为从Header获取
        return request.getHeader("X-User-Id");
    }
}
```

##### 3. 前端调用示例

```javascript
class OrderService {
    // 存储当前Token
    currentToken = null;
    
    // 获取Token
    async generateToken(businessType) {
        const response = await fetch(`/api/token/generate?businessType=${businessType}`, {
            method: 'GET',
            headers: {
                'X-User-Id': this.getUserId(),
                'Content-Type': 'application/json'
            }
        });
        
        const result = await response.json();
        if (result.success) {
            this.currentToken = result.data;
            return this.currentToken;
        }
        throw new Error('获取Token失败');
    }
    
    // 提交订单（自动处理Token）
    async createOrder(orderData) {
        if (!this.currentToken) {
            await this.generateToken('order_create');
        }
        
        const response = await fetch('/api/orders', {
            method: 'POST',
            headers: {
                'X-Idempotent-Token': this.currentToken,
                'X-User-Id': this.getUserId(),
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(orderData)
        });
        
        const result = await response.json();
        
        // 如果Token无效，重新获取并重试
        if (result.code === 'REPEAT_SUBMIT') {
            await this.generateToken('order_create');
            return this.createOrder(orderData); // 重试一次
        }
        
        // 请求成功后清空Token，防止重复使用
        this.currentToken = null;
        
        return result;
    }
    
    getUserId() {
        // 从本地存储获取用户ID
        return localStorage.getItem('userId');
    }
}
```

##### 4. 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * 幂等Token验证异常处理
     */
    @ExceptionHandler(IdempotentException.class)
    public ApiResponse<Void> handleIdempotentException(IdempotentException e) {
        return ApiResponse.error(ErrorCode.REPEAT_SUBMIT, e.getMessage());
    }
}

// 自定义幂等异常
public class IdempotentException extends RuntimeException {
    public IdempotentException(String message) {
        super(message);
    }
}

// 错误码定义
public enum ErrorCode {
    SUCCESS("0000", "成功"),
    REPEAT_SUBMIT("1001", "请勿重复提交"),
    TOKEN_EXPIRED("1002", "Token已过期"),
    TOKEN_INVALID("1003", "Token无效");
    
    private final String code;
    private final String message;
    
    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }
}
```

#### 33.2.3.4 Token机制的优势

1. **灵活性高**：可以为不同业务生成不同的Token
2. **安全性好**：Token具有时效性，过期自动失效
3. **用户体验佳**：前端可以主动获取Token，避免重复提交
4. **分布式友好**：基于Redis，适合分布式环境

#### 33.2.3.5 Token机制的适用场景

- **表单提交**：订单创建、数据录入等
- **支付操作**：防止重复支付
- **重要操作**：账号注销、资金转账等
- **第三方回调**：防止回调接口被重复调用

## 33.3 实现案例

### 33.3.1 电商订单系统的完整幂等实现

#### 1. 项目结构

```
src/main/java/com/example/ecommerce/
├── config/           # 配置类
├── controller/       # 控制器
├── service/          # 业务服务
├── aspect/           # 切面处理
├── annotation/       # 自定义注解
├── entity/           # 实体类
└── utils/            # 工具类
```

#### 2. 幂等注解定义

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    
    /**
     * 幂等键的SpEL表达式，如: #orderRequest.userId + ':' + #orderRequest.productId
     */
    String key() default "";
    
    /**
     * 业务类型，用于Token生成
     */
    String businessType() default "";
    
    /**
     * 过期时间(秒)，默认5分钟
     */
    long expire() default 300;
    
    /**
     * 错误消息
     */
    String message() default "请勿重复提交";
    
    /**
     * 幂等策略：TOKEN-令牌机制，LOCK-分布式锁，DB-数据库幂等
     */
    IdempotentType type() default IdempotentType.TOKEN;
}

// 幂等策略枚举
public enum IdempotentType {
    TOKEN,      // Token令牌机制
    LOCK,       // 分布式锁
    DB          // 数据库幂等（唯一索引等）
}
```

#### 3. 幂等切面实现

```java
@Aspect
@Component
@Slf4j
public class IdempotentAspect {
    
    @Autowired
    private IdempotentTokenService tokenService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Around("@annotation(idempotent)")
    public Object around(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        // 根据策略类型执行不同的幂等控制
        switch (idempotent.type()) {
            case TOKEN:
                return handleTokenStrategy(joinPoint, idempotent);
            case LOCK:
                return handleLockStrategy(joinPoint, idempotent);
            case DB:
                return handleDbStrategy(joinPoint, idempotent);
            default:
                return handleTokenStrategy(joinPoint, idempotent);
        }
    }
    
    /**
     * Token策略处理
     */
    private Object handleTokenStrategy(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        Object[] args = joinPoint.getArgs();
        
        // 从请求头获取Token
        String token = getTokenFromRequest();
        if (StringUtils.isEmpty(token)) {
            throw new IdempotentException("缺少幂等Token");
        }
        
        // 生成业务键
        String businessKey = generateBusinessKey(idempotent.key(), method, args);
        String fullBusinessKey = idempotent.businessType() + ":" + businessKey;
        
        // 验证并消费Token
        if (!tokenService.verifyAndConsumeToken(fullBusinessKey, token)) {
            throw new IdempotentException(idempotent.message());
        }
        
        // 执行业务逻辑
        return joinPoint.proceed();
    }
    
    /**
     * 分布式锁策略处理
     */
    private Object handleLockStrategy(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        Object[] args = joinPoint.getArgs();
        
        String businessKey = generateBusinessKey(idempotent.key(), method, args);
        String lockKey = "idempotent:lock:" + idempotent.businessType() + ":" + businessKey;
        
        // 尝试获取分布式锁
        boolean locked = tryLock(lockKey, idempotent.expire());
        if (!locked) {
            throw new IdempotentException(idempotent.message());
        }
        
        try {
            return joinPoint.proceed();
        } finally {
            releaseLock(lockKey);
        }
    }
    
    /**
     * 数据库策略处理（主要依赖唯一索引等）
     */
    private Object handleDbStrategy(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        // 数据库幂等主要依靠业务逻辑实现，这里只做标记记录
        log.info("使用数据库幂等策略，业务键: {}", generateBusinessKey(idempotent.key(), 
            (MethodSignature) joinPoint.getSignature(), joinPoint.getArgs()));
        
        return joinPoint.proceed();
    }
    
    // 其他工具方法...
    private String getTokenFromRequest() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes instanceof ServletRequestAttributes) {
            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
            return request.getHeader("X-Idempotent-Token");
        }
        return null;
    }
}
```

#### 4. 订单服务实现

```java
@Service
@Slf4j
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private IdempotentTokenService tokenService;
    
    /**
     * 创建订单 - 使用Token幂等
     */
    @Idempotent(
        key = "#request.userId + ':' + #request.productId",
        businessType = "order_create", 
        message = "订单正在处理中，请勿重复提交",
        type = IdempotentType.TOKEN
    )
    @Transactional
    public Order createOrder(OrderCreateRequest request) {
        log.info("开始创建订单，用户ID: {}, 商品ID: {}", request.getUserId(), request.getProductId());
        
        // 1. 参数校验
        validateRequest(request);
        
        // 2. 检查商品库存（使用悲观锁防止超卖）
        Product product = productService.getProductForUpdate(request.getProductId());
        if (product.getStock() < request.getQuantity()) {
            throw new BusinessException("商品库存不足");
        }
        
        // 3. 生成订单号（保证唯一性）
        String orderNo = generateOrderNo(request.getUserId());
        
        // 4. 创建订单实体
        Order order = buildOrder(request, orderNo);
        
        try {
            // 5. 保存订单（唯一索引防重）
            orderRepository.save(order);
        } catch (DataIntegrityViolationException e) {
            // 捕获唯一约束异常，实现幂等返回
            log.warn("订单重复创建，订单号: {}", orderNo);
            return orderRepository.findByOrderNo(orderNo)
                .orElseThrow(() -> new BusinessException("订单创建失败"));
        }
        
        // 6. 扣减库存（乐观锁）
        productService.decreaseStock(request.getProductId(), request.getQuantity());
        
        // 7. 记录操作日志
        log.info("订单创建成功，订单号: {}, 金额: {}", orderNo, order.getAmount());
        
        return order;
    }
    
    /**
     * 支付回调接口 - 使用分布式锁幂等
     */
    @Idempotent(
        key = "#callbackRequest.orderNo",
        businessType = "payment_callback", 
        message = "支付回调正在处理中",
        type = IdempotentType.LOCK,
        expire = 60 // 支付回调处理时间较短
    )
    @Transactional
    public void handlePaymentCallback(PaymentCallbackRequest callbackRequest) {
        String orderNo = callbackRequest.getOrderNo();
        
        // 1. 查询订单
        Order order = orderRepository.findByOrderNo(orderNo)
            .orElseThrow(() -> new BusinessException("订单不存在"));
        
        // 2. 检查订单状态（状态机幂等）
        if (order.getStatus() != OrderStatus.WAITING_PAYMENT) {
            log.info("订单已处理，当前状态: {}, 订单号: {}", order.getStatus(), orderNo);
            return; // 幂等返回
        }
        
        // 3. 更新订单状态
        order.setStatus(OrderStatus.PAID);
        order.setPayTime(new Date());
        orderRepository.save(order);
        
        // 4. 后续处理：发货、通知等
        processAfterPayment(order);
        
        log.info("支付回调处理完成，订单号: {}", orderNo);
    }
    
    /**
     * 生成唯一订单号
     */
    private String generateOrderNo(Long userId) {
        // 时间戳 + 用户ID后4位 + 随机数
        String timestamp = String.valueOf(System.currentTimeMillis());
        String userSuffix = String.format("%04d", userId % 10000);
        String random = String.valueOf((int)((Math.random() * 9 + 1) * 1000));
        
        return timestamp + userSuffix + random;
    }
}
```

#### 5. 控制器层

```java
@RestController
@RequestMapping("/api/orders")
@Validated
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private IdempotentTokenService tokenService;
    
    /**
     * 获取订单创建Token
     */
    @GetMapping("/token")
    public ApiResponse<String> getOrderToken(@RequestParam Long productId) {
        // 从安全上下文获取用户ID
        Long userId = SecurityUtils.getCurrentUserId();
        String businessKey = userId + ":" + productId;
        
        String token = tokenService.generateToken("order_create:" + businessKey);
        return ApiResponse.success("Token获取成功", token);
    }
    
    /**
     * 创建订单
     */
    @PostMapping("/create")
    public ApiResponse<Order> createOrder(@RequestBody @Valid OrderCreateRequest request,
                                        @RequestHeader("X-Idempotent-Token") String token) {
        // Token验证在切面中自动完成
        Order order = orderService.createOrder(request);
        return ApiResponse.success("订单创建成功", order);
    }
    
    /**
     * 支付回调接口（外部调用）
     */
    @PostMapping("/payment/callback")
    public ApiResponse<Void> paymentCallback(@RequestBody @Valid PaymentCallbackRequest request) {
        // 验证签名等安全措施
        if (!verifySignature(request)) {
            return ApiResponse.error("签名验证失败");
        }
        
        try {
            orderService.handlePaymentCallback(request);
            return ApiResponse.success("处理成功");
        } catch (IdempotentException e) {
            // 幂等异常，返回成功
            return ApiResponse.success("重复请求，已处理");
        }
    }
    
    private boolean verifySignature(PaymentCallbackRequest request) {
        // 支付签名验证逻辑
        return true;
    }
}
```

#### 6. 配置文件

```yaml
# application.yml
spring:
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 8
        max-wait: -1ms
        max-idle: 8
        min-idle: 0

# 幂等配置
idempotent:
  token:
    expire-time: 1800    # Token过期时间30分钟
    prefix: "idempotent:token:"
  lock:
    expire-time: 300     # 锁过期时间5分钟
    prefix: "idempotent:lock:"

# 日志配置
logging:
  level:
    com.example.ecommerce.aspect.IdempotentAspect: DEBUG
```

#### 7. 测试用例

```java
@SpringBootTest
@Slf4j
class OrderServiceTest {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private IdempotentTokenService tokenService;
    
    @Test
    void testCreateOrderIdempotent() {
        OrderCreateRequest request = new OrderCreateRequest();
        request.setUserId(1001L);
        request.setProductId(2001L);
        request.setQuantity(2);
        
        // 生成Token
        String businessKey = "1001:2001";
        String token = tokenService.generateToken("order_create:" + businessKey);
        
        // 模拟设置请求头
        MockHttpServletRequest mockRequest = new MockHttpServletRequest();
        mockRequest.addHeader("X-Idempotent-Token", token);
        
        // 第一次调用 - 应该成功
        Order order1 = orderService.createOrder(request);
        assertNotNull(order1);
        
        // 第二次调用 - 应该抛出幂等异常
        assertThrows(IdempotentException.class, () -> {
            orderService.createOrder(request);
        });
    }
    
    @Test
    void testConcurrentOrderCreation() throws InterruptedException {
        int threadCount = 5;
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger failCount = new AtomicInteger(0);
        
        OrderCreateRequest request = new OrderCreateRequest();
        request.setUserId(1002L);
        request.setProductId(2002L);
        request.setQuantity(1);
        
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    String token = tokenService.generateToken("order_create:1002:2002");
                    // 设置Token到ThreadLocal等
                    orderService.createOrder(request);
                    successCount.incrementAndGet();
                } catch (IdempotentException e) {
                    failCount.incrementAndGet();
                    log.info("幂等拦截: {}", e.getMessage());
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await(5, TimeUnit.SECONDS);
        
        // 只有一个请求应该成功
        assertEquals(1, successCount.get());
        assertEquals(threadCount - 1, failCount.get());
    }
}
```

### 33.3.2 案例总结

这个完整的电商订单系统幂等实现展示了：

1. **多策略支持**：Token机制、分布式锁、数据库幂等
2. **注解驱动**：使用自定义注解简化幂等控制
3. **切面编程**：非侵入式实现，业务代码保持简洁
4. **完整流程**：从前端Token获取到后端业务处理
5. **异常处理**：完善的错误处理和日志记录
6. **测试覆盖**：单元测试和并发测试
# 三十四、SpringBoot接口 - 如何对接口进行签名
## 34.1 准备知识点
> 建议从接口整体的安全体系角度来理解，比如存在哪些不安全的因素，加密解密等知识点。
### 34.1.1 API接口有哪些不安全的因素？
> 这里从体系角度，简单列举一些不安全的因素：

- 开发者访问开放接口
  - 是不是一个合法的开发者？
- 多客户端访问接口
  - 是不是一个合法的客户端？
- 用户访问接口
  - 是不是一个合法的用户?
  - 有没有权限访问接口？
- 接口传输
  - http明文传输数据？
- 其它方面
  - 接口重放，上文介绍的`接口幂等`
  - 接口超时，加timestamp控制？
  - ..
## 34.2 常见的保证接口安全的方式？
> 针对上述接口存在的不安全因素，这里向你展示一些典型的保障接口安全的方式。
### 34.2.1 AccessKey&SecretKey
> 这种设计一般用在开发接口的安全，以确保是一个`合法的开发者`。
- AccessKey： 开发者唯一标识
- SecretKey: 开发者密钥

以阿里云相关产品为例
![162.springboot-api-sign-1.png](../../assets/images/04-主流框架/spring/162.springboot-api-sign-1.png)
### 34.2.2 认证和授权
> 从两个视角去看
>
> 第一: `认证和授权`，认证是访问者的合法性，授权是访问者的权限分级；
> 
> 第二: 其中认证包括对`客户端的认证`以及对`用户的认证`；
- 对于客户端的认证

典型的是AppKey&AppSecret，或者ClientId&ClientSecret等

比如oauth2协议的client cridential模式
```sh
https://api.xxxx.com/token?grant_type=client_credentials&client_id=CLIENT_ID&client_secret=CLIENT_SECRET
```
grant_type参数等于client_credentials表示client credentials方式，client_id是客户端id，client_secret是客户端密钥。

返回token后，通过token访问其它接口。

- 对于用户的认证和授权

比如oauth2协议的授权码模式(authorization code)和密码模式(resource owner password credentials)
```sh
https://api.xxxx.com/token?grant_type=password&username=USERNAME&password=PASSWORD&client_id=CLIENT_ID&scope=read
```
grant_type参数等于password表示密码方式，client_id是客户端id，username是用户名，password是密码。

(PS：password模式只有在授权码模式(authorization code)不可用时才会采用，这里只是举个例子而已)

可选参数scope表示申请的权限范围。（相关开发框架可以参考spring security, Apache Shiro，<a href='https://sa-token.cc/doc.html#/'>SA-Token</a>等）
### 34.2.3 https
> 从接口传输安全的角度，防止接口数据明文传输

HTTP 有以下安全性问题:

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPs 并不是新协议，而是让 HTTP 先和 SSL(Secure Sockets Layer)通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。

通过使用 SSL，HTTPs 具有了加密(防窃听)、认证(防伪装)和完整性保护(防篡改)。
![163.ssl-offloading.jpg](../../assets/images/04-主流框架/spring/163.ssl-offloading.jpg)
### 34.2.4 接口签名（加密）
> 接口签名（加密），主要防止请求参数被篡改。特别是安全要求比较高的接口，比如支付领域的接口。
- 签名的主要流程

首先我们需要分配给客户端一个私钥用于URL签名加密，一般的签名算法如下：

1、首先对请求参数按key进行字母排序放入有序集合中（其它参数请参看后续补充部分）；

2、对排序完的数组键值对用&进行连接，形成用于加密的参数字符串；

3、在加密的参数字符串前面或者后面加上私钥，然后用加密算法进行加密，得到sign，然后随着请求接口一起传给服务器。

例如： https://api.xxxx.com/token?key=value&timetamp=xxxx&sign=xxxx-xxx-xxx-xxxx

服务器端接收到请求后，用同样的算法获得服务器的sign，对比客户端的sign是否一致，如果一致请求有效；如果不一致返回指定的错误信息。
- 补充：对什么签名？
  - 主要包括请求参数，这是最主要的部分，`签名的目的要防止参数被篡改，就要对可能被篡改的参数签名`；
  - 同时考虑到请求参数的来源可能是请求路径path中，请求header中，请求body中。
  - 如果对客户端分配了AppKey&AppSecret，也可加入签名计算；
  - 考虑到其它幂等，token失效等，也会将涉及的参数一并加入签名，比如timestamp，流水号nonce等（这些参数可能来源于header）
- 补充: 签名算法？

一般涉及这块，主要包含三点：密钥，签名算法，签名规则
1. 密钥secret： 前后端约定的secret，这里要注意前端可能无法妥善保存好secret，比如SPA单页应用；
2. 签名算法：也不一定要是对称加密算法，对称是反过来解析sign，这里是用同样的算法和规则计算出sign，并对比前端传过来的sign是否一致。
3. 签名规则：比如多次加盐加密等；
> PS：有读者会问，我们是可能从有些客户端获取密钥，算法和规则的(比如前端SPA单页应用生成的js中获取密钥，算法和规则），那么签名的意义在哪里？我认为`签名是手段而不是目的，签名是加大攻击者攻击难度的一种手段`，至少是可以抵挡大部分简单的攻击的，再加上其它防范方式（流水号，时间戳，token等)进一步提升攻击的难度而已。
- 补充：签名和加密是不是一回事？

严格来说不是一回事：
1. 签名是通过对参数按照指定的算法、规则计算出sign，最后前后端通过同样的算法计算出sign是否一致来防止参数篡改的，所以你可以看到参数是明文的，只是多加了一个计算出的sign。
2. 加密是对请求的参数加密，后端进行解密；同时有些情况下，也会对返回的response进行加密，前端进行解密；这里存在加密和解密的过程，所以思路上必然是对称加密的形式+时间戳接口时效性等。
- 补充：签名放在哪里？

签名可以放在请求参数中（path中，body中等），更为优雅的可以放在HEADER中，比如X-Sign（通常第三方的header参数以X-开头）
- 补充：大厂开放平台是怎么做的呢？哪些可以借鉴？
以腾讯开放平台为例，请参考<a href = 'https://wikinew.open.qq.com/#/iwiki/877913685'>腾讯开放平台第三方应用签名参数sig的说明</a>
## 34.3 实现案例
> 本例子采用AOP拦截自定义注解方式实现，主要看实现的思路而已(签名的目的要防止参数被篡改，就要对可能被篡改的参数签名)。
### 34.3.1 定义注解
```java
package tech.pdai.springboot.api.sign.config.sign;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author pdai
 */
@Target(ElementType.METHOD)   // 注解只能用于方法上
@Retention(RetentionPolicy.RUNTIME)    // 注解在运行时可用，便于AOP拦截
public @interface Signature {
}
```
- **作用**：这是一个标记注解，用于标识哪些方法需要签名校验。例如，在控制器方法上添加`@Signature`，AOP会拦截该方法执行前的请求。
- **关键点**：`@Retention(RetentionPolicy.RUNTIME)`确保注解在运行时可通过反射读取，这是AOP拦截的基础。

---
### 34.3.2 AOP拦截
这里可以看到需要对所有用户可能修改的参数点进行按规则签名
```java
package tech.pdai.springboot.api.sign.config.sign;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.Objects;

import javax.servlet.http.HttpServletRequest;

import cn.hutool.core.text.CharSequenceUtil;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.util.ContentCachingRequestWrapper;
import tech.pdai.springboot.api.sign.config.exception.BusinessException;
import tech.pdai.springboot.api.sign.util.SignUtil;

/**
 * @author pdai
 */
@Aspect
@Component
public class SignAspect {

    /**
     * SIGN_HEADER.
     */
    private static final String SIGN_HEADER = "X-SIGN";// 定义签名在请求头中的键名

    /**
     * pointcut.
     */
    // 定义切入点：拦截所有被@Signature注解的方法
    @Pointcut("execution(@tech.pdai.springboot.api.sign.config.sign.Signature * *(..))")
    private void verifySignPointCut() {
      // 空方法，仅用于定义切入点
    }

    /**
     * verify sign.// 在目标方法执行前执行验证
     */
    @Before("verifySignPointCut()")
    public void verify() {
            // 获取当前HTTP请求对象
        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();
        String sign = request.getHeader(SIGN_HEADER);// 从请求头获取客户端签名

       // 检查签名是否为空
        if (CharSequenceUtil.isBlank(sign)) {
            throw new BusinessException("no signature in header: " + SIGN_HEADER);
        }

      // 生成服务器端签名并比较
        try {
            String generatedSign = generatedSignature(request);
            if (!sign.equals(generatedSign)) {
                throw new BusinessException("invalid signature");
            }
        } catch (Throwable throwable) {
            throw new BusinessException("invalid signature");
        }
    }
    // 生成服务器端签名：收集请求参数并调用SignUtil.sign
    private String generatedSignature(HttpServletRequest request) throws IOException {
        // @RequestBody
        String bodyParam = null; // 存储@RequestBody参数
        // 处理@RequestBody：通过ContentCachingRequestWrapper读取缓存后的请求体
        if (request instanceof ContentCachingRequestWrapper) {
            bodyParam = new String(((ContentCachingRequestWrapper) request).getContentAsByteArray(), StandardCharsets.UTF_8);
        }

        // @RequestParam
        Map<String, String[]> requestParameterMap = request.getParameterMap();// 存储@RequestParam参数

        // @PathVariable
        String[] paths = null; // 存储@PathVariable参数
        // 处理@PathVariable：从请求属性中提取路径变量
        ServletWebRequest webRequest = new ServletWebRequest(request, null);
        Map<String, String> uriTemplateVars = (Map<String, String>) webRequest.getAttribute(
                HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);
        
        if (!CollectionUtils.isEmpty(uriTemplateVars)) {
            paths = uriTemplateVars.values().toArray(new String[0]);
        }
        // 调用工具类生成签名（参数排序、连接、加密等逻辑在SignUtil中实现）
        return SignUtil.sign(bodyParam, requestParameterMap, paths);
    }

}

```
- **AOP要点**：
  - `@Pointcut`定义了拦截规则：所有被`@Signature`注解的方法。
  - `@Before` advice在方法执行前触发校验。
- **签名校验流程**：
  1. **获取客户端签名**：从请求头`X-SIGN`中提取签名值。
  2. **参数收集**：从请求中收集三类参数：
     - `bodyParam`：通过`ContentCachingRequestWrapper`读取请求体（如JSON数据），确保请求体可重复读取。
     - `requestParameterMap`：查询参数（如`?key=value`）。
     - `paths`：路径变量（如URL中的`/test/{id}`）。
  3. **生成服务器签名**：调用`SignUtil.sign`方法，传入收集的参数。该方法内部应实现签名算法（如参数排序、连接、加私钥加密）。
  4. **比较签名**：如果客户端签名与服务器签名不匹配，抛出异常。
- **关键依赖**：`SignUtil.sign`是核心，但代码未展示其实现。通常，它会：
  - 对参数按key排序（防止顺序不一致导致签名不同）。
  - 将参数连接成字符串（如`key1=value1&key2=value2`）。
  - 拼接私钥后使用加密算法（如MD5或SHA）生成签名。
  - 私钥应从服务器端安全存储（如配置文件）获取，避免硬编码。

---

### 34.3.3 Request封装
请求封装 `RequestCachingFilter`

由于HTTP请求体（如`@RequestBody`）只能读取一次，直接读取会导致后续无法获取数据。此过滤器通过包装请求，实现请求体的缓存。
```java
package tech.pdai.springboot.api.sign.config;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ContentCachingRequestWrapper;

@Slf4j
public class RequestCachingFilter extends OncePerRequestFilter {

    /**
     * This {@code doFilter} implementation stores a request attribute for
     * "already filtered", proceeding without filtering again if the
     * attribute is already there.
     *
     * @param request     request
     * @param response    response
     * @param filterChain filterChain
     * @throws ServletException ServletException
     * @throws IOException      IOException
     * @see #getAlreadyFilteredAttributeName
     * @see #shouldNotFilter
     * @see #doFilterInternal
     */
    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull FilterChain filterChain) throws ServletException, IOException {
        boolean isFirstRequest = !isAsyncDispatch(request);
        HttpServletRequest requestWrapper = request;
         // 如果是首次请求且未被包装，则包装为ContentCachingRequestWrapper
        if (isFirstRequest && !(request instanceof ContentCachingRequestWrapper)) {
            requestWrapper = new ContentCachingRequestWrapper(request);
        }
        try {
            filterChain.doFilter(requestWrapper, response); // 继续过滤器链
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
- **作用**：将原始请求包装为`ContentCachingRequestWrapper`，允许多次读取请求体内容。这在AOP的`generatedSignature`方法中用于获取`@RequestBody`参数。
- **过滤器注册**：通过`FilterConfig`将过滤器注册到Spring容器，并设置执行顺序。

注册
```java
package tech.pdai.springboot.api.sign.config;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FilterConfig {
    @Bean
    public RequestCachingFilter requestCachingFilter() {
        return new RequestCachingFilter();
    }

    @Bean
    public FilterRegistrationBean requestCachingFilterRegistration(
            RequestCachingFilter requestCachingFilter) {
        FilterRegistrationBean bean = new FilterRegistrationBean(requestCachingFilter);
        bean.setOrder(1);
        return bean;
    }
}
```
### 34.3.4 实现接口
```java
package tech.pdai.springboot.api.sign.controller;

import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.api.sign.config.response.ResponseResult;
import tech.pdai.springboot.api.sign.config.sign.Signature;
import tech.pdai.springboot.api.sign.entity.User;

/**
 * @author pdai
 */
@RestController
@RequestMapping("user")
public class SignTestController {

    @Signature
    @PostMapping("test/{id}")
    public ResponseResult<String> myController(@PathVariable String id
            , @RequestParam String client
            , @RequestBody User user) {
        return ResponseResult.success(String.join(",", id, client, user.toString()));
    }

}
```
- **作用**：模拟一个API接口，接受路径变量、查询参数和请求体。当请求到达时，AOP会先校验签名，只有通过校验才执行方法逻辑。
- **参数类型**：
  - `@PathVariable String id`：路径变量（如`/test/123`中的`123`）。
  - `@RequestParam String client`：查询参数（如`?client=web`）。
  - `@RequestBody User user`：请求体（如JSON格式的用户数据）。
### 34.3.5 接口测试
body参数
![163.springboot-sign-2.png](../../assets/images/04-主流框架/spring/163.springboot-sign-2.png)

如果不带X-SIGN
![165.springboot-sign-3.png](../../assets/images/04-主流框架/spring/165.springboot-sign-3.png)

如果X-SIGN错误
![164.springboot-sign-4.png](../../assets/images/04-主流框架/spring/164.springboot-sign-4.png)

如果X-SIGN正确
![166.springboot-sign-1.png](../../assets/images/04-主流框架/spring/166.springboot-sign-1.png)
### 34.3.6 进一步解读
`OncePerRequestFilter` 和 `ContentCachingRequestWrapper` 的作用以及代码中 `isFirstRequest`，我将详细解释这段代码的原理。这涉及 Servlet 过滤器、请求包装器和异步请求处理的核心概念。

#### 1. 背景问题：为什么需要包装请求？
- **HTTP 请求体的单次读取限制**：HTTP 请求的 body（如 `@RequestBody` 对应的输入流）本质上是一个单向流，只能被读取一次。一旦读取，流就到达末尾，无法重置。如果在签名校验的 AOP 中直接读取了请求体，后续的控制器方法就无法再读取，导致 `@RequestBody` 参数为 null 或报错。
- **解决方案**：使用包装类缓存请求体。Spring 提供了 `ContentCachingRequestWrapper`，它在第一次读取请求体时将其内容缓存到内存中，后续读取直接返回缓存数据，从而支持多次读取。

#### 2. 代码逐行解析
```java
@Slf4j
public class RequestCachingFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull FilterChain filterChain) throws ServletException, IOException {
        // 判断是否为首次请求（非异步分发）
        boolean isFirstRequest = !isAsyncDispatch(request);
        HttpServletRequest requestWrapper = request; // 初始化为原始请求

        // 条件：如果是首次请求且请求尚未被包装，则进行包装
        if (isFirstRequest && !(request instanceof ContentCachingRequestWrapper)) {
            requestWrapper = new ContentCachingRequestWrapper(request);
        }

        try {
            // 继续执行过滤器链，传入包装后的请求（如果被包装）
            filterChain.doFilter(requestWrapper, response);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

##### 关键组件的作用
- **`OncePerRequestFilter`**：
  - 这是 Spring 提供的抽象过滤器类，**确保每个请求只被过滤一次**。
  - 在 Servlet 规范中，一个请求可能经过多个过滤器，且可能被转发（forward）或包含（include），导致过滤器重复执行。`OncePerRequestFilter` 通过内部标记机制（如请求属性）避免重复处理。
  - 例如，如果请求被转发到另一个 URL，普通过滤器可能会再次执行，但 `OncePerRequestFilter` 会跳过重复执行。

- **`ContentCachingRequestWrapper`**：
  - 这是 Spring 提供的请求包装器，**缓存请求体内容到字节数组**。
  - 工作原理：
    - 当第一次调用 `getInputStream()` 或 `getReader()` 读取请求体时，它会读取原始流并缓存数据。
    - 后续读取直接返回缓存数据，而不是重新读流（流已耗尽）。
  - 在签名校验场景中，AOP 和控制器方法都能安全读取请求体。

##### 逻辑详解：`isFirstRequest` 和包装条件
- **`boolean isFirstRequest = !isAsyncDispatch(request)`**：
  - `isAsyncDispatch(request)` 是 `OncePerRequestFilter` 的方法，用于判断当前请求是否属于**异步分发**（asynchronous dispatch）。
  - **异步请求处理流程**：在 Spring MVC 中，异步请求（如使用 `@Async` 或 `DeferredResult`）会经历多个阶段：
    - **初始请求**：客户端发起的原始请求。
    - **异步分发**：当异步任务完成时，服务器会重新分发请求到容器以生成响应（这算作第二次或后续分发）。
  - `isAsyncDispatch(request)` 返回 `true` 表示当前是异步分发阶段（非初始请求），返回 `false` 表示是初始请求（首次请求）。
  - 因此，`isFirstRequest = !isAsyncDispatch(request)` 表示：**只有初始请求（首次请求）时，`isFirstRequest` 为 `true`**。

- **为什么只在首次请求且未包装时包装？**
  - 条件：`if (isFirstRequest && !(request instanceof ContentCachingRequestWrapper))`
  - **避免重复包装**：
    - 如果请求已经是 `ContentCachingRequestWrapper` 实例（可能由其他过滤器包装），则无需再次包装，防止多层包装导致问题。
    - 例如，如果其他过滤器先包装了请求，本过滤器直接使用即可。
  - **避免异步分发时的错误缓存**：
    - 在异步分发阶段（`isFirstRequest` 为 `false`），请求可能是原始请求的后续分发。如果此时重新包装，会尝试缓存一个可能已被读取或处理的请求体，导致数据不一致或错误。
    - 异步分发时，请求体应已在初始请求阶段被缓存，直接使用缓存数据即可。
  - **总结**：包装只发生在请求生命周期的开始（首次请求），确保缓存一次，后续所有处理（包括异步分发）都使用同一缓存。

#### 3. 整体工作流程示例
假设一个请求到达 Spring Boot 应用：
1. **请求进入**：客户端发送 POST 请求到 `/user/test/123?client=web`，带有 JSON 请求体 `{"name": "Alice"}`。
2. **过滤器执行**：
   - `RequestCachingFilter` 被调用（因注册在过滤器链中）。
   - `isAsyncDispatch(request)` 检查：如果是初始请求，返回 `false`，故 `isFirstRequest = true`。
   - 检查请求类型：原始请求是 `HttpServletRequest`，不是 `ContentCachingRequestWrapper`，因此条件满足，创建 `ContentCachingRequestWrapper` 包装原始请求。
   - 过滤器链继续，传入包装后的请求。
3. **AOP 签名校验**：
   - AOP 拦截器从包装请求中读取请求体（通过 `getContentAsByteArray()`），不会消耗流。
4. **控制器方法执行**：
   - Spring 解析 `@RequestBody` 时，再次读取请求体，从缓存获取数据，正常注入参数。
5. **异步场景**：如果请求是异步的，异步分发时 `isFirstRequest` 为 `false`，过滤器跳过包装，直接使用已缓存的请求体。

#### 4. 为什么这对签名校验至关重要？
- 在签名校验的 AOP 中，需要读取请求体（`bodyParam`）来计算签名。如果没有缓存：
  - AOP 读取请求体后，流耗尽。
  - 控制器方法无法获取 `@RequestBody`，导致 `User user` 参数为 null 或报错。
- 通过包装，AOP 和控制器都能读取完整的请求数据，确保签名校验基于所有参数，防止篡改。

#### 总结
- **`OncePerRequestFilter`**：保证过滤器 per-request 执行一次，避免重复处理。
- **`ContentCachingRequestWrapper`**：缓存请求体，支持多次读取。
- **`isFirstRequest` 逻辑**：确保只在初始请求时缓存请求体，避免异步分发导致的问题。

# 三十五、SpringBoot接口 - 如何实现接口限流之单实例
> 在以SpringBoot开发Restful接口时，当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。在接口层如何做限流呢？ 本文主要回顾限流的知识点，并实践单实例限流的一种思路。
## 35.1 准备知识点
### 35.1.1 为什么要限流
每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。
### 35.1.2 限流有哪些常见思路？
- 从算法上看
  - 令牌桶(Token Bucket)、漏桶(leaky bucket)和计数器算法是最常用的三种限流的算法。
- 单实例
  - 应用级限流方式只是单应用内的请求限流，不能进行全局限流。
    - 限流总资源数
    - 限流总并发/连接/请求数
    - 限流某个接口的总并发/请求数
    - 限流某个接口的时间窗请求数
    - 平滑限流某个接口的请求数
    - Guava RateLimiter
- 分布式
  - 我们需要分布式限流和接入层限流来进行全局限流。
    - redis+lua实现中的lua脚本
    - 使用Nginx+Lua实现的Lua脚本
    - 使用 OpenResty 开源的限流方案
    - 限流框架，比如Sentinel实现降级限流熔断
## 35.2 实现思路
> 主要思路：AOP拦截自定义的RateLimit注解，在AOP中通过Guava RateLimiter; Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。
### 35.2.1 定义RateLimit注解
```java
package tech.pdai.ratelimit.guava.config.ratelimit;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author pdai
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {

    int limit() default 10;

}
```
### 35.2.2 定义AOP
```java
package tech.pdai.ratelimit.guava.config.ratelimit;

import java.lang.reflect.Method;
import java.util.concurrent.ConcurrentHashMap;

import com.google.common.util.concurrent.RateLimiter;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;

/**
 * @author pdai
 */
@Slf4j
@Aspect
@Component
public class RateLimitAspect {

    private final ConcurrentHashMap<String, RateLimiter> EXISTED_RATE_LIMITERS = new ConcurrentHashMap<>();

    @Pointcut("@annotation(tech.pdai.ratelimit.guava.config.ratelimit.RateLimit)")
    public void rateLimit() {
    }

    @Around("rateLimit()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        RateLimit annotation = AnnotationUtils.findAnnotation(method, RateLimit.class);

        // get rate limiter
        RateLimiter rateLimiter = EXISTED_RATE_LIMITERS.computeIfAbsent(method.getName(), k -> RateLimiter.create(annotation.limit()));

        // process
        if (rateLimiter!=null && rateLimiter.tryAcquire()) {
            return point.proceed();
        } else {
            throw new RuntimeException("too many requests, please try again later...");
        }
    }
}
```
### 35.2.3 自定义相关异常
```java
package tech.pdai.ratelimit.guava.config.exception;

import lombok.extern.slf4j.Slf4j;

/**
 * business exception, besides normal exception.
 *
 * @author pdai
 */
@Slf4j
public class BusinessException extends RuntimeException {

    /**
     * Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may
     * subsequently be initialized by a call to {@link #initCause}.
     */
    public BusinessException() {
        super();
    }

    /**
     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently
     * be initialized by a call to {@link #initCause}.
     *
     * @param message the detail message. The detail message is saved for later retrieval by the {@link #getMessage()}
     *                method.
     */
    public BusinessException(final String message) {
        super(message);
    }

    /**
     * Constructs a new exception with the specified detail message and cause.
     * <p>
     * Note that the detail message associated with {@code cause} is <i>not</i> automatically incorporated in this
     * exception's detail message.
     *
     * @param message the detail message (which is saved for later retrieval by the {@link #getMessage()} method).
     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method). (A <tt>null</tt>
     *                value is permitted, and indicates that the cause is nonexistent or unknown.)
     * @since 1.4
     */
    public BusinessException(final String message, final Throwable cause) {
        super(message, cause);
    }

    /**
     * Constructs a new exception with the specified cause and a detail message of
     * <tt>(cause==null ? null : cause.toString())</tt> (which typically contains the class and detail message of
     * <tt>cause</tt>). This constructor is useful for exceptions that are little more than wrappers for other
     * throwables (for example, {@link java.security.PrivilegedActionException}).
     *
     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method). (A <tt>null</tt>
     *              value is permitted, and indicates that the cause is nonexistent or unknown.)
     * @since 1.4
     */
    public BusinessException(final Throwable cause) {
        super(cause);
    }

    /**
     * Constructs a new exception with the specified detail message, cause, suppression enabled or disabled, and
     * writable stack trace enabled or disabled.
     *
     * @param message            the detail message.
     * @param cause              the cause. (A {@code null} value is permitted, and indicates that the cause is nonexistent or
     *                           unknown.)
     * @param enableSuppression  whether or not suppression is enabled or disabled
     * @param writableStackTrace whether or not the stack trace should be writable
     * @since 1.7
     */
    protected BusinessException(final String message, final Throwable cause, boolean enableSuppression,
                                boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }

}
```
异常的处理
```java
package tech.pdai.ratelimit.guava.config.exception;


import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import tech.pdai.ratelimit.guava.config.response.ResponseResult;
import tech.pdai.ratelimit.guava.config.response.ResponseStatus;

/**
 * @author pdai
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * handle business exception.
     *
     * @param businessException business exception
     * @return ResponseResult
     */
    @ResponseBody
    @ExceptionHandler(BusinessException.class)
    public ResponseResult<BusinessException> processBusinessException(BusinessException businessException) {
        log.error(businessException.getLocalizedMessage());
        return ResponseResult.fail(null, businessException.getLocalizedMessage()==null
                ? ResponseStatus.HTTP_STATUS_500.getDescription()
                :businessException.getLocalizedMessage());
    }

    /**
     * handle other exception.
     *
     * @param exception exception
     * @return ResponseResult
     */
    @ResponseBody
    @ExceptionHandler(Exception.class)
    public ResponseResult<Exception> processException(Exception exception) {
        log.error(exception.getLocalizedMessage(), exception);
        return ResponseResult.fail(null, ResponseStatus.HTTP_STATUS_500.getDescription());
    }
}
```
### 35.2.4 统一结果返回封装
```java
package tech.pdai.ratelimit.guava.config.response;

import java.io.Serializable;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@Data
@Builder
public class ResponseResult<T> {

    /**
     * response timestamp.
     */
    private long timestamp;

    /**
     * response code, 200 -> OK.
     */
    private String status;

    /**
     * response message.
     */
    private String message;

    /**
     * response data.
     */
    private T data;

    /**
     * response success result wrapper.
     *
     * @param <T> type of data class
     * @return response result
     */
    public static <T> ResponseResult<T> success() {
        return success(null);
    }

    /**
     * response success result wrapper.
     *
     * @param data response data
     * @param <T>  type of data class
     * @return response result
     */
    public static <T> ResponseResult<T> success(T data) {
        return ResponseResult.<T>builder().data(data)
                .message(ResponseStatus.SUCCESS.getDescription())
                .status(ResponseStatus.SUCCESS.getResponseCode())
                .timestamp(System.currentTimeMillis())
                .build();
    }

    /**
     * response error result wrapper.
     *
     * @param message error message
     * @param <T>     type of data class
     * @return response result
     */
    public static <T extends Serializable> ResponseResult<T> fail(String message) {
        return fail(null, message);
    }

    /**
     * response error result wrapper.
     *
     * @param data    response data
     * @param message error message
     * @param <T>     type of data class
     * @return response result
     */
    public static <T> ResponseResult<T> fail(T data, String message) {
        return ResponseResult.<T>builder().data(data)
                .message(message)
                .status(ResponseStatus.FAIL.getResponseCode())
                .timestamp(System.currentTimeMillis())
                .build();
    }


}
```
### 35.2.5 controller接口
```java
package tech.pdai.ratelimit.guava.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.ratelimit.guava.config.ratelimit.RateLimit;
import tech.pdai.ratelimit.guava.config.response.ResponseResult;

/**
 * @author pdai
 */
@Slf4j
@RestController
public class RateLimitTestController {

    @RateLimit
    @GetMapping("/limit")
    public ResponseResult<String> limit() {
        log.info("limit");
        return ResponseResult.success();
    }

    @RateLimit(limit = 5)
    @GetMapping("/limit1")
    public ResponseResult<String> limit1() {
        log.info("limit1");
        return ResponseResult.success();
    }

    @GetMapping("/nolimit")
    public ResponseResult<String> noRateLimiter() {
        log.info("no limit");
        return ResponseResult.success();
    }

}
```
## 35.3 接口测试
```java
@SneakyThrows
public static void test(int clientSize) {
    CountDownLatch downLatch = new CountDownLatch(clientSize);
    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(clientSize);
    IntStream.range(0, clientSize).forEach(i ->
            fixedThreadPool.submit(() -> {
                RestTemplate restTemplate = new RestTemplate();
                restTemplate.getForObject("http://localhost:8080/limit1", ResponseResult.class);
                downLatch.countDown();
            })
    );
    downLatch.await();
    fixedThreadPool.shutdown();
}
```
测试结果
```sh
2021-10-01 15:22:47.171  INFO 30092 --- [nio-8080-exec-4] t.p.r.g.c.RateLimitTestController        : limit1
2021-10-01 15:22:47.171  INFO 30092 --- [nio-8080-exec-8] t.p.r.g.c.RateLimitTestController        : limit1
2021-10-01 15:22:47.171  INFO 30092 --- [nio-8080-exec-5] t.p.r.g.c.RateLimitTestController        : limit1
2021-10-01 15:22:47.187  INFO 30092 --- [nio-8080-exec-9] t.p.r.g.c.RateLimitTestController        : limit1
2021-10-01 15:22:47.187  INFO 30092 --- [nio-8080-exec-2] t.p.r.g.c.RateLimitTestController        : limit1
2021-10-01 15:22:47.187  INFO 30092 --- [io-8080-exec-10] t.p.r.g.c.RateLimitTestController        : limit1
2021-10-01 15:22:47.202 ERROR 30092 --- [nio-8080-exec-7] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.202 ERROR 30092 --- [nio-8080-exec-6] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.221 ERROR 30092 --- [nio-8080-exec-1] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.222 ERROR 30092 --- [nio-8080-exec-5] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [nio-8080-exec-6] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [nio-8080-exec-8] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [nio-8080-exec-3] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [io-8080-exec-12] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [io-8080-exec-14] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [io-8080-exec-13] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.225 ERROR 30092 --- [io-8080-exec-15] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.240 ERROR 30092 --- [io-8080-exec-11] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.240 ERROR 30092 --- [nio-8080-exec-4] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
2021-10-01 15:22:47.256 ERROR 30092 --- [nio-8080-exec-2] t.p.r.g.c.e.GlobalExceptionHandler       : too many requests, please try again later...
```
## 35.4 上述实现方案的槽点

- 注意

> 必须要说明一下，上述实现方式只是单实例下一种思路而已，如果细细的看，上面的代码存在一些槽点。
1. 首先, EXISTED_RATE_LIMITERS.computeIfAbsent(method.getName(), k -> RateLimiter.create(annotation.limit())) 这行代码中 method.getName()表明是对方法名进行限流的，其实并不合适，应该需要至少加上类名；
2. 再者, 上述实现方式按照方法名去限定请求量，对于很多情况下至少需要支持按照IP和方法名，或者其它自定义的方式进行限流。
3. 其它一些场景支持的参数抽象和封装等
## 35.5 针对上述方案在并发情况下的一些修改方式

### 方案1：使用双重检查锁
```java
@Around("rateLimit()")
public Object around(ProceedingJoinPoint point) throws Throwable {
    MethodSignature signature = (MethodSignature) point.getSignature();
    Method method = signature.getMethod();
    RateLimit annotation = AnnotationUtils.findAnnotation(method, RateLimit.class);
    
    String methodName = method.getName();
    RateLimiter rateLimiter = EXISTED_RATE_LIMITERS.get(methodName);
    
    if (rateLimiter == null) {
        synchronized (this) {
            rateLimiter = EXISTED_RATE_LIMITERS.get(methodName);
            if (rateLimiter == null) {
                rateLimiter = RateLimiter.create(annotation.limit());
                EXISTED_RATE_LIMITERS.put(methodName, rateLimiter);
            }
        }
    }
    
    if (rateLimiter.tryAcquire()) {
        return point.proceed();
    } else {
        throw new RuntimeException("too many requests, please try again later...");
    }
}
```

### 方案2：使用原子操作（推荐）
```java
@Around("rateLimit()")
public Object around(ProceedingJoinPoint point) throws Throwable {
    MethodSignature signature = (MethodSignature) point.getSignature();
    Method method = signature.getMethod();
    RateLimit annotation = AnnotationUtils.findAnnotation(method, RateLimit.class);
    
    RateLimiter rateLimiter = EXISTED_RATE_LIMITERS.compute(method.getName(), 
        (k, v) -> v == null ? RateLimiter.create(annotation.limit()) : v);
    
    if (rateLimiter.tryAcquire()) {
        return point.proceed();
    } else {
        throw new RuntimeException("too many requests, please try again later...");
    }
}
```

### 方案3：使用 Guava Cache（最优）
```java
private final LoadingCache<String, RateLimiter> rateLimiters = CacheBuilder.newBuilder()
    .build(new CacheLoader<String, RateLimiter>() {
        @Override
        public RateLimiter load(String methodName) throws Exception {
            // 需要额外逻辑来获取对应方法的limit值
            Method method = // 根据methodName获取Method
            RateLimit annotation = AnnotationUtils.findAnnotation(method, RateLimit.class);
            return RateLimiter.create(annotation.limit());
        }
    });
```
# 三十六、SpringBoot接口 - 如何实现接口限流之分布式
## 36.1 准备知识点
我们需要`分布式限流`和`接入层限流`来进行全局限流。
1. redis+lua实现中的lua脚本
2. 使用Nginx+Lua实现的Lua脚本
3. 使用 OpenResty 开源的限流方案
4. 限流框架，比如Sentinel实现降级限流熔断
## 36.2 实现思路之redis+lua封装
> redis+lua是代码层实现较为常见的方案，网上有很多的封装， 我这里找一个给你分享下。以gitee开源的<a href='https://gitee.com/kailing/ratelimiter-spring-boot-starter'>ratelimiter-spring-boot-starter</a>为例，作者是kailing， 值得初学者学习思路+代码封装+starter封装：
### 36.2.1 使用场景：为什么有些分布式场景下，还会在代码层进行控制限流？
基于 redis 的偏业务应用的分布式限流组件，使得项目拥有分布式限流能力变得很简单。限流的场景有很多，常说的限流一般指网关限流，控制好洪峰流量，以免打垮后方应用。这里突出`偏业务应用的分布式限流`的原因，是因为区别于网关限流，业务侧限流可以轻松根据业务性质做到细粒度的流量控制。比如如下场景，
- 案例一：

有一个公开的 openApi 接口， openApi 会给接入方派发一个 appId，此时，如果需要根据各个接入方的 appId 限流，网关限流就不好做了，只能在业务侧实现
- 案例二：

公司内部的短信接口，内部对接了多个第三方的短信通道，每个短信通道对流量的控制都不尽相同，假设有的第三方根据手机号和短信模板组合限流，网关限流就更不好做了让我们看下，作者kailing是如何封装实现ratelimiter-spring-boot-starter的。
### 36.2.2 源代码的要点
- Redis 客户端采用redisson，AOP拦截方式

所以引入如下包
```sh
ext {
    redisson_Version = '3.15.1'
}

dependencies {
    compile "org.redisson:redisson:${redisson_Version}"
    compile 'org.springframework.boot:spring-boot-starter-aop'
    compileOnly 'org.springframework.boot:spring-boot-starter-web'

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springdoc:springdoc-openapi-ui:1.5.2'
}
```
- RateLimit注解

作者考虑了时间表达式，限流后的自定义回退后的拒绝逻辑, 用户自定义Key（PS：这里其实可以加一些默认的Key生成策略，比如按照方法策略， 按照方法&IP 策略, 按照自定义策略等，默认为按照方法）
```java
package com.taptap.ratelimiter.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author kl (http://kailing.pub)
 * @since 2021/3/16
 */
@Target(value = {ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface RateLimit {

    /**
     * 时间窗口流量数量
     * @return rate
     */
    long rate();

    /**
     * 时间窗口流量数量表达式
     * @return rateExpression
     */
    String rateExpression() default "";

    /**
     * 时间窗口，最小单位秒，如 2s，2h , 2d
     * @return rateInterval
     */
    String rateInterval();

    /**
     * 获取key
     * @return keys
     */
    String [] keys() default {};

    /**
     * 限流后的自定义回退后的拒绝逻辑
     * @return fallback
     */
    String fallbackFunction() default "";

    /**
     * 自定义业务 key 的 Function
     * @return key
     */
    String customKeyFunction() default "";

}
```
- AOP拦截

around环绕方式， 通过定义RateLimiterService获取方法注解的信息，存放在为RateLimiterInfo

如果还定义了回调方法，被限流后还会执行回调方法，回调方法也在RateLimiterService中。
```java
package com.taptap.ratelimiter.core;

import com.taptap.ratelimiter.annotation.RateLimit;
import com.taptap.ratelimiter.exception.RateLimitException;
import com.taptap.ratelimiter.model.LuaScript;
import com.taptap.ratelimiter.model.RateLimiterInfo;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.redisson.api.RScript;
import org.redisson.api.RedissonClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by kl on 2017/12/29.
 * Content : 切面拦截处理器
 */
@Aspect
@Component
@Order(0)
public class RateLimitAspectHandler {

    private static final Logger logger = LoggerFactory.getLogger(RateLimitAspectHandler.class);

    private final RateLimiterService rateLimiterService;
    private final RScript rScript;

    public RateLimitAspectHandler(RedissonClient client, RateLimiterService lockInfoProvider) {
        this.rateLimiterService = lockInfoProvider;
        this.rScript = client.getScript();
    }

    @Around(value = "@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        RateLimiterInfo limiterInfo = rateLimiterService.getRateLimiterInfo(joinPoint, rateLimit);

        List<Object> keys = new ArrayList<>();
        keys.add(limiterInfo.getKey());
        keys.add(limiterInfo.getRate());
        keys.add(limiterInfo.getRateInterval());
        List<Long> results = rScript.eval(RScript.Mode.READ_WRITE, LuaScript.getRateLimiterScript(), RScript.ReturnType.MULTI, keys);
        boolean allowed = results.get(0) == 0L;
        if (!allowed) {
            logger.info("Trigger current limiting,key:{}", limiterInfo.getKey());
            if (StringUtils.hasLength(rateLimit.fallbackFunction())) {
                return rateLimiterService.executeFunction(rateLimit.fallbackFunction(), joinPoint);
            }
            long ttl = results.get(1);
            throw new RateLimitException("Too Many Requests", ttl);
        }
        return joinPoint.proceed();
    }


}
```
这里LuaScript加载定义的lua脚本
```java
package com.taptap.ratelimiter.model;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StreamUtils;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

/**
 * @author kl (http://kailing.pub)
 * @since 2021/3/18
 */
public final class LuaScript {

    private LuaScript(){}
    private static final Logger log = LoggerFactory.getLogger(LuaScript.class);
    private static final String RATE_LIMITER_FILE_PATH = "META-INF/ratelimiter-spring-boot-starter-rateLimit.lua";
    private static String rateLimiterScript;

    static {
        InputStream in = Thread.currentThread().getContextClassLoader()
                .getResourceAsStream(RATE_LIMITER_FILE_PATH);
        try {
            rateLimiterScript =  StreamUtils.copyToString(in, StandardCharsets.UTF_8);
        } catch (IOException e) {
            log.error("ratelimiter-spring-boot-starter Initialization failure",e);
        }
    }

    public static String getRateLimiterScript() {
        return rateLimiterScript;
    }
}
```
lua脚本放在META-INF/ratelimiter-spring-boot-starter-rateLimit.lua， 如下
```lua
--
-- Created by IntelliJ IDEA.
-- User: kl
-- Date: 2021/3/18
-- Time: 11:17 上午
-- To change this template use File | Settings | File Templates.
local rateLimitKey = KEYS[1];
local rate = tonumber(KEYS[2]);
local rateInterval = tonumber(KEYS[3]);
local limitResult = 0;
local ttlResult = 0;
local currValue = redis.call('incr', rateLimitKey);
if (currValue == 1) then
    redis.call('expire', rateLimitKey, rateInterval);
    limitResult = 0;
else
    if (currValue > rate) then
        limitResult = 1;
        ttlResult = redis.call('ttl', rateLimitKey);
    end
end
return { limitResult, ttlResult }
```
- starter自动装配

RateLimiterAutoConfiguration + RateLimiterProperties + spring.factories
```java
package com.taptap.ratelimiter.configuration;

import com.taptap.ratelimiter.core.BizKeyProvider;
import com.taptap.ratelimiter.core.RateLimitAspectHandler;
import com.taptap.ratelimiter.core.RateLimiterService;
import com.taptap.ratelimiter.web.RateLimitExceptionHandler;
import io.netty.channel.nio.NioEventLoopGroup;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.codec.JsonJacksonCodec;
import org.redisson.config.Config;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

/**
 * @author kl (http://kailing.pub)
 * @since 2021/3/16
 */
@Configuration  //  标记为配置类
@ConditionalOnProperty(prefix = RateLimiterProperties.PREFIX, name = "enabled", havingValue = "true") // 只有当配置文件中 spring.ratelimiter.enabled=true 时才生效
@AutoConfigureAfter(RedisAutoConfiguration.class) // 确保在 Redis 自动配置之后执行
@EnableConfigurationProperties(RateLimiterProperties.class) //  启用配置属性绑定
@Import({RateLimitAspectHandler.class, RateLimitExceptionHandler.class})// 导入其他配置类
public class RateLimiterAutoConfiguration {

    private final RateLimiterProperties limiterProperties;

    public RateLimiterAutoConfiguration(RateLimiterProperties limiterProperties) {
        this.limiterProperties = limiterProperties;
    }

    @Bean(destroyMethod = "shutdown")
    @ConditionalOnMissingBean
    RedissonClient redisson() {
        Config config = new Config();
        if (limiterProperties.getRedisClusterServer() != null) {
            config.useClusterServers().setPassword(limiterProperties.getRedisPassword())
                    .addNodeAddress(limiterProperties.getRedisClusterServer().getNodeAddresses());
        } else {
            config.useSingleServer().setAddress(limiterProperties.getRedisAddress())
                    .setDatabase(limiterProperties.getRedisDatabase())
                    .setPassword(limiterProperties.getRedisPassword());
        }
        config.setCodec(new JsonJacksonCodec());
        config.setEventLoopGroup(new NioEventLoopGroup());
        return Redisson.create(config);
    }

    @Bean
    public RateLimiterService rateLimiterInfoProvider() {
        return new RateLimiterService();
    }

    @Bean
    public BizKeyProvider bizKeyProvider() {
        return new BizKeyProvider();
    }

}
```

- 详情可参考： https://gitee.com/kailing/ratelimiter-spring-boot-starter

### 36.2.3 @Import 的作用
1. 明确的依赖关系和控制加载顺序

@Import确保了这两个类一定会在配置类之后被加载，避免了可能的循环依赖或顺序问题。
```
// 确保加载顺序：RateLimiterAutoConfiguration → RateLimitAspectHandler
// AspectHandler 依赖配置类中定义的 Bean，必须后加载
```
2. 条件注解的精确控制

RateLimitExceptionHandler 上有自己的条件注解：
```java
@ConditionalOnProperty(prefix = RateLimiterProperties.PREFIX, 
                       name = "exceptionHandler.enable", 
                       havingValue = "true", 
                       matchIfMissing = true)
```
通过 @Import 可以确保：

- 条件一致性：只有当主配置启用时，才考虑是否加载异常处理器
- 避免意外加载：防止在限流功能禁用时异常处理器仍然被加载
3. 包扫描路径可能不一致

如果这两个类不在 Spring Boot 的主扫描路径下，或者项目使用了自定义的扫描规则，自动扫描可能会失效。@Import 提供了明确的引用。
4.  代码意图更清晰

使用 @Import 使得代码的依赖关系更加明确：

- "这个自动配置类需要这两个组件才能正常工作"
- 阅读代码时能够立即理解组件之间的关系
5. 对比说明

没有 @Import 的情况：
- 依赖 Spring 的组件扫描机制
- 加载顺序不确定
- 条件注解可能产生意外行为

有 @Import 的情况：
- 明确的依赖声明
- 可控的加载顺序
- 条件注解在预期时机执行
### 36.2.4 滑动时间窗口的逻辑解读
#### 36.2.4.1  TimeWindowRateLimiter
```java
public class TimeWindowRateLimiter implements RateLimiter {

    private final RScript rScript;

    public TimeWindowRateLimiter(@Qualifier(REDISSON_BEAN_NAME) RedissonClient client) {
        this.rScript = client.getScript(LongCodec.INSTANCE);
    }

    @Override
    public Result isAllowed(Rule rule) {
        List<Object> keys = getKeys(rule.getKey());
        String script = LuaScript.getTimeWindowRateLimiterScript();
        List<Long> results = rScript.eval(RScript.Mode.READ_WRITE, script, RScript.ReturnType.MULTI, keys, rule.getRate(), rule.getRateInterval());
        boolean isAllowed = results.get(0) == 1L;
        long ttl = results.get(1);

        return new Result(isAllowed, ttl);
    }

    static List<Object> getKeys(String key) {
        String prefix = "request_rate_limiter.{" + key;
        String keys = prefix + "}";
        return Collections.singletonList(keys);
    }

}
```
#### 36.2.4.2 lua脚本
```lua
local rateLimitKey = KEYS[1];
local rate = tonumber(ARGV[1]);
local rateInterval = tonumber(ARGV[2]);

local allowed = 1;
local ttlResult = 0;
local currValue = redis.call('incr', rateLimitKey);
if (currValue == 1) then
    redis.call('expire', rateLimitKey, rateInterval);
    allowed = 1;
else
    if (currValue > rate) then
        allowed = 0;
        ttlResult = redis.call('ttl', rateLimitKey);
    end
end
return { allowed, ttlResult }
```
#### 36.2.4.3 Lua 脚本执行流程


1. **参数解析**
```lua
local rateLimitKey = KEYS[1];        -- Redis key
local rate = tonumber(ARGV[1]);      -- 限流速率（单位时间内允许的请求数）
local rateInterval = tonumber(ARGV[2]); -- 时间窗口大小（秒）
```
2. **初始化变量**
```lua
local allowed = 1;    -- 是否允许访问（1允许，0拒绝）
local ttlResult = 0;  -- key的剩余生存时间
```

3. **核心逻辑 - 原子操作**
```lua
local currValue = redis.call('incr', rateLimitKey);
```

**第一次访问（currValue == 1）：**
```lua
if (currValue == 1) then
    redis.call('expire', rateLimitKey, rateInterval);  -- 设置过期时间
    allowed = 1;  -- 允许访问
```
- `incr` 将 key 的值从 0 增加到 1
- 设置 key 的过期时间为 `rateInterval` 秒
- 允许本次请求

**后续访问：**
```lua
else
    if (currValue > rate) then
        allowed = 0;  -- 超过速率限制，拒绝访问
        ttlResult = redis.call('ttl', rateLimitKey);  -- 获取剩余时间
    end
end
```
- 如果当前计数值超过限制速率，则拒绝访问
- 同时返回 key 的剩余生存时间（用于告诉客户端需要等待多久）

4. **返回结果**
```lua
return { allowed, ttlResult }
```

#### 36.2.4.4 Java 代码调用逻辑

```java
public Result isAllowed(Rule rule) {
    List<Object> keys = getKeys(rule.getKey());  // 生成Redis key
    String script = LuaScript.getTimeWindowRateLimiterScript();  // 获取Lua脚本
    
    // 执行Lua脚本
    List<Long> results = rScript.eval(RScript.Mode.READ_WRITE, script, 
                                     RScript.ReturnType.MULTI, keys, 
                                     rule.getRate(), rule.getRateInterval());
    
    boolean isAllowed = results.get(0) == 1L;  // 是否允许访问
    long ttl = results.get(1);  // 剩余生存时间
    
    return new Result(isAllowed, ttl);
}
```

#### 36.2.4.5 关键特性

1. **原子性操作**
- 整个限流判断在 Redis 中原子执行，避免竞态条件
- 保证分布式环境下的准确性

2. **固定时间窗口算法**
- 每个时间窗口独立计数
- 例如：rate=100，rateInterval=60，表示每分钟最多100次请求

3. **Redis Key 设计**
```java
static List<Object> getKeys(String key) {
    String prefix = "request_rate_limiter.{" + key + "}";
    return Collections.singletonList(prefix);
}
```
- 使用 `{}` 确保在 Redis 集群中所有相关 key 都分配到同一个 slot
- key 格式示例：`request_rate_limiter.{user:123}`

#### 36.2.4.6 使用示例

假设配置：rate=10，rateInterval=60（每分钟10次请求）

**执行过程：**
1. **第1次请求**：currValue=1，设置60秒过期，允许访问
2. **第10次请求**：currValue=10，允许访问  
3. **第11次请求**：currValue=11 > 10，拒绝访问，返回剩余时间

#### 36.2.4.7 优缺点

**优点：**
- 实现简单，性能好
- 分布式环境下一致性有保障
- 内存占用小（每个key只存储一个计数器）

**缺点：**
- 时间窗口边界可能出现双倍流量（临界点问题）
- 不够平滑，可能存在突发流量

这种实现适合对精度要求不是特别高，但需要高性能和分布式一致性的场景。
#### 36.2.4.8 KEYS 和 ARGV 的值是如何获取的？
在 Java 代码中：
```java
List<Object> keys = getKeys(rule.getKey());  // 生成 Redis key，例如 ["request_rate_limiter.{user:123}"]
List<Long> results = rScript.eval(
    RScript.Mode.READ_WRITE, 
    script, 
    RScript.ReturnType.MULTI, 
    keys,                    // 对应 Lua 脚本中的 KEYS 数组
    rule.getRate(),          // 对应 ARGV[1]，例如 10（限流速率）
    rule.getRateInterval()   // 对应 ARGV[2]，例如 60（时间窗口秒数）
);
```

- **`KEYS[1]`**：来自 Java 的 `keys` 列表的第一个元素，即 Redis 的 key（如 `request_rate_limiter.{user:123}`）。
- **`ARGV[1]`**：来自 Java 的 `rule.getRate()`，表示限流速率（如每秒允许的请求数）。
- **`ARGV[2]`**：来自 Java 的 `rule.getRateInterval()`，表示时间窗口大小（秒）。

Redis 的 `eval` 命令会将 `KEYS` 和 `ARGV` 作为参数传递给 Lua 脚本。
#### 36.2.4.9 Redis 命令解释

- `redis.call('incr', rateLimitKey)`
  - **对应 Redis 命令**：`INCR key`
  - **作用**：将 key 中存储的数字值增加 1。如果 key 不存在，会先初始化为 0，再执行加 1 操作。
  - **在限流中的用途**：用于计数当前时间窗口内的请求次数。例如，第一次请求时，key 从 0 变成 1。

- `redis.call('expire', rateLimitKey, rateInterval)`
  - **对应 Redis 命令**：`EXPIRE key seconds`
  - **作用**：为 key 设置生存时间（秒），超过时间后 key 会自动删除。
  - **在限流中的用途**：设置时间窗口的过期时间。例如，当第一次请求时（计数为 1），设置 key 在 60 秒后过期，从而实现固定时间窗口（如每分钟重置计数器）。

- `redis.call('ttl', rateLimitKey)`
  - **对应 Redis 命令**：`TTL key`
  - **作用**：返回 key 的剩余生存时间（秒）。如果 key 没有设置过期时间，返回 -1；如果 key 不存在，返回 -2。
  - **在限流中的用途**：当请求被限流时（计数超过速率），返回剩余时间，告诉客户端需要等待多久才能重试。
## 36.3 补充：为什么lua脚本可以保证并发安全
Lua 脚本在 Redis 中能够保证并发安全，主要基于以下几个关键机制：

### 36.3.1. **Redis 的单线程模型**

Redis 使用单线程处理命令，这意味着：
- **命令串行执行**：所有 Redis 命令都是原子执行的
- **无竞态条件**：同一时刻只有一个命令在执行，不会出现并发冲突
- **顺序一致性**：命令按照接收顺序依次处理

### 36.3.2. **Lua 脚本的原子性执行**

当 Redis 执行 Lua 脚本时：
```lua
-- 整个脚本作为一个原子操作执行
local currValue = redis.call('incr', rateLimitKey);
if (currValue == 1) then
    redis.call('expire', rateLimitKey, rateInterval);
else
    if (currValue > rate) then
        -- ...
    end
end
```

**关键特性：**
- **脚本执行期间不会中断**：Redis 在执行脚本时不会处理其他客户端请求
- **所有操作作为一个事务**：脚本中的多个 Redis 命令被视为一个原子操作
- **一致性保证**：脚本执行过程中，数据状态不会被其他操作改变

### 36.3.3. **对比无脚本的情况**

**没有 Lua 脚本的潜在问题：**
```java
// 伪代码：非原子操作，可能产生竞态条件
Long count = redis.incr(key);
if (count == 1) {
    // 在这两个操作之间，可能有其他请求修改了计数器的值
    redis.expire(key, 60);
}
```

**有 Lua 脚本的优势：**
- 所有操作（incr + 条件判断 + expire/ttl）在同一个原子操作中完成
- 避免了"检查然后设置"（check-then-set）的竞态条件

### 36.3.4. **具体并发安全场景分析**

#### 场景：两个请求同时到达
```
请求A: 执行Lua脚本开始
请求B: 在Redis队列中等待

时间线:
1. 请求A: incr(key) → 返回值1
2. 请求A: 判断count==1 → 执行expire
3. 请求A: 脚本执行完成
4. 请求B: 开始执行脚本，incr(key) → 返回值2
```

#### 关键保证：
- **请求A的整个脚本执行完毕后**，请求B才会开始执行
- 不会出现请求A执行完`incr`后，请求B也执行`incr`，然后两者都认为自己是第一个请求的情况

### 36.3.5. **Redis 对 Lua 脚本的特殊处理**

Redis 对 Lua 脚本的执行有特殊优化：
- **脚本缓存**：脚本会被缓存，后续执行更快
- **原子性保证**：脚本执行期间，Redis 不会切换到其他命令
- **错误处理**：如果脚本执行出错，所有已执行的操作会回滚

### 36.3.6. **为什么需要这种并发安全**

在限流场景中，并发安全至关重要：

**竞态条件示例（无原子性）：**
```
初始状态: count = 0

请求A: 读取count=0
请求B: 读取count=0  
请求A: 设置count=1, 设置过期时间
请求B: 设置count=1 (覆盖了A的设置)，但可能忘记设置过期时间
```

**Lua 脚本解决：**
- 读取、判断、设置的整个流程不可分割
- 每个请求看到的状态都是前一个请求完成后的最新状态

### 36.3.7总结

Lua 脚本在 Redis 中的并发安全性来自于：
1. **Redis 的单线程架构** - 命令串行执行
2. **脚本的原子性** - 整个脚本作为一个不可中断的操作
3. **操作序列化** - 避免了竞态条件和数据不一致

这使得 Lua 脚本成为实现分布式锁、限流、计数器等需要强一致性场景的理想选择。
### 36.3.8 为什么lua脚本可以保证并发安全
Lua 脚本在 Redis 中能够保证并发安全，主要基于以下几个关键机制：

#### 1. **Redis 的单线程模型**

Redis 使用单线程处理命令，这意味着：
- **命令串行执行**：所有 Redis 命令都是原子执行的
- **无竞态条件**：同一时刻只有一个命令在执行，不会出现并发冲突
- **顺序一致性**：命令按照接收顺序依次处理

#### 2. **Lua 脚本的原子性执行**

当 Redis 执行 Lua 脚本时：
```lua
-- 整个脚本作为一个原子操作执行
local currValue = redis.call('incr', rateLimitKey);
if (currValue == 1) then
    redis.call('expire', rateLimitKey, rateInterval);
else
    if (currValue > rate) then
        -- ...
    end
end
```

**关键特性：**
- **脚本执行期间不会中断**：Redis 在执行脚本时不会处理其他客户端请求
- **所有操作作为一个事务**：脚本中的多个 Redis 命令被视为一个原子操作
- **一致性保证**：脚本执行过程中，数据状态不会被其他操作改变

#### 3. **对比无脚本的情况**

**没有 Lua 脚本的潜在问题：**
```java
// 伪代码：非原子操作，可能产生竞态条件
Long count = redis.incr(key);
if (count == 1) {
    // 在这两个操作之间，可能有其他请求修改了计数器的值
    redis.expire(key, 60);
}
```

**有 Lua 脚本的优势：**
- 所有操作（incr + 条件判断 + expire/ttl）在同一个原子操作中完成
- 避免了"检查然后设置"（check-then-set）的竞态条件

#### 4. **具体并发安全场景分析**

##### 场景：两个请求同时到达
```
请求A: 执行Lua脚本开始
请求B: 在Redis队列中等待

时间线:
1. 请求A: incr(key) → 返回值1
2. 请求A: 判断count==1 → 执行expire
3. 请求A: 脚本执行完成
4. 请求B: 开始执行脚本，incr(key) → 返回值2
```

##### 关键保证：
- **请求A的整个脚本执行完毕后**，请求B才会开始执行
- 不会出现请求A执行完`incr`后，请求B也执行`incr`，然后两者都认为自己是第一个请求的情况

#### 5. **Redis 对 Lua 脚本的特殊处理**

Redis 对 Lua 脚本的执行有特殊优化：
- **脚本缓存**：脚本会被缓存，后续执行更快
- **原子性保证**：脚本执行期间，Redis 不会切换到其他命令
- **错误处理**：如果脚本执行出错，所有已执行的操作会回滚

#### 6. **为什么需要这种并发安全**

在限流场景中，并发安全至关重要：

**竞态条件示例（无原子性）：**
```
初始状态: count = 0

请求A: 读取count=0
请求B: 读取count=0  
请求A: 设置count=1, 设置过期时间
请求B: 设置count=1 (覆盖了A的设置)，但可能忘记设置过期时间
```

**Lua 脚本解决：**
- 读取、判断、设置的整个流程不可分割
- 每个请求看到的状态都是前一个请求完成后的最新状态

#### 总结

Lua 脚本在 Redis 中的并发安全性来自于：
1. **Redis 的单线程架构** - 命令串行执行
2. **脚本的原子性** - 整个脚本作为一个不可中断的操作
3. **操作序列化** - 避免了竞态条件和数据不一致

这使得 Lua 脚本成为实现分布式锁、限流、计数器等需要强一致性场景的理想选择。




# 三十七、▶SpringBoot集成MySQL - 基于JPA的封装

## 实现案例

本例主要简单示例下基于JPA DAO/Service层封装，并且注意下如下例子MySQL是5.7版本，8.x版本相关例子也在示例源码中。

## 准备DB

创建MySQL的schema test_db, 导入SQL文件如下：

```sql
-- MySQL dump 10.13  Distrib 5.7.12, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int(11) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user_role` (
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1,1);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-09-08 17:12:11
```

## 引入Maven依赖

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<!-- jpa-spec --->
<dependency>
    <groupId>com.github.wenhao</groupId>
    <artifactId>jpa-spec</artifactId>
    <version>3.1.0</version>
</dependency>
```

## 增加YAML配置

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: xxxxxxxxx
    initial-size: 20
    max-idle: 60
    max-wait: 10000
    min-idle: 10
    max-active: 200
  jpa:
    generate-ddl: false
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true
        use-new-id-generator-mappings: false
```

## 定义实体

### BaseEntity

```java
package tech.pdai.springboot.mysql57.jpa.entity;

import java.io.Serializable;

/**
 * @author pdai
 */
public interface BaseEntity extends Serializable {
}
```

### User实体

```java
package tech.pdai.springboot.mysql57.jpa.entity;

import java.time.LocalDateTime;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * @author pdai
 */
@Getter
@Setter
@ToString
@Entity
@Table(name = "tb_user")
public class User implements BaseEntity {

    /**
     * user id.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * username.
     */
    private String userName;

    /**
     * user pwd.
     */
    private String password;

    /**
     * email.
     */
    private String email;

    /**
     * phoneNumber.
     */
    private long phoneNumber;

    /**
     * description.
     */
    private String description;

    /**
     * create date time.
     */
    private LocalDateTime createTime;

    /**
     * update date time.
     */
    private LocalDateTime updateTime;

    /**
     * join to role table.
     */
    @ManyToMany(cascade = {CascadeType.REFRESH}, fetch = FetchType.EAGER)
    @JoinTable(name = "tb_user_role", joinColumns = {
            @JoinColumn(name = "user_id")}, inverseJoinColumns = {@JoinColumn(name = "role_id")})
    private Set<Role> roles;

}
```

### Role实体

```java
package tech.pdai.springboot.mysql57.jpa.entity;

import java.time.LocalDateTime;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * @author pdai
 */
@Getter
@Setter
@ToString
@Entity
@Table(name = "tb_role")
public class Role implements BaseEntity {

    /**
     * role id.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * role name.
     */
    private String name;

    /**
     * role key.
     */
    private String roleKey;

    /**
     * description.
     */
    private String description;

    /**
     * create date time.
     */
    private LocalDateTime createTime;

    /**
     * update date time.
     */
    private LocalDateTime updateTime;

}
```

## DAO层

### BaseDao

```java
package tech.pdai.springboot.mysql57.jpa.dao;

import java.io.Serializable;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.repository.NoRepositoryBean;
import tech.pdai.springboot.mysql57.jpa.entity.BaseEntity;

/**
 * @author pdai
 */
@NoRepositoryBean
public interface IBaseDao<T extends BaseEntity, I extends Serializable>
        extends JpaRepository<T, I>, JpaSpecificationExecutor<T> {
}
```

### UserDao

```java
package tech.pdai.springboot.mysql57.jpa.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.mysql57.jpa.entity.User;

/**
 * @author pdai
 */
@Repository
public interface IUserDao extends IBaseDao<User, Long> {

}
```

### RoleDao

```java
package tech.pdai.springboot.mysql57.jpa.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.mysql57.jpa.entity.Role;

/**
 * @author pdai
 */
@Repository
public interface IRoleDao extends IBaseDao<Role, Long> {

}
```
## Service层

### BaseService封装

#### BaseService接口

```java
package tech.pdai.springboot.mysql57.jpa.service;

import java.io.Serializable;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;

/**
 * @author pdai
 */
public interface IBaseService<T, I extends Serializable> {

    /**
     * @param id id
     * @return T
     */
    T find(I id);

    /**
     * @return List
     */
    List<T> findAll();

    /**
     * @param ids ids
     * @return List
     */
    List<T> findList(I[] ids);

    /**
     * @param ids ids
     * @return List
     */
    List<T> findList(Iterable<I> ids);

    /**
     * @param pageable pageable
     * @return Page
     */
    Page<T> findAll(Pageable pageable);

    /**
     * @param spec     spec
     * @param pageable pageable
     * @return Page
     */
    Page<T> findAll(Specification<T> spec, Pageable pageable);

    /**
     * @param spec spec
     * @return T
     */
    T findOne(Specification<T> spec);

    /**
     * count.
     *
     * @return long
     */
    long count();

    /**
     * count.
     *
     * @param spec spec
     * @return long
     */
    long count(Specification<T> spec);

    /**
     * exists.
     *
     * @param id id
     * @return boolean
     */
    boolean exists(I id);

    /**
     * save.
     *
     * @param entity entity
     */
    void save(T entity);

    /**
     * save.
     *
     * @param entities entities
     */
    void save(List<T> entities);

    /**
     * update.
     *
     * @param entity entity
     * @return T
     */
    T update(T entity);

    /**
     * delete.
     *
     * @param id id
     */
    void delete(I id);

    /**
     * delete by ids.
     *
     * @param ids ids
     */
    void deleteByIds(List<I> ids);

    /**
     * delete.
     *
     * @param entities entities
     */
    void delete(T[] entities);

    /**
     * delete.
     *
     * @param entities entities
     */
    void delete(Iterable<T> entities);

    /**
     * delete.
     *
     * @param entity entity
     */
    void delete(T entity);

    /**
     * delete all.
     */
    void deleteAll();

    /**
     * find list.
     *
     * @param spec spec
     * @return list
     */
    List<T> findList(Specification<T> spec);

    /**
     * find list.
     *
     * @param spec spec
     * @param sort sort
     * @return List
     */
    List<T> findList(Specification<T> spec, Sort sort);

    /**
     * flush.
     */
    void flush();
}
```

#### BaseService实现类

```java
package tech.pdai.springboot.mysql57.jpa.service.impl;

import java.io.Serializable;
import java.util.Arrays;
import java.util.List;

import javax.transaction.Transactional;

import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import tech.pdai.springboot.mysql57.jpa.dao.IBaseDao;
import tech.pdai.springboot.mysql57.jpa.entity.BaseEntity;
import tech.pdai.springboot.mysql57.jpa.service.IBaseService;

/**
 * @author pdai
 */
@Slf4j
@Transactional
public abstract class BaseDoServiceImpl<T extends BaseEntity, I extends Serializable> implements IBaseService<T, I> {

    /**
     * @return IBaseDao
     */
    public abstract IBaseDao<T, I> getBaseDao();

    /**
     * findById.
     *
     * @param id id
     * @return T
     */
    @Override
    public T find(I id) {
        return getBaseDao().findById(id).orElse(null);
    }

    /**
     * @return List
     */
    @Override
    public List<T> findAll() {
        return getBaseDao().findAll();
    }

    /**
     * @param ids ids
     * @return List
     */
    @Override
    public List<T> findList(I[] ids) {
        List<I> idList = Arrays.asList(ids);
        return getBaseDao().findAllById(idList);
    }

    /**
     * find list.
     *
     * @param spec spec
     * @return list
     */
    @Override
    public List<T> findList(Specification<T> spec) {
        return getBaseDao().findAll(spec);
    }

    /**
     * find list.
     *
     * @param spec spec
     * @param sort sort
     * @return List
     */
    @Override
    public List<T> findList(Specification<T> spec, Sort sort) {
        return getBaseDao().findAll(spec, sort);
    }

    /**
     * find one.
     *
     * @param spec spec
     * @return T
     */
    @Override
    public T findOne(Specification<T> spec) {
        return getBaseDao().findOne(spec).orElse(null);
    }

    /**
     * @param pageable pageable
     * @return Page
     */
    @Override
    public Page<T> findAll(Pageable pageable) {
        return getBaseDao().findAll(pageable);
    }

    /**
     * count.
     *
     * @return long
     */
    @Override
    public long count() {
        return getBaseDao().count();
    }

    /**
     * count.
     *
     * @param spec spec
     * @return long
     */
    @Override
    public long count(Specification<T> spec) {
        return getBaseDao().count(spec);
    }

    /**
     * exists.
     *
     * @param id id
     * @return boolean
     */
    @Override
    public boolean exists(I id) {
        return getBaseDao().findById(id).isPresent();
    }

    /**
     * save.
     *
     * @param entity entity
     */
    @Override
    public void save(T entity) {
        getBaseDao().save(entity);
    }

    /**
     * save.
     *
     * @param entities entities
     */
    @Override
    public void save(List<T> entities) {
        getBaseDao().saveAll(entities);
    }

    /**
     * update.
     *
     * @param entity entity
     * @return T
     */
    @Override
    public T update(T entity) {
        return getBaseDao().saveAndFlush(entity);
    }

    /**
     * delete.
     *
     * @param id id
     */
    @Override
    public void delete(I id) {
        getBaseDao().deleteById(id);
    }

    /**
     * delete by ids.
     *
     * @param ids ids
     */
    @Override
    public void deleteByIds(List<I> ids) {
        getBaseDao().deleteAllById(ids);
    }

    /**
     * delete all.
     */
    @Override
    public void deleteAll() {
        getBaseDao().deleteAllInBatch();
    }

    /**
     * delete.
     *
     * @param entities entities
     */
    @Override
    public void delete(T[] entities) {
        List<T> tList = Arrays.asList(entities);
        getBaseDao().deleteAll(tList);
    }

    /**
     * delete.
     *
     * @param entities entities
     */
    @Override
    public void delete(Iterable<T> entities) {
        getBaseDao().deleteAll(entities);
    }

    /**
     * delete.
     *
     * @param entity entity
     */
    @Override
    public void delete(T entity) {
        getBaseDao().delete(entity);
    }

    /**
     * @param ids ids
     * @return List
     */
    @Override
    public List<T> findList(Iterable<I> ids) {
        return getBaseDao().findAllById(ids);
    }

    /**
     * @param spec     spec
     * @param pageable pageable
     * @return Page
     */
    @Override
    public Page<T> findAll(Specification<T> spec, Pageable pageable) {
        return getBaseDao().findAll(spec, pageable);
    }

    /**
     * flush.
     */
    @Override
    public void flush() {
        getBaseDao().flush();
    }
}
```

### UserService

#### UserService接口定义

```java
package tech.pdai.springboot.mysql57.jpa.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import tech.pdai.springboot.mysql57.jpa.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql57.jpa.entity.User;

/**
 * @author pdai
 */
public interface IUserService extends IBaseService<User, Long> {

    /**
     * find by page.
     *
     * @param userQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    Page<User> findPage(UserQueryBean userQueryBean, PageRequest pageRequest);
}
```

#### UserService实现类

```java
package tech.pdai.springboot.mysql57.jpa.service.impl;

import com.github.wenhao.jpa.Specifications;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql57.jpa.dao.IBaseDao;
import tech.pdai.springboot.mysql57.jpa.dao.IUserDao;
import tech.pdai.springboot.mysql57.jpa.entity.User;
import tech.pdai.springboot.mysql57.jpa.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql57.jpa.service.IUserService;

@Service
public class UserDoServiceImpl extends BaseDoServiceImpl<User, Long> implements IUserService {

    /**
     * userDao.
     */
    private final IUserDao userDao;

    /**
     * init.
     *
     * @param userDao2 user dao
     */
    public UserDoServiceImpl(final IUserDao userDao2) {
        this.userDao = userDao2;
    }

    /**
     * @return base dao
     */
    @Override
    public IBaseDao<User, Long> getBaseDao() {
        return this.userDao;
    }

    /**
     * find by page.
     *
     * @param queryBean   query
     * @param pageRequest pageRequest
     * @return page
     */
    @Override
    public Page<User> findPage(UserQueryBean queryBean, PageRequest pageRequest) {
        Specification<User> specification = Specifications.<User>and()
                .like(StringUtils.isNotEmpty(queryBean.getName()), "user_name", queryBean.getName())
                .like(StringUtils.isNotEmpty(queryBean.getDescription()), "description",
                        queryBean.getDescription())
                .build();
        return this.getBaseDao().findAll(specification, pageRequest);
    }
}
```

### RoleService

#### RoleService接口定义

```java
package tech.pdai.springboot.mysql57.jpa.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import tech.pdai.springboot.mysql57.jpa.entity.Role;
import tech.pdai.springboot.mysql57.jpa.entity.query.RoleQueryBean;

public interface IRoleService extends IBaseService<Role, Long> {

    /**
     * find page by query.
     *
     * @param roleQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    Page<Role> findPage(RoleQueryBean roleQueryBean, PageRequest pageRequest);
}
```

#### RoleService实现类

```java
package tech.pdai.springboot.mysql57.jpa.service.impl;

import com.github.wenhao.jpa.Specifications;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql57.jpa.dao.IBaseDao;
import tech.pdai.springboot.mysql57.jpa.dao.IRoleDao;
import tech.pdai.springboot.mysql57.jpa.entity.Role;
import tech.pdai.springboot.mysql57.jpa.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql57.jpa.service.IRoleService;

@Service
public class RoleDoServiceImpl extends BaseDoServiceImpl<Role, Long> implements IRoleService {

    /**
     * roleDao.
     */
    private final IRoleDao roleDao;

    /**
     * init.
     *
     * @param roleDao2 role dao
     */
    public RoleDoServiceImpl(final IRoleDao roleDao2) {
        this.roleDao = roleDao2;
    }

    /**
     * @return base dao
     */
    @Override
    public IBaseDao<Role, Long> getBaseDao() {
        return this.roleDao;
    }

    /**
     * find page by query.
     *
     * @param roleQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    @Override
    public Page<Role> findPage(RoleQueryBean roleQueryBean, PageRequest pageRequest) {
        Specification<Role> specification = Specifications.<Role>and()
                .like(StringUtils.isNotEmpty(roleQueryBean.getName()), "name",
                        roleQueryBean.getName())
                .like(StringUtils.isNotEmpty(roleQueryBean.getDescription()), "description",
                        roleQueryBean.getDescription())
                .build();
        return this.roleDao.findAll(specification, pageRequest);
    }
}
```

## Controller层

### UserController

```java
package tech.pdai.springboot.mysql57.jpa.controller;

import java.time.LocalDateTime;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.mysql57.jpa.entity.User;
import tech.pdai.springboot.mysql57.jpa.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql57.jpa.entity.response.ResponseResult;
import tech.pdai.springboot.mysql57.jpa.service.IUserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId()==null || !userService.exists(user.getId())) {
            user.setCreateTime(LocalDateTime.now());
            user.setUpdateTime(LocalDateTime.now());
            userService.save(user);
        } else {
            user.setUpdateTime(LocalDateTime.now());
            userService.update(user);
        }
        return ResponseResult.success(userService.find(user.getId()));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.find(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User Page")
    @GetMapping("list")
    public ResponseResult<Page<User>> list(@RequestParam int pageSize, @RequestParam int pageNumber) {
        return ResponseResult.success(userService.findPage(UserQueryBean.builder().build(), PageRequest.of(pageNumber, pageSize)));
    }
}
```

## 总结

本文档详细展示了SpringBoot集成MySQL基于JPA的完整封装实现，包括：

1. **数据库准备**：创建了用户、角色和用户角色关联表
2. **依赖配置**：引入MySQL连接器、Spring Data JPA和相关工具依赖
3. **实体定义**：使用JPA注解定义User和Role实体类
4. **DAO层封装**：通过IBaseDao接口统一基础数据访问操作
5. **Service层封装**：实现通用的BaseService和具体的业务Service
6. **Controller层**：提供RESTful API接口

该架构具有良好的扩展性和维护性，可以作为企业级项目的参考模板。
# 三十八、SpringBoot集成MySQL - MyBatis XML方式

SpringBoot集成MySQL - MyBatis XML方式上文介绍了用JPA方式的集成MySQL数据库，JPA方式在中国以外地区开发而言基本是标配，在国内MyBatis及其延伸框架较为主流。本文主要介绍MyBatis技栈的演化以及SpringBoot集成基础的MyBatis XML实现方式的实例。

## 38.1 准备知识

需要了解MyBatis及MyBatis技术栈的演进，这对新的开发者可以很好的构筑其知识体系。

## 38.2 什么是MyBatis？

MyBatis是一款优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。

mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。

MyBatis的主要设计目的就是让我们对执行SQL语句时对输入输出的数据管理更加方便，所以方便地写出SQL和方便地获取SQL的执行结果才是MyBatis的核心竞争力。

Mybatis的功能架构分为三层：

- API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。
- 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。
- 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

更多介绍可以参考：<a href='https://mybatis.org/mybatis-3/zh_CN/configuration.html'>MyBatis3 官方网站</a>

## 38.3 为什么说MyBatis是半自动ORM？

### 38.3.1 什么是ORM？

ORM（Object-Relational Mapping）是对象关系映射，它将数据库中的表映射为Java对象，使得开发者可以以面向对象的方式操作数据库。JDBC是Java连接数据库的标准API，但需要手动处理连接和SQL，而ORM框架自动化了这些过程。

### 38.3.2 什么是全自动ORM？

全自动ORM框架可以根据对象关系模型直接获取、查询关联对象或者关联集合对象，简单而言使用全自动的ORM框架查询时可以不再写SQL。典型的框架如Hibernate；因为Spring-data-jpa很多代码也是Hibernate团队贡献的，所以spring-data-jpa也是全自动ORM框架。

### 38.3.3 MyBatis是半自动ORM？

Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动ORM 映射工具。（PS: 正是由于MyBatis是半自动框架，基于MyBatis技术栈的框架开始考虑兼容MyBatis开发框架的基础上提供自动化的能力，比如MyBatis-plus等框架）

## 38.4 MyBatis栈技术演进

了解MyBatis技术栈的演进，对你构建基于MyBatis的知识体系极为重要。

### 38.4.1 JDBC，自行封装JDBCUtil

Java5的时代，通常的开发中会自行封装JDBC的Util，比如创建 Connection，以及确保关闭 Connection等。

### 38.4.2 IBatis

MyBatis的前身，它封装了绝大多数的 JDBC 样板代码，使得开发者只需关注 SQL 本身，而不需要花费精力去处理例如注册驱动，创建 Connection，以及确保关闭 Connection 这样繁杂的代码。

### 38.4.3 MyBatis

伴随着JDK5+ 泛型和注解特性开始流行，IBatis在3.0变更为MyBatis，对泛型和注解等特性开始全面支持，同时支持了很多新的特性，比如：

- mybatis实现了接口绑定，通过Dao接口 和xml映射文件的绑定，自动生成接口的具体实现
- mybatis支持 ognl表达式，比如 <if>, <else>使用ognl进行解析
- mybatis插件机制等，（PageHelper分页插件应用而生，解决了数据库层的分页封装问题）

所以这个时期，MyBatis XML 配置方式 + PageHelper 成为重要的开发方式。

### 38.4.4 MyBatis衍生：代码生成工具等

MyBatis提供了开发上的便捷，但是依然需要写大量的xml配置，并且很多都是CRUD级别的（这便有了很多重复性的工作），所以为了减少重复编码，衍生出了MyBatis代码生成工具, 比如CodeGenerator等。其它开发IDE也开始出现封装一些工具和插件来生成代码生成工具等。由于后端视图解析引擎多样性（比如freemarker, volicty, thymeleaf等），以及前后端分离前端独立等，为了进一步减少重复代码的编写（包括视图层），自动生成的代码工具也开始演化为自动生成前端视图代码。

### 38.4.5 Spring+MyBatis基于注解的配置集成

与此同时，Spring 2.5 开始完全支持基于注解的配置并且也支持JSR250 注解。在Spring后续的版本发展倾向于通过注解和Java配置结合使用。基于Spring+MyBatis开发技术栈开始有xml配置方式往注解和java配置方式反向发展。Spring Boot的出现便是要解决配置过多的问题，它实际上通过约定大于配置的方式大大简化了用户的配置，对于三方组件使用xx-starter统一的对Bean进行默认初始化，用户只需要很少的配置就可以进行开发了。所以出现了mybatis-spring-boot-starter的封装等。这个阶段，主要的开发技术栈是 Spring + mybatis-spring-boot-starter 自动化配置 + PageHelper，并且很多数据库实体mapper还是通过xml方式配置的（伴随着使用一些自动化生成工具）。

### 38.4.6 MyBatis-Plus

为了更高的效率，出现了MyBatis-Plus这类工具，对MyBatis进行增强。考虑到MyBatis是半自动化ORM，MyBatis-Plus 启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作; 并且内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求；总体上让其支持全自动化的使用方式（本质上借鉴了Hibernate思路）。

- 考虑到Java8 Lambda（函数式编程）开始流行，MyBatis-Plus支持 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错
- 考虑到MyBatis还需要独立引入PageHelper分页插件，MyBatis-Plus支持了内置分页插件，同PageHelper一样基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询
- 考虑到自动化代码生成方式，MyBatis-Plus也支持了内置代码生成器，采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用
- 考虑到SQL性能优化等问题，MyBatis-Plus内置性能分析插件, 可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询
- 其它还有解决一些常见开发问题，比如支持主键自动生成，支持4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题；以及内置全局拦截插件，提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作

顶层思维能力用这种思路去理解，你便能很快了解MyBatis技术栈的演化（能够快速维护老一些的技术框架），以及理解新的中小项目中MyBatis-Plus被大量使用的原因（新项目的技术选型参考）；所以java全栈知识体系的目标是帮助你构建知识体系，甚至是辅助你培养顶层思维能力。

## 38.5 简单示例

尽管MyBatis-Plus大行其道，MyBatis XML 配置方式 + PageHelper依然是基础使用方式。本例依然向你展示MyBatis XML 配置方式，考虑到和spring-data-jpa方式对比，这里沿用上一篇文章的数据库。后续的案例中将具体介绍MyBatis分页，以及MyBatis-Plus的使用等。

### 38.5.1 准备DB和依赖配置

创建MySQL的schema test_db, 导入SQL 文件如下：

```sql
-- MySQL dump 10.13  Distrib 5.7.12, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int(11) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user_role` (
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1,1);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-09-08 17:12:11
```

引入maven依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.0</version>
</dependency>
<!--pagehelper分页 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.10</version>
</dependency>
```

增加yml配置：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf

mybatis:
  mapper-locations: classpath:mybatis/mapper/*.xml
  type-aliases-package: tech.pdai.springboot.mysql57.xml.entity
  configuration:
    cache-enabled: true
    use-generated-keys: true
    default-executor-type: REUSE
    use-actual-param-name: true
```

classpath:mybatis/mapper/*.xml是mapper的位置。

### 38.5.2 Mapper文件

mapper文件定义在配置的路径中（classpath:mybatis/mapper/*.xml）

UserMapper.xml:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="tech.pdai.springboot.mysql57.mybatis.xml.dao.IUserDao">

	<resultMap type="tech.pdai.springboot.mysql57.mybatis.xml.entity.User" id="UserResult">
		<id     property="id"       	column="id"      		/>
		<result property="userName"     column="user_name"    	/>
		<result property="password"     column="password"    	/>
		<result property="email"        column="email"        	/>
		<result property="phoneNumber"  column="phone_number"  	/>
		<result property="description"  column="description"  	/>
		<result property="createTime"   column="create_time"  	/>
		<result property="updateTime"   column="update_time"  	/>
		<collection property="roles" ofType="tech.pdai.springboot.mysql57.mybatis.xml.entity.Role">
			<result property="id" column="id"  />
			<result property="name" column="name"  />
			<result property="roleKey" column="role_key"  />
			<result property="description" column="description"  />
			<result property="createTime"   column="create_time"  	/>
			<result property="updateTime"   column="update_time"  	/>
		</collection>
	</resultMap>
	
	<sql id="selectUserSql">
        select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time, r.name, r.role_key, r.description, r.create_time, r.update_time
		from tb_user u
		left join tb_user_role ur on u.id=ur.user_id
		inner join tb_role r on ur.role_id=r.id
    </sql>
	
	<select id="findList" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.query.UserQueryBean" resultMap="UserResult">
		<include refid="selectUserSql"/>
		where u.id != 0
		<if test="userName != null and userName != ''">
			AND u.user_name like concat('%', #{user_name}, '%')
		</if>
		<if test="description != null and description != ''">
			AND u.description like concat('%', #{description}, '%')
		</if>
		<if test="phoneNumber != null and phoneNumber != ''">
			AND u.phone_number like concat('%', #{phoneNumber}, '%')
		</if>
		<if test="email != null and email != ''">
			AND u.email like concat('%', #{email}, '%')
		</if>
	</select>
	
	<select id="findById" parameterType="Long" resultMap="UserResult">
		<include refid="selectUserSql"/>
		where u.id = #{id}
	</select>
	
	<delete id="deleteById" parameterType="Long">
 		delete from tb_user where id = #{id}
 	</delete>
 	
 	<delete id="deleteByIds" parameterType="Long">
		delete from tb_user where id in
 		<foreach collection="array" item="id" open="(" separator="," close=")">
 			#{id}
        </foreach> 
 	</delete>
 	
 	<update id="update" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.User">
 		update tb_user
 		<set>
 			<if test="userName != null and userName != ''">user_name = #{userName},</if>
 			<if test="email != null and email != ''">email = #{email},</if>
 			<if test="phoneNumber != null and phoneNumber != ''">phone_number = #{phoneNumber},</if>
			<if test="description != null and description != ''">description = #{description},</if>
 			update_time = sysdate()
 		</set>
 		where id = #{id}
	</update>

	<update id="updatePassword" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.User">
		update tb_user
		<set>
			password = #{password}, update_time = sysdate()
		</set>
		where id = #{id}
	</update>
 	
 	<insert id="save" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.User" useGeneratedKeys="true" keyProperty="id">
 		insert into tb_user(
 			<if test="userName != null and userName != ''">user_name,</if>
			<if test="password != null and password != ''">password,</if>
 			<if test="email != null and email != ''">email,</if>
			<if test="phoneNumber != null and phoneNumber != ''">phone_number,</if>
 			<if test="description != null and description != ''">description,</if>
 			create_time,
			update_time
 		)values(
 			<if test="userName != null and userName != ''">#{userName},</if>
			<if test="password != null and password != ''">#{password},</if>
 			<if test="email != null and email != ''">#{email},</if>
 			<if test="phoneNumber != null and phoneNumber != ''">#{phone_number},</if>
 			<if test="description != null and description != ''">#{description},</if>
 			sysdate(),
			sysdate()
 		)
	</insert>
	
</mapper> 
```

RoleMapper.xml:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="tech.pdai.springboot.mysql57.mybatis.xml.dao.IRoleDao">

	<resultMap type="tech.pdai.springboot.mysql57.mybatis.xml.entity.Role" id="RoleResult">
		<id     property="id"       	column="id"      		/>
		<result property="name" 		column="name"  />
		<result property="roleKey" 		column="role_key"  />
		<result property="description" 	column="description"  />
		<result property="createTime"   column="create_time"  	/>
		<result property="updateTime"   column="update_time"  	/>
	</resultMap>
	
	<sql id="selectRoleSql">
        select  r.id, r.name, r.role_key, r.description, r.create_time, r.update_time
			from tb_role r
    </sql>
	
	<select id="findList" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.query.RoleQueryBean" resultMap="RoleResult">
		<include refid="selectRoleSql"/>
		where r.id != 0
		<if test="name != null and name != ''">
			AND r.name like concat('%', #{name}, '%')
		</if>
		<if test="roleKey != null and roleKey != ''">
			AND r.role_key = #{roleKey}
		</if>
		<if test="description != null and description != ''">
			AND r.description like concat('%', #{description}, '%')
		</if>
	</select>
	
</mapper> 
```

### 38.5.3 定义dao与Mapper文件中方法对应

UserDao:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.dao;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.User;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.UserQueryBean;

/**
 * @author pdai
 */
@Mapper
public interface IUserDao {

    List<User> findList(UserQueryBean userQueryBean);

    User findById(Long id);

    int deleteById(Long id);

    int deleteByIds(Long[] ids);

    int update(User user);

    int save(User user);

    int updatePassword(User user);
}
```

RoleDao:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.dao;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.Role;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.RoleQueryBean;

/**
 * @author pdai
 */
@Mapper
public interface IRoleDao {
    List<Role> findList(RoleQueryBean roleQueryBean);
}
```

### 38.5.4 定义Service接口和实现类

UserService接口:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.service;

import java.util.List;

import tech.pdai.springboot.mysql57.mybatis.xml.entity.User;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.UserQueryBean;


/**
 * @author pdai
 */
public interface IUserService {

    List<User> findList(UserQueryBean userQueryBean);

    User findById(Long id);

    int deleteById(Long id);

    int deleteByIds(Long[] ids);

    int update(User user);

    int save(User user);

    int updatePassword(User user);

}
```

User Service的实现类:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.service.impl;

import java.util.List;

import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql57.mybatis.xml.dao.IUserDao;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.User;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql57.mybatis.xml.service.IUserService;

@Service
public class UserDoServiceImpl implements IUserService {

    /**
     * userDao.
     */
    private final IUserDao userDao;

    /**
     * init.
     *
     * @param userDao2 user dao
     */
    public UserDoServiceImpl(final IUserDao userDao2) {
        this.userDao = userDao2;
    }

    @Override
    public List<User> findList(UserQueryBean userQueryBean) {
        return userDao.findList(userQueryBean);
    }

    @Override
    public User findById(Long id) {
        return userDao.findById(id);
    }

    @Override
    public int deleteById(Long id) {
        return userDao.deleteById(id);
    }

    @Override
    public int deleteByIds(Long[] ids) {
        return userDao.deleteByIds(ids);
    }

    @Override
    public int update(User user) {
        return userDao.update(user);
    }

    @Override
    public int save(User user) {
        return userDao.save(user);
    }

    @Override
    public int updatePassword(User user) {
        return userDao.updatePassword(user);
    }
}
```

Role Service 接口:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.service;

import java.util.List;

import tech.pdai.springboot.mysql57.mybatis.xml.entity.Role;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.RoleQueryBean;

public interface IRoleService {

    List<Role> findList(RoleQueryBean roleQueryBean);

}
```

Role Service 实现类:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.service.impl;

import java.util.List;

import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql57.mybatis.xml.dao.IRoleDao;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.Role;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql57.mybatis.xml.service.IRoleService;

@Service
public class RoleDoServiceImpl implements IRoleService {

    /**
     * roleDao.
     */
    private final IRoleDao roleDao;

    /**
     * init.
     *
     * @param roleDao2 role dao
     */
    public RoleDoServiceImpl(final IRoleDao roleDao2) {
        this.roleDao = roleDao2;
    }

    @Override
    public List<Role> findList(RoleQueryBean roleQueryBean) {
        return roleDao.findList(roleQueryBean);
    }
}
```

### 38.5.5 controller

User Controller:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.controller;


import java.time.LocalDateTime;
import java.util.List;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.User;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.response.ResponseResult;
import tech.pdai.springboot.mysql57.mybatis.xml.service.IUserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId()==null) {
            user.setCreateTime(LocalDateTime.now());
            user.setUpdateTime(LocalDateTime.now());
            userService.save(user);
        } else {
            user.setUpdateTime(LocalDateTime.now());
            userService.update(user);
        }
        return ResponseResult.success(userService.findById(user.getId()));
    }


    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.findById(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User List")
    @GetMapping("list")
    public ResponseResult<List<User>> list(UserQueryBean userQueryBean) {
        return ResponseResult.success(userService.findList(userQueryBean));
    }
}
```

Role Controller:

```java
package tech.pdai.springboot.mysql57.mybatis.xml.controller;


import java.util.List;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.Role;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql57.mybatis.xml.entity.response.ResponseResult;
import tech.pdai.springboot.mysql57.mybatis.xml.service.IRoleService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/role")
public class RoleController {

    @Autowired
    private IRoleService roleService;

    /**
     * @return user list
     */
    @ApiOperation("Query Role List")
    @GetMapping("list")
    public ResponseResult<List<Role>> list(RoleQueryBean roleQueryBean) {
        return ResponseResult.success(roleService.findList(roleQueryBean));
    }
}
```

# 三十九、SpringBoot集成MySQL - MyBatis 注解方式
## 39.1 准备知识
在构建知识体系时：我们最重要的目标并不是如何使用注解方式，而是要理解：
- 对于有原有xml方式改为注解方式（一定要有对比），如何写？ 
  - 基本的CRUD怎么用注解写？
  - 对于复杂的动态SQL如何写？
  - 对于表关联的如何写？
- 为什么xml方式依然是比注解方式使用广泛？
  -  xml方式和注解方式混合使用？
-  注解方式是如何工作的呢？
## 39.2 基本查改删操作
> 我们从最基本的增删改操作开始，对比xml方式进行理解。
### 39.2.1 查询操作
#### 39.2.1.1 @Results和@Result注解
> 对于xml配置查询时定义的ResultMap, 在注解中如何定义呢？
```xml
<resultMap type="tech.pdai.springboot.mysql57.mybatis.xml.entity.User" id="UserResult1">
  <id     property="id"       	column="id"      		/>
  <result property="userName"     column="user_name"    	/>
  <result property="password"     column="password"    	/>
  <result property="email"        column="email"        	/>
  <result property="phoneNumber"  column="phone_number"  	/>
  <result property="description"  column="description"  	/>
  <result property="createTime"   column="create_time"  	/>
  <result property="updateTime"   column="update_time"  	/>
</resultMap>
```
使用注解方式，用@Results注解对应
```java
@Results(
        id = "UserResult1",
        value = {
                @Result(id = true, property = "id", column = "id"),
                @Result(property = "userName", column = "user_name"),
                @Result(property = "password", column = "password"),
                @Result(property = "email", column = "email"),
                @Result(property = "phoneNumber", column = "phone_number"),
                @Result(property = "description", column = "description"),
                @Result(property = "createTime", column = "create_time"),
                @Result(property = "updateTime", column = "update_time")
        }
)l
```
#### 39.2.1.2 @Select和@Param注解
> 对于查询，用@Select注解；对于参数, 使用@Param注解

所以根据用户ID查询用户，使用注解方式写法如下：
```java
@Results(
        id = "UserResult1",
        value = {
                @Result(id = true, property = "id", column = "id"),
                @Result(property = "userName", column = "user_name"),
                @Result(property = "password", column = "password"),
                @Result(property = "email", column = "email"),
                @Result(property = "phoneNumber", column = "phone_number"),
                @Result(property = "description", column = "description"),
                @Result(property = "createTime", column = "create_time"),
                @Result(property = "updateTime", column = "update_time")
        }
)
@Select("select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time from tb_user u where id = #{id}")
User findById1(@Param("id") Long id);
```
#### 38.2.1.3 @ResultMap注解
> xml配置查询时定义的ResultMap是可以复用的，那么我们上面通过@Results定义在某个方法上的，如何复用呢？

比如查询所有用户返回用户实体@Results是和查询单个用户一致的，那么我们可以通过@ResultMap指定返回值对应关系
```java
@ResultMap("UserResult1")
@Select("select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time from tb_user u")
User findAll1();
```
由此你可以猜到，@ResultMap定义在哪个方法上并没有什么关系，因为它会被优先通过注解解析为数据库字段与Java字段的映射关系。 
#### 38.2.1.4 表关联查询
> 用户和角色存在着一对多的关系，上面的查询只是查询了用户的基本信息，如何关联查询（查询用户同时返回角色信息）呢？
**无论是一对一还是一对多关系，在MyBatis中都有两种实现方式**：

1. **嵌套查询方式**（分步查询/延迟加载）
2. **JOIN查询方式**（一次性查询）

下面我为您详细整理所有四种情况的XML和注解写法：

##### 一、一对多关系的两种实现方式

###### 方式1：嵌套查询（分步查询）

**XML配置：**
```xml
<!-- UserMapper.xml -->
<resultMap type="User" id="UserResult">
    <id property="id" column="id"/>
    <result property="userName" column="user_name"/>
    <!-- 其他User字段 -->
    <collection property="roles" ofType="Role" 
                select="findRoleByUserId" column="id"/>
</resultMap>

<select id="findUserById" resultMap="UserResult">
    SELECT * FROM user WHERE id = #{id}
</select>

<select id="findRoleByUserId" resultType="Role">
    SELECT r.* FROM role r 
    INNER JOIN user_role ur ON r.id = ur.role_id 
    WHERE ur.user_id = #{userId}
</select>
```

**注解配置：**
```java
@Mapper
public interface UserMapper {
    
    @Select("SELECT * FROM user WHERE id = #{id}")
    @Results(id = "UserResult", value = {
        @Result(property = "id", column = "id"),
        @Result(property = "userName", column = "user_name"),
        // 其他User字段
        @Result(property = "roles", column = "id", 
                many = @Many(select = "findRoleByUserId", fetchType = FetchType.EAGER))
    })
    User findUserById(Long id);
    
    @Select("SELECT r.* FROM role r INNER JOIN user_role ur ON r.id = ur.role_id WHERE ur.user_id = #{userId}")
    List<Role> findRoleByUserId(Long userId);
}
```

###### 方式2：JOIN查询（一次性查询）

**XML配置：**
```xml
<!-- UserMapper.xml -->
<resultMap type="User" id="UserResult">
    <id property="id" column="id"/>
    <result property="userName" column="user_name"/>
    <!-- 其他User字段 -->
    <collection property="roles" ofType="Role">
        <id property="id" column="role_id"/>
        <result property="name" column="role_name"/>
        <result property="roleKey" column="role_key"/>
        <!-- 其他Role字段 -->
    </collection>
</resultMap>

<select id="findUserById" resultMap="UserResult">
    SELECT u.*, 
           r.id as role_id, r.name as role_name, r.role_key as role_key
    FROM user u
    LEFT JOIN user_role ur ON u.id = ur.user_id
    LEFT JOIN role r ON ur.role_id = r.id
    WHERE u.id = #{id}
</select>
```

**注解配置：**
```java
@Mapper
public interface UserMapper {
    
    @Select("SELECT u.*, " +
            "r.id as role_id, r.name as role_name, r.role_key as role_key " +
            "FROM user u " +
            "LEFT JOIN user_role ur ON u.id = ur.user_id " +
            "LEFT JOIN role r ON ur.role_id = r.id " +
            "WHERE u.id = #{id}")
    @Results(id = "UserResult", value = {
        @Result(property = "id", column = "id"),
        @Result(property = "userName", column = "user_name"),
        // 其他User字段
        @Result(property = "roles", column = "id", 
                many = @Many(resultMap = "roleResult", fetchType = FetchType.EAGER))
    })
    User findUserById(Long id);
}

@Mapper
public interface RoleMapper {
    @Results(id = "roleResult", value = {
        @Result(property = "id", column = "role_id"),
        @Result(property = "name", column = "role_name"),
        @Result(property = "roleKey", column = "role_key")
    })
    @Select("SELECT * FROM role WHERE id = #{role_id}")
    Role findById(Long id);
}
```
注意如果存在关联关系的时候定义column要遵循sql查询中的命名规则
##### 二、一对一关系的两种实现方式

###### 方式1：嵌套查询（分步查询）

**XML配置：**
```xml
<!-- UserMapper.xml -->
<resultMap type="User" id="UserResult">
    <id property="id" column="id"/>
    <result property="userName" column="user_name"/>
    <!-- 其他User字段 -->
    <association property="organization" column="org_id" 
                 select="findOrganizationById"/>
</resultMap>

<select id="findUserById" resultMap="UserResult">
    SELECT * FROM user WHERE id = #{id}
</select>

<select id="findOrganizationById" resultType="Organization">
    SELECT * FROM organization WHERE id = #{orgId}
</select>
```

**注解配置：**
```java
@Mapper
public interface UserMapper {
    
    @Select("SELECT * FROM user WHERE id = #{id}")
    @Results(id = "UserResult", value = {
        @Result(property = "id", column = "id"),
        @Result(property = "userName", column = "user_name"),
        // 其他User字段
        @Result(property = "organization", column = "org_id", 
                one = @One(select = "findOrganizationById", fetchType = FetchType.EAGER))
    })
    User findUserById(Long id);
    
    @Select("SELECT * FROM organization WHERE id = #{orgId}")
    Organization findOrganizationById(Integer orgId);
}
```

###### 方式2：JOIN查询（一次性查询）

**XML配置：**
```xml
<!-- UserMapper.xml -->
<resultMap type="User" id="UserResult">
    <id property="id" column="id"/>
    <result property="userName" column="user_name"/>
    <!-- 其他User字段 -->
    <association property="organization" javaType="Organization">
        <id property="id" column="org_id"/>
        <result property="name" column="org_name"/>
        <result property="path" column="org_path"/>
        <!-- 其他Organization字段 -->
    </association>
</resultMap>

<select id="findUserById" resultMap="UserResult">
    SELECT u.*, 
           o.id as org_id, o.name as org_name, o.path as org_path
    FROM user u
    LEFT JOIN organization o ON u.org_id = o.id
    WHERE u.id = #{id}
</select>
```

**注解配置：**
```java
@Mapper
public interface UserMapper {
    
    @Select("SELECT u.*, " +
            "o.id as org_id, o.name as org_name, o.path as org_path " +
            "FROM user u " +
            "LEFT JOIN organization o ON u.org_id = o.id " +
            "WHERE u.id = #{id}")
    @Results(id = "UserResult", value = {
        @Result(property = "id", column = "id"),
        @Result(property = "userName", column = "user_name"),
        // 其他User字段
        @Result(property = "organization.id", column = "org_id"),
        @Result(property = "organization.name", column = "org_name"),
        @Result(property = "organization.path", column = "org_path")
        // 其他Organization字段
    })
    User findUserById(Long id);
}
```

##### 总结对比

| 关系类型 | 实现方式 | 特点 | 适用场景 |
|---------|---------|------|----------|
| 一对多 | 嵌套查询 | 分两步执行SQL，可能N+1查询 | 数据量大，需要延迟加载 |
| 一对多 | JOIN查询 | 一次性查询所有数据 | 数据量小，性能要求高 |
| 一对一 | 嵌套查询 | 分两步执行SQL | 关联表数据量大，需要延迟加载 |
| 一对一 | JOIN查询 | 一次性查询所有数据 | 关联表数据量小，性能要求高 |
### 39.2.2 插入操作
> 涉及插入操作的主要注解有：@Insert, @SelectKey等。

#### 39.2.2.1 @Insert注解
对于插入操作，在xml配置可以定义为：
```xml
<insert id="save" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.User" useGeneratedKeys="true" keyProperty="id">
 		insert into tb_user(
 			<if test="userName != null and userName != ''">user_name,</if>
			<if test="password != null and password != ''">password,</if>
 			<if test="email != null and email != ''">email,</if>
			<if test="phoneNumber != null and phoneNumber != ''">phone_number,</if>
 			<if test="description != null and description != ''">description,</if>
 			create_time,
			update_time
 		)values(
 			<if test="userName != null and userName != ''">#{userName},</if>
			<if test="password != null and password != ''">#{password},</if>
 			<if test="email != null and email != ''">#{email},</if>
 			<if test="phoneNumber != null and phoneNumber != ''">#{phoneNumber},</if>
 			<if test="description != null and description != ''">#{description},</if>
 			sysdate(),
			sysdate()
 		)
	</insert>
```
特别是，这里通过`<if>`判断条件更新的情况应该如何在注解中写呢？

可以通过`@Insert + <script>`
```java
@Insert({"<script> ", "insert into tb_user(\n" +
        " <if test=\"userName != null and userName != ''\">user_name,</if>\n" +
        " <if test=\"password != null and password != ''\">password,</if>\n" +
        " <if test=\"email != null and email != ''\">email,</if>\n" +
        " <if test=\"phoneNumber != null and phoneNumber != ''\">phone_number,</if>\n" +
        " <if test=\"description != null and description != ''\">description,</if>\n" +
        " create_time,\n" +
        " update_time\n" +
        " )values(\n" +
        " <if test=\"userName != null and userName != ''\">#{userName},</if>\n" +
        " <if test=\"password != null and password != ''\">#{password},</if>\n" +
        " <if test=\"email != null and email != ''\">#{email},</if>\n" +
        " <if test=\"phoneNumber != null and phoneNumber != ''\">#{phoneNumber},</if>\n" +
        " <if test=\"description != null and description != ''\">#{description},</if>\n" +
        " sysdate(),\n" +
        " sysdate()\n" +
        " )", " </script>"})
@Options(useGeneratedKeys = true, keyProperty = "id")
int save(User user);
```
#### 39.2.2.2 返回Insert后实体的主键值
> 上述@Options(useGeneratedKeys = true, keyProperty = "id") 表示什么意思呢？

表示，如果数据库提供了自增列生成Key的方式(比如这里的id), 并且需要返回自增主键时，可以通过这种方式返回实体。

那么，如果id的自增不使用数据库自增主键时, 在xml中可以使用SelectKey：
```xml
<selectKey keyColumn="id" resultType="long" keyProperty="id" order="AFTER">
    SELECT LAST_INSERT_ID()
</selectKey>
```
对应着注解：
```java
@SelectKey(statement = "SELECT LAST_INSERT_ID()", keyColumn = "id", keyProperty = "id", resultType = Long.class, before = false)
```
- before = false, 相当于XML中的order="AFTRE"，这是MySql数据库的配置。
- before = true, 相当于XML中的order="BEFORE"，这是Oracle数据库的配置。

注意事项：不同的数据库statement的值会不同，上面中的值适用于MySql数据库，使用其他类型的数据库时要注意修改。


#### 39.2.2.3  `@SelectKey` 到底是干什么的？

`@SelectKey`是MyBatis中用于**在插入操作前后获取数据库生成的键值**的注解。它的主要作用是：

##### 核心功能
- **在执行INSERT语句之前或之后，执行一个额外的SQL语句来获取生成的键值**
- **将获取的键值设置到实体对象的指定属性中**

##### 适用场景
1. **数据库不支持自增主键**（如Oracle使用序列）
2. **需要复杂的主键生成逻辑**
3. **需要获取非自增的其他生成键**

##### 参数详解
```java
@SelectKey(
    statement = "SELECT LAST_INSERT_ID()",  // 要执行的SQL语句
    keyColumn = "id",                       // 数据库中的主键列名
    keyProperty = "id",                     // 实体类中的属性名
    resultType = Long.class,                // 返回值的类型
    before = false                          // 执行时机：false=INSERT之后，true=INSERT之前
)
```

##### 具体示例

**MySQL场景（INSERT之后获取）：**
```java
@Insert("INSERT INTO user(user_name, password) VALUES(#{userName}, #{password})")
@SelectKey(statement = "SELECT LAST_INSERT_ID()", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = false)
int insertUser(User user);
```

**Oracle场景（INSERT之前获取）：**
```java
@Insert("INSERT INTO user(id, user_name, password) VALUES(#{id}, #{userName}, #{password})")
@SelectKey(statement = "SELECT user_seq.nextval FROM dual", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = true)
int insertUser(User user);
```

#### 39.2.2.4 `@Options` 注解的作用

`@Options`是一个更通用的配置注解，其中包含`useGeneratedKeys`参数用于处理自增主键：

##### 核心功能
- **自动使用数据库的自增机制生成主键**
- **适用于支持自增主键的数据库（如MySQL、SQL Server等）**

##### 参数详解
```java
@Options(
    useGeneratedKeys = true,    // 使用数据库生成的主键
    keyProperty = "id",         // 主键值设置到实体类的哪个属性
    keyColumn = "id"            // 数据库中的主键列名（可选）
)
```

##### 具体示例
```java
@Insert("INSERT INTO user(user_name, password) VALUES(#{userName}, #{password})")
@Options(useGeneratedKeys = true, keyProperty = "id")
int insertUser(User user);
```

##### 两者的主要区别

| 特性 | `@Options(useGeneratedKeys=true)` | `@SelectKey` |
|------|-----------------------------------|--------------|
| **适用数据库** | 支持自增主键的数据库（MySQL等） | 所有数据库 |
| **执行方式** | 自动利用数据库的自增机制 | 需要手动编写SQL语句获取键值 |
| **灵活性** | 简单，但功能有限 | 灵活，可以处理复杂场景 |
| **性能** | 通常更好（数据库原生支持） | 需要额外执行SQL语句 |

##### 实际使用场景对比

###### 场景1：MySQL数据库（推荐使用`@Options`）
```java
// 简单高效的方式
@Insert("INSERT INTO user(user_name, password) VALUES(#{userName}, #{password})")
@Options(useGeneratedKeys = true, keyProperty = "id")
int insertUser(User user);

// 插入后，user对象的id属性会自动被设置
User user = new User();
user.setUserName("test");
user.setPassword("123456");
userMapper.insertUser(user);
System.out.println(user.getId()); // 这里会输出自动生成的主键ID
```

###### 场景2：Oracle数据库（必须使用`@SelectKey`）
```java
// Oracle使用序列生成主键
@Insert("INSERT INTO user(id, user_name, password) VALUES(#{id}, #{userName}, #{password})")
@SelectKey(statement = "SELECT user_seq.nextval FROM dual", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = true)
int insertUser(User user);
```

##### 场景3：复杂的键生成逻辑（使用`@SelectKey`）
```java
// 需要根据业务规则生成复杂主键
@Insert("INSERT INTO order(order_no, amount) VALUES(#{orderNo}, #{amount})")
@SelectKey(statement = "SELECT generate_order_no()", 
           keyProperty = "orderNo", 
           resultType = String.class, 
           before = true)
int insertOrder(Order order);
```

##### 总结

- **`@Options(useGeneratedKeys=true)`**：适用于简单的自增主键场景，代码简洁
- **`@SelectKey`**：功能更强大，适用于所有数据库和复杂的主键生成需求

您提供的文档中的说明是正确的，关键是理解两者的适用场景和区别。在MySQL环境下，通常推荐使用`@Options`，因为它更简洁高效；而在Oracle或其他需要复杂主键生成的场景下，`@SelectKey`是必不可少的。
#### 39.2.2.5 @SelectKey中before参数的设置（true或false）的区别

##### 执行时机的区别

###### `before = false`（INSERT之后执行）
```java
@Insert("INSERT INTO user(user_name, password) VALUES(#{userName}, #{password})")
@SelectKey(statement = "SELECT LAST_INSERT_ID()", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = false)
int insertUser(User user);
```

**执行流程：**
1. 先执行INSERT语句
2. 再执行`SELECT LAST_INSERT_ID()`
3. 将获取到的主键值设置到`user.id`属性中

###### `before = true`（INSERT之前执行）
```java
@Insert("INSERT INTO user(id, user_name, password) VALUES(#{id}, #{userName}, #{password})")
@SelectKey(statement = "SELECT user_seq.nextval FROM dual", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = true)
int insertUser(User user);
```

**执行流程：**
1. 先执行`SELECT user_seq.nextval FROM dual`
2. 将获取到的主键值设置到`user.id`属性中
3. 再执行INSERT语句（此时`#{id}`已经有值了）

##### 适用场景的区别

###### `before = false` 适用场景
**主要适用于支持自增主键的数据库：**
- MySQL、SQL Server、PostgreSQL等
- 使用数据库的自增机制

**特点：**
- INSERT语句中**不包含主键字段**
- 数据库自动生成主键值
- 插入后通过特定函数获取生成的主键

**示例：**
```sql
-- INSERT语句（不包含id字段）
INSERT INTO user(user_name, password) VALUES('test', '123456');

-- 插入后获取自增ID
SELECT LAST_INSERT_ID();  -- 返回刚插入记录的自增ID
```

###### `before = true` 适用场景
**主要适用于使用序列的数据库：**
- Oracle、DB2等
- 需要手动生成主键值的场景

**特点：**
- INSERT语句中**必须包含主键字段**
- 先获取序列值，再执行插入
- 适用于复杂的主键生成规则

**示例：**
```sql
-- 先获取序列值
SELECT user_seq.nextval FROM dual;  -- 返回序列的下一个值，比如1001

-- 然后插入（包含id字段）
INSERT INTO user(id, user_name, password) VALUES(1001, 'test', '123456');
```

##### 实际代码对比

###### MySQL场景（before = false）
```java
// 实体类
public class User {
    private Long id;        // 插入前为null，插入后被设置
    private String userName;
    private String password;
}

// Mapper接口
@Insert("INSERT INTO user(user_name, password) VALUES(#{userName}, #{password})")
@SelectKey(statement = "SELECT LAST_INSERT_ID()", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = false)
int insertUser(User user);

// 使用示例
User user = new User();
user.setUserName("test");
user.setPassword("123456");
System.out.println(user.getId()); // null

userMapper.insertUser(user);
System.out.println(user.getId()); // 自动生成的主键值，如1001
```

###### Oracle场景（before = true）
```java
// 实体类
public class User {
    private Long id;        // 插入前就被设置，插入后不变
    private String userName;
    private String password;
}

// Mapper接口
@Insert("INSERT INTO user(id, user_name, password) VALUES(#{id}, #{userName}, #{password})")
@SelectKey(statement = "SELECT user_seq.nextval FROM dual", 
           keyProperty = "id", 
           resultType = Long.class, 
           before = true)
int insertUser(User user);

// 使用示例
User user = new User();
user.setUserName("test");
user.setPassword("123456");
System.out.println(user.getId()); // null

userMapper.insertUser(user);
System.out.println(user.getId()); // 序列生成的值，如1001
```

##### 关键区别总结

| 特性 | `before = false` | `before = true` |
|------|------------------|-----------------|
| **执行顺序** | INSERT → SELECT | SELECT → INSERT |
| **适用数据库** | MySQL等自增数据库 | Oracle等序列数据库 |
| **INSERT语句** | 不包含主键字段 | 必须包含主键字段 |
| **实体对象状态** | 插入后才有id | 插入前就有id |

##### 选择建议

1. **如果是MySQL数据库**：推荐使用`before = false`，或者直接用`@Options(useGeneratedKeys = true)`
2. **如果是Oracle数据库**：必须使用`before = true`
3. **如果需要自定义主键生成逻辑**：根据生成逻辑的时机选择`before`参数

**简单记忆：**
- MySQL：`before = false` + `LAST_INSERT_ID()`
- Oracle：`before = true` + `序列.nextval`

理解这个区别对于在不同数据库环境下正确使用MyBatis非常重要！
### 39.2.3 更新操作
> 涉及更新操作的主要注解有：@Update等。
#### 39.2.3.1 @Update 注解
对于xml的更新操作如下：
```xml
<update id="update" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.User">
  update tb_user
  <set>
    <if test="userName != null and userName != ''">user_name = #{userName},</if>
    <if test="email != null and email != ''">email = #{email},</if>
    <if test="phoneNumber != null and phoneNumber != ''">phone_number = #{phoneNumber},</if>
    <if test="description != null and description != ''">description = #{description},</if>
    update_time = sysdate()
  </set>
  where id = #{id}
</update>

<update id="updatePassword" parameterType="tech.pdai.springboot.mysql57.mybatis.xml.entity.User">
  update tb_user
  <set>
    password = #{password}, update_time = sysdate()
  </set>
  where id = #{id}
</update>
```
对应的注解写法如下：
```java
@Update({"update tb_user set password = #{password}, update_time = sysdate()", " where id = #{id}"})
int updatePassword(User user);

@Update({"<script> ", "update tb_user\n" +
        " <set>\n" +
        " <if test=\"userName != null and userName != ''\">user_name = #{userName},</if>\n" +
        " <if test=\"email != null and email != ''\">email = #{email},</if>\n" +
        " <if test=\"phoneNumber != null and phoneNumber != ''\">phone_number = #{phoneNumber},</if>\n" +
        " <if test=\"description != null and description != ''\">description = #{description},</if>\n" +
        " update_time = sysdate()\n" +
        " </set>\n" +
        " where id = #{id}", " </script>"})
int update(User user);
```
### 39.2.4 删除操作
> 涉及删除操作的主要注解有：@Delete等。
#### 39.2.4.1@Delete 注解
对于xml的删除操作如下：
```xml
<delete id="deleteById" parameterType="Long">
  delete from tb_user where id = #{id}
</delete>

<delete id="deleteByIds" parameterType="Long">
  delete from tb_user where id in
  <foreach collection="array" item="id" open="(" separator="," close=")">
    #{id}
      </foreach> 
</delete>
```
对应的注解写法如下：
```java
@Delete("delete from tb_user where id = #{id}")
int deleteById(Long id);

@Delete({"<script> ", "delete from tb_user where id in\n" +
        "<foreach collection=\"array\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n" +
        "#{id}\n" +
        "</foreach>", " </script>"})
int deleteByIds(Long[] ids);
```
## 39.3 Provider注解
> 其实你可以发现通过注解方式，对于有一些需要通过动态构建查询条件的操作是非常不方便的。MyBatis的作者们自然就想到了动态构建SQL，动态构建SQL的方式是配合@Provider注解来完成的。

MyBatis提供了4种Provider注解，分别是@SelectProvider、@InsertProvider、@UpdateProvider和@DeleteProvider。

这里以@SelectProvider为例来根据Id查询User：
1. 定义包含自定义生成的动态SQL的类，比如UserDaoProvider
```java
/**
 * @author pdai
 */
public class UserDaoProvider {

    public String findById(final Long id) {
        SQL sql = new SQL();
        sql.SELECT("u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time");
        sql.FROM("tb_user u");
        sql.WHERE("id = " + id);
        return sql.toString();
    }
}
```
2. 通过@SelectProvider注解关联到定义的类和方法
```java
@ResultMap("UserResult")
@SelectProvider(type = UserDaoProvider.class, method = "findById")
User findById2(Long id);
```
## 39.4 其它注解
- `@CacheNamespace` ：为给定的命名空间 (比如类) 配置缓存。对应xml中的`<cache>`。
- `@CacheNamespaceRef` ：参照另外一个命名空间的缓存来使用。属性:value,应该是一个名空间的字 符串值(也就是类的完全限定名) 。对应xml中的`<cacheRef>`标签。
- `@ConstructorArgs` ：收集一组结果传递给一个劫夺对象的 构造方法。属性:value,是形式参数 的数组。
- `@Arg` ：单 独 的 构 造 方 法 参 数 , 是 ConstructorArgs 集合的一部分。属性: id,column,javaType,typeHandler。id 属性是布尔值, 来标识用于比较的属 性,和XML 元素相似。对应xml中的`<arg>`标签。
- `@Case` ：单独实例的值和它对应的映射。属性: value,type,results。Results 属性是结 果数组,因此这个注解和实际的 ResultMap 很相似,由下面的 Results 注解指定。对应xml中标签`<case>`。
- `@TypeDiscriminator` : 一组实例值被用来决定结果映射的表 现。 属性: column, javaType, jdbcType, typeHandler,cases。cases 属性就是实 例的数组。对应xml中标签`<discriminator>`。
- `@Flush`： 在MyBatis 3.3以上版本，可以通过此注解在Mapper接口中调用SqlSession#flushStatements()。
## 39.5 xml方式和注解方式融合
xml方式和注解方式是可以融合写的， 我们可以将复杂的SQL写在xml中

比如将resultMap定义在xml中
```xml
<resultMap type="tech.pdai.springboot.mysql57.mybatis.xml.entity.User" id="UserResult3">
  <id     property="id"       	column="id"      		/>
  <result property="userName"     column="user_name"    	/>
  <result property="password"     column="password"    	/>
  <result property="email"        column="email"        	/>
  <result property="phoneNumber"  column="phone_number"  	/>
  <result property="description"  column="description"  	/>
  <result property="createTime"   column="create_time"  	/>
  <result property="updateTime"   column="update_time"  	/>
  <collection property="roles" ofType="tech.pdai.springboot.mysql57.mybatis.xml.entity.Role">
    <result property="id" column="id"  />
    <result property="name" column="name"  />
    <result property="roleKey" column="role_key"  />
    <result property="description" column="description"  />
    <result property="createTime"   column="create_time"  	/>
    <result property="updateTime"   column="update_time"  	/>
  </collection>
</resultMap>
```
在方法中用@ResultMap
```java
@ResultMap("UserResult3")
@Select("select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time from tb_user u")
User findAll1();
```
## 39.6 为什么纯注解方式不是最佳选择?
> 纯注解方式为何很少大规模呢？ 说说我的一些看法

- 对于复杂的SQL，特别是按照条件动态生成方式极为不便，即便有`<script>`， 代码的阅读体验和维护极为不佳；
- 对于复杂的SQL，即便有@Provider方式，这种充其量是一个半成品 
  - 不是所见即所得的写法，需要再定义额外的类和方法
  - 动态构建时不便利
  - 函数式编程成为主流，lambda方式才是未来
  - ...

这也是mybatis-plus等工具改进的地方。
## 39.7 @Options注解详解
`@Options` 注解用于为单个 Mapper 方法提供细粒度的配置，这些配置通常对应 XML 映射文件中的标签属性。它非常强大，可以解决许多常见场景下的特定需求。

---

### 39.7.1 核心参数详解与使用案例

#### 1. `useGeneratedKeys` 和 `keyProperty`（最常用组合）

- **功能**：
    - `useGeneratedKeys`：指示 MyBatis 使用 JDBC 的 `getGeneratedKeys` 方法来获取数据库内部生成的主键（如自增 ID、序列等）。默认值为 `false`。
    - `keyProperty`：指定哪个对象属性来接收这个生成的主键值。

- **使用场景**：**插入数据后，需要立即获取该数据在数据库中生成的主键ID。**

- **案例代码**：
假设我们有一个 `User` 表，其 `id` 字段是自增主键。

```java
// User 实体类
public class User {
    private Long id;    // 对应数据库自增主键
    private String name;
    private String email;
    // ... 省略 getter/setter
}

// Mapper 接口
public interface UserMapper {

    @Insert("INSERT INTO user (name, email) VALUES (#{name}, #{email})")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int insertUser(User user);
}
```

- **如何使用**：
```java
User newUser = new User();
newUser.setName("张三");
newUser.setEmail("zhangsan@example.com");

// 执行插入
userMapper.insertUser(newUser);

// 插入完成后，数据库生成的 id 会自动回填到 newUser 对象的 id 属性中
System.out.println("新用户ID: " + newUser.getId()); // 这里可以直接获取到ID，例如 5
```

#### 2. `keyColumn`

- **功能**：明确指定数据库表中主键列的名称。当数据库列名（如 `user_id`）与对象属性名（如 `id`）不一致时，需要使用此属性来建立映射。

- **使用场景**：数据库主键列名与实体类属性名不匹配时。

- **案例代码**：
```java
// 实体类属性名为 id，但数据库列名为 user_id
public class User {
    private Long id;
    // ...
}

@Insert("INSERT INTO user (name, email) VALUES (#{name}, #{email})")
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "user_id")
int insertUser(User user);
```

#### 3. `flushCache`

- **功能**：设置语句执行后是否清空一级缓存和二级缓存。可选值为 `FlushCachePolicy.TRUE`（默认） 或 `FlushCachePolicy.FALSE`。
    - 对于 `@Insert`, `@Update`, `@Delete` 语句，**默认值为 `true`**，即执行后会清空缓存，以保证后续查询能获取到最新数据。
    - 对于 `@Select` 语句，**默认值为 `false`**。

- **使用场景**：在极少数需要极致性能、且能容忍一定时间内数据不一致（脏读）的写操作场景下，可以设置为 `false` 以避免清空缓存。**通常不建议修改默认值。**

- **案例代码**：
```java
// 这是一个不常见的操作，仅用于演示：更新用户邮箱但不清空缓存（风险高！）
@Update("UPDATE user SET email = #{email} WHERE id = #{id}")
@Options(flushCache = FlushCachePolicy.FALSE)
int updateUserEmailWithoutFlushCache(Long id, String email);
```

#### 4. `useCache`

- **功能**：**仅对 `@Select` 语句有效**。设置是否将本次查询结果存入二级缓存。默认值为 `true`。

- **使用场景**：对于实时性要求极高、数据变化频繁，或者结果集非常大的查询，可以设置为 `false` 以避免缓存占用内存或返回旧数据。

- **案例代码**：
```java
// 查询最新在线用户列表，此数据变化快，不需要缓存
@Select("SELECT * FROM user WHERE status = 'online' ORDER BY last_active_time DESC")
@Options(useCache = false)
List<User> selectOnlineUsers();
```

#### 5. `timeout`

- **功能**：设置该 SQL 语句在数据库端的执行超时时间（单位：秒）。如果超时，数据库会抛出超时异常。

- **使用场景**：防止复杂查询或慢 SQL 长时间占用数据库连接，影响系统整体性能。

- **案例代码**：
```java
// 一个复杂的报表查询，我们设置超时时间为 30 秒
@Select("SELECT ... (复杂的 JOIN 和 GROUP BY 语句) ...")
@Options(timeout = 30)
List<ReportVO> generateComplexReport();
```

#### 6. `fetchSize`

- **功能**：给 JDBC 驱动程序的一个提示，希望每次从数据库服务器端批量获取的记录数。这是一个性能调优参数。

- **使用场景**：当需要查询大量数据（如导出上万条记录）时，设置合理的 `fetchSize` 可以减少网络往返次数，提升性能。具体效果因数据库和驱动而异。

- **案例代码**：
```java
// 需要导出全部用户数据，设置每次获取 500 条
@Select("SELECT * FROM user")
@Options(fetchSize = 500)
List<User> selectAllUsersForExport();
```

---

### 39.7.2 综合案例

一个方法上可以同时配置多个选项。

```java
@Insert("INSERT INTO audit_log (operation, operator, detail) VALUES (#{operation}, #{operator}, #{detail})")
@Options(
    useGeneratedKeys = true,    // 需要获取生成的主键
    keyProperty = "logId",      // 主键值设置到参数对象的 logId 属性上
    timeout = 5,                // 插入日志操作应在5秒内完成
    flushCache = FlushCachePolicy.FALSE // 日志插入不影响业务缓存（可选）
)
int insertAuditLog(AuditLog log);
```

### 39.7.3 总结

| 参数 | 核心功能 | 适用语句 | 常用值 |
| :--- | :--- | :--- | :--- |
| **`useGeneratedKeys`** | **获取数据库生成的主键** | `@Insert` | `true` |
| **`keyProperty`** | **指定接收主键的对象属性** | `@Insert` | 如 `"id"` |
| `keyColumn` | 指定数据库主键列名（用于列名与属性名不一致时） | `@Insert` | 如 `"user_id"` |
| `flushCache` | 执行后是否清空缓存 | 所有 | 通常保持默认 |
| `useCache` | 是否缓存查询结果 | `@Select` | `true`（默认）或 `false`（实时数据） |
| `timeout` | 设置SQL执行超时时间 | 所有 | 正整数，如 `10` |
| `fetchSize` | 设置批量获取的记录数（性能优化） | `@Select` | 正整数，如 `500` |

**核心要点**：
1.  **`useGeneratedKeys` + `keyProperty`** 是日常开发中使用频率最高的组合，务必掌握。
2.  其他参数主要用于特定的性能调优或控制场景，按需使用。
3.  如果不确定是否需要某个配置，保持默认行为通常是最安全的选择。
### 补充：fetchSize 参数的进一步说明
**`fetchSize` 是 JDBC 层面的性能优化参数，它控制的是：**

> **每次从数据库服务器到应用程序的内存中批量传输多少条记录**

#### 具体解释：

1. **不限制总返回数量**：你的 `SELECT * FROM user` 会返回表中**所有**的用户记录，可能是1000条、10000条甚至更多。

2. **控制数据传输的"批次大小"**：
   - 没有设置 `fetchSize` 时，JDBC 驱动可能一次性把所有数据都加载到内存中
   - 设置 `fetchSize = 500` 后，JDBC 驱动会：
     - 第一次从数据库获取500条记录
     - 第二次再获取500条记录
     - ...依此类推，直到获取所有数据

#### 实际工作流程对比：

**没有设置 fetchSize（或默认值）：**
```
应用程序 ←── 一次性加载 10000条记录 ──→ 数据库
        （内存瞬间占用很大）
```

**设置了 `fetchSize = 500`：**
```
应用程序 ←── 第一批500条 ──→ 数据库
        ←── 第二批500条 ──→
        ←── 第三批500条 ──→
        ...（分20次完成10000条数据的传输）
```

#### 为什么要这样设置？

**性能优化好处：**
- **减少内存峰值**：避免一次性加载海量数据导致内存溢出（OOM）
- **改善响应性**：应用程序可以更早开始处理第一批数据
- **减少网络延迟影响**：分批传输可以更好地利用网络带宽
#### 核心问题：`List<User>` vs `Cursor<User>`

##### 情况1：使用 `List<User>`（你的示例）

```java
@Select("SELECT * FROM user")
@Options(fetchSize = 500)
List<User> selectAllUsersForExport();  // ❌ 你的理解是对的！
```

**你说的完全正确：**
- 即使设置了 `fetchSize = 500`，由于返回类型是 `List<User>`
- **MyBatis 会等待所有数据都从数据库获取完毕，组装成完整的 List 后，才返回给调用方**
- 所以调用方的代码确实会**阻塞**，直到所有数据准备就绪
- 这时候 `fetchSize` 的主要作用是**优化JDBC驱动内部的数据获取过程**，减少内存峰值

##### 情况2：使用 `Cursor<User>`（正确的流式处理方式）

```java
@Select("SELECT * FROM user")
@Options(fetchSize = 500)
Cursor<User> selectAllUsersForExport();  // ✅ 这才是真正的流式处理
```

**这才是 `fetchSize` 真正发挥价值的地方：**

```java
// 使用游标，真正的流式处理
try (Cursor<User> users = userMapper.selectAllUsersForExport()) {
    for (User user : users) {
        // 🔥 重点：这里不是等所有数据都准备好！
        // 当处理第一条记录时，JDBC可能只从数据库获取了500条
        // 处理完500条后，会自动获取下一批500条
        exportToFile(user);
    }
}
```

##### 两种方式的对比：

| 特性 | `List<User>` + fetchSize | `Cursor<User>` + fetchSize |
|------|--------------------------|----------------------------|
| **是否阻塞** | ✅ **是**，等待所有数据 | ❌ **否**，边获取边处理 |
| **内存占用** | 所有数据都在内存中 | 只有当前批次的数据在内存中 |
| **适用场景** | 数据量不大（几千条） | 大数据量导出（几万条以上） |
| **响应速度** | 慢，要等所有数据 | 快，立即开始处理 |

##### 为什么有人会误用？

很多开发者（包括一些教程）会错误地认为 `List + fetchSize` 就能实现流式查询，但实际上：

```java
// 错误理解：以为这样就能流式处理
List<User> list = mapper.selectAllUsers(); // 这里已经阻塞了！
for (User user : list) { // 到这里所有数据已在内存中
    process(user);
}

// 正确做法：使用游标
try (Cursor<User> cursor = mapper.selectAllUsers()) {
    for (User user : cursor) { // 真正的流式处理
        process(user);
    }
}
```
`fetchSize` 只有在配合 `Cursor` 返回类型时，才能实现真正的**非阻塞流式处理**。如果使用 `List`，无论 `fetchSize` 设多少，调用方都会阻塞等待所有数据加载完成。
# 四十、SpringBoot集成MySQL - MyBatis PageHelper分页
## 40.1 准备知识
### 40.1.1 逻辑分页和物理分页的区别？
> 为什么会出现PageHelper这类框架？

这便要从逻辑分页和物理分页开始说起：
- `逻辑分页`：从数据库将所有记录查询出来，存储到内存中，展示当前页，然后数据再直接从内存中获取（前台分页）
- `物理分页`：只从数据库中查询当前页的数据（后台分页）

由于MyBatis默认实现中采用的是逻辑分页，所以才诞生了PageHelper一类的物理分页框架。hibernate不要是因为hibernate采用的就是物理分页。
### 40.1.2 不同数据库的物理分页是如何实现的？
> 那物理分页通常是如何实现的呢？

不同的数据库有不同的实现方式：（简单而言：mysql 使用limit ，SQLServer 使用top ，Oracle使用rowNum）
- MySQL 使用LIMIT

例如：
```sql
SELECT username, password 
FROM tb_user 
WHERE id = 1 
LIMIT 100,10
```
- SQLServer 2012 使用top

SQL SERVER 2012 支持了OFFSET + TOP方式提高了性能
```sql
SELECT top(50) LastName, FirstName, EmailAddress
FROM Employee
ORDER BY LastName, FirstName, EmailAddress
OFFSET 14000 ROWS
FETCH NEXT 50 ROWS ONLY;
```
- ORACLE
```sql
SELECT *  
  FROM (SELECT AA.*, ROWNUM RN  
          FROM (SELECT * FROM USERS ORDER BY ID DESC) AA  
         WHERE ROWNUM <= 10 )  
 WHERE RN > 0 
```
## 40.2 PageHelper是如何实现物理分页的前提:MyBatis的插件机制？
- MyBatis提供了一种插件(plugin)的功能，虽然叫做插件，但其实这是拦截器功能。
- Mybatis的分页功能很弱，它是基于内存的分页（查出所有记录再按偏移量和limit取结果），在大数据量的情况下这样的分页基本上是没有用的。本文基于插件，通过拦截StatementHandler重写sql语句，实现数据库的物理分页# 简单示例
## 40.3 简单示例
PageHelper 有多种用法，这里主要介绍官网提供的几种常见用法。具体请参考<a href ='https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md'>官网的介绍</a>

### 第一种：RowBounds方式的调用

RowBounds 是 MyBatis 提供的物理分页方式，通过传入 RowBounds 对象来指定偏移量和限制条数。

```java
List<User> list = sqlSession.selectList("x.y.selectIf", null, new RowBounds(0, 10));
```

### 第二种：Mapper接口方式的调用startPage

使用 PageHelper 的 `startPage` 方法进行分页，推荐这种方式。它会自动拦截后续的 Mapper 方法调用并添加分页逻辑。

```java
PageHelper.startPage(1, 10);
List<User> list = userMapper.selectIf(1);
```

### 第三种：Mapper接口方式的调用offsetPage

使用 PageHelper 的 `offsetPage` 方法进行分页，同样推荐使用。这种方式基于偏移量进行分页。

```java
PageHelper.offsetPage(1, 10);
List<User> list = userMapper.selectIf(1);
```

### 第四种：参数方法调用

在 Mapper 接口方法中直接定义分页参数，无需在 XML 中处理分页逻辑。需要配置 `supportMethodsArguments=true`。

Mapper 接口定义：
```java
public interface CountryMapper {
    List<User> selectByPageNumSize(
            @Param("user") User user,
            @Param("pageNum") int pageNum, 
            @Param("pageSize") int pageSize);
}
```

调用方式：
```java
List<User> list = userMapper.selectByPageNumSize(user, 1, 10);
```

### 第五种：参数对象

如果分页参数（pageNum 和 pageSize）存在于参数对象中，当这些参数有值时，会自动触发分页。

User 对象定义：
```java
public class User {
    // 其他字段
    private Integer pageNum;
    private Integer pageSize;
    // getter 和 setter
}
```

Mapper 接口定义：
```java
public interface CountryMapper {
    List<User> selectByPageNumSize(User user);
}
```

调用方式（当 user 中的 pageNum 和 pageSize 不为 null 时自动分页）：
```java
List<User> list = userMapper.selectByPageNumSize(user);
```

### 第六种：ISelect 接口方式

通过 ISelect 接口实现分页查询，支持多种用法。

#### jdk6、7 用法

创建 ISelect 接口匿名实现类：

```java
Page<User> page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() {
    @Override
    public void doSelect() {
        userMapper.selectGroupBy();
    }
});
```

#### jdk8 lambda 用法

使用 lambda 表达式简化代码：

```java
Page<User> page = PageHelper.startPage(1, 10).doSelectPage(() -> userMapper.selectGroupBy());
```

#### 直接返回 PageInfo

也可以直接返回 PageInfo 对象，注意使用 `doSelectPageInfo` 方法。

jdk6、7 用法：
```java
PageInfo pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() {
    @Override
    public void doSelect() {
        userMapper.selectGroupBy();
    }
});
```

jdk8 lambda 用法：
```java
PageInfo pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -> userMapper.selectGroupBy());
```

#### count 查询

进行 count 查询，返回查询语句的计数。

jdk6、7 用法：
```java
long total = PageHelper.count(new ISelect() {
    @Override
    public void doSelect() {
        userMapper.selectLike(user);
    }
});
```

jdk8 lambda 用法：
```java
long total = PageHelper.count(() -> userMapper.selectLike(user));
```
## 40.4 PageHelper是如何实现分页的？
> 我们知道如何使用PageHelper后，我们发现使用PageHelper.startPage(pageNum, pageSize, orderBy)方法后的第一个select是具备分页能力的，那它是如何做到的呢？

理解它的原理，有两个点：
1. 第一，相对对于JDBC这种嵌入式的分页而言，PageHelper分页是独立的，能做到独立分页查询，那`它必然是通过某个拦截点进行了拦截，这样它才能够进行解耦分离出分页`。
2. 第二，我们通过PageHelper.startPage(pageNum, pageSize, orderBy)方法后的第一个select是具备分页能力的，那它必然缓存了分页信息，同时结合线程知识，`这里必然使用的是本地栈ThreadLocal，即每个线程有一个本地缓存`。

所以结合这两点，聪明的你就会想到它大概是如何实现的，关键就是两点（拦截，ThreadLocal), 我们看下源码：

简单看下拦截
```java
/**
 * Mybatis拦截器方法
 *
 * @param invocation 拦截器入参
 * @return 返回执行结果
 * @throws Throwable 抛出异常
 */
public Object intercept(Invocation invocation) throws Throwable {
    if (autoRuntimeDialect) {
        SqlUtil sqlUtil = getSqlUtil(invocation);
        return sqlUtil.processPage(invocation);
    } else {
        if (autoDialect) {
            initSqlUtil(invocation);
        }
        return sqlUtil.processPage(invocation);
    }
}
```
进而看下sqlUtil.processPage(invocation);方法
```java
/**
 *
 * @param invocation 拦截器入参
 * @return 返回执行结果
 * @throws Throwable 抛出异常
 */
private Object _processPage(Invocation invocation) throws Throwable {
    final Object[] args = invocation.getArgs();
    Page page = null;
    //支持方法参数时，会先尝试获取Page
    if (supportMethodsArguments) {
        // 从线程本地变量中获取Page信息，就是我们刚刚设置的
        page = getPage(args);
    }
    //分页信息
    RowBounds rowBounds = (RowBounds) args[2];
    //支持方法参数时，如果page == null就说明没有分页条件，不需要分页查询
    if ((supportMethodsArguments && page == null)
            //当不支持分页参数时，判断LocalPage和RowBounds判断是否需要分页
            || (!supportMethodsArguments && SqlUtil.getLocalPage() == null && rowBounds == RowBounds.DEFAULT)) {
        return invocation.proceed();
    } else {
        //不支持分页参数时，page==null，这里需要获取
        if (!supportMethodsArguments && page == null) {
            page = getPage(args);
        }
        // 进入查看
        return doProcessPage(invocation, page, args);
    }
}
```
所以startPage方法和这里的getPage(args);这方法里应该包含了ThreadLocal中设置和获取分页参数的，让我们看下startPage方法即可：
```java
public static <E> Page<E> startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) {
    Page<E> page = new Page(pageNum, pageSize, count);
    page.setReasonable(reasonable);
    page.setPageSizeZero(pageSizeZero);
    Page<E> oldPage = getLocalPage();
    if (oldPage != null && oldPage.isOrderByOnly()) {
        page.setOrderBy(oldPage.getOrderBy());
    }

    setLocalPage(page);
    return page;
}
// ...
protected static final ThreadLocal<Page> LOCAL_PAGE = new ThreadLocal();

protected static void setLocalPage(Page page) {
    LOCAL_PAGE.set(page); // 看这里
}

// ...
```
> 所以这里提示下想进阶的开发者，源码的阅读是伴随着思路现行的（有了思路，简单看源码），而不是直接源码。
## 40.5 使用PageHelper有何注意点
<a href ='https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/Important.md'>官网说明</a>

1. `PageHelper.startPage`方法重要提示

只有紧跟在`PageHelper.startPage`方法后的<b>第一个</b>Mybatis的<b>查询（Select）</b>方法会被分页。

2. 请不要配置多个分页插件

请不要在系统中配置多个分页插件(使用Spring时,`mybatis-config.xml`和`Spring<bean>`配置方式，请选择其中一种，不要同时配置多个分页插件)！

3. 分页插件不支持带有`for update`语句的分页

对于带有`for update`的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。

4. 分页插件不支持嵌套结果映射

由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。
## 40.6 PageHelper的配置方式
### 40.6.1. Maven 依赖配置
- 传统spring/非spring项目
```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.3.2</version>
</dependency>
```
- springboot专属推荐
```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.2</version>
</dependency>
```

### 40.6.2. Spring Boot 配置（推荐）

在 `application.yml` 或 `application.properties` 中配置：

### YAML 配置方式
```yaml
# application.yml
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql
  auto-runtime-dialect: true
```

### Properties 配置方式
```properties
# application.properties
pagehelper.helper-dialect=mysql
pagehelper.reasonable=true
pagehelper.support-methods-arguments=true
pagehelper.params=count=countSql
pagehelper.auto-runtime-dialect=true
```

### 40.6.3. 传统 Spring 配置

### XML 配置方式
```xml
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="plugins">
        <array>
            <bean class="com.github.pagehelper.PageInterceptor">
                <property name="properties">
                    <props>
                        <prop key="helperDialect">mysql</prop>
                        <prop key="reasonable">true</prop>
                        <prop key="supportMethodsArguments">true</prop>
                        <prop key="params">count=countSql</prop>
                    </props>
                </property>
            </bean>
        </array>
    </property>
</bean>
```

### Java Config 配置方式
```java
@Configuration
public class MyBatisConfig {
    
    @Bean
    public PageInterceptor pageInterceptor() {
        PageInterceptor pageInterceptor = new PageInterceptor();
        Properties properties = new Properties();
        properties.setProperty("helperDialect", "mysql");
        properties.setProperty("reasonable", "true");
        properties.setProperty("supportMethodsArguments", "true");
        properties.setProperty("params", "count=countSql");
        pageInterceptor.setProperties(properties);
        return pageInterceptor;
    }
}
```

### 40.6.4. MyBatis 原生配置

在 `mybatis-config.xml` 中配置：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" 
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
            <property name="helperDialect" value="mysql"/>
            <property name="reasonable" value="true"/>
            <property name="supportMethodsArguments" value="true"/>
            <property name="params" value="count=countSql"/>
        </plugin>
    </plugins>
</configuration>
```

### 40.6.5. 主要配置参数说明

| 参数名 | 默认值 | 说明 |
|--------|--------|------|
| `helperDialect` | - | **必须配置**，数据库方言：mysql, oracle, db2, postgresql, sqlserver 等 |
| `reasonable` | false | 分页合理化参数，当 pageNum < 1 时查询第一页，pageNum > pages 时查询最后一页 |
| `supportMethodsArguments` | false | 支持通过 Mapper 接口参数来传递分页参数 |
| `params` | - | 用于从对象中根据属性名取值，可配置 pageNum, pageSize, count 等 |
| `autoRuntimeDialect` | false | 多数据源时自动获取对应数据库方言 |
| `autoDialect` | true | 自动获取数据库方言 |
| `closeConn` | true | 当使用运行时动态数据源时，自动关闭连接 |

### 40.6.6. 完整配置示例

```yaml
# 完整的 PageHelper 配置示例
pagehelper:
  # 数据库方言（必须）
  helper-dialect: mysql
  # 分页合理化
  reasonable: true
  # 支持方法参数
  support-methods-arguments: true
  # 参数映射
  params: count=countSql
  # 多数据源自动检测
  auto-runtime-dialect: true
  # 默认分页参数
  page-size-zero: true
  # 溢出总页数后处理
  reasonable: true
  # 默认页码参数名
  offset-as-page-num: false
  # RowBounds参数模式
  row-bounds-with-count: false
```

### 40.6.7. 注意事项

1. **必须配置数据库方言**：`helperDialect` 参数是必须的
2. **调用顺序**：`PageHelper.startPage()` 必须在执行查询**之前**调用
3. **线程安全**：PageHelper 使用了 ThreadLocal，所以是线程安全的
4. **仅对第一个查询有效**：`startPage` 后执行的第一个 MyBatis 查询方法会被分页

### 40.6.8. 验证配置是否成功

```java
@SpringBootTest
class PageHelperTest {
    
    @Autowired
    private UserMapper userMapper;
    
    @Test
    void testPageHelper() {
        // 第1页，每页10条
        PageHelper.startPage(1, 10);
        List<User> users = userMapper.selectAll();
        
        // 使用PageInfo包装结果
        PageInfo<User> pageInfo = new PageInfo<>(users);
        
        System.out.println("总记录数: " + pageInfo.getTotal());
        System.out.println("总页数: " + pageInfo.getPages());
        System.out.println("当前页: " + pageInfo.getPageNum());
        System.out.println("每页大小: " + pageInfo.getPageSize());
    }
}
```
# 四十一、SpringBoot集成MySQL - MyBatis 多个数据源
> 前文介绍的SpringBoot集成单个MySQL数据库的情形，那么什么场景会使用多个数据源以及什么场景会需要多个数据源的动态切换呢？本文主要介绍上述场景及SpringBoot+MyBatis实现多个数据源的方案和示例。

## 41.1 知识准备
### 41.1.1 什么场景会出现多个数据源？
> 一般而言有如下几种出现多数据源的场景。
- 场景一：不同的业务涉及的表位于不同的数据库

随着业务的拓展，模块解耦，服务化的拆分等，不同的业务涉及的表会放在不同的数据库中。
- 场景二：主库和从库分离（读写分离）
- 场景三：数据库的分片
- 场景四：多租户隔离

所有数据库表结构一致，只是不同客户的数据放在不同数据库中，通过数据库名对不同客户的数据隔离。这种场景有一个典型的叫法：多租户。

(PS：除了这种多租户除了用不同的数据库隔离不同客户数据外，还会通过额外的表字段隔离（比如tenant_id字段，不同的tenant_id表示不同的客户）)
### 41.1.2 常见的多数据源的实现思路？
> 应对上述出现的场景，多数据源方式如何实现呢？
- 针对场景一：不同的业务涉及的表位于不同的数据库
  - 首先，出现这种场景且在一个模块中设计多数据源时，需要考虑当前架构的合理性，因为从设计的角度而言不同的业务拆分需要对应着不同的服务/模块。
  - 其次，我们会考虑不同的package去隔离，不同的数据源放在不同的包下的代码中。
- 针对场景二：主库和从库分离（读写分离）
  - 这种场景下我们叫动态数据源，通常方式使用AOP方式拦截+ThreadLocal切换。（本文的示例主要针对这种场景）

## 41.2 SpringBoot + MyBatis 多数据源集成方案

针对你提到的两种场景，我将分别给出完整的集成方案。每个方案都包含完整的代码示例和配置。

### 41.2.1 场景一：基于包隔离的多数据源（不同业务不同数据库）

这种方案适用于不同的业务模块使用不同的数据库，通过包路径来隔离不同的数据源。

#### 41.2.1.1. 项目结构和依赖

##### Maven 依赖 (pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.3.1</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

##### 项目结构
```
src/main/java/com/example/multids/
├── config/
│   ├── PrimaryDataSourceConfig.java
│   └── SecondaryDataSourceConfig.java
├── primary/
│   ├── entity/User.java
│   ├── mapper/UserMapper.java
│   └── service/UserService.java
├── secondary/
│   ├── entity/Product.java
│   ├── mapper/ProductMapper.java
│   └── service/ProductService.java
└── MultiDsApplication.java
```

#### 41.2.1.2. 配置文件 (application.yml)
```yaml
spring:
  datasource:
    primary:
      jdbc-url: jdbc:mysql://localhost:3306/db_primary?useSSL=false&serverTimezone=UTC
      username: root
      password: 123456
      driver-class-name: com.mysql.cj.jdbc.Driver
    secondary:
      jdbc-url: jdbc:mysql://localhost:3306/db_secondary?useSSL=false&serverTimezone=UTC
      username: root
      password: 123456
      driver-class-name: com.mysql.cj.jdbc.Driver

# MyBatis配置
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.example.multids.**.entity
```

#### 41.2.1.3. 数据源配置类

##### 主数据源配置
```java
package com.example.multids.config;

import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@MapperScan(
    basePackages = "com.example.multids.primary.mapper",
    sqlSessionFactoryRef = "primarySqlSessionFactory"
)
public class PrimaryDataSourceConfig {

    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public SqlSessionFactory primarySqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(primaryDataSource());
        sessionFactory.setMapperLocations(
            new PathMatchingResourcePatternResolver()
                .getResources("classpath:mapper/primary/*.xml")
        );
        return sessionFactory.getObject();
    }
}
```

##### 从数据源配置
```java
package com.example.multids.config;

import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@MapperScan(
    basePackages = "com.example.multids.secondary.mapper",
    sqlSessionFactoryRef = "secondarySqlSessionFactory"
)
public class SecondaryDataSourceConfig {

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public SqlSessionFactory secondarySqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(secondaryDataSource());
        sessionFactory.setMapperLocations(
            new PathMatchingResourcePatternResolver()
                .getResources("classpath:mapper/secondary/*.xml")
        );
        return sessionFactory.getObject();
    }
}
```

#### 41.2.1.4. 实体类和Mapper

##### 主数据源相关
```java
// User.java
package com.example.multids.primary.entity;

public class User {
    private Long id;
    private String name;
    private String email;
    // getter/setter省略
}

// UserMapper.java
package com.example.multids.primary.mapper;

import com.example.multids.primary.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.util.List;

@Mapper
public interface UserMapper {
    @Select("SELECT * FROM user")
    List<User> findAll();
    
    @Select("SELECT * FROM user WHERE id = #{id}")
    User findById(Long id);
}

// UserService.java
package com.example.multids.primary.service;

import com.example.multids.primary.entity.User;
import com.example.multids.primary.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    public List<User> getAllUsers() {
        return userMapper.findAll();
    }
    
    public User getUserById(Long id) {
        return userMapper.findById(id);
    }
}
```

##### 从数据源相关
```java
// Product.java
package com.example.multids.secondary.entity;

public class Product {
    private Long id;
    private String name;
    private Double price;
    // getter/setter省略
}

// ProductMapper.java
package com.example.multids.secondary.mapper;

import com.example.multids.secondary.entity.Product;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.util.List;

@Mapper
public interface ProductMapper {
    @Select("SELECT * FROM product")
    List<Product> findAll();
    
    @Select("SELECT * FROM product WHERE id = #{id}")
    Product findById(Long id);
}

// ProductService.java
package com.example.multids.secondary.service;

import com.example.multids.secondary.entity.Product;
import com.example.multids.secondary.mapper.ProductMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class ProductService {
    
    @Autowired
    private ProductMapper productMapper;
    
    public List<Product> getAllProducts() {
        return productMapper.findAll();
    }
    
    public Product getProductById(Long id) {
        return productMapper.findById(id);
    }
}
```

#### 41.2.1.5. 控制器测试
```java
package com.example.multids.controller;

import com.example.multids.primary.entity.User;
import com.example.multids.primary.service.UserService;
import com.example.multids.secondary.entity.Product;
import com.example.multids.secondary.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController
public class TestController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private ProductService productService;
    
    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
    
    @GetMapping("/products")
    public List<Product> getProducts() {
        return productService.getAllProducts();
    }
}
```

### 41.2.2 场景二：动态数据源切换（读写分离）

这种方案适用于主从数据库分离的场景，通过AOP动态切换数据源。

#### 41.2.2.1. 项目结构和依赖

##### Maven 依赖 (pom.xml) - 额外添加AOP依赖
```xml
<dependencies>
    <!-- 其他依赖同上 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
</dependencies>
```

##### 项目结构
```
src/main/java/com/example/dynamicds/
├── config/
│   ├── DataSourceConfig.java
│   ├── DynamicDataSource.java
│   └── DataSourceAspect.java
├── annotation/
│   └── DataSource.java
├── entity/User.java
├── mapper/UserMapper.java
├── service/UserService.java
└── DynamicDsApplication.java
```

#### 41.2.2.2. 配置文件 (application.yml)
```yaml
spring:
  datasource:
    master:
      jdbc-url: jdbc:mysql://localhost:3306/db_master?useSSL=false&serverTimezone=UTC
      username: root
      password: 123456
      driver-class-name: com.mysql.cj.jdbc.Driver
    slave:
      jdbc-url: jdbc:mysql://localhost:3306/db_slave?useSSL=false&serverTimezone=UTC
      username: root
      password: 123456
      driver-class-name: com.mysql.cj.jdbc.Driver

# MyBatis配置
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.example.dynamicds.entity
```

#### 41.2.2.3. 数据源注解和上下文

##### 数据源注解
```java
package com.example.dynamicds.annotation;

import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataSource {
    String value() default "master"; // 默认主库
}
```

##### 数据源上下文（ThreadLocal）
```java
package com.example.dynamicds.config;

public class DataSourceContextHolder {
    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();
    
    public static void setDataSource(String dataSource) {
        CONTEXT_HOLDER.set(dataSource);
    }
    
    public static String getDataSource() {
        return CONTEXT_HOLDER.get();
    }
    
    public static void clearDataSource() {
        CONTEXT_HOLDER.remove();
    }
}
```

##### 41.2.2.4. 动态数据源配置

##### 动态数据源类
```java
package com.example.dynamicds.config;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import javax.sql.DataSource;
import java.util.Map;

public class DynamicDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSource();
    }
    
    // 设置默认数据源
    public void setDefaultDataSource(Object defaultDataSource) {
        super.setDefaultTargetDataSource(defaultDataSource);
    }
    
    // 设置目标数据源
    public void setTargetDataSources(Map<Object, Object> targetDataSources) {
        super.setTargetDataSources(targetDataSources);
    }
}
```

##### 数据源配置类
```java
package com.example.dynamicds.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DataSource dynamicDataSource() {
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        
        // 配置多数据源
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put("master", masterDataSource());
        dataSourceMap.put("slave", slaveDataSource());
        
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());
        
        return dynamicDataSource;
    }
}
```

##### 41.2.2.5. AOP切面配置

```java
package com.example.dynamicds.config;

import com.example.dynamicds.annotation.DataSource;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Aspect
@Component
public class DataSourceAspect {

    @Around("@annotation(com.example.dynamicds.annotation.DataSource)")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        
        DataSource dataSource = method.getAnnotation(DataSource.class);
        if (dataSource != null) {
            DataSourceContextHolder.setDataSource(dataSource.value());
        }
        
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clearDataSource();
        }
    }
}
```

#### 41.2.2.6. MyBatis配置

```java
package com.example.dynamicds.config;

import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@MapperScan("com.example.dynamicds.mapper")
public class MyBatisConfig {

    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(
            new PathMatchingResourcePatternResolver()
                .getResources("classpath:mapper/*.xml")
        );
        return sessionFactory.getObject();
    }
}
```

#### 41.2.2.7. 业务代码示例

```java
// User.java
package com.example.dynamicds.entity;

public class User {
    private Long id;
    private String name;
    private String email;
    // getter/setter省略
}

// UserMapper.java
package com.example.dynamicds.mapper;

import com.example.dynamicds.entity.User;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface UserMapper {
    
    @Select("SELECT * FROM user WHERE id = #{id}")
    User findById(Long id);
    
    @Select("SELECT * FROM user")
    List<User> findAll();
    
    @Insert("INSERT INTO user(name, email) VALUES(#{name}, #{email})")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int insert(User user);
    
    @Update("UPDATE user SET name=#{name}, email=#{email} WHERE id=#{id}")
    int update(User user);
    
    @Delete("DELETE FROM user WHERE id=#{id}")
    int delete(Long id);
}

// UserService.java
package com.example.dynamicds.service;

import com.example.dynamicds.annotation.DataSource;
import com.example.dynamicds.entity.User;
import com.example.dynamicds.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    // 读操作使用从库
    @DataSource("slave")
    public User getUserById(Long id) {
        return userMapper.findById(id);
    }
    
    // 读操作使用从库
    @DataSource("slave")
    public List<User> getAllUsers() {
        return userMapper.findAll();
    }
    
    // 写操作使用主库
    @DataSource("master")
    @Transactional
    public void addUser(User user) {
        userMapper.insert(user);
    }
    
    // 写操作使用主库
    @DataSource("master")
    @Transactional
    public void updateUser(User user) {
        userMapper.update(user);
    }
    
    // 写操作使用主库
    @DataSource("master")
    @Transactional
    public void deleteUser(Long id) {
        userMapper.delete(id);
    }
}
```

#### 41.2.2.8. 控制器测试
```java
package com.example.dynamicds.controller;

import com.example.dynamicds.entity.User;
import com.example.dynamicds.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
    
    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
    
    @PostMapping
    public String addUser(@RequestBody User user) {
        userService.addUser(user);
        return "success";
    }
    
    @PutMapping
    public String updateUser(@RequestBody User user) {
        userService.updateUser(user);
        return "success";
    }
    
    @DeleteMapping("/{id}")
    public String deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return "success";
    }
}
```

### 41.2.3 方案总结

#### 场景一方案（包隔离）特点：
- **优点**：结构清晰，不同数据源的代码完全隔离，易于维护
- **缺点**：不支持动态切换，每个Mapper固定绑定一个数据源
- **适用场景**：业务模块明确分离，不同模块使用不同数据库

#### 场景二方案（动态切换）特点：
- **优点**：灵活性强，支持运行时动态切换数据源
- **缺点**：配置相对复杂，需要处理线程安全和事务问题
- **适用场景**：读写分离、多租户等需要动态切换数据源的场景
## 41.3 进一步讲解多数据源切换
- SpringBoot + MyBatis 多数据源实现原理详解

### 两种方案的实现原理对比

#### 方案一：基于包隔离的多数据源（静态绑定）

##### 核心原理：**编译时绑定**
- 在应用启动时，通过不同的配置类为不同的包路径创建独立的`SqlSessionFactory`
- 每个Mapper接口在编译时就确定了使用哪个数据源
- **本质是创建了多个独立的MyBatis会话工厂**

##### 涉及的核心概念：

1. **@ConfigurationProperties**

`@ConfigurationProperties(prefix = "spring.datasource.slave")`这个注解的作用是将配置文件中的属性值自动绑定到Java Bean的属性上。
   ```java
   @ConfigurationProperties(prefix = "spring.datasource.primary")
   public DataSource primaryDataSource() {
       return DataSourceBuilder.create().build();
   }
   ```
   - **作用**：将配置文件中的属性映射到DataSource对象
   - **原理**：Spring Boot的属性绑定机制

2. **@MapperScan**
   ```java
   @MapperScan(
       basePackages = "com.example.multids.primary.mapper",
       sqlSessionFactoryRef = "primarySqlSessionFactory"
   )
   ```
   - **作用**：指定特定包下的Mapper使用特定的SqlSessionFactory
   - **原理**：MyBatis-Spring的扫描注册机制

3. **SqlSessionFactoryBean**
   ```java
   SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
   sessionFactory.setDataSource(primaryDataSource());
   ```
   - **作用**：创建MyBatis的会话工厂
   - **原理**：每个SqlSessionFactory绑定一个特定的DataSource

##### 工作流程：
```
应用启动 → 创建多个DataSource Bean → 为每个DataSource创建SqlSessionFactory → 
Mapper扫描注册 → 不同包的Mapper绑定到不同的SqlSessionFactory → 
业务调用时直接使用绑定的数据源
```

#### 方案二：动态数据源切换（运行时切换）

##### 核心原理：**运行时动态路由**
- 创建一个**路由数据源**，在每次数据库操作时动态决定使用哪个具体数据源
- 通过AOP在方法执行前设置数据源标识，方法执行后清理
- **本质是数据源的路由和代理模式**

##### 涉及的核心概念：

1. **AbstractRoutingDataSource（核心类）**
   ```java
   public class DynamicDataSource extends AbstractRoutingDataSource {
       protected Object determineCurrentLookupKey() {
           return DataSourceContextHolder.getDataSource();
       }
   }
   ```
   - **作用**：Spring提供的抽象路由数据源，根据key动态选择数据源
   - **原理**：模板方法模式，在每次获取连接时调用`determineCurrentLookupKey()`

2. **ThreadLocal（线程隔离）**
   ```java
   public class DataSourceContextHolder {
       private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();
   }
   ```
   - **作用**：在每个线程中独立存储数据源标识
   - **原理**：线程本地存储，确保多线程环境下的数据隔离

3. **AOP切面编程**
   ```java
   @Around("@annotation(com.example.dynamicds.annotation.DataSource)")
   public Object around(ProceedingJoinPoint point) throws Throwable {
       // 方法执行前设置数据源
       // 方法执行后清理数据源
   }
   ```
   - **作用**：拦截方法调用，在方法执行前后处理数据源切换逻辑
   - **原理**：动态代理和环绕通知

##### 工作流程：
```
方法调用 → AOP拦截 → 读取@DataSource注解 → 设置ThreadLocal数据源标识 → 
AbstractRoutingDataSource.determineCurrentLookupKey()获取标识 → 
路由到具体数据源 → 执行数据库操作 → 清理ThreadLocal标识
```

### 关键逻辑概念详解

#### 1. 数据源路由机制（方案二的核心）

```java
// Spring框架的AbstractRoutingDataSource源码逻辑
public abstract class AbstractRoutingDataSource extends AbstractDataSource {
    
    private Map<Object, Object> targetDataSources;  // 存储所有数据源的映射
    private Object defaultTargetDataSource;         // 默认数据源
    
    public Connection getConnection() throws SQLException {
        return determineTargetDataSource().getConnection();
    }
    
    protected DataSource determineTargetDataSource() {
        Object lookupKey = determineCurrentLookupKey();  // 获取路由key
        DataSource dataSource = this.targetDataSources.get(lookupKey);
        if (dataSource == null) {
            dataSource = this.defaultTargetDataSource;   // 使用默认数据源
        }
        return dataSource;
    }
    
    protected abstract Object determineCurrentLookupKey();  // 抽象方法，由子类实现
}
```

#### 2. ThreadLocal的工作原理

```java
// ThreadLocal的简化实现逻辑
public class ThreadLocal<T> {
    // 每个线程都有自己的ThreadLocalMap
    public void set(T value) {
        Thread currentThread = Thread.currentThread();
        ThreadLocalMap map = getMap(currentThread);
        map.set(this, value);  // 以ThreadLocal实例为key存储值
    }
    
    public T get() {
        Thread currentThread = Thread.currentThread();
        ThreadLocalMap map = getMap(currentThread);
        return map.get(this);  // 从当前线程的map中获取值
    }
}
```

#### 3. AOP拦截的执行时序

```
1. 方法调用开始
2. AOP切面拦截方法执行
3. 读取方法上的@DataSource注解值
4. DataSourceContextHolder.setDataSource("slave")
5. 执行目标方法
6. MyBatis获取数据库连接时调用determineCurrentLookupKey()
7. 返回"slave"，路由到从库数据源
8. 执行SQL操作
9. AOP切面清理：DataSourceContextHolder.clearDataSource()
10. 方法执行结束
```

### 两种方案的适用场景深度分析

#### 方案一（包隔离）的适用场景：

**架构特点**：
- 业务模块边界清晰
- 数据访问模式固定
- 不需要跨数据源的事务

**技术实现优势**：
- 编译期就能发现配置错误
- 性能更好（没有运行时路由开销）
- 调试更容易（数据源关系明确）

#### 方案二（动态切换）的适用场景：

**架构特点**：
- 需要根据业务逻辑动态选择数据源
- 读写分离场景
- 多租户数据隔离
- A/B测试数据路由

**技术实现挑战**：
- **事务管理复杂**：在事务中切换数据源可能不生效
- **连接泄漏风险**：必须确保ThreadLocal的清理
- **性能开销**：每次数据库操作都需要路由判断

### 重要注意事项

#### 1. 事务管理的问题（方案二）
```java
@Service
public class UserService {
    
    @DataSource("slave")  // 这个注解在事务中可能不生效！
    @Transactional
    public User getUserWithTransaction(Long id) {
        // 因为@Transactional会先于@DataSource执行
        // 数据源在事务开始时已经确定，后续切换无效
        return userMapper.findById(id);
    }
}
```

**解决方案**：
- 使用`TransactionSynchronizationManager`判断当前是否有事务
- 在事务环境下使用主数据源
- 或者使用更复杂的事务管理器

#### 2. 连接池管理
两种方案都需要注意连接池配置：
```yaml
spring:
  datasource:
    master:
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5
    slave:
      hikari:
        maximum-pool-size: 15
        minimum-idle: 3
```

#### 3. 健康检查（方案二）
动态数据源需要自定义健康检查：
```java
@Component
public class DynamicDataSourceHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DynamicDataSource dynamicDataSource;
    
    @Override
    public Health health() {
        // 检查所有数据源的健康状态
        // 返回组合的健康信息
    }
}
```

### 总结

**方案一（包隔离）**：通过**编译时绑定**实现数据源隔离，适合业务模块明确分离的场景。

**方案二（动态切换）**：通过**运行时路由**实现数据源切换，适合需要灵活切换的场景。

**选择建议**：
- 如果业务模块边界清晰，优先选择方案一（更简单稳定）
- 如果需要读写分离或多租户，选择方案二（更灵活）
- 在方案二中要特别注意事务和线程安全的问题

两种方案都体现了Spring框架的扩展性和MyBatis的灵活性，理解其底层原理有助于在实际项目中做出更好的架构决策。
# 四十二、SpringBoot集成MySQL - MyBatis-Plus方式
> MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。MyBatis-Plus在国内也有很多的用户，本文主要介绍MyBatis-Plus和SpringBoot的集成。
## 42.1 知识准备
> MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。

### 42.1.1 为什么会诞生MyBatis-Plus？
1. **考虑到MyBatis是半自动化OR**M，MyBatis-Plus 启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作; 并且内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求；总体上让其支持全自动化的使用方式（本质上借鉴了Hibernate思路）。
2. **考虑到Java8 Lambda（函数式编程）开始流行**，MyBatis-Plus支持 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错
3. **考虑到MyBatis还需要独立引入PageHelper分页插件**，MyBatis-Plus支持了内置分页插件，同PageHelper一样基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询
4. **考虑到自动化代码生成方式**，MyBatis-Plus也支持了内置代码生成器，采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用
5. **考虑到SQL性能优化等问题**，MyBatis-Plus内置性能分析插件, 可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询
6. 其它还有解决一些常见开发问题，比如**支持主键自动生成**，支持4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题；以及**内置全局拦截插件**，提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作
### 42.1.2 支持数据库
任何能使用 MyBatis 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下：
- MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb
- 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库
### 42.1.3 整体架构
![167.springboot-mybatis-plus-1.jpeg](../../assets/images/04-主流框架/spring/167.springboot-mybatis-plus-1.jpeg)
## 42.2 简单示例
### 42.2.1 数据库准备

创建MySQL数据库`test_db`，并导入以下SQL文件：

```sql
-- MySQL dump 10.13  Distrib 5.7.12, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int(11) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user_role` (
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1,1);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-09-08 17:12:11
```

### 42.2.2 依赖配置

在`pom.xml`中引入以下Maven依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.1</version>
</dependency>
```

### 42.2.3 应用配置

在`application.yml`中配置数据源和MyBatis-Plus：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf

mybatis-plus:
  configuration:
    cache-enabled: true
    use-generated-keys: true
    default-executor-type: REUSE
    use-actual-param-name: true
```

### 42.2.4 DAO层定义

#### 42.2.4.1 RoleDao

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.dao;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.Role;

/**
 * @author pdai
 */
public interface IRoleDao extends BaseMapper<Role> {
}
```

#### 42.2.4.2 UserDao

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.dao;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;

import java.util.List;

/**
 * @author pdai
 */
public interface IUserDao extends BaseMapper<User> {

    List<User> findList(UserQueryBean userQueryBean);
}
```

#### 42.2.4.3 UserDao XML映射配置

`IUserDao.xml`（支持自定义SQL和关联查询）：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="tech.pdai.springboot.mysql8.mybatisplus.anno.dao.IUserDao">

	<resultMap type="tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User" id="UserResult">
		<id     property="id"       	column="id"      		/>
		<result property="userName"     column="user_name"    	/>
		<result property="password"     column="password"    	/>
		<result property="email"        column="email"        	/>
		<result property="phoneNumber"  column="phone_number"  	/>
		<result property="description"  column="description"  	/>
		<result property="createTime"   column="create_time"  	/>
		<result property="updateTime"   column="update_time"  	/>
		<collection property="roles" ofType="tech.pdai.springboot.mysql8.mybatisplus.anno.entity.Role">
			<result property="id" column="id"  />
			<result property="name" column="name"  />
			<result property="roleKey" column="role_key"  />
			<result property="description" column="description"  />
			<result property="createTime"   column="create_time"  	/>
			<result property="updateTime"   column="update_time"  	/>
		</collection>
	</resultMap>
	
	<sql id="selectUserSql">
        select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time, r.name, r.role_key, r.description, r.create_time, r.update_time
		from tb_user u
		left join tb_user_role ur on u.id=ur.user_id
		inner join tb_role r on ur.role_id=r.id
    </sql>
	
	<select id="findList" parameterType="tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean" resultMap="UserResult">
		<include refid="selectUserSql"/>
		where u.id != 0
		<if test="userName != null and userName != ''">
			AND u.user_name like concat('%', #{user_name}, '%')
		</if>
		<if test="description != null and description != ''">
			AND u.description like concat('%', #{description}, '%')
		</if>
		<if test="phoneNumber != null and phoneNumber != ''">
			AND u.phone_number like concat('%', #{phoneNumber}, '%')
		</if>
		<if test="email != null and email != ''">
			AND u.email like concat('%', #{email}, '%')
		</if>
	</select>
	
</mapper> 
```

### 42.2.5 Service层实现

#### 42.2.5.1 UserService接口

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.service;

import com.baomidou.mybatisplus.extension.service.IService;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;

import java.util.List;

/**
 * @author pdai
 */
public interface IUserService extends IService<User> {

    List<User> findList(UserQueryBean userQueryBean);

}
```

#### 42.2.5.2 UserService实现类

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql8.mybatisplus.anno.dao.IUserDao;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IUserService;

import java.util.List;

@Service
public class UserDoServiceImpl extends ServiceImpl<IUserDao, User> implements IUserService {

    @Override
    public List<User> findList(UserQueryBean userQueryBean) {
        return baseMapper.findList(userQueryBean);
    }
}
```

#### 42.2.5.3 RoleService接口

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.service;

import com.baomidou.mybatisplus.extension.service.IService;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.Role;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.RoleQueryBean;

import java.util.List;

public interface IRoleService extends IService<Role> {

    List<Role> findList(RoleQueryBean roleQueryBean);

}
```

#### 42.2.5.4 RoleService实现类

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql8.mybatisplus.anno.dao.IRoleDao;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.Role;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IRoleService;

import java.util.List;

@Service
public class RoleDoServiceImpl extends ServiceImpl<IRoleDao, Role> implements IRoleService {

    @Override
    public List<Role> findList(RoleQueryBean roleQueryBean) {
        return lambdaQuery().like(StringUtils.isNotEmpty(roleQueryBean.getName()), Role::getName, roleQueryBean.getName())
                .like(StringUtils.isNotEmpty(roleQueryBean.getDescription()), Role::getDescription, roleQueryBean.getDescription())
                .like(StringUtils.isNotEmpty(roleQueryBean.getRoleKey()), Role::getRoleKey, roleQueryBean.getRoleKey())
                .list();
    }
}
```

### 42.2.6 Controller层

#### 42.2.6.1 UserController

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.controller;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.response.ResponseResult;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IUserService;

import java.time.LocalDateTime;
import java.util.List;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId() == null) {
            user.setCreateTime(LocalDateTime.now());
        }
        user.setUpdateTime(LocalDateTime.now());
        userService.save(user);
        return ResponseResult.success(userService.getById(user.getId()));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.getById(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User List")
    @GetMapping("list")
    public ResponseResult<List<User>> list(UserQueryBean userQueryBean) {
        return ResponseResult.success(userService.findList(userQueryBean));
    }
}
```

#### 42.2.6.2 RoleController

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.controller;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.Role;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.response.ResponseResult;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IRoleService;

import java.util.List;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/role")
public class RoleController {

    @Autowired
    private IRoleService roleService;

    /**
     * @return role list
     */
    @ApiOperation("Query Role List")
    @GetMapping("list")
    public ResponseResult<List<Role>> list(RoleQueryBean roleQueryBean) {
        return ResponseResult.success(roleService.findList(roleQueryBean));
    }
}
```

### 42.2.7 分页配置

通过配置`MyBatisPlusInterceptor`拦截器实现分页功能：

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.config;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * MyBatis-plus configuration, add pagination interceptor.
 *
 * @author pdai
 */
@Configuration
public class MyBatisConfig {

    /**
     * inject pagination interceptor.
     *
     * @return pagination
     */
    @Bean
    public PaginationInnerInterceptor paginationInnerInterceptor() {
        return new PaginationInnerInterceptor();
    }

    /**
     * add pagination interceptor.
     *
     * @return MybatisPlusInterceptor
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```
## 42.3 进一步理解
### 42.3.1 MyBatis-plus学习梳理
- <a href='https://baomidou.com/'>官方文档</a>
- <a href='https://github.com/baomidou/mybatis-plus-samples'>官方案例</a>
- <a href='https://github.com/baomidou/mybatis-plus'>官方源码仓库</a>
- <a href='https://github.com/baomidou/awesome-mybatis-plus'>Awesome Mybatis-Plus</a>
### 42.3.2 比较好的实践
1. Mapper层：继承BaseMapper
```java
public interface IRoleDao extends BaseMapper<Role> {
}
```
2. Service层：继承ServiceImpl并实现对应接口
```java
public interface IRoleService extends IService<Role> {

    List<Role> findList(RoleQueryBean roleQueryBean);

}
```
```java
public class RoleDoServiceImpl extends ServiceImpl<IRoleDao, Role> implements IRoleService {

}
```
3. Lambda函数式查询
```java
@Override
public List<Role> findList(RoleQueryBean roleQueryBean) {
    return lambdaQuery().like(StringUtils.isNotEmpty(roleQueryBean.getName()), Role::getName, roleQueryBean.getName())
            .like(StringUtils.isNotEmpty(roleQueryBean.getDescription()), Role::getDescription, roleQueryBean.getDescription())
            .like(StringUtils.isNotEmpty(roleQueryBean.getRoleKey()), Role::getRoleKey, roleQueryBean.getRoleKey())
            .list();
}
```
4. 分页采用内置MybatisPlusInterceptor
```java
/**
  * inject pagination interceptor.
  *
  * @return pagination
  */
@Bean
public PaginationInnerInterceptor paginationInnerInterceptor() {
    return new PaginationInnerInterceptor();
}

/**
  * add pagination interceptor.
  *
  * @return MybatisPlusInterceptor
  */
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
    mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor());
    return mybatisPlusInterceptor;
}
```
5. 对于复杂的关联查询

可以配置原生xml方式, 在其中自定义ResultMap
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="tech.pdai.springboot.mysql8.mybatisplus.anno.dao.IUserDao">

	<resultMap type="tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User" id="UserResult">
		<id     property="id"       	column="id"      		/>
		<result property="userName"     column="user_name"    	/>
		<result property="password"     column="password"    	/>
		<result property="email"        column="email"        	/>
		<result property="phoneNumber"  column="phone_number"  	/>
		<result property="description"  column="description"  	/>
		<result property="createTime"   column="create_time"  	/>
		<result property="updateTime"   column="update_time"  	/>
		<collection property="roles" ofType="tech.pdai.springboot.mysql8.mybatisplus.anno.entity.Role">
			<result property="id" column="id"  />
			<result property="name" column="name"  />
			<result property="roleKey" column="role_key"  />
			<result property="description" column="description"  />
			<result property="createTime"   column="create_time"  	/>
			<result property="updateTime"   column="update_time"  	/>
		</collection>
	</resultMap>
	
	<sql id="selectUserSql">
        select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time, r.name, r.role_key, r.description, r.create_time, r.update_time
		from tb_user u
		left join tb_user_role ur on u.id=ur.user_id
		inner join tb_role r on ur.role_id=r.id
    </sql>
	
	<select id="findList" parameterType="tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean" resultMap="UserResult">
		<include refid="selectUserSql"/>
		where u.id != 0
		<if test="userName != null and userName != ''">
			AND u.user_name like concat('%', #{user_name}, '%')
		</if>
		<if test="description != null and description != ''">
			AND u.description like concat('%', #{description}, '%')
		</if>
		<if test="phoneNumber != null and phoneNumber != ''">
			AND u.phone_number like concat('%', #{phoneNumber}, '%')
		</if>
		<if test="email != null and email != ''">
			AND u.email like concat('%', #{email}, '%')
		</if>
	</select>
	
</mapper> 
```
### 42.3.3 除了分页插件之外还提供了哪些插件？
插件都是基于拦截器实现的，MyBatis-Plus提供了如下<a href='https://baomidou.com/plugins/'>插件</a>：
- 自动分页: PaginationInnerInterceptor
- 多租户: TenantLineInnerInterceptor
- 动态表名: DynamicTableNameInnerInterceptor
- 乐观锁: OptimisticLockerInnerInterceptor
- sql 性能规范: IllegalSQLInnerInterceptor
- 防止全表更新与删除: BlockAttackInnerInterceptor
### 42.3.4 乐观锁: OptimisticLockerInnerInterceptor插件示例
MyBatis-Plus 乐观锁插件在 Spring Boot 中的使用

乐观锁是解决并发问题的一种机制，通过在更新数据时检查版本号来避免数据冲突。MyBatis-Plus 提供了内置的乐观锁插件支持。

#### 42.3.4.1. 数据库表结构

为表添加版本号字段：

```sql
ALTER TABLE `tb_user` ADD COLUMN `version` INT DEFAULT 0 COMMENT '版本号';
```

#### 42.3.4.2. 实体类配置

在实体类中添加版本号字段，并使用 `@Version` 注解：

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;

import java.time.LocalDateTime;

@Data
@TableName("tb_user")
public class User {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String userName;
    private String password;
    private String email;
    private Integer phoneNumber;
    private String description;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    // 乐观锁版本号字段
    @Version
    private Integer version;
    
    // 其他字段和方法...
}
```

#### 42.3.4.3. 乐观锁插件配置

创建配置类启用乐观锁插件：

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisPlusConfig {

    /**
     * 配置MyBatis-Plus插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        
        // 添加乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        
        // 添加分页插件（如果之前已配置）
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        
        return interceptor;
    }
}
```

#### 42.3.4.4. 服务层使用示例

**UserService 接口：**

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.service;

import com.baomidou.mybatisplus.extension.service.IService;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;

import java.util.List;

public interface IUserService extends IService<User> {

    List<User> findList(UserQueryBean userQueryBean);
    
    // 乐观锁更新示例方法
    boolean updateUserWithOptimisticLock(User user);
    
    // 并发测试方法
    boolean concurrentUpdateTest(Long userId);
}
```

**UserService 实现类：**

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tech.pdai.springboot.mysql8.mybatisplus.anno.dao.IUserDao;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IUserService;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl<IUserDao, User> implements IUserService {

    @Override
    public List<User> findList(UserQueryBean userQueryBean) {
        return baseMapper.findList(userQueryBean);
    }

    /**
     * 使用乐观锁更新用户信息
     */
    @Override
    public boolean updateUserWithOptimisticLock(User user) {
        // 先查询当前版本号
        User currentUser = getById(user.getId());
        if (currentUser == null) {
            throw new RuntimeException("用户不存在");
        }
        
        // 设置版本号（必须与数据库中的版本号一致）
        user.setVersion(currentUser.getVersion());
        
        // 执行更新操作
        boolean success = updateById(user);
        
        if (!success) {
            throw new RuntimeException("更新失败，可能数据已被其他线程修改");
        }
        
        return true;
    }

    /**
     * 乐观锁并发测试
     */
    @Override
    @Transactional
    public boolean concurrentUpdateTest(Long userId) {
        // 模拟并发场景：两个线程同时读取并更新同一条记录
        User user1 = getById(userId);
        User user2 = getById(userId);
        
        // 线程1更新
        user1.setEmail("thread1@example.com");
        boolean result1 = updateById(user1);
        
        // 线程2更新（此时版本号已过期，会更新失败）
        user2.setEmail("thread2@example.com");
        boolean result2 = updateById(user2);
        
        return result1 && !result2; // 预期结果：第一个成功，第二个失败
    }
}
```

#### 42.3.4.5. Controller 层示例

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno.controller;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.response.ResponseResult;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IUserService;

import java.util.List;

@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * 使用乐观锁更新用户
     */
    @ApiOperation("使用乐观锁更新用户")
    @PostMapping("update-with-lock")
    public ResponseResult<Boolean> updateWithLock(@RequestBody User user) {
        try {
            boolean result = userService.updateUserWithOptimisticLock(user);
            return ResponseResult.success(result);
        } catch (Exception e) {
            return ResponseResult.fail(e.getMessage());
        }
    }

    /**
     * 乐观锁并发测试
     */
    @ApiOperation("乐观锁并发测试")
    @GetMapping("concurrent-test/{userId}")
    public ResponseResult<Boolean> concurrentTest(@PathVariable Long userId) {
        try {
            boolean result = userService.concurrentUpdateTest(userId);
            return ResponseResult.success(result);
        } catch (Exception e) {
            return ResponseResult.fail(e.getMessage());
        }
    }
}
```

#### 42.3.4.6. 测试用例

```java
package tech.pdai.springboot.mysql8.mybatisplus.anno;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import tech.pdai.springboot.mysql8.mybatisplus.anno.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.anno.service.IUserService;

import javax.annotation.Resource;

@SpringBootTest
class OptimisticLockTest {

    @Resource
    private IUserService userService;

    @Test
    void testOptimisticLock() {
        // 1. 创建测试用户
        User user = new User();
        user.setUserName("test_user");
        user.setPassword("123456");
        userService.save(user);
        
        Long userId = user.getId();
        System.out.println("创建用户ID: " + userId);
        
        // 2. 模拟并发更新
        boolean result = userService.concurrentUpdateTest(userId);
        System.out.println("并发测试结果: " + result);
        
        // 3. 验证最终数据
        User finalUser = userService.getById(userId);
        System.out.println("最终邮箱: " + finalUser.getEmail());
        System.out.println("最终版本号: " + finalUser.getVersion());
    }
}
```

#### 42.3.4.7. 乐观锁工作原理

**更新时的SQL语句：**
```sql
UPDATE tb_user 
SET user_name = '新名称', version = version + 1 
WHERE id = 1 AND version = 1
```

**执行流程：**
1. 读取数据时获取当前版本号
2. 更新时在WHERE条件中包含版本号检查
3. 如果版本号匹配，更新成功并自动增加版本号
4. 如果版本号不匹配，更新返回影响行数为0

#### 42.3.4.8. 注意事项

1. **版本号字段必须存在**：数据库表和实体类中都必须有版本号字段
2. **支持的数据类型**：版本号字段支持 `Integer`、`Long`、`Date`、`Timestamp` 等类型
3. **新记录版本号**：新插入的记录版本号通常为0或1
4. **异常处理**：更新失败时应进行适当的异常处理
5. **重试机制**：在高并发场景下可以实现重试逻辑

```java
/**
 * 带重试机制的乐观锁更新
 */
public boolean updateWithRetry(User user, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        try {
            User currentUser = getById(user.getId());
            user.setVersion(currentUser.getVersion());
            if (updateById(user)) {
                return true;
            }
        } catch (Exception e) {
            // 记录日志，继续重试
        }
        // 短暂等待后重试
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            break;
        }
    }
    return false;
}
```

通过以上配置和使用，MyBatis-Plus 的乐观锁插件可以有效解决并发更新时的数据一致性问题。
# 四十三、SpringBoot集成MySQL - MyBatis-Plus代码自动生成
## 43.1 知识准备

### 43.1.1 为什么会产生此类代码生成工具？
由于CRUD的工作占了普通开发很多工作，而这些工作是重复的，所以出现了此类的代码生成工具。这些工具通过模板引擎来生成代码，常见于三方集成工具，IDE插件等等。
### 43.1.2 什么是模板引擎？
模板引擎可以在代码生成过程中减少大量机械重复工作，大大提高开发效率，良好的设计使得代码重用，后期维护都降低成本。一个好的模板引擎的使用要考虑的方面无外乎：功能是否强大，使用是否简单，整合性、扩展性与灵活性，性能。

比如：

- Velocity
- FreeMarker
- Thymeleaf
- ...
![168.springboot-engine-1.png](../../assets/images/04-主流框架/spring/168.springboot-engine-1.png)
## 43.2 简单示例

### 准备DB

创建MySQL数据库`test_db`，并导入以下SQL文件：

```sql
-- MySQL dump 10.13  Distrib 5.7.12, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db
-- ------------------------------------------------------
-- Server version	5.7.17-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int(11) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user_role` (
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1,1);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-09-08 17:12:11
```

### 添加POM依赖

在`pom.xml`中添加MyBatis-Plus代码生成器相关依赖：

```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.1</version>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-generator</artifactId>
    <version>3.5.2</version>
</dependency>
<dependency>
    <groupId>org.apache.velocity</groupId>
    <artifactId>velocity-engine-core</artifactId>
    <version>2.0</version>
</dependency>
```

### 代码生成配置

**注意：** mybatis-plus-generator 3.5.1 及其以上版本对历史版本不兼容！3.5.1 以下版本请参考官方文档。

```java
import com.baomidou.mybatisplus.generator.FastAutoGenerator;

/**
 * This class is for xxxx.
 *
 * @author pdai
 */
public class TestGenCode {

    public static void main(String[] args) {
        FastAutoGenerator.create("jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8", "test", "bfXa4Pt2lUUScy8jakXf")
                .globalConfig(builder ->
                        builder.author("pdai") // 设置作者
                                .enableSwagger() // 开启 swagger 模式
                )
                .packageConfig(builder ->
                        builder.parent("tech.pdai.springboot.mysql8.mybatisplus.anno") // 设置父包名
                                .moduleName("gencode") // 设置父包模块名
                )
                .strategyConfig(builder ->
                        builder.addInclude("tb_user", "tb_role", "tb_user_role")
                )
                .execute();
    }
}
```

### 生成的代码结构

执行上述代码生成器后，将自动生成以下代码文件：

```
src/main/java/tech/pdai/springboot/mysql8/mybatisplus/anno/gencode/
├── controller/
│   ├── TbRoleController.java
│   ├── TbUserController.java
│   └── TbUserRoleController.java
├── entity/
│   ├── TbRole.java
│   ├── TbUser.java
│   └── TbUserRole.java
├── mapper/
│   ├── TbRoleMapper.java
│   ├── TbUserMapper.java
│   └── TbUserRoleMapper.java
└── service/
    ├── ITbRoleService.java
    ├── ITbUserService.java
    ├── ITbUserRoleService.java
    ├── impl/
    │   ├── TbRoleServiceImpl.java
    │   ├── TbUserServiceImpl.java
    │   └── TbUserRoleServiceImpl.java
```

### 高级配置示例

如果需要更详细的配置，可以使用以下完整示例：

```java
import com.baomidou.mybatisplus.generator.FastAutoGenerator;
import com.baomidou.mybatisplus.generator.config.OutputFile;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

import java.util.Collections;

public class AdvancedCodeGenerator {

    public static void main(String[] args) {
        FastAutoGenerator.create("jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8", "root", "password")
                .globalConfig(builder -> {
                    builder.author("pdai") // 设置作者
                            .enableSwagger() // 开启 swagger 模式
                            .fileOverride() // 覆盖已生成文件
                            .outputDir("D://mybatis-plus-code"); // 指定输出目录
                })
                .packageConfig(builder -> {
                    builder.parent("tech.pdai.springboot") // 设置父包名
                            .moduleName("system") // 设置父包模块名
                            .pathInfo(Collections.singletonMap(OutputFile.xml, "D://mybatis-plus-code")); // 设置mapperXml生成路径
                })
                .strategyConfig(builder -> {
                    builder.addInclude("tb_user", "tb_role") // 设置需要生成的表名
                            .addTablePrefix("tb_") // 设置过滤表前缀
                            .entityBuilder()
                            .enableLombok() // 开启lombok
                            .enableTableFieldAnnotation() // 开启字段注解
                            .controllerBuilder()
                            .enableRestStyle(); // 开启生成@RestController控制器
                })
                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                .execute();
    }
}
```

### 使用说明

1. **运行代码生成器**：执行`TestGenCode`类的`main`方法
2. **查看生成结果**：在指定包路径下查看生成的代码文件
3. **集成到项目**：将生成的代码文件复制到项目中相应位置
4. **配置数据源**：确保项目中的数据库连接配置正确

### 注意事项

- 确保数据库连接信息正确
- 生成的代码文件可能需要根据项目结构进行调整
- 如果使用不同的模板引擎（如Freemarker），需要添加相应依赖
- 生成的代码建议进行二次定制以满足具体业务需求

## 43.3 进一步理解
> 主要了解MyBatis-Plus生成代码的原理。

### 43.3.1 代码生成的基本原理
> 其实代码生成是非常简单的，有了模板引擎的介绍，我们再看下MyBatis-Plus的代码生成工具是如何生成代码的。

配置的装载, FastAutoGenerator本质上就是通过builder注入各种配置，并将它交给代码生成主类：AutoGenerator
```java
public void execute() {
    new AutoGenerator(this.dataSourceConfigBuilder.build())
        // 全局配置
        .global(this.globalConfigBuilder.build())
        // 包配置
        .packageInfo(this.packageConfigBuilder.build())
        // 策略配置
        .strategy(this.strategyConfigBuilder.build())
        // 注入配置
        .injection(this.injectionConfigBuilder.build())
        // 模板配置
        .template(this.templateConfigBuilder.build())
        // 执行
        .execute(this.templateEngine);
}
```
AutoGenerator中execute方法，包括初始化配置和模板引擎（默认是Velocity），然后将配置交给模板引擎初始化执行文件输出
```java
/**
  * 生成代码
  *
  * @param templateEngine 模板引擎
  */
public void execute(AbstractTemplateEngine templateEngine) {
    logger.debug("==========================准备生成文件...==========================");
    // 初始化配置
    if (null == config) {
        config = new ConfigBuilder(packageInfo, dataSource, strategy, template, globalConfig, injection);
    }
    if (null == templateEngine) {
        // 为了兼容之前逻辑，采用 Velocity 引擎 【 默认 】
        templateEngine = new VelocityTemplateEngine();
    }
    templateEngine.setConfigBuilder(config);
    // 模板引擎初始化执行文件输出
    templateEngine.init(config).batchOutput().open();
    logger.debug("==========================文件生成完成！！！==========================");
}
```
模板引擎中batchOuput方法中，包含获取表的信息并根据模板来生成类文件。
```java
/**
  * 批量输出 java xml 文件
  */
@NotNull
public AbstractTemplateEngine batchOutput() {
    try {
        ConfigBuilder config = this.getConfigBuilder();
        List<TableInfo> tableInfoList = config.getTableInfoList();
        tableInfoList.forEach(tableInfo -> {
            Map<String, Object> objectMap = this.getObjectMap(config, tableInfo);
            Optional.ofNullable(config.getInjectionConfig()).ifPresent(t -> {
                t.beforeOutputFile(tableInfo, objectMap);
                // 输出自定义文件
                outputCustomFile(t.getCustomFile(), tableInfo, objectMap);
            });
            // entity
            outputEntity(tableInfo, objectMap);
            // mapper and xml
            outputMapper(tableInfo, objectMap);
            // service
            outputService(tableInfo, objectMap);
            // controller
            outputController(tableInfo, objectMap);
        });
    } catch (Exception e) {
        throw new RuntimeException("无法创建文件，请检查配置信息！", e);
    }
    return this;
}
```
获取表的列表，由ConfigBuilder完成
```java
public List<TableInfo> getTableInfoList() {
    if (tableInfoList.isEmpty()) {
        // TODO 暂时不开放自定义
        List<TableInfo> tableInfos = new IDatabaseQuery.DefaultDatabaseQuery(this).queryTables();
        if (!tableInfos.isEmpty()) {
            this.tableInfoList.addAll(tableInfos);
        }
    }
    return tableInfoList;
}
```
然后获取上述单个表（tableInfo)的具体信息（objectMap)
```java
/**
  * 渲染对象 MAP 信息
  *
  * @param config    配置信息
  * @param tableInfo 表信息对象
  * @return ignore
  */
@NotNull
public Map<String, Object> getObjectMap(@NotNull ConfigBuilder config, @NotNull TableInfo tableInfo) {
    StrategyConfig strategyConfig = config.getStrategyConfig();
    Map<String, Object> controllerData = strategyConfig.controller().renderData(tableInfo);
    Map<String, Object> objectMap = new HashMap<>(controllerData);
    Map<String, Object> mapperData = strategyConfig.mapper().renderData(tableInfo);
    objectMap.putAll(mapperData);
    Map<String, Object> serviceData = strategyConfig.service().renderData(tableInfo);
    objectMap.putAll(serviceData);
    Map<String, Object> entityData = strategyConfig.entity().renderData(tableInfo);
    objectMap.putAll(entityData);
    objectMap.put("config", config);
    objectMap.put("package", config.getPackageConfig().getPackageInfo());
    GlobalConfig globalConfig = config.getGlobalConfig();
    objectMap.put("author", globalConfig.getAuthor());
    objectMap.put("kotlin", globalConfig.isKotlin());
    objectMap.put("swagger", globalConfig.isSwagger());
    objectMap.put("date", globalConfig.getCommentDate());
    // 启用 schema 处理逻辑
    String schemaName = "";
    if (strategyConfig.isEnableSchema()) {
        // 存在 schemaName 设置拼接 . 组合表名
        schemaName = config.getDataSourceConfig().getSchemaName();
        if (StringUtils.isNotBlank(schemaName)) {
            schemaName += ".";
            tableInfo.setConvert(true);
        }
    }
    objectMap.put("schemaName", schemaName);
    objectMap.put("table", tableInfo);
    objectMap.put("entity", tableInfo.getEntityName());
    return objectMap;
}
```
根据TableInfo和objectMap输出类文件，以输出Entity实体类为例
```java
/**
  * 输出实体文件
  *
  * @param tableInfo 表信息
  * @param objectMap 渲染数据
  * @since 3.5.0
  */
protected void outputEntity(@NotNull TableInfo tableInfo, @NotNull Map<String, Object> objectMap) {
    String entityName = tableInfo.getEntityName();
    String entityPath = getPathInfo(OutputFile.entity);
    if (StringUtils.isNotBlank(entityName) && StringUtils.isNotBlank(entityPath)) {
        getTemplateFilePath(template -> template.getEntity(getConfigBuilder().getGlobalConfig().isKotlin())).ifPresent((entity) -> {
            String entityFile = String.format((entityPath + File.separator + "%s" + suffixJavaOrKt()), entityName);
            outputFile(new File(entityFile), objectMap, entity, getConfigBuilder().getStrategyConfig().entity().isFileOverride());
        });
    }
}
```
在outputFile中来确定生成文件的名字和路径
```java
/**
  * 输出文件
  *
  * @param file         文件
  * @param objectMap    渲染信息
  * @param templatePath 模板路径
  * @param fileOverride 是否覆盖已有文件
  * @since 3.5.2
  */
protected void outputFile(@NotNull File file, @NotNull Map<String, Object> objectMap, @NotNull String templatePath, boolean fileOverride) {
    if (isCreate(file, fileOverride)) {
        try {
            // 全局判断【默认】
            boolean exist = file.exists();
            if (!exist) {
                File parentFile = file.getParentFile();
                FileUtils.forceMkdir(parentFile);
            }
            writer(objectMap, templatePath, file);
        } catch (Exception exception) {
            throw new RuntimeException(exception);
        }
    }
}
```
最后通过writer方法生成文件
```java
/**
  * 将模板转化成为文件
  *
  * @param objectMap    渲染对象 MAP 信息
  * @param templatePath 模板文件
  * @param outputFile   文件生成的目录
  * @throws Exception 异常
  * @since 3.5.0
  */
public void writer(@NotNull Map<String, Object> objectMap, @NotNull String templatePath, @NotNull File outputFile) throws Exception {
    this.writer(objectMap, templatePath, outputFile.getPath());
    logger.debug("模板:" + templatePath + ";  文件:" + outputFile);
}
```
本质上就是调用模板引擎来生成
```java
   @Override
    public void writer(@NotNull Map<String, Object> objectMap, @NotNull String templatePath, @NotNull File outputFile) throws Exception {
        Template template = velocityEngine.getTemplate(templatePath, ConstVal.UTF8);
        try (FileOutputStream fos = new FileOutputStream(outputFile);
             OutputStreamWriter ow = new OutputStreamWriter(fos, ConstVal.UTF8);
             BufferedWriter writer = new BufferedWriter(ow)) {
            template.merge(new VelocityContext(objectMap), writer);
        }
    }
```
比如Entity，velocityEngine.getTemplate会获取如下entity.vm模板生成Entity的类文件。
```java
package ${package.Entity};

#foreach($pkg in ${table.importPackages})
import ${pkg};
#end
#if(${swagger})
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
#end

/**
 * <p>
 * $!{table.comment}
 * </p>
 *
 * @author ${author}
 * @since ${date}
 */
#if(${table.convert})
@TableName("${schemaName}${table.name}")
#end
#if(${swagger})
@ApiModel(value = "${entity}对象", description = "$!{table.comment}")
#end
#if(${superEntityClass})
class ${entity} : ${superEntityClass}#if(${activeRecord})<${entity}>#end() {
#elseif(${activeRecord})
class ${entity} : Model<${entity}>() {
#elseif(${entitySerialVersionUID})
class ${entity} : Serializable {
#else
class ${entity} {
#end

## ----------  BEGIN 字段循环遍历  ----------
#foreach($field in ${table.fields})
#if(${field.keyFlag})
#set($keyPropertyName=${field.propertyName})
#end
#if("$!field.comment" != "")
    #if(${swagger})
    @ApiModelProperty(value = "${field.comment}")
    #else
    /**
     * ${field.comment}
     */
    #end
#end
#if(${field.keyFlag})
## 主键
#if(${field.keyIdentityFlag})
    @TableId(value = "${field.annotationColumnName}", type = IdType.AUTO)
#elseif(!$null.isNull(${idType}) && "$!idType" != "")
    @TableId(value = "${field.annotationColumnName}", type = IdType.${idType})
#elseif(${field.convert})
    @TableId("${field.annotationColumnName}")
#end
## 普通字段
#elseif(${field.fill})
## -----   存在字段填充设置   -----
#if(${field.convert})
    @TableField(value = "${field.annotationColumnName}", fill = FieldFill.${field.fill})
#else
    @TableField(fill = FieldFill.${field.fill})
#end
#elseif(${field.convert})
    @TableField("${field.annotationColumnName}")
#end
## 乐观锁注解
#if(${field.versionField})
    @Version
#end
## 逻辑删除注解
#if(${field.logicDeleteField})
    @TableLogic
#end
    #if(${field.propertyType} == "Integer")
    var ${field.propertyName}: Int? = null
    #else
    var ${field.propertyName}: ${field.propertyType}? = null
    #end

#end
## ----------  END 字段循环遍历  ----------
#if(${entityColumnConstant})
    companion object {
#foreach($field in ${table.fields})

        const val ${field.name.toUpperCase()} : String = "${field.name}"

#end
    }

#end
#if(${activeRecord})
    override fun pkVal(): Serializable? {
#if(${keyPropertyName})
        return ${keyPropertyName}
#else
        return null
#end
    }

#end
    override fun toString(): String {
        return "${entity}{" +
#foreach($field in ${table.fields})
#if($!{foreach.index}==0)
        "${field.propertyName}=" + ${field.propertyName} +
#else
        ", ${field.propertyName}=" + ${field.propertyName} +
#end
#end
        "}"
    }
}
```
同理生成mapper, service, controller等文件。是不是很简单？

### 43.3.2 如何看MyBatis-Plus生成代码的功能？
> 简单而言，对于初学者好像能生成代码作用很大，实际情况是很鸡肋！
- 从上面的源码我们可以看出，生成类只适合单表结构，表的关联无法处理；
- 对于单表的CRUD类，如果可以自动化生成，必然是可以很好的抽象的，而BaseMapper, BaseServiceImpl的封装已经足够了；
- 通常真正可以通过一体化集成前端代码的生成，才有一定的意义；当
- 然少部分情况快速提供接口的可以考虑，不过其实也省不了什么时间。
# 四十四、SpringBoot集成MySQL - MyBatis-Plus基于字段隔离的多租户

## 44.1 知识准备

需要了解多租户及常见的实现方式，以及MyBatis-Plus的基于字段的隔离方式原理。

## 44.2 什么是多租户？

如下解释来源于百度百科：

多租户技术（英语：multi-tenancy technology）或称多重租赁技术，是一种软件架构技术，它是在探讨与实现如何于多用户的环境下共用相同的系统或程序组件，并且仍可确保各用户间数据的隔离性。

多租户简单来说是指一个单独的实例可以为多个组织服务。多租户技术为共用的数据中心内如何以单一系统架构与服务提供多数客户端相同甚至可定制化的服务，并且仍然可以保障客户的数据隔离。

一个支持多租户技术的系统需要在设计上对它的数据和配置进行虚拟分区，从而使系统的每个租户或称组织都能够使用一个单独的系统实例，并且每个租户都可以根据自己的需求对租用的系统实例进行个性化配置。

多租户技术可以实现多个租户之间共享系统实例，同时又可以实现租户的系统实例的个性化定制。通过使用多租户技术可以保证系统共性的部分被共享，个性的部分被单独隔离。通过在多个租户之间的资源复用，运营管理维护资源，有效节省开发应用的成本。而且，在租户之间共享应用程序的单个实例，可以实现当应用程序升级时，所有租户可以同时升级。同时，因为多个租户共享一份系统的核心代码，因此当系统升级时，只需要升级相同的核心代码即可。

## 44.3 多租户在数据存储上有哪些实现方式？

如下解释来源于百度百科：

多租户在数据存储上存在三种主要的方案，分别是：

### 44.3.1 DB隔离：独立数据库

这是第一种方案，即一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本也高。

- 优点：为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。
- 缺点：增大了数据库的安装数量，随之带来维护成本和购置成本的增加。

这种方案与传统的一个客户、一套数据、一套部署类似，差别只在于软件统一部署在运营商那里。如果面对的是银行、医院等需要非常高数据隔离级别的租户，可以选择这种模式，提高租用的定价。如果定价较低，产品走低价路线，这种方案一般对运营商来说是无法承受的。

### 44.3.2 Schema隔离：共享数据库，隔离数据架构

这是第二种方案，即多个或所有租户共享Database，但一个租户（Tenant）一个Schema。

- 优点：为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可以支持更多的租户数量。
- 缺点：如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其他租户的数据；如果需要跨租户统计数据，存在一定困难。

### 44.3.3 字段隔离：共享数据库，共享数据架构

这是第三种方案，即租户共享同一个Database、同一个Schema，但在表中通过TenantID区分租户的数据。这是共享程度最高、隔离级别最低的模式。

- 优点：三种方案比较，第三种方案的维护和购置成本最低，允许每个数据库支持的租户数量最多。
- 缺点：隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；数据备份和恢复最困难，需要逐表逐条备份和还原。

如果希望以最少的服务器为最多的租户提供服务，并且租户接受以牺牲隔离级别换取降低成本，这种方案最适合。

## 44.4 MyBatis-Plus的基于字段的隔离方式原理是什么？

这里请看MyBatis的插件机制：MyBatis详解 - 插件机制。

## 44.5 简单示例

这里沿用之前的test_db，在表中添加tenant_id，并命名为新的schema test_db_tenant。

### 44.5.1 准备DB和依赖配置

创建MySQL的schema test_db_tenant, 导入SQL 文件如下：

```sql
-- MySQL dump 10.13  Distrib 8.0.28, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db_tenant
-- ------------------------------------------------------
-- Server version	8.0.28

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role` (
  `id` int NOT NULL AUTO_INCREMENT,
  `tenant_id` int DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `tenant_id` int DEFAULT NULL,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role` (
  `user_id` int NOT NULL,
  `role_id` int NOT NULL,
  `tenant_id` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1,1,1);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-04-02 12:50:14
```

引入maven依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.5.1</version>
</dependency>
```

增加yml配置：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db_tenant?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf

mybatis-plus:
  configuration:
    cache-enabled: true
    use-generated-keys: true
    default-executor-type: REUSE
    use-actual-param-name: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 输出SQL log 方便 debug
```

### 44.5.2 MyBatis-Plus配置

通过添加TenantLineInnerInterceptor来完成。

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.config;

import java.util.List;

import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.handler.TenantLineHandler;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.TenantLineInnerInterceptor;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.LongValue;
import net.sf.jsqlparser.schema.Column;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * MyBatis-plus configuration, add pagination interceptor.
 *
 * @author pdai
 */
@Configuration
public class MyBatisConfig {

    /**
     * inject pagination interceptor.
     *
     * @return pagination
     */
    @Bean
    public PaginationInnerInterceptor paginationInnerInterceptor() {
        return new PaginationInnerInterceptor();
    }

    /**
     * add interceptor.
     *
     * @return MybatisPlusInterceptor
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // TenantLineInnerInterceptor
        interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() {
            @Override
            public Expression getTenantId() {
                // 实际可以将TenantId放在threadLocale中(比如xxxxContext中)，并获取。
                return new LongValue(1);
            }

            @Override
            public String getTenantIdColumn() {
                return "tenant_id";
            }

            @Override
            public boolean ignoreTable(String tableName) {
            // 配置需要忽略多租户的表
            List<String> ignoreTables = Arrays.asList("sys_config", "sys_dict", "common_log");
            return ignoreTables.contains(tableName);
            }

            @Override
            public boolean ignoreInsert(List<Column> columns, String tenantIdColumn) {
                return TenantLineHandler.super.ignoreInsert(columns, tenantIdColumn);
            }
        }));
        // 如果用了分页插件注意先 add TenantLineInnerInterceptor 再 add PaginationInnerInterceptor
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return interceptor;
    }

}
```
- 有些表我们可能不需要多租户，如何处理：
  - 在TenantLineHandler的ignoreTable方法中，你可以根据表名来决定是否忽略多租户：
  -  使用@InterceptorIgnore注解
  ```java
    public interface IUserDao extends BaseMapper<User> {

        List<User> findList(UserQueryBean userQueryBean);
        
        // 忽略租户拦截器
        @InterceptorIgnore(tenantLine = "true")
        List<User> findAllWithoutTenant();
        
        // 只忽略租户拦截器，其他拦截器正常生效
        @InterceptorIgnore(tenantLine = "true")
        Page<User> findPageWithoutTenant(Page<User> page, UserQueryBean userQueryBean);
    }

  ```
  -  在XML中使用tenantLine属性
    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="tech.pdai.springboot.mysql8.mybatisplus.tenant.dao.IUserDao">

        <!-- 这个查询会应用多租户 -->
        <select id="findList" parameterType="UserQueryBean" resultMap="UserResult">
            select * from tb_user
            where 1=1
            <if test="userName != null and userName != ''">
                AND user_name like concat('%', #{userName}, '%')
            </if>
        </select>
        
        <!-- 这个查询忽略多租户 -->
        <select id="findAllWithoutTenant" resultType="User">
            select * from tb_user
        </select>
        
        <!-- 使用tenantLine属性控制 -->
        <select id="findByCondition" resultType="User" tenantLine="false">
            select * from tb_user where user_name = #{userName}
        </select>
    </mapper>

    ```
### 44.5.3 定义DAO

RoleDao：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.dao;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.Role;

/**
 * @author pdai
 */
public interface IRoleDao extends BaseMapper<Role> {
}
```

UserDao：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.dao;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.UserQueryBean;

import java.util.List;

/**
 * @author pdai
 */
public interface IUserDao extends BaseMapper<User> {

    List<User> findList(UserQueryBean userQueryBean);
}
```

这里你也同时可以支持BaseMapper方式和自己定义的xml的方法（比较适用于关联查询），比如findList是自定义xml配置：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="tech.pdai.springboot.mysql8.mybatisplus.tenant.dao.IUserDao">

	<resultMap type="tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.User" id="UserResult">
		<id     property="id"       	column="id"      		/>
		<result property="userName"     column="user_name"    	/>
		<result property="password"     column="password"    	/>
		<result property="email"        column="email"        	/>
		<result property="phoneNumber"  column="phone_number"  	/>
		<result property="description"  column="description"  	/>
		<result property="createTime"   column="create_time"  	/>
		<result property="updateTime"   column="update_time"  	/>
		<collection property="roles" ofType="tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.Role">
			<result property="id" column="id"  />
			<result property="name" column="name"  />
			<result property="roleKey" column="role_key"  />
			<result property="description" column="description"  />
			<result property="createTime"   column="create_time"  	/>
			<result property="updateTime"   column="update_time"  	/>
		</collection>
	</resultMap>
	
	<sql id="selectUserSql">
        select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time, r.name, r.role_key, r.description, r.create_time, r.update_time
		from tb_user u
		left join tb_user_role ur on u.id=ur.user_id
		inner join tb_role r on ur.role_id=r.id
    </sql>
	
	<select id="findList" parameterType="tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.UserQueryBean" resultMap="UserResult">
		<include refid="selectUserSql"/>
		where u.id != 0
		<if test="userName != null and userName != ''">
			AND u.user_name like concat('%', #{user_name}, '%')
		</if>
		<if test="description != null and description != ''">
			AND u.description like concat('%', #{description}, '%')
		</if>
		<if test="phoneNumber != null and phoneNumber != ''">
			AND u.phone_number like concat('%', #{phoneNumber}, '%')
		</if>
		<if test="email != null and email != ''">
			AND u.email like concat('%', #{email}, '%')
		</if>
	</select>
	
</mapper> 
```

### 44.5.4 定义Service

UserService接口：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.service;

import com.baomidou.mybatisplus.extension.service.IService;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.UserQueryBean;

import java.util.List;

/**
 * @author pdai
 */
public interface IUserService extends IService<User> {

    List<User> findList(UserQueryBean userQueryBean);

}
```

User Service的实现类：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.dao.IUserDao;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.service.IUserService;

import java.util.List;

@Service
public class UserDoServiceImpl extends ServiceImpl<IUserDao, User> implements IUserService {

    @Override
    public List<User> findList(UserQueryBean userQueryBean) {
        return baseMapper.findList(userQueryBean);
    }
}
```

Role Service 接口：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.service;

import com.baomidou.mybatisplus.extension.service.IService;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.Role;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.RoleQueryBean;

import java.util.List;

public interface IRoleService extends IService<Role> {

    List<Role> findList(RoleQueryBean roleQueryBean);

}
```

Role Service 实现类：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.dao.IRoleDao;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.Role;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.service.IRoleService;

import java.util.List;

@Service
public class RoleDoServiceImpl extends ServiceImpl<IRoleDao, Role> implements IRoleService {

    @Override
    public List<Role> findList(RoleQueryBean roleQueryBean) {
        return lambdaQuery().like(StringUtils.isNotEmpty(roleQueryBean.getName()), Role::getName, roleQueryBean.getName())
                .like(StringUtils.isNotEmpty(roleQueryBean.getDescription()), Role::getDescription, roleQueryBean.getDescription())
                .like(StringUtils.isNotEmpty(roleQueryBean.getRoleKey()), Role::getRoleKey, roleQueryBean.getRoleKey())
                .list();
    }
}
```

### 44.5.5 Controller

User Controller：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.controller;


import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.User;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.UserQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.response.ResponseResult;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.service.IUserService;

import java.time.LocalDateTime;
import java.util.List;


/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId() == null) {
            user.setCreateTime(LocalDateTime.now());
        }
        user.setUpdateTime(LocalDateTime.now());
        userService.save(user);
        return ResponseResult.success(userService.getById(user.getId()));
    }


    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.getById(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User List")
    @GetMapping("list")
    public ResponseResult<List<User>> list(UserQueryBean userQueryBean) {
        return ResponseResult.success(userService.findList(userQueryBean));
    }
}
```

Role Controller：

```java
package tech.pdai.springboot.mysql8.mybatisplus.tenant.controller;


import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.Role;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.query.RoleQueryBean;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.entity.response.ResponseResult;
import tech.pdai.springboot.mysql8.mybatisplus.tenant.service.IRoleService;

import java.util.List;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/role")
public class RoleController {

    @Autowired
    private IRoleService roleService;

    /**
     * @return role list
     */
    @ApiOperation("Query Role List")
    @GetMapping("list")
    public ResponseResult<List<Role>> list(RoleQueryBean roleQueryBean) {
        return ResponseResult.success(roleService.findList(roleQueryBean));
    }
}
```

## 44.6 简单测试

访问页面：http://localhost:8080/doc.html

拦截之前的SQL：

```sql
original SQL: select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time, r.name, r.role_key, r.description, r.create_time, r.update_time
		from tb_user u
		left join tb_user_role ur on u.id=ur.user_id
		inner join tb_role r on ur.role_id=r.id  
		where u.id != 0
```

最后执行的SQL中，对联表查询的每个表都加了：tenant_id

```log
2021-09-22 20:26:22.368  INFO 28404 --- [nio-8080-exec-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
JDBC Connection [HikariProxyConnection@529070127 wrapping com.mysql.cj.jdbc.ConnectionImpl@785a9c8] will not be managed by Spring
==>  Preparing: SELECT u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time, r.name, r.role_key, r.description, r.create_time, r.update_time FROM tb_user u LEFT JOIN tb_user_role ur ON u.id = ur.user_id AND ur.tenant_id = 1 INNER JOIN tb_role r ON ur.role_id = r.id AND u.tenant_id = 1 AND r.tenant_id = 1 WHERE u.id != 0
==> Parameters: 
<==    Columns: id, password, user_name, email, phone_number, description, create_time, update_time, name, role_key, description, create_time, update_time
<==        Row: 1, dfasdf, pdai, suzhou.daipeng@gmail.com, 1212121213, afsdfsaf, 2021-09-08 17:09:15, 2021-09-08 17:09:15, admin, admin, admin, 2021-09-08 17:09:15, 2021-09-08 17:09:15
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@5cf94cf9]
```

## 44.7 进一步理解

在实际使用字段进行多租户隔离时有哪些注意点呢？

### 44.7.1 来自官方的注意点

相关建议：

- 多租户 != 权限过滤,不要乱用,租户之间是完全隔离的!!!
- 启用多租户后所有执行的method的sql都会进行处理.
- 自写的sql请按规范书写(sql涉及到多个表的每个表都要给别名,特别是 inner join 的要写标准的 inner join)

### 44.7.2 插件的顺序

MyBatis-Plus使用多个功能插件需要注意顺序关系：

MyBatis-Plus基于字段的多租户是通过插件机制拦截实现的，因为还有很多其它的拦截器，比如:

- 自动分页: PaginationInnerInterceptor
- 多租户: TenantLineInnerInterceptor
- 动态表名: DynamicTableNameInnerInterceptor
- 乐观锁: OptimisticLockerInnerInterceptor
- sql 性能规范: IllegalSQLInnerInterceptor
- 防止全表更新与删除: BlockAttackInnerInterceptor

所以需要注意顺序: 使用多个功能需要注意顺序关系,建议使用如下顺序：

1. 多租户,动态表名
2. 分页,乐观锁
3. sql 性能规范,防止全表更新与删除

总结: 对 sql 进行单次改造的优先放入,不对 sql 进行改造的最后放入。

### 44.7.3 封装性实践

实际项目中还需要对配置进行封装。回看如下的处理， 我们看下可以封装的点：

```java
// TenantLineInnerInterceptor
interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() {
    @Override
    public Expression getTenantId() {
        // 实际可以将TenantId放在threadLocale中(比如xxxxContext中)，并获取。
        return new LongValue(1);
    }

    @Override
    public String getTenantIdColumn() {
        return "tenant_id";
    }

    @Override
    public boolean ignoreTable(String tableName) {
        return false;
    }

    @Override
    public boolean ignoreInsert(List<Column> columns, String tenantIdColumn) {
        return TenantLineHandler.super.ignoreInsert(columns, tenantIdColumn);
    }
}));
```

对于配置相关配置可以封装到yml, 然后注入进来。

- 对于TenantId实际可以将TenantId放在threadLocale中(比如xxxxContext中)，并获取。
- 对于ignoreTable比如有些表不要自动进行拦截的，可以在yml中配置并重写ignoreTable方法。
- 对于ignoreInsert对于插入数据是否需要携带TenantId，可以通过重写ignoreInsert方法。
# 四十五、▶SpringBoot集成ShardingJDBC - Sharding-JDBC简介和基于MyBatis的单库分表
> 本文主要介绍分表分库，以及SpringBoot集成基于ShardingJDBC+MyBatis的单库分表实践。
## 45.1 知识准备
> 主要理解分表分库，Sharding-JDBC要解决什么问题，Sharding-JDBC及ShardingSphere的关系等。
### 45.1.1 为什么要分表分库？
#### 45.1.1.1 水平切分
水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。
![169.63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg](../../assets/images/04-主流框架/spring/169.63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg)
#### 45.1.1.2 垂直切分
![170.e130e5b8-b19a-4f1e-b860-223040525cf6.jpg](../../assets/images/04-主流框架/spring/170.e130e5b8-b19a-4f1e-b860-223040525cf6.jpg)

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。
#### 45.1.1.3 Sharding 策略
- 哈希取模: hash(key) % NUM_DB
- 范围: 可以是 ID 范围也可以是时间范围
- 映射表: 使用单独的一个数据库来存储映射关系
#### 45.1.1.4 Sharding 存在的问题及解决方案
 1. 事务问题
   
使用分布式事务来解决，比如 XA 接口。
 2. 链接
   
可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。
 3. ID 唯一性

- 使用全局唯一 ID: GUID
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)
### 45.1.2 什么是Sharding-JDBC？
> 来自ShardingSphere官网

Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。
- 适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。
- 基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。
- 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。
![171.spring-sharding-3.png](../../assets/images/04-主流框架/spring/171.spring-sharding-3.png)
### 45.1.3 和ShardingSphere是什么关系？
> 来自ShardingSphere官网

ShardingSphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。

ShardingSphere定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 它与NoSQL和NewSQL是并存而非互斥的关系。NoSQL和NewSQL作为新技术探索的前沿，放眼未来，拥抱变化，是非常值得推荐的。反之，也可以用另一种思路看待问题，放眼未来，关注不变的东西，进而抓住事物本质。 关系型数据库当今依然占有巨大市场，是各个公司核心业务的基石，未来也难于撼动，我们目前阶段更加关注在原有基础上的增量，而非颠覆。
![172.spring-sharding-1.png](../../assets/images/04-主流框架/spring/172.spring-sharding-1.png)

对应的版本功能
![173.spring-sharding-2.png](../../assets/images/04-主流框架/spring/173.spring-sharding-2.png)
## 45.2 简单示例

这里主要介绍SpringBoot集成基于ShardingJDBC的单库分表实践，主要承接之前的相关文章在MyBatis的注解方式的基础上实现的。

### 45.2.1 准备DB和依赖配置

创建MySQL的schema test_db_sharding，导入SQL文件如下：

```sql
-- MySQL dump 10.13  Distrib 8.0.28, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db_sharding
-- ------------------------------------------------------
-- Server version	8.0.28

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role_0`
--

DROP TABLE IF EXISTS `tb_role_0`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role_0` (
  `id` bigint NOT NULL,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role_0`
--

LOCK TABLES `tb_role_0` WRITE;
/*!40000 ALTER TABLE `tb_role_0` DISABLE KEYS */;
INSERT INTO `tb_role_0` VALUES (3,'333','333','33','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role_0` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_role_1`
--

DROP TABLE IF EXISTS `tb_role_1`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role_1` (
  `id` bigint NOT NULL,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role_1`
--

LOCK TABLES `tb_role_1` WRITE;
/*!40000 ALTER TABLE `tb_role_1` DISABLE KEYS */;
INSERT INTO `tb_role_1` VALUES (1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15'),(2,'11','11','11','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role_1` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_0`
--

DROP TABLE IF EXISTS `tb_user_0`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_0` (
  `id` bigint NOT NULL,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_0`
--

LOCK TABLES `tb_user_0` WRITE;
/*!40000 ALTER TABLE `tb_user_0` DISABLE KEYS */;
INSERT INTO `tb_user_0` VALUES (718415228786159616,'pdai','dad','pdai@pdai.tech',121212121,'pdai','2022-04-06 20:45:38','2022-04-06 20:45:38');
/*!40000 ALTER TABLE `tb_user_0` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_1`
--

DROP TABLE IF EXISTS `tb_user_1`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_1` (
  `id` bigint NOT NULL,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_1`
--

LOCK TABLES `tb_user_1` WRITE;
/*!40000 ALTER TABLE `tb_user_1` DISABLE KEYS */;
INSERT INTO `tb_user_1` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15'),(718415481409089537,'pdai2','dad2','pdai2@pdai.tech',1212121212,'pdai2','2022-04-06 20:46:38','2022-04-06 20:46:38');
/*!40000 ALTER TABLE `tb_user_1` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role_0`
--

DROP TABLE IF EXISTS `tb_user_role_0`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role_0` (
  `id` bigint NOT NULL,
  `user_id` bigint NOT NULL,
  `role_id` bigint NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role_0`
--

LOCK TABLES `tb_user_role_0` WRITE;
/*!40000 ALTER TABLE `tb_user_role_0` DISABLE KEYS */;
INSERT INTO `tb_user_role_0` VALUES (1,1,1);
/*!40000 ALTER TABLE `tb_user_role_0` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role_1`
--

DROP TABLE IF EXISTS `tb_user_role_1`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role_1` (
  `id` bigint NOT NULL,
  `user_id` bigint NOT NULL,
  `role_id` bigint NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role_1`
--

LOCK TABLES `tb_user_role_1` WRITE;
/*!40000 ALTER TABLE `tb_user_role_1` DISABLE KEYS */;
INSERT INTO `tb_user_role_1` VALUES (11,718415481409089537,3),(13,718415228786159616,2);
/*!40000 ALTER TABLE `tb_user_role_1` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-04-06 23:06:23
------
著作权归@pdai所有
原文链接：https://pdai.tech/md/spring/springboot/springboot-x-mysql-shardingjdbc-jpa.html
```

引入maven依赖，包含mysql驱动、mybatis和pageHelper，以及sharding-jdbc的依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.0</version>
</dependency>
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.2.10</version>
</dependency>
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
    <version>4.1.1</version>
</dependency>
```

增加yml配置：

```yaml
spring:
  shardingsphere:
    datasource:
      names: ds
      ds:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_sharding?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: test
        password: bfXa4Pt2lUUScy8jakXf
    sharding:
      tables:
        tb_user:
          actual-data-nodes: ds.tb_user_$->{0..1}
          table-strategy:
            inline:
              sharding-column: id
              algorithm-expression: tb_user_$->{id % 2}
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
      binding-tables: tb_user
      broadcast-tables: t_address
mybatis:
  type-aliases-package: tech.pdai.springboot.shardingjdbc.mybatis.tables.entity
  configuration:
    cache-enabled: true
    use-generated-keys: true
    default-executor-type: REUSE
    use-actual-param-name: true
```

### 45.2.2 DAO

mapper/dao：

```java
package tech.pdai.springboot.shardingjdbc.mybatis.tables.dao;

import org.apache.ibatis.annotations.*;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.dao.provider.UserDaoProvider;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.User;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.query.UserQueryBean;

import java.util.List;

/**
 * @author pdai
 */
@Mapper
public interface IUserDao {

    String SELECT_USER_SQL = "select u.id, u.password, u.user_name, u.email, u.phone_number, u.description, u.create_time, u.update_time from tb_user u";

    @Results(
            id = "UserResult",
            value = {
                    @Result(property = "id", column = "id"),
                    @Result(property = "userName", column = "user_name"),
                    @Result(property = "password", column = "password"),
                    @Result(property = "email", column = "email"),
                    @Result(property = "phoneNumber", column = "phone_number"),
                    @Result(property = "description", column = "description"),
                    @Result(property = "createTime", column = "create_time"),
                    @Result(property = "updateTime", column = "update_time")
            }
    )
    @Select({SELECT_USER_SQL, " where id = #{id}"})
    User findById(@Param("id") Long id);

    @ResultMap("UserResult")
    @Select(SELECT_USER_SQL)
    User findAll();

    @ResultMap("UserResult")
    @Select({"<script> ", SELECT_USER_SQL, " where u.id != 0\n" +
            "\t\t<if test=\"userName != null and userName != ''\">\n" +
            "AND u.user_name like concat('%', #{user_name}, '%')\n" +
            "\t\t</if>\n" +
            "\t\t<if test=\"description != null and description != ''\">\n" +
            "AND u.description like concat('%', #{description}, '%')\n" +
            "\t\t</if>\n" +
            "\t\t<if test=\"phoneNumber != null and phoneNumber != ''\">\n" +
            "AND u.phone_number like concat('%', #{phoneNumber}, '%')\n" +
            "\t\t</if>\n" +
            "\t\t<if test=\"email != null and email != ''\">\n" +
            "AND u.email like concat('%', #{email}, '%')\n" +
            "\t\t</if>", " </script>"})
    List<User> findList(UserQueryBean userQueryBean);

    @Delete("delete from tb_user where id = #{id}")
    int deleteById(Long id);

    @Delete({"<script> ", "delete from tb_user where id in\n" +
            "<foreach collection=\"array\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n" +
            "#{id}\n" +
            "</foreach>", " </script>"})
    int deleteByIds(Long[] ids);

    @Update({"<script> ", "update tb_user\n" +
            " <set>\n" +
            " <if test=\"userName != null and userName != ''\">user_name = #{userName},</if>\n" +
            " <if test=\"email != null and email != ''\">email = #{email},</if>\n" +
            " <if test=\"phoneNumber != null and phoneNumber != ''\">phone_number = #{phoneNumber},</if>\n" +
            " <if test=\"description != null and description != ''\">description = #{description},</if>\n" +
            " update_time = sysdate()\n" +
            " </set>\n" +
            " where id = #{id}", " </script>"})
    int update(User user);

    @Insert({"<script> ", "insert into tb_user(\n" +
            " <if test=\"userName != null and userName != ''\">user_name,</if>\n" +
            " <if test=\"password != null and password != ''\">password,</if>\n" +
            " <if test=\"email != null and email != ''\">email,</if>\n" +
            " <if test=\"phoneNumber != null and phoneNumber != ''\">phone_number,</if>\n" +
            " <if test=\"description != null and description != ''\">description,</if>\n" +
            " create_time,\n" +
            " update_time\n" +
            " )values(\n" +
            " <if test=\"userName != null and userName != ''\">#{userName},</if>\n" +
            " <if test=\"password != null and password != ''\">#{password},</if>\n" +
            " <if test=\"email != null and email != ''\">#{email},</if>\n" +
            " <if test=\"phoneNumber != null and phoneNumber != ''\">#{phoneNumber},</if>\n" +
            " <if test=\"description != null and description != ''\">#{description},</if>\n" +
            " sysdate(),\n" +
            " sysdate()\n" +
            " )", " </script>"})
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int save(User user);

    @Update({"update tb_user set password = #{password}, update_time = sysdate()", " where id = #{id}"})
    int updatePassword(User user);

    @ResultMap("UserResult")
    @SelectProvider(type = UserDaoProvider.class, method = "findById")
    User findById2(Long id);
}
```

### 45.2.3 Service

user service 接口：

```java
package tech.pdai.springboot.shardingjdbc.mybatis.tables.service;

import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.User;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.query.UserQueryBean;

import java.util.List;

/**
 * @author pdai
 */
public interface IUserService {

    List<User> findList(UserQueryBean userQueryBean);

    User findById(Long id);

    int deleteById(Long id);

    int deleteByIds(Long[] ids);

    int update(User user);

    int save(User user);

    int updatePassword(User user);

    User findById2(Long userId);
}
```

service实现类：

```java
package tech.pdai.springboot.shardingjdbc.mybatis.tables.service.impl;

import tech.pdai.springboot.shardingjdbc.mybatis.tables.dao.IUserDao;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.User;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.query.UserQueryBean;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.service.IUserService;

import java.util.List;

@Service
public class UserDoServiceImpl implements IUserService {

    /**
     * userDao.
     */
    private final IUserDao userDao;

    /**
     * init.
     *
     * @param userDao2 user dao
     */
    public UserDoServiceImpl(final IUserDao userDao2) {
        this.userDao = userDao2;
    }

    @Override
    public List<User> findList(UserQueryBean userQueryBean) {
        return userDao.findList(userQueryBean);
    }

    @Override
    public User findById(Long id) {
        return userDao.findById(id);
    }

    @Override
    public int deleteById(Long id) {
        return userDao.deleteById(id);
    }

    @Override
    public int deleteByIds(Long[] ids) {
        return userDao.deleteByIds(ids);
    }

    @Override
    public int update(User user) {
        return userDao.update(user);
    }

    @Override
    public int save(User user) {
        return userDao.save(user);
    }

    @Override
    public int updatePassword(User user) {
        return userDao.updatePassword(user);
    }

    @Override
    public User findById2(Long userId) {
        return userDao.findById2(userId);
    }
}
```

### 45.2.4 Controller

user controller：

```java
package tech.pdai.springboot.shardingjdbc.mybatis.tables.controller;

import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.User;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.query.UserQueryBean;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.entity.response.ResponseResult;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.shardingjdbc.mybatis.tables.service.IUserService;

import java.util.List;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId() == null) {
            userService.save(user);
        } else {
            userService.update(user);
        }
        return ResponseResult.success(userService.findById(user.getId()));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.findById(userId));
    }

    /**
     * @return user list 2
     */
    @ApiOperation("Query User One 2")
    @GetMapping("edit2/{userId}")
    public ResponseResult<User> edit2(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.findById2(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User List")
    @GetMapping("list")
    public ResponseResult<List<User>> list(UserQueryBean userQueryBean) {
        return ResponseResult.success(userService.findList(userQueryBean));
    }

    @ApiOperation("Delete by id")
    @PostMapping("delete")
    public ResponseResult<Integer> delete(Long userId) {
        return ResponseResult.success(userService.deleteById(userId));
    }
}
```

### 45.2.5 简单测试

访问页面：http://localhost:8080/doc.html插入数据。

## 45.3 进一步理解
### 45.3.1 几个常见的错误
在使用sharding-jdbc以及和其它组件集成（比如mybatis，mybatis-plus，druid等）遇到的问题会比较多，这里举几个典型的报错例子：
- Sharding value must implements Comparable.

由于数据分片，原有的数据库自动增长ID设置以及ORM层相关配置策略都不能再使用，所以需要取消数据库自增长以及ORM层@ID或者@TableID等注解。

key-generator 由如下配置替代
```yml
  key-generator:
    column: id
    type: SNOWFLAKE
    props:
      worker:
        id: 123
```
- Data truncation: Out of range value for column 'id'

正是由于上述SNOWFLAKE雪花算法（相关文章请参考分布式算法 - Snowflake算法）， 相关ID是64位的long类型，所以需要设置相关字段位BIGINT类型。
- java.sql.SQLFeatureNotSupportedException: getObject with type

这是与Mybatis等其它框架集成的一个bug：LocalDateTimeTypeHandler未能进行关联处理； 官方在5.0版本修复了这个问题，只是当前sharding-jdbc-spring-boot-starter的版本依然是4.1.1，所以依然有问题。这也凸显出了国产开源（即便是进入Apache且在不断完善）整体上还有很长的路（文档，闭环，Ecosystem...等等）要走。

https://github.com/apache/shardingsphere/pull/6202

### 45.3.2 核心作者采访谈Sharding-JDBC
https://juejin.cn/post/6844903476393164813
# 四十六、SpringBoot集成ShardingJDBC - 基于JPA的读写分离
## 46.1 知识准备
### 46.1.1 读写分离库的场景和设计目标？
> 透明化读写分离所带来的影响，**让使用方尽量像使用一个数据库一样使用主从数据库集群**，是ShardingSphere读写分离模块的主要设计目标。

面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为主库和从库，**主库负责处理事务性的增删改操作，从库负责处理查询操作**，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。

通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。

与将数据根据分片键打散至各个数据节点的水平分片不同，读写分离则是根据SQL语义的分析，将读操作和写操作分别路由至主库与从库。
![174.spring-sharding-11.png](../../assets/images/04-主流框架/spring/174.spring-sharding-11.png)

读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。

读写分离虽然可以提升系统的吞吐量和可用性，但同时也带来了数据不一致的问题。 这包括多个主库之间的数据一致性，以及主库与从库之间的数据一致性的问题。 并且，读写分离也带来了与数据分片同样的问题，它同样会使得应用开发和运维人员对数据库的操作和运维变得更加复杂。 下图展现了将分库分表与读写分离一同使用时，应用程序与数据库集群之间的复杂拓扑关系。
![175.spring-sharding-12.png](../../assets/images/04-主流框架/spring/175.spring-sharding-12.png)
### 46.1.2 核心功能
- 提供一主多从的读写分离配置，可独立使用，也可配合分库分表使用。
- 独立使用读写分离支持SQL透传。
- 同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性。
- 基于Hint的强制主库路由。
## 46.2 简单示例

这里主要介绍SpringBoot集成基于ShardingJDBC的读写分离和数据分片实践，主要承接之前的相关文章在JPA方式的基础上实现的。

### 46.2.1 准备DB和依赖配置

创建MySQL的schema test_db_sharding_master 和 test_db_sharding_slave，导入SQL文件如下：

test_db_sharding_master：

```sql
-- MySQL dump 10.13  Distrib 8.0.28, for macos11 (x86_64)
--
-- Host: localhost    Database: test_db_sharding_master
-- ------------------------------------------------------
-- Server version	8.0.22

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (2,'pdai2','aaa','pdai@pdai.tech',123133332,'pdai2','2022-04-06 20:44:34','2022-04-06 20:44:34');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role` (
  `user_id` int NOT NULL,
  `role_id` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-04-06 21:08:09
```

test_db_sharding_slave：

```sql
-- MySQL dump 10.13  Distrib 8.0.28, for macos11 (x86_64)
--
-- Host: localhost    Database: test_db_sharding_slave0
-- ------------------------------------------------------
-- Server version	8.0.22

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (2,'pdai-salve','xxx','xx',12111,'pdai','2022-04-06 20:44:34','2022-04-06 20:44:34');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role` (
  `user_id` int NOT NULL,
  `role_id` int NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-04-06 21:08:28
```

引入maven依赖，包含mysql驱动、JPA包，以及sharding-jdbc的依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>com.github.wenhao</groupId>
    <artifactId>jpa-spec</artifactId>
    <version>3.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
    <version>4.1.1</version>
</dependency>
```

增加yml配置：

```yaml
spring:
  shardingsphere:
    datasource:
      names: master,slave0
      master:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_sharding_master?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
      slave0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_sharding_slave0?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
    sharding:
      tables:
        tb_user:
          database-strategy:
            inline:
              sharding-column: id
              algorithm-expression: master
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_role:
          database-strategy:
            inline:
              sharding-column: id
              algorithm-expression: master
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_user_role:
          database-strategy:
            inline:
              sharding-column: id
              algorithm-expression: master
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
    master-slave:
        name: ms
        load-balance-algorithm-type: round_robin
        master-data-source-name: master
        slave-data-source-names: slave0
    props:
      sql:
        show: true
  jpa:
    open-in-view: false
    generate-ddl: false
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true
        use-new-id-generator-mappings: false
```

### 46.2.2 Entity

user entity：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity;

import java.time.LocalDateTime;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * @author pdai
 */
@Getter
@Setter
@ToString
@Entity
@Table(name = "tb_user")
public class User implements BaseEntity {

    /**
     * user id.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * username.
     */
    private String userName;

    /**
     * user pwd.
     */
    private String password;

    /**
     * email.
     */
    private String email;

    /**
     * phoneNumber.
     */
    private long phoneNumber;

    /**
     * description.
     */
    private String description;

    /**
     * create date time.
     */
    private LocalDateTime createTime;

    /**
     * update date time.
     */
    private LocalDateTime updateTime;

    /**
     * join to role table.
     */
    @ManyToMany(cascade = {CascadeType.REFRESH}, fetch = FetchType.EAGER)
    @JoinTable(name = "tb_user_role", joinColumns = {
            @JoinColumn(name = "user_id")}, inverseJoinColumns = {@JoinColumn(name = "role_id")})
    private Set<Role> roles;

}
```

role entity：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity;

import java.time.LocalDateTime;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * @author pdai
 */
@Getter
@Setter
@ToString
@Entity
@Table(name = "tb_role")
public class Role implements BaseEntity {

    /**
     * role id.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * role name.
     */
    private String name;

    /**
     * role key.
     */
    private String roleKey;

    /**
     * description.
     */
    private String description;

    /**
     * create date time.
     */
    private LocalDateTime createTime;

    /**
     * update date time.
     */
    private LocalDateTime updateTime;

}
```

### 46.2.3 DAO

user dao：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.User;

/**
 * @author pdai
 */
@Repository
public interface IUserDao extends IBaseDao<User, Long> {

}
```

role dao：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.Role;

/**
 * @author pdai
 */
@Repository
public interface IRoleDao extends IBaseDao<Role, Long> {

}
```

### 46.2.4 Service

user service 接口：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.User;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.query.UserQueryBean;

/**
 * @author pdai
 */
public interface IUserService extends IBaseService<User, Long> {

    /**
     * find by page.
     *
     * @param userQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    Page<User> findPage(UserQueryBean userQueryBean, PageRequest pageRequest);

}
```

user service 实现类：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.service.impl;

import com.github.wenhao.jpa.Specifications;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.dao.IBaseDao;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.dao.IUserDao;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.User;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.query.UserQueryBean;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.service.IUserService;

@Service
public class UserDoServiceImpl extends BaseDoServiceImpl<User, Long> implements IUserService {

    /**
     * userDao.
     */
    private final IUserDao userDao;

    /**
     * init.
     *
     * @param userDao2 user dao
     */
    public UserDoServiceImpl(final IUserDao userDao2) {
        this.userDao = userDao2;
    }

    /**
     * @return base dao
     */
    @Override
    public IBaseDao<User, Long> getBaseDao() {
        return this.userDao;
    }

    /**
     * find by page.
     *
     * @param queryBean   query
     * @param pageRequest pageRequest
     * @return page
     */
    @Override
    public Page<User> findPage(UserQueryBean queryBean, PageRequest pageRequest) {
        Specification<User> specification = Specifications.<User>and()
                .like(StringUtils.isNotEmpty(queryBean.getName()), "user_name", queryBean.getName())
                .like(StringUtils.isNotEmpty(queryBean.getDescription()), "description",
                        queryBean.getDescription())
                .build();
        return this.getBaseDao().findAll(specification, pageRequest);
    }

}
```

role service 接口：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.Role;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.query.RoleQueryBean;

public interface IRoleService extends IBaseService<Role, Long> {

    /**
     * find page by query.
     *
     * @param roleQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    Page<Role> findPage(RoleQueryBean roleQueryBean, PageRequest pageRequest);

}
```

role service 实现类：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.service.impl;

import com.github.wenhao.jpa.Specifications;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.dao.IBaseDao;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.dao.IRoleDao;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.Role;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.query.RoleQueryBean;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.service.IRoleService;

@Service
public class RoleDoServiceImpl extends BaseDoServiceImpl<Role, Long> implements IRoleService {

    /**
     * roleDao.
     */
    private final IRoleDao roleDao;

    /**
     * init.
     *
     * @param roleDao2 role dao
     */
    public RoleDoServiceImpl(final IRoleDao roleDao2) {
        this.roleDao = roleDao2;
    }

    /**
     * @return base dao
     */
    @Override
    public IBaseDao<Role, Long> getBaseDao() {
        return this.roleDao;
    }

    /**
     * find page by query.
     *
     * @param roleQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    @Override
    public Page<Role> findPage(RoleQueryBean roleQueryBean, PageRequest pageRequest) {
        Specification<Role> specification = Specifications.<Role>and()
                .like(StringUtils.isNotEmpty(roleQueryBean.getName()), "name",
                        roleQueryBean.getName())
                .like(StringUtils.isNotEmpty(roleQueryBean.getDescription()), "description",
                        roleQueryBean.getDescription())
                .build();
        return this.roleDao.findAll(specification, pageRequest);
    }

}
```

### 46.2.5 Controller

user controller：

```java
package tech.pdai.springboot.shardingjdbc.jpa.masterslave.controller;

import java.time.LocalDateTime;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.User;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.query.UserQueryBean;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.entity.response.ResponseResult;
import tech.pdai.springboot.shardingjdbc.jpa.masterslave.service.IUserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId()==null || !userService.exists(user.getId())) {
            user.setCreateTime(LocalDateTime.now());
            user.setUpdateTime(LocalDateTime.now());
            userService.save(user);
        } else {
            user.setUpdateTime(LocalDateTime.now());
            userService.update(user);
        }
        return ResponseResult.success(userService.find(user.getId()));
    }


    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.find(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User Page")
    @GetMapping("list")
    public ResponseResult<Page<User>> list(@RequestParam int pageSize, @RequestParam int pageNumber) {
        return ResponseResult.success(userService.findPage(UserQueryBean.builder().build(), PageRequest.of(pageNumber, pageSize)));
    }
}
```

### 46.2.6 简单测试

访问页面：http://localhost:8080/doc.html
- 插入数据，写入master库
![176.springboot-sharding-5.png](../../assets/images/04-主流框架/spring/176.springboot-sharding-5.png)
- (注意：主库和从库的数据同步不是shardingJDBC做的，需要自行同步)
![177.springboot-sharding-6.png](../../assets/images/04-主流框架/spring/177.springboot-sharding-6.png)
- 查询数据，从slave中查询

slave db中的数据
![178.springboot-sharding-7.png](../../assets/images/04-主流框架/spring/178.springboot-sharding-7.png)

查询结果
![179.springboot-sharding-8.png](../../assets/images/04-主流框架/spring/179.springboot-sharding-8.png)

相关查询console打印出的日志：
```sh
// pdai: 如下是插入
2022-04-06 20:44:11.045  INFO 26013 --- [nio-8080-exec-4] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2022-04-06 20:44:34.127  INFO 26013 --- [nio-8080-exec-8] ShardingSphere-SQL                       : Logic SQL: insert into tb_user (create_time, description, email, password, phone_number, update_time, user_name) values (?, ?, ?, ?, ?, ?, ?)
2022-04-06 20:44:34.127  INFO 26013 --- [nio-8080-exec-8] ShardingSphere-SQL                       : SQLStatement: CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.InsertStatement@5a160db9, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@4070419f)
2022-04-06 20:44:34.128  INFO 26013 --- [nio-8080-exec-8] ShardingSphere-SQL                       : Actual SQL: master ::: insert into tb_user (create_time, description, email, password, phone_number, update_time, user_name) values (?, ?, ?, ?, ?, ?, ?)
2022-04-06 20:44:34.184  INFO 26013 --- [nio-8080-exec-8] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.update_time as update_t7_1_0_, user0_.user_name as user_nam8_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.update_time as update_t6_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=?
2022-04-06 20:44:34.184  INFO 26013 --- [nio-8080-exec-8] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@1089fea0, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@60fc819), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@60fc819, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=541, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_0_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_0_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_0_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_0_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_0_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_0_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t7_1_0_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam8_1_0_]), ColumnProjection(owner=roles1_, name=user_id, alias=Optional[user_id1_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[role_id2_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[id1_0_2_]), ColumnProjection(owner=role2_, name=create_time, alias=Optional[create_t2_0_2_]), ColumnProjection(owner=role2_, name=description, alias=Optional[descript3_0_2_]), ColumnProjection(owner=role2_, name=name, alias=Optional[name4_0_2_]), ColumnProjection(owner=role2_, name=role_key, alias=Optional[role_key5_0_2_]), ColumnProjection(owner=role2_, name=update_time, alias=Optional[update_t6_0_2_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@456da89f, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@4f139aa4, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@10b01118, containsSubquery=false)
2022-04-06 20:44:34.184  INFO 26013 --- [nio-8080-exec-8] ShardingSphere-SQL                       : Actual SQL: slave0 ::: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.update_time as update_t7_1_0_, user0_.user_name as user_nam8_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.update_time as update_t6_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=?

// pdai: 如下是查询
2022-04-06 20:58:50.220  INFO 26013 --- [nio-8080-exec-5] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.update_time as update_t7_1_0_, user0_.user_name as user_nam8_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.update_time as update_t6_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=?
2022-04-06 20:58:50.220  INFO 26013 --- [nio-8080-exec-5] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@1089fea0, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@75ff28f7), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@75ff28f7, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=541, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_0_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_0_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_0_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_0_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_0_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_0_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t7_1_0_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam8_1_0_]), ColumnProjection(owner=roles1_, name=user_id, alias=Optional[user_id1_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[role_id2_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[id1_0_2_]), ColumnProjection(owner=role2_, name=create_time, alias=Optional[create_t2_0_2_]), ColumnProjection(owner=role2_, name=description, alias=Optional[descript3_0_2_]), ColumnProjection(owner=role2_, name=name, alias=Optional[name4_0_2_]), ColumnProjection(owner=role2_, name=role_key, alias=Optional[role_key5_0_2_]), ColumnProjection(owner=role2_, name=update_time, alias=Optional[update_t6_0_2_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@1d491acc, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@61fdb66b, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@2ee96c65, containsSubquery=false)
2022-04-06 20:58:50.220  INFO 26013 --- [nio-8080-exec-5] ShardingSphere-SQL                       : Actual SQL: slave0 ::: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.update_time as update_t7_1_0_, user0_.user_name as user_nam8_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.update_time as update_t6_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=?
```
## 46.3 进一步理解
### 46.3.1 shardingJDBC的主从分离解决不了什么问题？
- 主库和从库的数据同步。
- 主库和从库的数据同步延迟导致的数据不一致。
- 主库双写或多写。
### 46.3.2 读写分离加数据分片？
可以参考官方给的如下配置：
```yml
dataSources:
  ds0: !!org.apache.commons.dbcp.BasicDataSource
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ds0
    username: root
    password: 
  ds0_slave0: !!org.apache.commons.dbcp.BasicDataSource
      driverClassName: com.mysql.jdbc.Driver
      url: jdbc:mysql://localhost:3306/ds0_slave0
      username: root
      password: 
  ds0_slave1: !!org.apache.commons.dbcp.BasicDataSource
      driverClassName: com.mysql.jdbc.Driver
      url: jdbc:mysql://localhost:3306/ds0_slave1
      username: root
      password: 
  ds1: !!org.apache.commons.dbcp.BasicDataSource
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ds1
    username: root
    password: 
  ds1_slave0: !!org.apache.commons.dbcp.BasicDataSource
        driverClassName: com.mysql.jdbc.Driver
        url: jdbc:mysql://localhost:3306/ds1_slave0
        username: root
        password: 
  ds1_slave1: !!org.apache.commons.dbcp.BasicDataSource
        driverClassName: com.mysql.jdbc.Driver
        url: jdbc:mysql://localhost:3306/ds1_slave1
        username: root
        password: 

shardingRule:  
  tables:
    t_order: 
      actualDataNodes: ms_ds${0..1}.t_order${0..1}
      databaseStrategy:
        inline:
          shardingColumn: user_id
          algorithmExpression: ms_ds${user_id % 2}
      tableStrategy: 
        inline:
          shardingColumn: order_id
          algorithmExpression: t_order${order_id % 2}
      keyGenerator:
        type: SNOWFLAKE
        column: order_id
    t_order_item:
      actualDataNodes: ms_ds${0..1}.t_order_item${0..1}
      databaseStrategy:
        inline:
          shardingColumn: user_id
          algorithmExpression: ms_ds${user_id % 2}
      tableStrategy:
        inline:
          shardingColumn: order_id
          algorithmExpression: t_order_item${order_id % 2}  
  bindingTables:
    - t_order,t_order_item
  broadcastTables:
    - t_config
  
  defaultDataSourceName: ds0
  defaultTableStrategy:
    none:
  defaultKeyGenerator:
    type: SNOWFLAKE
    column: order_id
  
  masterSlaveRules:
      ms_ds0:
        masterDataSourceName: ds0
        slaveDataSourceNames:
          - ds0_slave0
          - ds0_slave1
        loadBalanceAlgorithmType: ROUND_ROBIN
      ms_ds1:
        masterDataSourceName: ds1
        slaveDataSourceNames: 
          - ds1_slave0
          - ds1_slave1
        loadBalanceAlgorithmType: ROUND_ROBIN
props:
  sql.show: true
```
!! 表示实例化该类
- 表示可以包含一个或多个

[] 表示数组，可以与减号相互替换使用
# 四十七、SpringBoot集成ShardingJDBC - 基于JPA的DB隔离多租户方案
## 47.1 知识准备
### 47.1.1 逻辑表？绑定表？
> <a href='https://shardingsphere.apache.org/'>如下内容来自官网</a>
- 逻辑表
  - 水平拆分的数据库（表）的相同逻辑和数据结构表的总称。例：订单数据根据主键尾数拆分为10张表，分别是t_order_0到t_order_9，他们的逻辑表名为t_order。
- 真实表
  - 在分片的数据库中真实存在的物理表。即上个示例中的t_order_0到t_order_9。
- 数据节点
  - 数据分片的最小单元。由数据源名称和数据表组成，例：ds_0.t_order_0。
- 绑定表
  - 指分片规则一致的主表和子表。例如：t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果SQL为：
```sql
SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
```
在不配置绑定表关系时，假设分片键order_id将数值10路由至第0片，将数值11路由至第1片，那么路由后的SQL应该为4条，它们呈现为笛卡尔积：
```sql
SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);

SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);

SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);

SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
```
在配置绑定表关系后，路由的SQL应该为2条：
```sql
SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);

SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
```
其中t_order在FROM的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同。
- 广播表

指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致。适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。
### 47.1.2 分片算法？分片策略？
#### 47.1.2.1 分片键
用于分片的数据库字段，是将数据库(表)水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，ShardingSphere也支持根据多个字段进行分片。
#### 47.1.2.2 分片算法
> 通过分片算法将数据分片，支持通过=、>=、<=、>、<、BETWEEN和IN分片。分片算法需要应用方开发者自行实现，可实现的灵活度非常高。

目前提供4种分片算法。由于分片算法和业务实现紧密相关，因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。
- 精确分片算法

对应PreciseShardingAlgorithm，用于处理使用单一键作为分片键的=与IN进行分片的场景。需要配合StandardShardingStrategy使用。
- 范围分片算法

对应RangeShardingAlgorithm，用于处理使用单一键作为分片键的BETWEEN AND、>、<、>=、<=进行分片的场景。需要配合StandardShardingStrategy使用。
- 复合分片算法

对应ComplexKeysShardingAlgorithm，用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合ComplexShardingStrategy使用。
- Hint分片算法

对应HintShardingAlgorithm，用于处理使用Hint行分片的场景。需要配合HintShardingStrategy使用。
![180.spring-sharding-21.png](../../assets/images/04-主流框架/spring/180.spring-sharding-21.png)
#### 47.1.2.3 分片策略
> 包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供5种分片策略。
- 标准分片策略
  - 对应StandardShardingStrategy。提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND, >, <, >=, <=分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。
- 复合分片策略
  - 对应ComplexShardingStrategy。 复合分片策略。提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。
- 行表达式分片策略
  - 对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$->{u_id % 8} 表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7。
- Hint分片策略
  - 对应HintShardingStrategy。通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略。
- 不分片策略
  - 对应NoneShardingStrategy。不分片的策略。
![181.spring-sharding-22.png](../../assets/images/04-主流框架/spring/181.spring-sharding-22.png)
### 47.1.3 SQL Hint
对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例：内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过Java API和SQL注释(待实现)两种方式使用。
- ShardingJDBC 内部结构
![182.spring-sharding-23.png](../../assets/images/04-主流框架/spring/182.spring-sharding-23.png)


- 黄色部分
  - 图中黄色部分表示的是Sharding-JDBC的入口API，采用工厂方法的形式提供。 目前有ShardingDataSourceFactory和MasterSlaveDataSourceFactory两个工厂类。ShardingDataSourceFactory用于创建分库分表或分库分表+读写分离的JDBC驱动，MasterSlaveDataSourceFactory用于创建独立使用读写分离的JDBC驱动。
- 蓝色部分
  - 图中蓝色部分表示的是Sharding-JDBC的配置对象，提供灵活多变的配置方式。 ShardingRuleConfiguration是分库分表配置的核心和入口，它可以包含多个TableRuleConfiguration和MasterSlaveRuleConfiguration。每一组相同规则分片的表配置一个TableRuleConfiguration。如果需要分库分表和读写分离共同使用，每一个读写分离的逻辑库配置一个MasterSlaveRuleConfiguration。 每个TableRuleConfiguration对应一个ShardingStrategyConfiguration，它有5中实现类可供选择。仅读写分离使用MasterSlaveRuleConfiguration即可。
- 红色部分
  - 图中红色部分表示的是内部对象，由Sharding-JDBC内部使用，应用开发者无需关注。Sharding-JDBC通过ShardingRuleConfiguration和MasterSlaveRuleConfiguration生成真正供ShardingDataSource和MasterSlaveDataSource使用的规则对象。ShardingDataSource和MasterSlaveDataSource实现了DataSource接口，是JDBC的完整实现方案。
### 47.1.4 初始化流程配置
1. Configuration对象。
2. 通过Factory对象将Configuration对象转化为Rule对象。
3. 通过Factory对象将Rule对象与DataSource对象装配。
4. Sharding-JDBC使用DataSource对象进行分库。
### 47.1.5 使用约定
在org.apache.shardingsphere.api和org.apache.shardingsphere.shardingjdbc.api 包中的类是面向用户的API，每次修改都会在release notes中明确声明。 其他包中的类属于内部实现，可能随时进行调整，请勿直接使用。
<think>首先，用户提供了一个关于SpringBoot集成ShardingJDBC的按字段分库的示例，要求整理成markdown格式。格式要求以"## 47.2 简单示例"开头，后面的编号继续往下，例如"### 47.2.1"。

我需要回顾之前的对话历史。在历史中，第一个示例是45.2，第二个是46.2，所以这个应该是47.2。用户指定了"## 47.2 简单示例"，所以我应该从这里开始。

内容是关于按字段分库的两种策略：标准分片策略和行表达式分片策略。基于JPA方式。

用户提供了以下部分：
- 准备DB和依赖配置
- Entity
- DAO
- Service
- Controller

我需要将这些内容组织成markdown格式，使用标题层次结构。

标题结构应该是：
- ## 47.2 简单示例
- 然后子标题如### 47.2.1 准备DB和依赖配置
- 继续编号，如### 47.2.2 Entity 等。

从用户输入中，内容已经分成了几个部分：
1. 准备DB和依赖配置
2. Entity
3. DAO
4. Service
5. Controller

我需要为每个部分创建子标题。

用户输入中有一些代码块和SQL，我需要确保它们被正确格式化为代码块。

用户输入的开头是："简单示例这里主要介绍SpringBoot集成基于ShardingJDBC的按字段分库，两种策略（标准分片策略 和 行表达式分片策略），主要承接之前的相关文章在JPA方式的基础上实现的。"

我应该将这个描述放在## 47.2 简单示例下面，作为介绍。

然后，按照用户提供的顺序组织内容。

用户输入中有SQL文件和代码，我需要将它们放入代码块中。

在之前的响应中，我使用了```sql和```java等来格式化代码。

现在，编号应该是47.2，因为之前的对话中，第一个是45.2，第二个是46.2，所以这个是47.2。

用户说："整理为markdown格式，以## 47.2 简单示例开头后面按照编号排序，例如### 47.2.1"

所以，我需要：
- ## 47.2 简单示例
- 然后是子标题，如### 47.2.1 准备DB和依赖配置
- ### 47.2.2 Entity
- 等等。

用户输入中，部分内容有重复或相似的结构，我需要保持原样。

用户输入中有两个SQL文件：test_db_tenant_a 和 test_db_tenant_b，我应该将它们分别放在代码块中。

在依赖配置部分，有maven依赖和yml配置。

在Entity部分，有user和role的entity代码。

在DAO部分，有user和role的dao接口。

在Service部分，有user和role的service接口和实现类。

在Controller部分，有user controller。

我需要确保代码块使用正确的语言标记。

最后，用户输入以"# 简单测试"结束，但没有具体内容，只有"访问页面：http://localhost:8080/doc.html"，我应该将其作为一个部分。

用户输入的最后是："整理为markdown格式，以## 47.2 简单示例开头后面按照编号排序，例如### 47.2.1"

所以，我需要从### 47.2.1开始编号。

让我列出所有部分：

1. 介绍（放在## 47.2 简单示例下）
2. 准备DB和依赖配置
3. Entity
4. DAO
5. Service
6. Controller
7. 简单测试

所以，子标题可以是：
- ### 47.2.1 准备DB和依赖配置
- ### 47.2.2 Entity
- ### 47.2.3 DAO
- ### 47.2.4 Service
- ### 47.2.5 Controller
- ### 47.2.6 简单测试

现在，构建markdown响应。

首先，## 47.2 简单示例，然后介绍文本。

然后，每个子标题。

在代码块中，使用正确的语言。

例如，SQL文件用```sql，Java代码用```java，yml用```yaml。

用户输入中，SQL文件有注释和结构，我应该保持原样。

在依赖部分，maven依赖是XML，yml配置是YAML。

在Entity部分，有两个entity类：User和Role。

在DAO部分，有两个dao接口。

在Service部分，有接口和实现类。

在Controller部分，有一个controller。

我需要将它们分别放入代码块。

确保格式正确。

现在，写出响应。</think>## 47.2 简单示例

这里主要介绍SpringBoot集成基于ShardingJDBC的按字段分库，两种策略（标准分片策略 和 行表达式分片策略），主要承接之前的相关文章在JPA方式的基础上实现的。

### 47.2.1 准备DB和依赖配置

创建MySQL的schema test_db_tenant_a 和 test_db_tenant_b，导入SQL文件如下：

test_db_tenant_a：

```sql
-- MySQL dump 10.13  Distrib 8.0.28, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db_tenant_a
-- ------------------------------------------------------
-- Server version	8.0.28

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role` (
  `id` bigint NOT NULL,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `tenant` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `id` bigint NOT NULL,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `tenant` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role` (
  `id` bigint NOT NULL,
  `user_id` bigint NOT NULL,
  `role_id` bigint NOT NULL,
  `tenant` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-04-07 20:28:34
```

test_db_tenant_b：

```sql
-- MySQL dump 10.13  Distrib 8.0.28, for Win64 (x86_64)
--
-- Host: localhost    Database: test_db_tenant_b
-- ------------------------------------------------------
-- Server version	8.0.28

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_role` (
  `id` bigint NOT NULL,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `tenant` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `id` bigint NOT NULL,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `tenant` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user_role` (
  `id` bigint NOT NULL,
  `user_id` bigint NOT NULL,
  `role_id` bigint NOT NULL,
  `tenant` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-04-07 20:28:29
```

引入maven依赖，包含mysql驱动、JPA包，以及sharding-jdbc的依赖：

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>com.github.wenhao</groupId>
    <artifactId>jpa-spec</artifactId>
    <version>3.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
    <version>4.1.1</version>
</dependency>
```

增加yml配置：

```yaml
spring:
  shardingsphere:
    datasource:
      names: tenant-a,tenant-b
      tenant-a:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_tenant_a?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
      tenant-b:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_tenant_b?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
    sharding:
      default-database-strategy:
        # way 1: standard strategy
        # standard:
        #  precise-algorithm-class-name: tech.pdai.springboot.shardingjdbc.jpa.tenant.db.config.MyPreciseShardingDBAlgorithm
        #  sharding-column: tenant
        # way 2: inline strategy
        inline:
          sharding-column: tenant
          algorithm-expression: tenant-$->{tenant}
      tables:
        tb_user:
          actual-data-nodes: tenant-${['a','b']}.tb_user
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_role:
          actual-data-nodes: tenant-${['a','b']}.tb_role
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_user_role:
          actual-data-nodes: tenant-${['a','b']}.tb_user_role
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
      binding-tables: tb_user,tb_role,tb_user_role
    props:
      sql:
        show: true
  jpa:
    open-in-view: false
    generate-ddl: false
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true
        use-new-id-generator-mappings: false
```

### 47.2.2 Entity

user entity：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity;

import java.time.LocalDateTime;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * @author pdai
 */
@Getter
@Setter
@ToString
@Entity
@Table(name = "tb_user")
public class User implements BaseEntity {

    /**
     * user id.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * username.
     */
    private String userName;

    /**
     * user pwd.
     */
    private String password;

    /**
     * email.
     */
    private String email;

    /**
     * phoneNumber.
     */
    private long phoneNumber;

    /**
     * description.
     */
    private String description;

    /**
     * create date time.
     */
    private LocalDateTime createTime;

    /**
     * update date time.
     */
    private LocalDateTime updateTime;

    /**
     * tenant.
     */
    private String tenant;

    /**
     * join to role table.
     */
    @ManyToMany(cascade = {CascadeType.REFRESH}, fetch = FetchType.EAGER)
    @JoinTable(name = "tb_user_role", joinColumns = {
            @JoinColumn(name = "user_id")}, inverseJoinColumns = {@JoinColumn(name = "role_id")})
    private Set<Role> roles;

}
```

role entity：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.persistence.*;
import java.time.LocalDateTime;

/**
 * @author pdai
 */
@Getter
@Setter
@ToString
@Entity
@Table(name = "tb_role")
public class Role implements BaseEntity {

    /**
     * role id.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * role name.
     */
    private String name;

    /**
     * role key.
     */
    private String roleKey;

    /**
     * description.
     */
    private String description;

    /**
     * create date time.
     */
    private LocalDateTime createTime;

    /**
     * update date time.
     */
    private LocalDateTime updateTime;

    /**
     * tenant.
     */
    private String tenant;

}
```

### 47.2.3 DAO

user dao：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.User;

/**
 * @author pdai
 */
@Repository
public interface IUserDao extends IBaseDao<User, Long> {

}
```

role dao：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.dao;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.Role;

/**
 * @author pdai
 */
@Repository
public interface IRoleDao extends IBaseDao<Role, Long> {

}
```

### 47.2.4 Service

user service 接口：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.User;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.query.UserQueryBean;

/**
 * @author pdai
 */
public interface IUserService extends IBaseService<User, Long> {

    /**
     * find by page.
     *
     * @param userQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    Page<User> findPage(UserQueryBean userQueryBean, PageRequest pageRequest);

}
```

user service 实现类：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service.impl;

import com.github.wenhao.jpa.Specifications;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.dao.IBaseDao;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.dao.IUserDao;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.User;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.query.UserQueryBean;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service.IUserService;

@Service
public class UserDoServiceImpl extends BaseDoServiceImpl<User, Long> implements IUserService {

    /**
     * userDao.
     */
    private final IUserDao userDao;

    /**
     * init.
     *
     * @param userDao2 user dao
     */
    public UserDoServiceImpl(final IUserDao userDao2) {
        this.userDao = userDao2;
    }

    /**
     * @return base dao
     */
    @Override
    public IBaseDao<User, Long> getBaseDao() {
        return this.userDao;
    }

    /**
     * find by page.
     *
     * @param queryBean   query
     * @param pageRequest pageRequest
     * @return page
     */
    @Override
    public Page<User> findPage(UserQueryBean queryBean, PageRequest pageRequest) {
        Specification<User> specification = Specifications.<User>and()
                .eq(StringUtils.isNotEmpty(queryBean.getTenant()), "tenant", queryBean.getTenant())
                .like(StringUtils.isNotEmpty(queryBean.getName()), "user_name", queryBean.getName())
                .like(StringUtils.isNotEmpty(queryBean.getDescription()), "description",
                        queryBean.getDescription())
                .build();
        return this.getBaseDao().findAll(specification, pageRequest);
    }

}
```

role service 接口：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.Role;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.query.RoleQueryBean;

public interface IRoleService extends IBaseService<Role, Long> {

    /**
     * find page by query.
     *
     * @param roleQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    Page<Role> findPage(RoleQueryBean roleQueryBean, PageRequest pageRequest);

}
```

role service 实现类：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service.impl;

import com.github.wenhao.jpa.Specifications;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.dao.IBaseDao;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.dao.IRoleDao;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.Role;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.query.RoleQueryBean;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service.IRoleService;

@Service
public class RoleDoServiceImpl extends BaseDoServiceImpl<Role, Long> implements IRoleService {

    /**
     * roleDao.
     */
    private final IRoleDao roleDao;

    /**
     * init.
     *
     * @param roleDao2 role dao
     */
    public RoleDoServiceImpl(final IRoleDao roleDao2) {
        this.roleDao = roleDao2;
    }

    /**
     * @return base dao
     */
    @Override
    public IBaseDao<Role, Long> getBaseDao() {
        return this.roleDao;
    }

    /**
     * find page by query.
     *
     * @param roleQueryBean query
     * @param pageRequest   pageRequest
     * @return page
     */
    @Override
    public Page<Role> findPage(RoleQueryBean roleQueryBean, PageRequest pageRequest) {
        Specification<Role> specification = Specifications.<Role>and()
                .eq(StringUtils.isNotEmpty(roleQueryBean.getTenant()), "tenant", roleQueryBean.getTenant())
                .like(StringUtils.isNotEmpty(roleQueryBean.getName()), "name",
                        roleQueryBean.getName())
                .like(StringUtils.isNotEmpty(roleQueryBean.getDescription()), "description",
                        roleQueryBean.getDescription())
                .build();
        return this.roleDao.findAll(specification, pageRequest);
    }

}
```

### 47.2.5 Controller

user controller：

```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.controller;

import java.time.LocalDateTime;

import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.User;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.query.UserQueryBean;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.entity.response.ResponseResult;
import tech.pdai.springboot.shardingjdbc.jpa.tenant.db.service.IUserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add/Edit User")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        if (user.getId()==null || !userService.exists(user.getId())) {
            user.setCreateTime(LocalDateTime.now());
            user.setUpdateTime(LocalDateTime.now());
            userService.save(user);
        } else {
            user.setUpdateTime(LocalDateTime.now());
            userService.update(user);
        }
        return ResponseResult.success(userService.find(user.getId()));
    }


    /**
     * @return user list
     */
    @ApiOperation("Query User One")
    @GetMapping("edit/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") Long userId) {
        return ResponseResult.success(userService.find(userId));
    }

    /**
     * @return user list
     */
    @ApiOperation("Query User Page")
    @GetMapping("list")
    public ResponseResult<Page<User>> list(@RequestParam int pageSize, @RequestParam int pageNumber, String tenant) {
        return ResponseResult.success(userService.findPage(UserQueryBean.builder().tenant(tenant).build(), PageRequest.of(pageNumber, pageSize)));
    }
}
```

### 47.2.6 简单测试

访问页面：http://localhost:8080/doc.html

- 插入数据
![187.springboot-sharding-x1.png](../../assets/images/04-主流框架/spring/187.springboot-sharding-x1.png)
- DB 中对应schema中的数据
![188.springboot-sharding-x2.png](../../assets/images/04-主流框架/spring/188.springboot-sharding-x2.png)
- 查询数据
![189.springboot-sharding-x3.png](../../assets/images/04-主流框架/spring/189.springboot-sharding-x3.png)
- 相关查询console打印出的日志：
```sh
2022-04-08 20:58:35.755  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Logic SQL: insert into tb_user (create_time, description, email, password, phone_number, tenant, update_time, user_name) values (?, ?, ?, ?, ?, ?, ?, ?)
2022-04-08 20:58:35.755  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : SQLStatement: InsertStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.InsertStatement@67776a98, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@1d5f5394), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@1d5f5394, columnNames=[create_time, description, email, password, phone_number, tenant, update_time, user_name], insertValueContexts=[InsertValueContext(parametersCount=8, valueExpressions=[ParameterMarkerExpressionSegment(startIndex=118, stopIndex=118, parameterMarkerIndex=0), ParameterMarkerExpressionSegment(startIndex=121, stopIndex=121, parameterMarkerIndex=1), ParameterMarkerExpressionSegment(startIndex=124, stopIndex=124, parameterMarkerIndex=2), ParameterMarkerExpressionSegment(startIndex=127, stopIndex=127, parameterMarkerIndex=3), ParameterMarkerExpressionSegment(startIndex=130, stopIndex=130, parameterMarkerIndex=4), ParameterMarkerExpressionSegment(startIndex=133, stopIndex=133, parameterMarkerIndex=5), ParameterMarkerExpressionSegment(startIndex=136, stopIndex=136, parameterMarkerIndex=6), ParameterMarkerExpressionSegment(startIndex=139, stopIndex=139, parameterMarkerIndex=7), DerivedParameterMarkerExpressionSegment(super=ParameterMarkerExpressionSegment(startIndex=0, stopIndex=0, parameterMarkerIndex=8))], parameters=[2022-04-08 20:58:35.323, pdai-b, pdai2@pdai.tech, dad23b, 1212121212, b, 2022-04-08 20:58:35.323, pdai23b])], generatedKeyContext=Optional[GeneratedKeyContext(columnName=id, generated=true, generatedValues=[719173465277968384])])
2022-04-08 20:58:35.755  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Actual SQL: tenant-b ::: insert into tb_user (create_time, description, email, password, phone_number, tenant, update_time, user_name, id) values (?, ?, ?, ?, ?, ?, ?, ?, ?) ::: [2022-04-08 20:58:35.323, pdai-b, pdai2@pdai.tech, dad23b, 1212121212, b, 2022-04-08 20:58:35.323, pdai23b, 719173465277968384]
2022-04-08 20:58:35.849  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.tenant as tenant7_1_0_, user0_.update_time as update_t8_1_0_, user0_.user_name as user_nam9_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.tenant as tenant6_0_2_, role2_.update_time as update_t7_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=?
2022-04-08 20:58:35.849  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@8ca5ff1, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@120db4fa), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@120db4fa, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=603, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_0_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_0_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_0_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_0_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_0_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_0_]), ColumnProjection(owner=user0_, name=tenant, alias=Optional[tenant7_1_0_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t8_1_0_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam9_1_0_]), ColumnProjection(owner=roles1_, name=user_id, alias=Optional[user_id1_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[role_id2_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[id1_0_2_]), ColumnProjection(owner=role2_, name=create_time, alias=Optional[create_t2_0_2_]), ColumnProjection(owner=role2_, name=description, alias=Optional[descript3_0_2_]), ColumnProjection(owner=role2_, name=name, alias=Optional[name4_0_2_]), ColumnProjection(owner=role2_, name=role_key, alias=Optional[role_key5_0_2_]), ColumnProjection(owner=role2_, name=tenant, alias=Optional[tenant6_0_2_]), ColumnProjection(owner=role2_, name=update_time, alias=Optional[update_t7_0_2_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@419cdd89, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@5c35abd5, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@6da5275, containsSubquery=false)
2022-04-08 20:58:35.849  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Actual SQL: tenant-b ::: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.tenant as tenant7_1_0_, user0_.update_time as update_t8_1_0_, user0_.user_name as user_nam9_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.tenant as tenant6_0_2_, role2_.update_time as update_t7_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=? ::: [719173465277968384]
2022-04-08 20:58:35.849  INFO 8256 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.tenant as tenant7_1_0_, user0_.update_time as update_t8_1_0_, user0_.user_name as user_nam9_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.tenant as tenant6_0_2_, role2_.update_time as update_t7_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=? ::: [719173465277968384]
2022-04-08 21:03:33.876  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_, user0_.create_time as create_t2_1_, user0_.description as descript3_1_, user0_.email as email4_1_, user0_.password as password5_1_, user0_.phone_number as phone_nu6_1_, user0_.tenant as tenant7_1_, user0_.update_time as update_t8_1_, user0_.user_name as user_nam9_1_ from tb_user user0_ where user0_.tenant=? limit ?
2022-04-08 21:03:33.877  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@15243518, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@23f84ca7), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@23f84ca7, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=293, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_]), ColumnProjection(owner=user0_, name=tenant, alias=Optional[tenant7_1_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t8_1_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam9_1_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@18e2796e, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@6a16cbdf, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@5eaeaf70, containsSubquery=false)
2022-04-08 21:03:33.877  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-b ::: select user0_.id as id1_1_, user0_.create_time as create_t2_1_, user0_.description as descript3_1_, user0_.email as email4_1_, user0_.password as password5_1_, user0_.phone_number as phone_nu6_1_, user0_.tenant as tenant7_1_, user0_.update_time as update_t8_1_, user0_.user_name as user_nam9_1_ from tb_user user0_ where user0_.tenant=? limit ? ::: [b, 10]
2022-04-08 21:03:33.890  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Logic SQL: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.tenant as tenant6_0_1_, role1_.update_time as update_t7_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=?
2022-04-08 21:03:33.890  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@5e7c4e50, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@6f2681ce), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@6f2681ce, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=302, distinctRow=false, projections=[ColumnProjection(owner=roles0_, name=user_id, alias=Optional[user_id1_2_0_]), ColumnProjection(owner=roles0_, name=role_id, alias=Optional[role_id2_2_0_]), ColumnProjection(owner=role1_, name=id, alias=Optional[id1_0_1_]), ColumnProjection(owner=role1_, name=create_time, alias=Optional[create_t2_0_1_]), ColumnProjection(owner=role1_, name=description, alias=Optional[descript3_0_1_]), ColumnProjection(owner=role1_, name=name, alias=Optional[name4_0_1_]), ColumnProjection(owner=role1_, name=role_key, alias=Optional[role_key5_0_1_]), ColumnProjection(owner=role1_, name=tenant, alias=Optional[tenant6_0_1_]), ColumnProjection(owner=role1_, name=update_time, alias=Optional[update_t7_0_1_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@3212b90b, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@516424e5, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@6d56fe57, containsSubquery=false)
2022-04-08 21:03:33.890  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-b ::: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.tenant as tenant6_0_1_, role1_.update_time as update_t7_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=? ::: [719173465277968384]
2022-04-08 21:03:33.890  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.tenant as tenant6_0_1_, role1_.update_time as update_t7_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=? ::: [719173465277968384]
```
## 47.3 进一步理解
### 47.3.1 如果使用standard策略如何？
> 上述inline策略也可以改成standard策略，效果一样。

首先自定义PreciseShardingAlgorithm算法：
```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.db.config;

import java.util.Collection;

import org.apache.shardingsphere.api.sharding.standard.PreciseShardingAlgorithm;
import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;

/**
 * This class is for MyPreciseShardingDBAlgorithm.
 *
 * @author pdai
 */
public class MyPreciseShardingDBAlgorithm implements PreciseShardingAlgorithm<String> {

    private static final String DATABASE_TENANT_PREFIX = "tenant-";

    /**
     * @param availableTargetNames tenant-a, tenant-b
     * @param shardingValue        sharding value
     * @return targetDb
     */
    @Override
    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<String> shardingValue) {
        String targetDb = DATABASE_TENANT_PREFIX + shardingValue.getValue();
        if (availableTargetNames.contains(targetDb)) {
            return targetDb;
        }

        throw new UnsupportedOperationException("UnsupportedOperationException: " + shardingValue.getValue());
    }
}
```
然后配置sharding.default-database-strategy为standard，具体如下
```yml
spring:
  shardingsphere:
    datasource:
      names: tenant-a,tenant-b
      tenant-a:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_tenant_a?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
      tenant-b:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_tenant_b?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
    sharding:
      default-database-strategy:
        # way 1: standard strategy
        standard:
          precise-algorithm-class-name: tech.pdai.springboot.shardingjdbc.jpa.tenant.db.config.MyPreciseShardingDBAlgorithm
          sharding-column: tenant
        # way 2: inline strategy
#        inline:
#          sharding-column: tenant
#          algorithm-expression: tenant-$->{tenant}
      tables:
        tb_user:
          actual-data-nodes: tenant-${['a','b']}.tb_user
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_role:
          actual-data-nodes: tenant-${['a','b']}.tb_role
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_user_role:
          actual-data-nodes: tenant-${['a','b']}.tb_user_role
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
      binding-tables: tb_user,tb_role,tb_user_role
    props:
      sql:
        show: true
  jpa:
    open-in-view: false
    generate-ddl: false
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true
        use-new-id-generator-mappings: false

```
### 47.3.2 上述两种策略存在什么问题？
- 侵入性： DB层和代码层

上述两种模式需要增加一个新的字段tenant, 并且根据这个字段来对不同租户进行sharding（db级别或者table级别）； 这时候你会发现所有的查询必须要有tenant这个字段，这意味着所有的方法都支持tenant查询。一旦没有全部支持，你会看到Actual SQL会执行多次（每个DB一次）：
```sh
2022-04-08 21:03:33.890  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-b ::: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.tenant as tenant6_0_1_, role1_.update_time as update_t7_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=? ::: [719173465277968384]
2022-04-08 21:03:33.890  INFO 8256 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.tenant as tenant6_0_1_, role1_.update_time as update_t7_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=? ::: [719173465277968384]
```
- 租户之外的数据

比如系统级别的管理人员数据，元数据等，需要独立一个DB； 虽然可以通过一些配置来解决一些场景，但是上述两种方式的动态性不够（场景变动意味着推翻这两种模式）。
### 47.3.3 如何使用Hint强制路由方式？
> 针对侵入性的问题，就多租户的场景下而言，可以通过Hint强制路由策略解决。

首先我们需要定义个拦截的APO切面, 对数据操作层进行拦截。通过hintManager设置ShardingValue, 实际环境将client信息放在xxxContext中（由ThreadLocal承接），并通过client-id来获取tenant。
```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.dbhint.config;

import org.apache.shardingsphere.api.hint.HintManager;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * @author pdai
 */
@Aspect
@Order(1)
@Component
public class TenantDatasourceAspect {

    /**
     * point cut.
     */
    @Pointcut("execution(* tech.pdai.springboot.shardingjdbc.jpa.tenant.dbhint.dao.*.*(..))")
    public void useTenantDSPointCut() {
        // no impl
    }

    @Before("useTenantDSPointCut()")
    public void doDs0Before() {
        HintManager.clear();
        HintManager hintManager = HintManager.getInstance();
        // pdai: 实际环境将client信息放在xxxContext中（由ThreadLocal承接），并通过client-id来获取tenant.
        // 这里为了方便演示，只是使用了tenant-a
        hintManager.setDatabaseShardingValue("tenant-a");
    }

    @After("useTenantDSPointCut()")
    public void doDs0after() {
        HintManager.clear();
    }

}
```
然后自定义HintShardingAlgorithm实现类
```java
package tech.pdai.springboot.shardingjdbc.jpa.tenant.dbhint.config;

import java.util.Collection;
import java.util.stream.Collectors;

import org.apache.shardingsphere.api.sharding.hint.HintShardingAlgorithm;
import org.apache.shardingsphere.api.sharding.hint.HintShardingValue;

/**
 * @author pdai
 */
public class MyHintShardingDBAlgorithm implements HintShardingAlgorithm<String> {

    /**
     * Sharding.
     *
     * <p>sharding value injected by hint, not in SQL.</p>
     *
     * @param availableTargetNames available data sources or tables's names
     * @param shardingValue        sharding value
     * @return sharding result for data sources or tables's names
     */
    @Override
    public Collection<String> doSharding(Collection<String> availableTargetNames, HintShardingValue<String> shardingValue) {
        return shardingValue.getValues().stream().filter(availableTargetNames::contains).collect(Collectors.toList());
    }
}
```
在配置中配置sharding.default-database-strategy为inline
```yml
spring:
  shardingsphere:
    datasource:
      names: tenant-a,tenant-b
      tenant-a:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_tenant_a?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
      tenant-b:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/test_db_tenant_b?allowPublicKeyRetrieval=true&useSSL=false&autoReconnect=true&characterEncoding=utf8
        username: root
        password: bfXa4Pt2lUUScy8jakXf
    sharding:
      default-database-strategy:
        hint:
          algorithm-class-name: tech.pdai.springboot.shardingjdbc.jpa.tenant.dbhint.config.MyHintShardingDBAlgorithm
      tables:
        tb_user:
          actual-data-nodes: tenant-${['a','b']}.tb_user
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_role:
          actual-data-nodes: tenant-${['a','b']}.tb_role
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
        tb_user_role:
          actual-data-nodes: tenant-${['a','b']}.tb_user_role
          key-generator:
            column: id
            type: SNOWFLAKE
            props:
              worker:
                id: 123
      binding-tables: tb_user,tb_role,tb_user_role
    props:
      sql:
        show: true
  jpa:
    open-in-view: false
    generate-ddl: false
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true
        use-new-id-generator-mappings: false
```
访问页面：

http://localhost:8080/doc.html

插入数据，会进入hint策略对应的算法
![183.springboot-sharding-x4.png](../../assets/images/04-主流框架/spring/183.springboot-sharding-x4.png)

成功插入数据(因为我们上面hintManager中是tenant-a)
![184.springboot-sharding-x5.png](../../assets/images/04-主流框架/spring/184.springboot-sharding-x5.png)

DB 中对应schema中的数据
![185.springboot-sharding-x6.png](../../assets/images/04-主流框架/spring/185.springboot-sharding-x6.png)

查询数据
![186.springboot-sharding-x7.png](../../assets/images/04-主流框架/spring/186.springboot-sharding-x7.png)

执行console log
```sh
2022-04-08 21:38:49.473  INFO 13136 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Logic SQL: insert into tb_user (create_time, description, email, password, phone_number, update_time, user_name) values (?, ?, ?, ?, ?, ?, ?)
2022-04-08 21:38:49.473  INFO 13136 --- [nio-8080-exec-1] ShardingSphere-SQL                       : SQLStatement: InsertStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.InsertStatement@3f8ce2d6, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@7845fc58), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@7845fc58, columnNames=[create_time, description, email, password, phone_number, update_time, user_name], insertValueContexts=[InsertValueContext(parametersCount=7, valueExpressions=[ParameterMarkerExpressionSegment(startIndex=110, stopIndex=110, parameterMarkerIndex=0), ParameterMarkerExpressionSegment(startIndex=113, stopIndex=113, parameterMarkerIndex=1), ParameterMarkerExpressionSegment(startIndex=116, stopIndex=116, parameterMarkerIndex=2), ParameterMarkerExpressionSegment(startIndex=119, stopIndex=119, parameterMarkerIndex=3), ParameterMarkerExpressionSegment(startIndex=122, stopIndex=122, parameterMarkerIndex=4), ParameterMarkerExpressionSegment(startIndex=125, stopIndex=125, parameterMarkerIndex=5), ParameterMarkerExpressionSegment(startIndex=128, stopIndex=128, parameterMarkerIndex=6), DerivedParameterMarkerExpressionSegment(super=ParameterMarkerExpressionSegment(startIndex=0, stopIndex=0, parameterMarkerIndex=7))], parameters=[2022-04-08 21:37:45.061, pdai-hint-a, pdai2@pdai.tech, dad23i-hint-a, 0, 2022-04-08 21:37:45.061, pdai23i-hint-a])], generatedKeyContext=Optional[GeneratedKeyContext(columnName=id, generated=true, generatedValues=[719183321087062016])])
2022-04-08 21:38:49.473  INFO 13136 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: insert into tb_user (create_time, description, email, password, phone_number, update_time, user_name, id) values (?, ?, ?, ?, ?, ?, ?, ?) ::: [2022-04-08 21:37:45.061, pdai-hint-a, pdai2@pdai.tech, dad23i-hint-a, 0, 2022-04-08 21:37:45.061, pdai23i-hint-a, 719183321087062016]
2022-04-08 21:38:53.287  INFO 13136 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.update_time as update_t7_1_0_, user0_.user_name as user_nam8_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.update_time as update_t6_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=?
2022-04-08 21:38:53.287  INFO 13136 --- [nio-8080-exec-1] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@602d359e, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@3bf8fb09), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@3bf8fb09, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=541, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_0_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_0_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_0_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_0_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_0_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_0_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t7_1_0_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam8_1_0_]), ColumnProjection(owner=roles1_, name=user_id, alias=Optional[user_id1_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[role_id2_2_1_]), ColumnProjection(owner=role2_, name=id, alias=Optional[id1_0_2_]), ColumnProjection(owner=role2_, name=create_time, alias=Optional[create_t2_0_2_]), ColumnProjection(owner=role2_, name=description, alias=Optional[descript3_0_2_]), ColumnProjection(owner=role2_, name=name, alias=Optional[name4_0_2_]), ColumnProjection(owner=role2_, name=role_key, alias=Optional[role_key5_0_2_]), ColumnProjection(owner=role2_, name=update_time, alias=Optional[update_t6_0_2_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@17cddd9a, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@43769c72, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@4afed047, containsSubquery=false)
2022-04-08 21:38:53.287  INFO 13136 --- [nio-8080-exec-1] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select user0_.id as id1_1_0_, user0_.create_time as create_t2_1_0_, user0_.description as descript3_1_0_, user0_.email as email4_1_0_, user0_.password as password5_1_0_, user0_.phone_number as phone_nu6_1_0_, user0_.update_time as update_t7_1_0_, user0_.user_name as user_nam8_1_0_, roles1_.user_id as user_id1_2_1_, role2_.id as role_id2_2_1_, role2_.id as id1_0_2_, role2_.create_time as create_t2_0_2_, role2_.description as descript3_0_2_, role2_.name as name4_0_2_, role2_.role_key as role_key5_0_2_, role2_.update_time as update_t6_0_2_ from tb_user user0_ left outer join tb_user_role roles1_ on user0_.id=roles1_.user_id left outer join tb_role role2_ on roles1_.role_id=role2_.id where user0_.id=? ::: [719183321087062016]
2022-04-08 21:39:26.996  INFO 13136 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_, user0_.create_time as create_t2_1_, user0_.description as descript3_1_, user0_.email as email4_1_, user0_.password as password5_1_, user0_.phone_number as phone_nu6_1_, user0_.update_time as update_t7_1_, user0_.user_name as user_nam8_1_ from tb_user user0_ where 1=1 limit ?
2022-04-08 21:39:26.997  INFO 13136 --- [nio-8080-exec-2] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@2dbe7c04, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@7ce6951d), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@7ce6951d, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=264, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t7_1_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam8_1_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@77b55ac4, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@765e7ff9, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@28de736a, containsSubquery=false)
2022-04-08 21:39:26.997  INFO 13136 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select user0_.id as id1_1_, user0_.create_time as create_t2_1_, user0_.description as descript3_1_, user0_.email as email4_1_, user0_.password as password5_1_, user0_.phone_number as phone_nu6_1_, user0_.update_time as update_t7_1_, user0_.user_name as user_nam8_1_ from tb_user user0_ where 1=1 limit ? ::: [10]
2022-04-08 21:39:27.004  INFO 13136 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Logic SQL: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.update_time as update_t6_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=?
2022-04-08 21:39:27.005  INFO 13136 --- [nio-8080-exec-2] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@17b5967d, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@7ac1dcb9), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@7ac1dcb9, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=271, distinctRow=false, projections=[ColumnProjection(owner=roles0_, name=user_id, alias=Optional[user_id1_2_0_]), ColumnProjection(owner=roles0_, name=role_id, alias=Optional[role_id2_2_0_]), ColumnProjection(owner=role1_, name=id, alias=Optional[id1_0_1_]), ColumnProjection(owner=role1_, name=create_time, alias=Optional[create_t2_0_1_]), ColumnProjection(owner=role1_, name=description, alias=Optional[descript3_0_1_]), ColumnProjection(owner=role1_, name=name, alias=Optional[name4_0_1_]), ColumnProjection(owner=role1_, name=role_key, alias=Optional[role_key5_0_1_]), ColumnProjection(owner=role1_, name=update_time, alias=Optional[update_t6_0_1_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@68d9e73a, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@6331421f, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@580c367a, containsSubquery=false)
2022-04-08 21:39:27.005  INFO 13136 --- [nio-8080-exec-2] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.update_time as update_t6_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=? ::: [719183321087062016]
2022-04-08 21:40:28.220  INFO 13136 --- [nio-8080-exec-4] ShardingSphere-SQL                       : Logic SQL: select user0_.id as id1_1_, user0_.create_time as create_t2_1_, user0_.description as descript3_1_, user0_.email as email4_1_, user0_.password as password5_1_, user0_.phone_number as phone_nu6_1_, user0_.update_time as update_t7_1_, user0_.user_name as user_nam8_1_ from tb_user user0_ where 1=1 limit ?
2022-04-08 21:40:28.220  INFO 13136 --- [nio-8080-exec-4] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@2dbe7c04, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@5c74176f), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@5c74176f, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=264, distinctRow=false, projections=[ColumnProjection(owner=user0_, name=id, alias=Optional[id1_1_]), ColumnProjection(owner=user0_, name=create_time, alias=Optional[create_t2_1_]), ColumnProjection(owner=user0_, name=description, alias=Optional[descript3_1_]), ColumnProjection(owner=user0_, name=email, alias=Optional[email4_1_]), ColumnProjection(owner=user0_, name=password, alias=Optional[password5_1_]), ColumnProjection(owner=user0_, name=phone_number, alias=Optional[phone_nu6_1_]), ColumnProjection(owner=user0_, name=update_time, alias=Optional[update_t7_1_]), ColumnProjection(owner=user0_, name=user_name, alias=Optional[user_nam8_1_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@19769285, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@2caf7930, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@28258a73, containsSubquery=false)
2022-04-08 21:40:28.220  INFO 13136 --- [nio-8080-exec-4] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select user0_.id as id1_1_, user0_.create_time as create_t2_1_, user0_.description as descript3_1_, user0_.email as email4_1_, user0_.password as password5_1_, user0_.phone_number as phone_nu6_1_, user0_.update_time as update_t7_1_, user0_.user_name as user_nam8_1_ from tb_user user0_ where 1=1 limit ? ::: [10]
2022-04-08 21:40:28.221  INFO 13136 --- [nio-8080-exec-4] ShardingSphere-SQL                       : Logic SQL: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.update_time as update_t6_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=?
2022-04-08 21:40:28.221  INFO 13136 --- [nio-8080-exec-4] ShardingSphere-SQL                       : SQLStatement: SelectStatementContext(super=CommonSQLStatementContext(sqlStatement=org.apache.shardingsphere.sql.parser.sql.statement.dml.SelectStatement@17b5967d, tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@14ffd315), tablesContext=org.apache.shardingsphere.sql.parser.binder.segment.table.TablesContext@14ffd315, projectionsContext=ProjectionsContext(startIndex=7, stopIndex=271, distinctRow=false, projections=[ColumnProjection(owner=roles0_, name=user_id, alias=Optional[user_id1_2_0_]), ColumnProjection(owner=roles0_, name=role_id, alias=Optional[role_id2_2_0_]), ColumnProjection(owner=role1_, name=id, alias=Optional[id1_0_1_]), ColumnProjection(owner=role1_, name=create_time, alias=Optional[create_t2_0_1_]), ColumnProjection(owner=role1_, name=description, alias=Optional[descript3_0_1_]), ColumnProjection(owner=role1_, name=name, alias=Optional[name4_0_1_]), ColumnProjection(owner=role1_, name=role_key, alias=Optional[role_key5_0_1_]), ColumnProjection(owner=role1_, name=update_time, alias=Optional[update_t6_0_1_])]), groupByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.groupby.GroupByContext@6aff8332, orderByContext=org.apache.shardingsphere.sql.parser.binder.segment.select.orderby.OrderByContext@32acce81, paginationContext=org.apache.shardingsphere.sql.parser.binder.segment.select.pagination.PaginationContext@70f82e86, containsSubquery=false)
2022-04-08 21:40:28.221  INFO 13136 --- [nio-8080-exec-4] ShardingSphere-SQL                       : Actual SQL: tenant-a ::: select roles0_.user_id as user_id1_2_0_, roles0_.role_id as role_id2_2_0_, role1_.id as id1_0_1_, role1_.create_time as create_t2_0_1_, role1_.description as descript3_0_1_, role1_.name as name4_0_1_, role1_.role_key as role_key5_0_1_, role1_.update_time as update_t6_0_1_ from tb_user_role roles0_ inner join tb_role role1_ on roles0_.role_id=role1_.id where roles0_.user_id=? ::: [719183321087062016]
```
# 四十八、▶SpringBoot集成连接池 - 数据库连接池和默认连接池HikariCP
> 本文主要介绍数据库连接池，以及SpringBoot集成默认的HikariCP的实践。
## 48.1 知识准备
### 48.1.1 什么是数据库连接池？
> 什么是连接池，它要解决什么样的问题呢？

数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。
### 48.1.2 数据库连接池基本原理？
连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：
- 最小连接数

是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。
- 最大连接数

是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。
- 最小连接数与最大连接数差距

最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。
### 48.1.3 有哪些常见的数据库连接池？
> 开源的数据库连接池众多，这里我们需要了解曾经常用的开源数据库连接池及其被淘汰原因，并了解目前最常用的数据库连接池。
- C3P0(被淘汰：历史悠久，过于复杂，性能差)

是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。由于一度是Hibernate内置的数据库连接池而被开发者熟知，但是由于性能和复杂度，官方已经放弃维护。
- DBCP（被淘汰：依赖Commons-Pool，性能差） 

DBCP（DataBase Connection Pool）属于Apache顶级项目Commons中的核心子项目。但DBCP并不是独立实现连接池功能的，它内部依赖于Commons-Pool项目，连接池最核心的“池”，就是由Commons-Pool组件提供的，因此，DBCP的性能实际上就是Pool的性能。终于在tomcat 7.0版本中，tomcat重新设计开发出了一套连接池（Tomcat JDBC Pool）并且于13年9月发布了Commons-Pool 2.0。命脉已经更新的DBCP终于在14年2月份发布了DBCP2.0。但是，毕竟由于长时间没有更新突破的DBCP，已经被人放弃了。
- BoneCP（被淘汰：为解决C3P0/DBCP性能而生，后续出现了更高性能的hikariCP，BoneCP也不再更新）

是一个快速、开源的数据库连接池。帮用户管理数据连接，让应用程序能更快速地访问数据库。BoneCP的出现主要是为了解决C3P0/DBCP连接池性能问题，有一些测试表明其性能提升了25倍。后来出现了更高性能的hikariCP，BoneCP也不再更新，所以BoneCP目前也很少被使用。
- Druid

Druid功能最为全面，sql拦截等功能，统计数据较为全面，具有良好的扩展性
## 48.2 简单示例
> 主要展示HikariCP的使用配置等。

如下是常用的HikariCP的使用配置
```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf
    # 指定为HikariDataSource
    type: com.zaxxer.hikari.HikariDataSource
    # hikari连接池配置
    hikari:
      #连接池名
      pool-name: HikariCP
      #最小空闲连接数
      minimum-idle: 5
      # 空闲连接存活最大时间，默认10分钟
      idle-timeout: 600000
      # 连接池最大连接数，默认是10
      maximum-pool-size: 10
      # 此属性控制从池返回的连接的默认自动提交行为,默认值：true
      auto-commit: true
      # 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认30分钟
      max-lifetime: 1800000
      # 数据库连接超时时间,默认30秒
      connection-timeout: 30000
      # 连接测试query
      connection-test-query: SELECT 1
```
## 48.3 进一步理解
> 通过如下几个问题，进一步理解HikariCP。
### 48.3.1 SpringBoot2默认连接池HikariCP是如何起作用的？
> 从SpringBoot自动初始化配置 和 默认的数据源 两个角度理解。
- SpringBoot自动初始化配置

关键代码如下
![190.springboot-hikari-1.png](../../assets/images/04-主流框架/spring/190.springboot-hikari-1.png)

然后可以找到HikariCP数据源的配置
![191.springboot-hikari-2.png](../../assets/images/04-主流框架/spring/191.springboot-hikari-2.png)

你可以发现，为了支持动态更新配置（基于MXBean)，这里还设计了一层HikariConfigMXBean接口
- 为什么说是默认的数据源呢？

首先，springboot-starter-jdbc中默认加载了Hikari
![192.springboot-hikari-3.png](../../assets/images/04-主流框架/spring/192.springboot-hikari-3.png
)

其次，在配置初始化或者加载时都是第一个被加载的
```java
private static <T extends DataSource> MappedDataSourceProperties<T> lookupPooled(ClassLoader classLoader,
    Class<T> type) {
  MappedDataSourceProperties<T> result = null;
  result = lookup(classLoader, type, result, "com.zaxxer.hikari.HikariDataSource",
      HikariDataSourceProperties::new);
  result = lookup(classLoader, type, result, "org.apache.tomcat.jdbc.pool.DataSource",
      TomcatPoolDataSourceProperties::new);
  result = lookup(classLoader, type, result, "org.apache.commons.dbcp2.BasicDataSource",
      MappedDbcp2DataSource::new);
  result = lookup(classLoader, type, result, "oracle.ucp.jdbc.PoolDataSourceImpl",
      OraclePoolDataSourceProperties::new, "oracle.jdbc.OracleConnection");
  return result;
}
```
### 48.3.2 更多HikariCP配置参数？
从代码的角度，你已经可以看到，可以配置如下：
![191.springboot-hikari-2.png](../../assets/images/04-主流框架/spring/191.springboot-hikari-2.png)
| 属性 | 描述 | 构造器默认值 | 默认配置 | validate之后的值 | validate重置 |
|------|------|--------------|----------|-----------------|-------------|
| autoCommit | 自动提交从池中返回的连接 | TRUE | TRUE | – | – |
| connectionTimeout | 等待来自池的连接的最大毫秒数 | SECONDS.toMillis(30) = 30000 | 30000 | – | 如果小于250毫秒，则被重置回30秒 |
| idleTimeout | 连接允许在池中闲置的最长时间 | MINUTES.toMillis(10) = 600000 | 600000 | – | 如果idleTimeout+1秒>maxLifetime 且 maxLifetime>0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒 |
| maxLifetime | 池中连接最长生命周期 | MINUTES.toMillis(30) = 1800000 | 1800000 | – | 如果不等于0且小于30秒则会被重置回30分钟 |
| connectionTestQuery | 如果您的驱动程序支持JDBC4，我们强烈建议您不要设置此属性 | null | null | – | – |
| minimumIdle | 池中维护的最小空闲连接数 | -1 | 10 | – | minIdle<0或者minIdle>maxPoolSize,则被重置为maxPoolSize |
| maximumPoolSize | 池中最大连接数，包括闲置和使用中的连接 | -1 | 10 | – | 如果maxPoolSize小于1，则会被重置。当minIdle<=0被重置为DEFAULT_POOL_SIZE则为10;如果minIdle>0则重置为minIdle的值 |
| metricRegistry | 该属性允许您指定一个 Codahale / Dropwizard MetricRegistry 的实例，供池使用以记录各种指标 | null | null | – | – |
| healthCheckRegistry | 该属性允许您指定池使用的Codahale / Dropwizard HealthCheckRegistry的实例来报告当前健康信息 | null | null | – | – |
| poolName | 连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置 | null | HikariPool-1 | – | – |
| initializationFailTimeout | 如果池无法成功初始化连接，则此属性控制池是否将 fail fast | 1 | 1 | – | – |
| isolateInternalQueries | 是否在其自己的事务中隔离内部池查询，例如连接活动测试 | FALSE | FALSE | – | – |
| allowPoolSuspension | 控制池是否可以通过JMX暂停和恢复 | FALSE | FALSE | – | – |
| readOnly | 从池中获取的连接是否默认处于只读模式 | FALSE | FALSE | – | – |
| registerMbeans | 是否注册JMX管理Bean（MBeans） | FALSE | FALSE | – | – |
| catalog | 为支持 catalog 概念的数据库设置默认 catalog | driverdefault | null | – | – |
| connectionInitSql | 该属性设置一个SQL语句，在将每个新连接创建后，将其添加到池中之前执行该语句。 | null | null | – | – |
| driverClassName | HikariCP将尝试通过仅基于jdbcUrl的DriverManager解析驱动程序，但对于一些较旧的驱动程序，还必须指定driverClassName | null | null | – | – |
| transactionIsolation | 控制从池返回的连接的默认事务隔离级别 | null | null | – | – |
| validationTimeout | 连接将被测试活动的最大时间量 | SECONDS.toMillis(5) = 5000 | 5000 | – | 如果小于250毫秒，则会被重置回5秒 |
| leakDetectionThreshold | 记录消息之前连接可能离开池的时间量，表示可能的连接泄漏 | 0 | 0 | – | 如果大于0且不是单元测试，则进一步判断：(leakDetectionThreshold < SECONDS.toMillis(2) or (leakDetectionThreshold > maxLifetime && maxLifetime > 0)，会被重置为0 . 即如果要生效则必须>0，而且不能小于2秒，而且当maxLifetime > 0时不能大于maxLifetime |
| dataSource | 这个属性允许你直接设置数据源的实例被池包装，而不是让HikariCP通过反射来构造它 | null | null | – | – |
| schema | 该属性为支持模式概念的数据库设置默认模式 | driverdefault | null | – | – |
| threadFactory | 此属性允许您设置将用于创建池使用的所有线程的java.util.concurrent.ThreadFactory的实例。 | null | null | – | – |
| scheduledExecutor | 此属性允许您设置将用于各种内部计划任务的java.util.concurrent.ScheduledExecutorService实例 | null | null | – | – |

更具体的可以看<a href='https://github.com/brettwooldridge/HikariCP'>官方配置</a>或者如下<a href='http://www.lanxinbase.com/?p=2482'>深蓝Blog总结翻译的配置</a>
### 48.3.3 为什么HikariCP会成为默认连接池？
> 官网详细地说明了HikariCP所做的一些优化，总结如下：
- `字节码精简` ：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；
- `优化代理和拦截器`：减少代码，例如HikariCP的Statement proxy只有100行代码，只有BoneCP的十分之一；
- `自定义数组类型（FastStatementList）代替ArrayList`：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描；
- `自定义集合类型(ConcurrentBag)`：提高并发读写的效率；
- `其它`：针对BoneCP缺陷的优化，比如对于耗时超过一个CPU时间片的方法调用的研究等。

更多可以参考：<a href='https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole'>Down the Rabbit Hole</a>

更多常见的使用问题
请参考 <a href='https://github.com/brettwooldridge/HikariCP/wiki/FAQ'>官方WIKI - FAQ</a>
# 四十九、SpringBoot集成连接池 - 集成数据库Druid连接池
> 上文介绍默认数据库连接池HikariCP，本文主要介绍SpringBoot集成阿里的Druid连接池的实践; 客观的来说，阿里Druid只能说是中文开源中功能全且广泛的连接池为基础的监控组件，但是（仅从连接池的角度）在生态，维护性，开源规范性，综合性能等方面和HikariCP比还是有很大差距。
## 49.1 知识准备
### 49.1.1 Druid连接池的定位？
> Druid连接池是阿里巴巴开源的数据库连接池项目。Druid连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防SQL注入，内置Loging能诊断Hack应用行为。
- Github项目地址 https://github.com/alibaba/druid
- 文档 https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98
- 下载 http://repo1.maven.org/maven2/com/alibaba/druid/

## 49.2 简单示例
### 49.2.1 POM配置
增加依赖
```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.9</version>
</dependency>
```
### 49.2.2 yml配置
详细的yml配置如下：
```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf
    # Druid datasource
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      # 初始化大小
      initial-size: 5
      # 最小连接数
      min-idle: 10
      # 最大连接数
      max-active: 20
      # 获取连接时的最大等待时间
      max-wait: 60000
      # 一个连接在池中最小生存的时间，单位是毫秒
      min-evictable-idle-time-millis: 300000
      # 多久才进行一次检测需要关闭的空闲连接，单位是毫秒
      time-between-eviction-runs-millis: 60000
      # 配置扩展插件：stat-监控统计，log4j-日志，wall-防火墙（防止SQL注入），去掉后，监控界面的sql无法统计
      filters: stat,wall
      # 检测连接是否有效的 SQL语句，为空时以下三个配置均无效
      validation-query: SELECT 1
      # 申请连接时执行validationQuery检测连接是否有效，默认true，开启后会降低性能
      test-on-borrow: true
      # 归还连接时执行validationQuery检测连接是否有效，默认false，开启后会降低性能
      test-on-return: true
      # 申请连接时如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效，默认false，建议开启，不影响性能
      test-while-idle: true
      # 是否开启 StatViewServlet
      stat-view-servlet:
        enabled: true
        # 访问监控页面 白名单，默认127.0.0.1
        allow: 127.0.0.1
        login-username: admin
        login-password: admin
      # FilterStat
      filter:
        stat:
          # 是否开启 FilterStat，默认true
          enabled: true
          # 是否开启 慢SQL 记录，默认false
          log-slow-sql: true
          # 慢 SQL 的标准，默认 3000，单位：毫秒
          slow-sql-millis: 5000
          # 合并多个连接池的监控数据，默认false
          merge-sql: false
  jpa:
    open-in-view: false
    generate-ddl: false
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        format_sql: true
        use-new-id-generator-mappings: false
```
更多的配置，请参考<a href='https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8'>官方配置</a>

### 49.2.3 测试
访问http://localhost:8080/druid/datasource.html

admin/admin登录
![193.springboot-druid-11.png](../../assets/images/04-主流框架/spring/193.springboot-druid-11.png)

访问接口，进行SQL查询
![194.springboot-druid-12.png](../../assets/images/04-主流框架/spring/194.springboot-druid-12.png)

SQL和慢查询监控
![195.springboot-druid-13.png](../../assets/images/04-主流框架/spring/195.springboot-druid-13.png)

## 49.3 进一步理解
> Druid连接池最初就是为监控系统采集jdbc运行信息而生的，它内置了StatFilter 功能，能采集非常完备的连接池执行信息Druid连接池内置了能和Spring/Servlet关联监控的实现，使得监控Web应用特别方便Druid连接池内置了一个监控页面，提供了非常完备的监控信息，可以快速诊断系统的瓶颈。更多请参考：Druid 的GitHub仓库<a href='https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98'>wiki</a>
### 49.3.1 监控信息采集的StatFilter
Druid连接池的监控信息主要是通过StatFilter 采集的，采集的信息非常全面，包括SQL执行、并发、慢查、执行时间区间分布等。具体配置可以看这个 https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter
- 监控不影响性能

Druid增加StatFilter之后，能采集大量统计信息，同时对性能基本没有影响。StatFilter对CPU和内存的消耗都极小，对系统的影响可以忽略不计。监控不影响性能是Druid连接池的重要特性。
- SQL参数化合并监控

实际业务中，如果SQL不是走PreparedStatement，SQL没有参数化，这时SQL需要参数化合并监控才能真实反映业务情况。如下SQL：
```sql
select * from t where id = 1
select * from t where id = 2
select * from t where id = 3
```
参数化后：
```sql
select * from t where id = ?
```
参数化合并监控是基于SQL Parser语法解析实现的，是Druid连接池独一无二的功能。

- 执行次数、返回行数、更新行数和并发监控

StatFilter能采集到每个SQL的执行次数、返回行数总和、更新行数总和、执行中次数和和最大并发。并发监控的统计是在SQL执行开始对计数器加一，结束后对计数器减一实现的。可以采集到每个SQL的当前并发和采集期间的最大并发。

- 慢查监控

缺省执行耗时超过3秒的被认为是慢查，统计项中有包括每个SQL的最后发生的慢查的耗时和发生时的参数。
- Exception监控

如果SQL执行时抛出了Exception，SQL统计项上会Exception有最后的发生时间、堆栈和Message，根据这些信息可以很容易定位错误原因。

### 49.3.2 诊断支持
Druid连接池内置了LogFilter，将Connection/Statement/ResultSet相关操作的日志输出，可以用于诊断系统问题，也可以用于Hack一个不熟悉的系统。

LogFilter可以输出连接申请/释放，事务提交回滚，Statement的Create/Prepare/Execute/Close，ResultSet的Open/Next/Close，通过LogFilter可以详细诊断一个系统的Jdbc行为。

LogFilter有Log4j、Log4j2、Slf4j、CommsLog等实现，具体配置看这里 https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_LogFilter
### 49.3.3 防SQL注入
SQL注入攻击是黑客对数据库进行攻击的常用手段，Druid连接池内置了WallFilter 提供防SQL注入功能，在不影响性能的同时防御SQL注入攻击。
- 基于语意的防SQL注入

Druid连接池内置了一个功能完备的SQL Parser，能够完整解析mysql、sql server、oracle、postgresql的语法，通过语意分析能够精确识别SQL注入攻击。
- 极低的漏报率和误报率

基于SQL语意分析，大量应用和反馈，使得Druid的防SQL注入拥有极低的漏报率和误报率
- 防注入对性能影响极小

内置参数化后的Cache、高性能手写的Parser，使得打开防SQL注入对应用的性能基本不受影响。

### 49.3.4 如何评价阿里的Druid连接池
首先，仅从<a href='https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D'>功能</a>上看，Druid并不是一个存粹的连接池，它还承载了监控，诊断，安全的功能。从产品的角度看，all in one 也是有代价的，如果我只期望使用连接池的功能，其它的功能对于使用者来说就是鸡肋；而我们没有看到其长期架构设计（比如插拔式架构，分包设计等）， 大概率是当时Druid这种开源的驱动方式并不是一个完善规范的开源软件开发方式（比如KPI driven和个人主义色彩)

（如果你仅仅从功能上比较，你就已经输了，因为这种比较根本不在一个维度上；看到druid主要作者wenshao和hikari作者的<a href='https://github.com/brettwooldridge/HikariCP/issues/232'>讨论</a>，读者自行辨别~）
![196.springboot-druid-1.png](../../assets/images/04-主流框架/spring/196.springboot-druid-1.png)
# 五十、 ▶SpringBoot数据库管理 - 用Liquibase对数据库管理和迁移
## 50.1 知识准备
### 50.1.1 什么是Liquibase？这类工具要解决什么问题？
> Liquibase是一个**用于跟踪、管理和应用数据库变化的开源工具**，通过日志文件(changelog)的形式记录数据库的变更(changeset)，然后执行日志文件中的修改，将数据库更新或回滚(rollback)到一致的状态。它的目标是提供一种数据库类型无关的解决方案，通过执行schema类型的文件来达到迁移。

其优点主要有以下：
- 支持几乎所有主流的数据库，目前支持包括 Oracle/Sql Server/DB2/MySql/Sybase/PostgreSQL等<a href='https://docs.liquibase.com/install/tutorials/home.html'>各种数据库</a>，这样在数据库的部署和升级环节可帮助应用系统支持多数据库；
- 支持版本控制，这样就能支持多开发者的协作维护；
- 日志文件支持多种格式，如XML, YAML, JSON, SQL等；
- 提供变化应用的回滚功能，可按时间、数量或标签（tag）回滚已应用的变化。通过这种方式，开发人员可轻易的还原数据库在任何时间点的状态
- 支持多种运行方式，如命令行、Spring集成、Maven插件、Gradle插件等。

为何会出现Liquibase这类工具呢？

在实际上线的应用中，随着版本的迭代，经常会遇到需要变更数据库表和字段，必然会遇到需要对这些变更进行记录和管理，以及回滚等等；同时只有脚本化且版本可管理，才能在让数据库实现真正的DevOps（自动化执行 + 回滚等）。在这样的场景下Liquibase等工具的出现也就成为了必然。
### 50.1.2 Liquibase有哪些概念？是如何工作的？
> 工作流程：将SQL变更记录到changeset，多个changeset变更组成了日志文件(changelog)，liquibase将changelog更新日志文件同步到指定的RDBMS中。
![197.springboot-liquibase-1.png](../../assets/images/04-主流框架/spring/197.springboot-liquibase-1.png)

日志文件(databaseChangeLog)支持多种格式，如XML, YAML, JSON, SQL; 我们以xml为例，看下相关配置
```xml
<?xml version="1.0" encoding="UTF-8"?> 
<databaseChangeLog
	xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
	xmlns:pro="http://www.liquibase.org/xml/ns/pro"
	xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
		http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.0.xsd
		http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd
		http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-4.9.0.xsd">
    <changeSet id="1" author="bob">  
        <comment>A sample change log</comment>  
        <createTable/> 
    </changeSet>  
    <changeSet id="2" author="bob" runAlways="true">  
        <alterTable/>  
    </changeSet>  
    <changeSet id="3" author="alice" failOnError="false" dbms="oracle">
        <alterTable/>  
    </changeSet>  
    <changeSet id="4" author="alice" failOnError="false" dbms="!oracle">
        <alterTable/>  
    </changeSet>  
</databaseChangeLog>
```
## 50.2 简单示例
> 这里主要介绍基于SpringBoot集成liquibase来管理数据库的变更。
### 50.2.1 POM依赖
Maven 包的依赖，主要包含mysql驱动, JDBC(这里spring-boot-starter-data-jpa包含了jdbc包，当然直接引入jdbc包也行)，以及liquibase包。
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>com.github.wenhao</groupId>
    <artifactId>jpa-spec</artifactId>
    <version>3.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
    <version>4.9.1</version>
</dependency>
```
### 50.2.2 yml配置
> SpringBoot AutoConfig默认已经包含了对liquibase的配置，在spring.liquibase配置下。

基础的配置，可以直接使用如下（主要是指定change-log的位置，默认的位置是classpath:/db/changelog/db.changelog-master.yaml）：
```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db_liquibase?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf
  liquibase:
    enabled: true
    # 如下配置是被spring.datasource赋值的，所以可以不配置
#    url: jdbc:mysql://localhost:3306/test_db_liquibase?useSSL=false&autoReconnect=true&characterEncoding=utf8
#    user: root
#    password: bfXa4Pt2lUUScy8jakXf
    change-log: classpath:/db/changelog/db.changelog-master.yaml
```
在开发时，更多的配置可以从如下SpringBoot AutoConfig中找到。
![198.springboot-liquibase-2.png](../../assets/images/04-主流框架/spring/198.springboot-liquibase-2.png)
### 50.2.3 新增changelog
XML方式固然OK，不过依然推荐使用yml格式。
```yml
databaseChangeLog:
  - changeSet:
      id: 20220412-01
      author: pdai
      changes:
        - createTable:
            tableName: person
            columns:
              - column:
                  name: id
                  type: int
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: firstname
                  type: varchar(50)
              - column:
                  name: lastname
                  type: varchar(50)
                  constraints:
                    nullable: false
              - column:
                  name: state
                  type: char(2)

  - changeSet:
      id: 20220412-02
      author: pdai
      changes:
        - addColumn:
            tableName: person
            columns:
              - column:
                  name: username
                  type: varchar(8)

  - changeSet:
      id: 20220412-03
      author: pdai
      changes:
        - addLookupTable:
            existingTableName: person
            existingColumnName: state
            newTableName: state
            newColumnName: id
            newColumnDataType: char(2)
```
### 50.2.4 测试
启动springBootApplication, 我们可以看到如下的几个changeSet被依次执行`
```sh
2022-04-12 20:41:20.591  INFO 8476 --- [           main] liquibase.lockservice                    : Successfully acquired change log lock
2022-04-12 20:41:20.737  INFO 8476 --- [           main] liquibase.changelog                      : Creating database history table with name: test_db_liquibase.DATABASECHANGELOG
2022-04-12 20:41:20.783  INFO 8476 --- [           main] liquibase.changelog                      : Reading from test_db_liquibase.DATABASECHANGELOG
Running Changeset: classpath:/db/changelog/db.changelog-master.yaml::20220412-01::pdai
2022-04-12 20:41:20.914  INFO 8476 --- [           main] liquibase.changelog                      : Table person created
2022-04-12 20:41:20.914  INFO 8476 --- [           main] liquibase.changelog                      : ChangeSet classpath:/db/changelog/db.changelog-master.yaml::20220412-01::pdai ran successfully in 53ms
Running Changeset: classpath:/db/changelog/db.changelog-master.yaml::20220412-02::pdai
2022-04-12 20:41:20.952  INFO 8476 --- [           main] liquibase.changelog                      : Columns username(varchar(8)) added to person
2022-04-12 20:41:20.952  INFO 8476 --- [           main] liquibase.changelog                      : ChangeSet classpath:/db/changelog/db.changelog-master.yaml::20220412-02::pdai ran successfully in 31ms
Running Changeset: classpath:/db/changelog/db.changelog-master.yaml::20220412-03::pdai
2022-04-12 20:41:21.351  INFO 8476 --- [           main] liquibase.changelog                      : Lookup table added for person.state
2022-04-12 20:41:21.351  INFO 8476 --- [           main] liquibase.changelog                      : ChangeSet classpath:/db/changelog/db.changelog-master.yaml::20220412-03::pdai ran successfully in 389ms
2022-04-12 20:41:21.382  INFO 8476 --- [           main] liquibase.lockservice                    : Successfully released change log lock
```
查看数据库，你会发现数据已经变更
![199.springboot-liquibase-3.png](../../assets/images/04-主流框架/spring/199.springboot-liquibase-3.png)

那我们如果重新启动这个SpringBootApplication，会怎么呢？

很显然，因为databasechangelog表中已经有相关执行记录了，所以将不再执行变更
```sh
2022-04-12 20:49:01.566  INFO 9144 --- [           main] liquibase.lockservice                    : Successfully acquired change log lock
2022-04-12 20:49:01.761  INFO 9144 --- [           main] liquibase.changelog                      : Reading from test_db_liquibase.DATABASECHANGELOG
2022-04-12 20:49:01.812  INFO 9144 --- [           main] liquibase.lockservice                    : Successfully released change log lock
```
### 50.2.5 进一步解释 

#### 1. 什么是 Liquibase？

Liquibase 是一个开源的、与数据库无关的**数据库版本控制和管理工具**。它的核心思想是像用 Git 管理代码一样来管理你的数据库结构（Schema）。

**它解决了什么问题？**
在项目开发中，尤其是在团队协作环境下，数据库结构会频繁变更（例如：添加新表、修改字段、创建索引等）。传统方式会遇到以下问题：
*   **手动执行 SQL 脚本**：容易出错，且难以记录谁、在什么时候、执行了什么操作。
*   **环境不一致**：开发、测试、生产环境的数据库结构可能不一致，导致程序运行结果不同。
*   **回滚困难**：当新版本出现问题时，很难快速、安全地将数据库回退到上一个版本。

**Liquibase 的核心概念：**
*   **变更日志（Changelog）**：一个文件（通常是 XML、YAML、JSON 或 SQL 格式），它是所有数据库变更的“总清单”。
*   **变更集（ChangeSet）**：代表一个具体的、原子性的数据库变更操作（比如创建一个表）。每个变更集都有一个唯一的标识符（由 `id`、`author` 和 `changelog 的文件路径` 共同组成）。Liquibase 通过跟踪哪些变更集已被执行来确保每个变更只运行一次。
*   **DATABASECHANGELOG 表**：Liquibase 会在你配置的数据库中自动创建这个表，用于记录所有已经执行过的变更集，从而实现版本控制。

---

#### 2. Spring Boot 项目如何使用 Liquibase？

Spring Boot 对 Liquibase 提供了**开箱即用**的自动配置支持，集成起来非常简单。

**步骤如下：**

**1. 添加依赖**
在你的 `pom.xml` (Maven) 或 `build.gradle` (Gradle) 中添加 Liquibase 依赖。

**Maven:**
```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
```
Spring Boot 的父 POM 已经管理了版本号，所以你不需要指定版本。

**2. 配置数据源**
在 `application.yml` 或 `application.properties` 中配置你的数据库连接。Liquibase 会自动使用应用的数据源。

**application.yml 示例：**
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/my_database
    username: my_username
    password: my_password
    driver-class-name: com.mysql.cj.jdbc.Driver
```

**3. 创建主变更日志文件（Master Changelog）**
默认情况下，Spring Boot 会在 `src/main/resources/db/changelog/` 目录下寻找名为 `db.changelog-master.yaml` (或 .xml, .json) 的文件。你可以通过 `spring.liquibase.change-log` 属性来修改这个路径。

创建文件：`src/main/resources/db/changelog/db.changelog-master.yaml`

**4. 编写变更集（ChangeSet）**
最佳实践是将不同版本或功能的变更集分到不同的文件中，然后在主变更日志文件中引入（include）它们。这使得管理大量变更更加清晰。

---

#### 3. 使用它能做什么？给出一个示例

**它能做什么：**
*   **自动化数据库部署**：应用启动时，Liquibase 自动检查并执行未应用的变更集。
*   **版本控制**：清晰地记录数据库结构的每一次变更历史。
*   **支持回滚**：可以生成或执行回滚脚本，撤销变更。
*   **多数据库支持**：同一套变更日志（如 YAML）可以用于 MySQL、PostgreSQL、Oracle 等不同数据库，Liquibase 会自动生成对应的 SQL 方言。
*   **协同工作**：团队成员只需将变更日志文件提交到代码仓库，其他人的环境在启动应用时会自动同步数据库结构。

#### 完整示例：为一个“用户管理系统”添加用户表

**项目结构：**
```
src/main/resources/
└── db/
    └── changelog/
        ├── db.changelog-master.yaml
        └── v1.0/
            └── create-user-table.yaml
```

**1. 主变更日志文件：`db.changelog-master.yaml`**
```yaml
databaseChangeLog:
  - includeAll:
      path: db/changelog/v1.0/
```
这个文件表示包含 `v1.0` 目录下的所有变更日志文件。

**2. 具体的变更集文件：`create-user-table.yaml`**
```yaml
databaseChangeLog:
  - changeSet:
      id: 1
      author: your_name
      changes:
        - createTable:
            tableName: user
            columns:
              - column:
                  name: id
                  type: bigint
                  constraints:
                    primaryKey: true
                    nullable: false
                    autoIncrement: true
              - column:
                  name: username
                  type: varchar(255)
                  constraints:
                    nullable: false
                    unique: true
              - column:
                  name: email
                  type: varchar(255)
              - column:
                  name: created_at
                  type: timestamp
```
这个变更集定义了一个创建 `user` 表的操作。

**3. 运行项目**
当你启动 Spring Boot 应用时，Liquibase 会自动：
1.  检查数据库中的 `DATABASECHANGELOG` 表（如果不存在则创建）。
2.  读取 `db.changelog-master.yaml` 文件。
3.  发现有一个来自 `v1.0/create-user-table.yaml` 的变更集（ID=1, author=your_name）还未执行。
4.  执行该变更集，在数据库中创建 `user` 表。
5.  在 `DATABASECHANGELOG` 表中插入一条记录，标记这个变更集已执行。

**4. 后续更新（例如，添加手机号字段）**
你不需要修改原来的文件。只需创建一个新的变更集文件，例如 `v1.1/add-user-phone.yaml`，并在主日志文件中引入它。

**新的变更集文件：`add-user-phone.yaml`**
```yaml
databaseChangeLog:
  - changeSet:
      id: 1
      author: your_name
      changes:
        - addColumn:
            tableName: user
            columns:
              - column:
                  name: phone
                  type: varchar(20)
```

**更新主日志文件：`db.changelog-master.yaml`**
```yaml
databaseChangeLog:
  - includeAll:
      path: db/changelog/v1.0/
  - includeAll:
      path: db/changelog/v1.1/
```
再次启动应用，Liquibase 就会自动为 `user` 表添加 `phone` 字段。

通过这种方式，你的数据库结构变更就和代码变更一样，被清晰、可追溯地管理起来了。
### 50.2.6 日志文件都是手动写的吗？
这正是 Liquibase 的核心工作模式，您的理解是完全正确的。

**是的，Liquibase 的变更日志文件（changelog）是需要我们开发者手动去编写和维护的。它本身并不会像“监控摄像头”一样自动记录数据库发生的任何变更。**

它的核心价值在于 **“将数据库的变更脚本化、版本化，并确保其可重复、可追溯地执行”**，而不是自动发现变更。

#### 为什么这种方式更好？

您可能会想：“这听起来还是很手动啊，有什么优势呢？” 优势恰恰在于这种“手动”的明确性和可控性：

1.  **意图明确（Declarative）：** 您写的变更日志文件（YAML/XML）描述的是 **“你想要数据库变成什么样子”**（例如：创建一个叫 `user` 的表），而不是具体生成的一连串 SQL 命令。Liquibase 会负责将这些声明转换成对应数据库（MySQL, PostgreSQL等）的方言SQL。这保证了变更的准确性。

2.  **可重复性（Repeatable）：** 这个编写好的变更日志文件可以被无数次地、安全地执行在任何一个环境（开发、测试、生产）的数据库上。因为 Liquibase 通过 `DATABASECHANGELOG` 表记住了哪些变更已经执行过，绝不会重复执行同一个变更集。

3.  **可回滚（Rollback）：** 您可以（也应该）在变更集中定义回滚操作。这样当需要撤销某个变更时（比如新功能上线失败），Liquibase 可以自动执行回滚，将数据库恢复。
    *   *示例：在 `create-table` 的变更集中，可以定义回滚操作为 `drop-table`。*

4.  **协同工作的基石：** 在团队开发中，数据库变更是由多个开发者共同完成的。如果靠自动记录，会变得混乱不堪。而通过要求开发者主动编写变更集文件，并纳入版本控制（如 Git），可以实现：
    *   **代码审查：** 团队成员可以像审查业务代码一样审查数据库变更脚本。
    *   **明确责任：** 每个变更集都有 `author`，谁做的变更一清二楚。
    *   **解决冲突：** 如果两个开发者同时修改了数据库，可以在 Git 层面合并他们的变更日志文件，而不是直接在数据库上冲突。

#### 工作流程（理想情况）

所以，一个理想的最佳实践流程是：

1.  **开发前：** 当您需要新增一个功能（比如“为产品添加分类功能”）时，您首先构思数据库需要如何变更（例如：创建 `category` 表，并在 `product` 表中添加 `category_id` 外键）。
2.  **编写变更集：** 在编写业务代码之前，先编写对应的 Liquibase 变更集文件（例如 `v2.1/add-product-category.yaml`）。
3.  **提交代码：** 将变更集文件和业务代码一起提交到 Git 分支，发起合并请求（Pull Request）。
4.  **代码审查：** 同事会审查您的业务代码 **和** 数据库变更脚本。
5.  **部署：** 功能分支合并到主干后，部署到测试或生产环境。应用启动时，Liquibase **自动** 执行新的变更集，数据库结构就和新的代码版本完美匹配了。

#### 有没有“自动”的方式？

有，但通常仅用于**生成初始变更集**，而不是用于日常开发。

Liquibase 提供了一个 `diff` 命令/功能，可以比较两个数据库（例如，一个空的数据库和一个您已经手动修改好的开发数据库）之间的差异，然后**生成**一个代表这些差异的变更日志文件。

*   **适用场景：** 接手一个遗留项目，该项目没有使用任何数据库版本控制工具，但有一个现成的数据库。您可以用 `diff` 工具生成一个初始的变更日志，作为后续版本控制的起点。
*   **不适用于日常开发：** 因为自动生成的变更集可能不是最优的，也可能无法包含您期望的回滚逻辑。在团队协作中，直接使用 `diff` 结果会失去意图明确和可审查的优点。
# 五十一、SpringBoot数据库管理 - 用flyway对数据库管理和迁移
> 上文介绍了Liquibase，以及和SpringBoot的集成。除了Liquibase之外，还有一个组件Flyway也是经常被使用到的类似的数据库版本管理中间件。本文主要介绍Flyway, 以及SpringBoot集成Flyway。
## 51.1 知识准备
> 需要了解Flyway和要解决的问题，以及一些基础概念，比如变迁(migrations)，常用命令(commands)等。
### 51.1.1 什么是Flyway? 要解决什么问题？
> Flyway是一款数据库迁移（migration）工具。简单点说，就是在你部署应用的时候，帮你执行数据库脚本的工具。Flyway支持SQL和Java两种类型的脚本，你可以将脚本打包到应用程序中，在应用程序启动时，由Flyway来管理这些脚本的执行，这些脚本被Flyway称之为migration。

*PS: 本质上和liquibase机制一致。*

按照verion的顺序（和数据库中的更新记录对比，找到未更新的），更新如下
![200.springboot-flyway-11.png](../../assets/images/04-主流框架/spring/200.springboot-flyway-11.png)

更新记录如下
![201.springboot-flyway-12.png](../../assets/images/04-主流框架/spring/201.springboot-flyway-12.png)
### 51.1.2 Flyway中的变迁(migrations)
> 对于Flyway，对数据库的所有更改都称为变迁(migrations)，等同于liquibase中的changeset。

在Flyway中变迁(migrations)定义的更细，包含如下三种：
1. 版本变迁(Versioned Migrations): 每个版本执行一次，包含有版本、描述和校验和；常用于创建，修改，删除表；插入，修改数据等
2. 撤销变迁(Undo Migrations): 版本变迁(Versioned Migrations)的反操作。
3. 可重复变迁(Repeatable Migrations): 可以执行多次，包含描述和校验和（没有版本）；主要用于视图，存储过程，函数等

这三种类型对应的格式如下：
![202.springboot-flyway-1.png](../../assets/images/04-主流框架/spring/202.springboot-flyway-1.png)

1. 前缀: V 代表版本变迁(Versioned Migrations), U 代表撤销变迁(Undo Migrations)， R 代表可重复变迁(Repeatable Migrations)
2. 版本号: 唯一的版本号，比如V1.0.1
3. 分隔符: __ (两个下划线)
4. 描述信息: 描述信息
5. 后缀: .sql

（PS：撤销变迁(Undo Migrations)在收费版本中）
### 51.1.3 Flyway中常用命令
> Flyway中的常用commands有哪些？什么含义？

Migrate: 是Flyway工作流的核心。它将扫描文件系统或类路径以查找可用的Migrate。它将把它们与已应用于数据库的Migrate进行比较。如果发现任何差异则迁移数据。
![203.springboot-flyway-2.png](../../assets/images/04-主流框架/spring/203.springboot-flyway-2.png)

Clean: 清除掉对应数据库Schema中所有的对象，包括表结构，视图，存储过程等，clean操作在dev 和 test阶段很好用；(PS：不能用在product环境)
![204.springboot-flyway-3.png](../../assets/images/04-主流框架/spring/204.springboot-flyway-3.png)

Info: 用于打印所有的Migrations的详细和状态信息，也是通过MetaData和Migrations完成的，可以快速定位当前的数据库版本；
![205.springboot-flyway-4.png](../../assets/images/04-主流框架/spring/205.springboot-flyway-4.png)

Validate: 验证以及apply的Migrations是否有变更，默认开启的；原理是对比MetaData表与本地Migrations的checkNum值，如果值相同则验证通过，否则失败。
![206.springboot-flyway-5.png](../../assets/images/04-主流框架/spring/206.springboot-flyway-5.png)

Undo: Migrate的反操作, 即回滚操作，这是收费功能
![207.springboot-flyway-6.png](../../assets/images/04-主流框架/spring/207.springboot-flyway-6.png)

BaseLine：对已经存在数据库Schema结构的数据库一种解决方案。实现在非空数据库新建MetaData表，并把Migrations应用到该数据库；也可以应用到已有表结构的数据库中也可以实现添加Metadata表。
![208.springboot-flyway-7.png](../../assets/images/04-主流框架/spring/208.springboot-flyway-7.png)

Repair：repair操作能够修复metaData表，该操作在metadata出现错误时很有用
![209.springboot-flyway-9.png](../../assets/images/04-主流框架/spring/209.springboot-flyway-9.png)
## 51.2 简单示例
### 51.2.1 POM依赖
Maven 包的依赖，主要包含mysql驱动, JDBC(这里spring-boot-starter-data-jpa包含了jdbc包，当然直接引入jdbc包也行)，以及flyway包。
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
<dependency>
    <groupId>com.github.wenhao</groupId>
    <artifactId>jpa-spec</artifactId>
    <version>3.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-mysql</artifactId>
    <version>8.5.7</version>
</dependency>
```
### 51.2.2 yml配置
> SpringBoot AutoConfig默认已经包含了对flyway的配置，在spring.flyway配置下
```yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_db_flyway?useSSL=false&autoReconnect=true&characterEncoding=utf8
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: bfXa4Pt2lUUScy8jakXf
  flyway:
    enabled: true
    encoding: UTF-8
    # 可以支持多个location, 用','隔开
    locations: classpath:db/migration
    # migrate是否校验
    validate-on-migrate: true
```
在开发时，更多的配置可以从如下SpringBoot AutoConfig中找到。
![210.springboot-flyway-21.png](../../assets/images/04-主流框架/spring/210.springboot-flyway-21.png)
### 51.2.3 Migrate配置
这里我们准备两个Versioned Migration
![211.springboot-flyway-25.png](../../assets/images/04-主流框架/spring/211.springboot-flyway-25.png)

- V1.0__Init_DB.sql
```sql
DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int(11) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
```
- V1.1__Init_Data.sql
```sql
LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;
```
### 51.2.4 测试
启动springBootApplication, 我们可以看到如下log
```sh
2022-04-13 07:56:56.122  INFO 86030 --- [           main] o.f.c.i.database.base.DatabaseType       : Database: jdbc:mysql://localhost:3306/test_db_flyway (MySQL 8.0)
2022-04-13 07:56:56.220  INFO 86030 --- [           main] o.f.core.internal.command.DbValidate     : Successfully validated 2 migrations (execution time 00:00.074s)
2022-04-13 07:56:56.245  INFO 86030 --- [           main] o.f.c.i.s.JdbcTableSchemaHistory         : Creating Schema History table `test_db_flyway`.`flyway_schema_history` ...
2022-04-13 07:56:56.270  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.282  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.292  INFO 86030 --- [           main] o.f.core.internal.command.DbMigrate      : Current version of schema `test_db_flyway`: << Empty Schema >>
2022-04-13 07:56:56.297  INFO 86030 --- [           main] o.f.core.internal.command.DbMigrate      : Migrating schema `test_db_flyway` to version "1.0 - Init DB"
2022-04-13 07:56:56.309  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: Unknown table 'test_db_flyway.tb_user' (SQL State: 42S02 - Error Code: 1051)
2022-04-13 07:56:56.309  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.309  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.310  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous. (SQL State: HY000 - Error Code: 3719)
2022-04-13 07:56:56.310  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.317  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: Integer display width is deprecated and will be removed in a future release. (SQL State: HY000 - Error Code: 1681)
2022-04-13 07:56:56.317  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: Integer display width is deprecated and will be removed in a future release. (SQL State: HY000 - Error Code: 1681)
2022-04-13 07:56:56.317  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous. (SQL State: HY000 - Error Code: 3719)
2022-04-13 07:56:56.317  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.318  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.333  INFO 86030 --- [           main] o.f.core.internal.command.DbMigrate      : Migrating schema `test_db_flyway` to version "1.1 - Init Data"
2022-04-13 07:56:56.334  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.335  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: Table storage engine for 'tb_user' doesn't have this option (SQL State: HY000 - Error Code: 1031)
2022-04-13 07:56:56.335  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.335  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 1 rows affected
2022-04-13 07:56:56.336  WARN 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : DB: Table storage engine for 'tb_user' doesn't have this option (SQL State: HY000 - Error Code: 1031)
2022-04-13 07:56:56.337  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.337  INFO 86030 --- [           main] o.f.c.i.s.DefaultSqlScriptExecutor       : 0 rows affected
2022-04-13 07:56:56.346  INFO 86030 --- [           main] o.f.core.internal.command.DbMigrate      : Successfully applied 2 migrations to schema `test_db_flyway`, now at version v1.1 (execution time 00:00.058s)
```
生成的flyway更新的记录，`test_db_flyway.flyway_schema_history`
![212.springboot-flyway-26.png](../../assets/images/04-主流框架/spring/212.springboot-flyway-26.png)

已经user表结构和数据
![213.springboot-flyway-27.png](../../assets/images/04-主流框架/spring/213.springboot-flyway-27.png)
### 51.2.5 进一步解释
我们来详细介绍一下 Flyway，并把它和 Liquibase 进行对比，这样您就能更清晰地理解它们的设计哲学和区别。

#### 1. 什么是 Flyway？

Flyway 和 Liquibase 一样，是一个开源的**数据库版本控制工具**。它的核心目标完全相同：像管理代码一样管理数据库结构。

**Flyway 的核心哲学：简单和约定优于配置。**

它与 Liquibase 最根本的区别在于：
*   **Liquibase**：使用与数据库无关的**声明式**格式（如 XML, YAML）来描述变更。你告诉 Liquibase *“我想要什么”*（例如，创建一张表），它来生成具体的 SQL。
*   **Flyway**：直接使用 **SQL 脚本** 作为变更的基本单位。你直接编写*“如何变更”* 的 SQL 命令。Flyway 的核心工作就是确保这些 SQL 脚本按照正确的顺序被执行一次且仅一次。

**Flyway 的核心概念：**
*   **迁移脚本（Migration Script）**：一个普通的 SQL 文件，包含了需要执行的 DDL（如 `CREATE TABLE`）或 DML（如 `INSERT`）语句。
*   **版本控制（Versioning）**：通过**文件命名**来严格控制执行顺序。文件名有固定的格式。
*   **Schema History 表**：Flyway 会在你的数据库中创建一个名为 `flyway_schema_history` 的表，用于记录所有已经执行过的迁移脚本的版本、校验和等信息，从而保证幂等性。

---

#### 2. Spring Boot 项目如何使用 Flyway？

Spring Boot 对 Flyway 同样提供了**开箱即用**的自动配置，集成非常简单。

**步骤如下：**

**1. 添加依赖**
在 `pom.xml` (Maven) 中添加 Flyway 依赖。

**Maven:**
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

**2. 配置数据源**
和 Liquibase 一样，Flyway 会自动使用应用配置的数据源。

**application.yml 示例：**
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/my_database
    username: my_username
    password: my_password
    driver-class-name: com.mysql.cj.jdbc.Driver
```

**3. 创建迁移脚本（SQL文件）**
默认情况下，Flyway 会在 `src/main/resources/db/migration/` 目录下寻找 SQL 文件。

**迁移脚本的命名规则至关重要：**
*   **前缀**: `V` 用于版本化迁移（最常见），`U` 用于撤销迁移，`R` 用于可重复迁移。
*   **版本号**: 例如 `1`, `1.1`, `2.0.3`。版本号之间用点或下划线分隔，它们将按字母顺序**和**版本号顺序被应用。
*   **分隔符**: 两个下划线 `__`（注意是双下划线）。
*   **描述信息**: 对本次迁移的简单描述，使用下划线连接单词。
*   **后缀**: `.sql`

**示例：**
*   `V1__Create_user_table.sql`
*   `V1.1__Add_phone_to_user_table.sql`
*   `V2.0.0__Insert_default_categories.sql`

---

#### 3. 使用它能做什么？给出一个示例

**它能做什么：**
Flyway 的能力与 Liquibase 非常相似：
*   **自动化数据库部署**：应用启动时，自动按顺序执行未应用的迁移脚本。
*   **版本控制**：通过 `flyway_schema_history` 表记录所有迁移历史。
*   **简单直接**：对于熟悉 SQL 的开发者来说几乎没有学习成本。
*   **可靠性**：通过校验和（Checksum）保证脚本内容在首次执行后不会被更改，否则会报错，防止意外情况。

#### 完整示例：同样为“用户管理系统”添加用户表

**项目结构：**
```
src/main/resources/
└── db/
    └── migration/
        ├── V1__Create_user_table.sql
        └── V1.1__Add_phone_to_user_table.sql
```

**1. 首次迁移脚本：`V1__Create_user_table.sql`**
```sql
CREATE TABLE user (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) NOT NULL UNIQUE,
    email VARCHAR(255),
    created_at TIMESTAMP
);
```
这个文件包含了创建表的原生 SQL。

**2. 运行项目**
启动 Spring Boot 应用，Flyway 会自动：
1.  检查数据库中的 `flyway_schema_history` 表（如果不存在则创建）。
2.  扫描 `db/migration/` 目录下的所有文件。
3.  发现版本号为 `1` 的脚本还未执行。
4.  执行该 SQL 文件中的命令，创建 `user` 表。
5.  在 `flyway_schema_history` 表中插入一条记录，包含版本号、描述、校验和以及执行状态。

**3. 后续更新：添加手机号字段**
创建新的迁移脚本：`V1.1__Add_phone_to_user_table.sql`

```sql
ALTER TABLE user ADD phone VARCHAR(20);
```
再次启动应用，Flyway 会识别到新版本 `V1.1` 的脚本，并自动执行 `ALTER TABLE` 语句。

---

#### Liquibase vs. Flyway：核心区别与如何选择

| 特性 | Flyway | Liquibase |
| :--- | :--- | :--- |
| **核心哲学** | **简单、直接**，基于 SQL | **灵活、强大**，基于抽象变更描述 |
| **变更定义** | 纯 SQL 文件 | XML, YAML, JSON 或 SQL 格式 |
| **学习成本** | **低**（只需懂SQL和命名规则） | **中**（需要学习其DSL语法和概念） |
| **数据库无关性** | **弱**。SQL 脚本是针对特定数据库编写的。如果要换数据库，需要准备多套脚本。 | **强**。声明式的变更描述由 Liquibase 转换为特定数据库的 SQL，一套配置通用。 |
| **回滚（Rollback）** | **社区版不支持自动回滚**。需要自己编写撤销迁移脚本（如 `U2__Undo_V2.sql`），但这并非核心功能。**付费版支持。** | **支持良好**。可以在变更集中直接定义回滚语句（如 `rollback: dropTable tableName: user`），是核心功能之一。 |
| **可读性/可维护性** | SQL 对开发者非常直观。但大量变更时，文件会很多。 | 声明式格式更紧凑，一个文件可包含多个变更。但需要熟悉其语法。 |
| **团队协作** | 如果多人同时修改数据库，在 Git 中合并 SQL 文件可能产生冲突。 | 变更日志文件是结构化的，合并冲突相对容易解决。 |

#### 如何选择？

*   **选择 Flyway 如果：**
    *   你的团队非常熟悉 SQL，希望工具简单透明、学习成本低。
    *   你的项目主要只使用一种数据库（如一直用 MySQL），并且近期没有更换数据库的计划。
    *   你对回滚的需求不强烈，或者可以接受通过编写逆向 SQL 脚本的方式手动处理。

*   **选择 Liquibase 如果：**
    *   你的项目需要支持多种不同的数据库（例如，产品要同时支持 MySQL 和 PostgreSQL）。
    *   你需要强大的、自动化的回滚功能。
    *   你希望数据库变更脚本是结构化的、易于代码审查的（非纯文本 SQL）。
    *   你愿意花一点时间学习其 DSL 以换取长期的灵活性。

**总而言之，两者都是极其优秀的工具。Flyway 胜在简单粗暴，Liquibase 胜在功能强大灵活。** 对于大多数单一数据库项目，Flyway 的简洁性使其成为一个非常有吸引力的选择。
## 51.3 补充：Spring Boot 内置的数据库初始化机制
Spring Boot 提供了一套自己的数据库初始化机制。我们来详细分析一下这个机制，并与 Liquibase/Flyway 进行比较。

### Spring Boot 内置的数据库初始化机制

#### 1. 它是什么技术？

Spring Boot 的这套机制是基于其 **`DataSourceInitializer`** 组件实现的。它**不依赖于任何第三方数据库版本控制工具**，是 Spring Framework 和 Spring Boot 自带的核心功能。

**工作原理：**
- 当应用启动时，Spring Boot 会检查 `spring.sql.init.mode` 属性。
- 如果设置为 `always`（或在不安全的嵌入式数据库中默认为此行为），它会自动查找指定的 SQL 文件。
- 它会创建一个 `DataSourceInitializer` Bean，该 Bean 会使用 Spring 的 `ResourceDatabasePopulator` 来**按顺序解析和执行**你指定的 SQL 脚本。
- 它**不会**在数据库中创建任何表来跟踪执行状态。

---

### 2. 与 Liquibase/Flyway 的核心区别

这三者虽然目标相似（初始化/更新数据库），但设计哲学、能力和适用场景有根本性不同。我们可以从以下几个维度来对比：

| 特性 | Spring Boot 内置初始化 | Flyway | Liquibase |
| :--- | :--- | :--- | :--- |
| **核心技术** | Spring Framework 的 `DataSourceInitializer` | 自研的版本控制引擎 | 自研的版本控制引擎 |
| **版本控制** | **无**。每次启动都会尝试执行脚本（取决于 `mode`）。 | **有**。通过 `flyway_schema_history` 表记录版本。 | **有**。通过 `DATABASECHANGELOG` 表记录版本。 |
| **执行策略** | **简单的“如果存在就执行”**。无法感知脚本是否已执行过。 | **幂等性执行**。只执行未应用的新迁移脚本。 | **幂等性执行**。只执行未应用的新变更集。 |
| **回滚 (Rollback)** | **不支持**。 | 社区版不支持自动回滚，需手动写回退SQL。企业版支持。 | **支持良好**。可在变更集中定义回滚操作。 |
| **适用场景** | 1. 简单的演示项目、测试。<br>2. 始终需要全量重置数据的场景（如测试环境）。<br>3. **初始化固定不变的基础数据**（如国家列表、货币类型）。 | 1. 需要严格版本控制的真实项目。<br>2. 团队协作开发。<br>3. 生产环境的数据库部署。 | 1. 需要严格版本控制且追求数据库无关性的项目。<br>2. 需要强大回滚功能的项目。<br>3. 团队协作开发。 |
| **脚本管理** | 简单的文件路径配置。通常只有一两个文件（`schema.sql`, `data.sql`）。 | 严格的命名规则（`V1__Description.sql`），支持多个版本脚本。 | 结构化的主变更日志文件，可包含多个子文件，支持多种格式（YAML/XML/JSON/SQL）。 |
| **安全性** | **低**。容易因重复执行导致错误（如重复创建表）。 | **高**。通过版本记录确保安全。 | **高**。通过版本记录确保安全。 |

---

### 3. 详细对比与示例

让我们用一个例子来说明三者的不同行为。

**场景：** 你需要为 `user` 表添加一个 `age` 字段。

#### Spring Boot 内置初始化 的“问题”方式

1.  **你可能会修改已有的 `schema.sql` 文件：**
    ```sql
    -- schema.sql (修改后的版本)
    DROP TABLE IF EXISTS user;
    CREATE TABLE user (
        id BIGINT AUTO_INCREMENT PRIMARY KEY,
        username VARCHAR(255),
        age INT -- 新增的字段
    );
    ```
2.  **结果：**
    - **第一次启动：** 成功创建带有 `age` 字段的 `user` 表。
    - **第二次及以后启动：** **每次启动都会先执行 `DROP TABLE`，再 `CREATE TABLE`**。这会导致：
        - 所有现有数据**被清空**！
        - 如果 `data.sql` 中有初始化数据，会被重新插入。
        - 这显然不适用于生产环境或任何已有真实数据的场景。

#### Flyway/Liquibase 的“正确”方式

1.  **Flyway:** 创建一个新的迁移脚本 `V2__Add_age_to_user.sql`，里面只包含 `ALTER TABLE user ADD age INT;`。
2.  **Liquibase:** 创建一个新的变更集，描述 `addColumn` 操作。
3.  **结果：**
    - **第一次启动（V2 脚本未执行时）：** 执行 `ALTER TABLE` 语句，安全地添加字段。**现有数据完好无损。**
    - **第二次及以后启动：** Flyway/Liquibase 检查到 `V2` 已经执行过，**直接跳过**。绝对安全。

---

### 4. 如何正确使用 Spring Boot 的内置初始化？

虽然它不能用于版本控制，但在特定场景下非常有用：

1.  **与版本控制工具配合使用：**
    - 用 **Liquibase/Flyway** 来管理**数据库结构（DDL）的变更**（建表、改表）。
    - 用 Spring Boot 的 `data.sql` 来插入**应用运行所必需的、固定的基础数据（DML）**。
    - **配置示例：**
      ```yaml
      # 使用 Liquibase 进行 DDL 版本控制
      spring.liquibase.enabled: true
      spring.liquibase.change-log: classpath:db/changelog/db.changelog-master.yaml

      # 使用内置机制初始化基础数据（但只在没有表的时候才插入，避免重复）
      spring.sql.init.mode: always
      # 注意：只配置 data-locations，不配置 schema-locations！
      spring.sql.init.data-locations: classpath:db/data.sql
      ```
    这样，Liquibase 会负责创建和更新表结构，然后 Spring Boot 会插入基础数据。`data.sql` 中的 `INSERT` 语句应该使用 `INSERT IGNORE` 或 `ON CONFLICT DO NOTHING` 等语法来避免重复插入。

2.  **用于测试环境：**
    在集成测试中，你可能希望每次测试都从一个干净的数据库开始。这时可以配置为 `always`，并在 `schema.sql` 中编写完整的建表语句，在 `data.sql` 中准备测试数据。

### 总结

- **Spring Boot 内置初始化**：是一个**简单、一次性**的数据库填充工具。它**没有版本控制概念**，适用于数据重置、插入基础数据或极其简单的项目。**绝对不能用于管理生产环境的数据库结构变更**。

- **Liquibase / Flyway**：是**专业的数据库版本控制（Schema Migration）工具**。它们通过跟踪已执行的版本来实现**幂等性**和**安全性**，是管理数据库结构演进的事实标准，适用于任何严肃的、尤其是团队协作的项目。

简单来说，Spring Boot 内置的机制是 **“初始化”**，而 Liquibase/Flyway 是 **“版本迁移”**。前者像是一张白纸，每次都可以重画；后者则像一本历史书，记录着每一次修改，并确保能安全地翻到最新一页。
# 五十二、▶SpringBoot集成Redis - 基于RedisTemplate+Jedis的数据操作
> Redis是最常用的KV数据库，Spring 通过模板方式（RedisTemplate）提供了对Redis的数据查询和操作功能。本文主要介绍基于RedisTemplate + Jedis方式对Redis进行查询和操作的案例。
## 52.1 知识准备
### 52.1.1 Redis基础和5种基础数据类型
首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。
![214.db-redis-ds-1.jpeg](../../assets/images/04-主流框架/spring/214.db-redis-ds-1.jpeg)


| 结构类型 | 结构说明 | 存储的值 | 读写能力 |
| :--- | :--- | :--- | :--- |
| **String（字符串）** | 最简单的键值对类型 | 可以是字符串、整数或浮点数 | - 对整个字符串或部分字符串进行操作<br>- 对整数或浮点数进行自增（INCR）或自减（DECR）操作 |
| **List（列表）** | 一个有序的字符串链表 | 链表上的每个节点都包含一个字符串 | - 对链表两端进行推入（LPUSH/RPUSH）和弹出（LPOP/RPOP）操作<br>- 读取单个或多个元素<br>- 根据值查找或删除元素 |
| **Set（集合）** | 一个无序的、不重复的字符串集合 | 包含字符串的无序集合 | - 检查元素是否存在、添加、获取、删除元素<br>- 计算多个集合的交集（SINTER）、并集（SUNION）、差集（SDIFF） |
| **Hash（散列）** | 适合存储对象的键值对集合 | 包含字段（Field）和值（Value）的无序散列表 | - 添加（HSET）、获取（HGET）、删除（HDEL）单个字段<br>- 一次性获取或设置所有字段 |
| **Zset / Sorted Set（有序集合）** | 带排序功能的 Set | 字符串成员（Member）与浮点数分数（Score）之间的有序映射 | - 添加、获取、删除单个元素<br>- 根据分值范围或成员来获取元素<br>- **元素的排列顺序由分数的大小决定** |
### 52.1.2 什么是Jedis
Jedis是Redis的Java客户端，在SpringBoot 1.x版本中也是默认的客户端。在SpringBoot 2.x版本中默认客户端是Luttuce。
### 52.1.3 Spring中的Template和RedisTemplate
> Spring 通过模板方式（RedisTemplate）提供了对Redis的数据查询和操作功能。
- 什么是模板模式？

模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤。
![215.c3c1c0e8-3a78-4426-961f-b46dd0879dd8.png](../../assets/images/04-主流框架/spring/215.c3c1c0e8-3a78-4426-961f-b46dd0879dd8.png)
- Spring中有哪些模板模式的设计？

比如：jdbcTemplate, mongodbTemplate, elasticsearchTemplate...等等
- RedisTemplate对于Redis5种基础类型的操作？
```java
redisTemplate.opsForValue(); // 操作字符串
redisTemplate.opsForHash(); // 操作hash
redisTemplate.opsForList(); // 操作list
redisTemplate.opsForSet(); // 操作set
redisTemplate.opsForZSet(); // 操作zset
```
- 对HyperLogLogs（基数统计）类型的操作?
```java
redisTemplate.opsForHyperLogLog();
```
- 对geospatial (地理位置)类型的操作?
```java
redisTemplate.opsForGeo();
```
- 对于BitMap的操作？也是在opsForValue()方法返回类型ValueOperations中
```java
Boolean setBit(K key, long offset, boolean value);
Boolean getBit(K key, long offset);
```
- 对于Stream的操作？
```java
redisTemplate.opsForStream();
```
## 52.2 实现案例
> 本例子主要基于SpringBoot2+ 使用Jedis客户端，通过RedisTemplate模板方式访问Redis数据。
### 52.2.1 包依赖
引入spring-boot-starter-data-redis包，SpringBoot2中默认的客户端是Lettuce, 所以需要exclude掉lettuce-core包，并引入jedis的包。
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>lettuce-core</artifactId>
            <groupId>io.lettuce</groupId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
    <version>2.9.0</version>
</dependency>
```
### 52.2.2 yml配置
如下是常用的Jedis的使用配置
```yml
spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
    password: test
    jedis:
      pool:
        min-idle: 0
        max-active: 8
        max-idle: 8
        max-wait: -1ms
    connect-timeout: 30000ms
```
### 52.2.3 RedisConfig配置

通过@Bean的方式配置RedisTemplate，主要是设置RedisConnectionFactory以及各种类型数据的Serializer。
```java
package tech.pdai.springboot.redis.jedis.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Redis configuration.
 *
 * @author pdai
 */
@Configuration
public class RedisConfig {

    /**
     * redis template.
     *
     * @param factory factory
     * @return RedisTemplate
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}
```
### 52.2.4 RedisTemplate的使用
我们以整个系列文章一致的UserController简单示例下
```java
package tech.pdai.springboot.redis.jedis.controller;


import io.swagger.annotations.ApiOperation;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.redis.jedis.entity.User;
import tech.pdai.springboot.redis.jedis.entity.response.ResponseResult;

import javax.annotation.Resource;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    // 注意：这里@Autowired是报错的，因为@Autowired按照类名注入的
    @Resource
    private RedisTemplate<String, User> redisTemplate;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        redisTemplate.opsForValue().set(String.valueOf(user.getId()), user);
        return ResponseResult.success(redisTemplate.opsForValue().get(String.valueOf(user.getId())));
    }

    /**
     * @return user list
     */
    @ApiOperation("Find")
    @GetMapping("find/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") String userId) {
        return ResponseResult.success(redisTemplate.opsForValue().get(userId));
    }

}
```
### 52.2.5 简单测试
插入数据：redisTemplate.opsForValue().set();
![216.springboot-redis-jedis-2.png](../../assets/images/04-主流框架/spring/216.springboot-redis-jedis-2.png)

获取数据：redisTemplate.opsForValue().get();

![217.springboot-redis-jedis-1.png](../../assets/images/04-主流框架/spring/217.springboot-redis-jedis-1.png)
# 五十三、SpringBoot集成Redis - 基于RedisTemplate+Lettuce数据操作
> 在SpringBoot 2.x版本中Redis默认客户端是Lettuce，本文主要介绍SpringBoot 和默认的Lettuce的整合案例。
## 53.1 知识准备
### 53.1.1 什么是Lettuce?
> Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection。它利用优秀 netty NIO 框架来高效地管理多个连接。<a href='https://github.com/redis/lettuce'>Github</a>

Lettuce的特性：
- 支持 同步、异步、响应式 的方式
- 支持 Redis Sentinel
- 支持 Redis Cluster
- 支持 SSL 和 Unix Domain Socket 连接
- 支持 Streaming API
- 支持 CDI 和 Spring 的集成
- 支持 Command Interfaces
- 兼容 Java 8+ 以上版本
### 53.1.2 为何SpringBoot2.x中Lettuce会成为默认的客户端？
> 除了上述特性的支持性之外，最为重要的是Lettuce中使用了Netty框架，使其具备线程共享和异步的支持性。
- 线程共享

Jedis 是直连模式，在多个线程间共享一个 Jedis 实例时是线程不安全的，如果想要在多线程环境下使用 Jedis，需要使用连接池，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，物理连接成本就较高了。

Lettuce 是基于 netty 的，连接实例可以在多个线程间共享，所以，一个多线程的应用可以使用一个连接实例，而不用担心并发线程的数量。
- 异步和反应式

Lettuce 从一开始就按照非阻塞式 IO 进行设计，是一个纯异步客户端，对异步和反应式 API 的支持都很全面。

即使是同步命令，底层的通信过程仍然是异步模型，只是通过阻塞调用线程来模拟出同步效果而已。

PS: Jedis和Lettuce的对比如下，参考<a href='https://docs.spring.io/spring-data/redis/reference/#redis:connectors:connection'>官方文档</a>
![218.springboot-redis-lettuce-1.png](../../assets/images/04-主流框架/spring/218.springboot-redis-lettuce-1.png)
### 53.1.3 Lettuce的基本的API方式
- 依赖POM包
```xml
<dependency>
  <groupId>io.lettuce</groupId>
  <artifactId>lettuce-core</artifactId>
  <version>x.y.z.BUILD-SNAPSHOT</version>
</dependency>
```
- 基础用法
```java
RedisClient client = RedisClient.create("redis://localhost");
StatefulRedisConnection<String, String> connection = client.connect();
RedisStringCommands sync = connection.sync();
String value = sync.get("key");
```
- 异步方式
```java
StatefulRedisConnection<String, String> connection = client.connect();
RedisStringAsyncCommands<String, String> async = connection.async();
RedisFuture<String> set = async.set("key", "value")
RedisFuture<String> get = async.get("key")

async.awaitAll(set, get) == true

set.get() == "OK"
get.get() == "value"
```
- 响应式
```java
StatefulRedisConnection<String, String> connection = client.connect();
RedisStringReactiveCommands<String, String> reactive = connection.reactive();
Mono<String> set = reactive.set("key", "value");
Mono<String> get = reactive.get("key");

set.subscribe();

get.block() == "value"
```
## 53.2 实现案例
> 本例子主要基于SpringBoot2+ 使用Lettuce客户端，通过RedisTemplate模板方式访问Redis数据。
### 53.2.1 包依赖
引入spring-boot-starter-data-redis包，SpringBoot2中默认的客户端是Lettuce。
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
    <version>2.9.0</version>
</dependency>
```
### 53.2.2 yml配置
如下是常用的Lettuce的使用配置
```yml
spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
    password: test
    lettuce:
      pool:
        min-idle: 0
        max-active: 8
        max-idle: 8
        max-wait: -1ms
    connect-timeout: 30000ms
```
### 53.2.3 RedisConfig配置
通过@Bean的方式配置RedisTemplate，主要是设置RedisConnectionFactory以及各种类型数据的Serializer。
```java
package tech.pdai.springboot.redis.lettuce.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Redis configuration.
 *
 * @author pdai
 */
@Configuration
public class RedisConfig {

    /**
     * redis template.
     *
     * @param factory factory
     * @return RedisTemplate
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}
```
### 53.2.4 RedisTemplate的使用
我们以整个系列文章一致的UserController简单示例下
```java
package tech.pdai.springboot.redis.lettuce.controller;


import io.swagger.annotations.ApiOperation;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.redis.lettuce.entity.User;
import tech.pdai.springboot.redis.lettuce.entity.response.ResponseResult;

import javax.annotation.Resource;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    // 注意：这里@Autowired是报错的，因为@Autowired按照类名注入的
    @Resource
    private RedisTemplate<String, User> redisTemplate;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        redisTemplate.opsForValue().set(String.valueOf(user.getId()), user);
        return ResponseResult.success(redisTemplate.opsForValue().get(String.valueOf(user.getId())));
    }

    /**
     * @return user list
     */
    @ApiOperation("Find")
    @GetMapping("find/{userId}")
    public ResponseResult<User> find(@PathVariable("userId") String userId) {
        return ResponseResult.success(redisTemplate.opsForValue().get(userId));
    }

}
```
### 53.2.5 简单测试
插入数据：redisTemplate.opsForValue().set();
![219.springboot-redis-lettuce-1.png](../../assets/images/04-主流框架/spring/219.springboot-redis-lettuce-1.png)

获取数据：redisTemplate.opsForValue().get();
![220.springboot-redis-lettuce-2.png](../../assets/images/04-主流框架/spring/220.springboot-redis-lettuce-2.png)

查看Redis中的数据(通过Redis Desktop Manager)
![221.springboot-redis-lettuce-3.png](../../assets/images/04-主流框架/spring/221.springboot-redis-lettuce-3.png)
## 53.3 为什么需要引入common-pool2
引入 `commons-pool2` 的原因是 Spring Boot 的 Redis 客户端（通常是 Lettuce 或 Jedis）**依赖连接池来管理 Redis 连接**。具体说明如下：

---

### 53.3.1. **连接池的作用**
- **复用连接**：避免每次操作 Redis 都创建和销毁连接（TCP 连接开销大）。
- **控制资源**：限制最大连接数，防止服务因过多连接而崩溃。
- **提高性能**：复用已建立的连接，减少网络延迟和系统资源消耗。

---

### 53.3.2. **为什么需要显式引入 `commons-pool2`？**
- Spring Boot 2.x 版本后，默认的 Redis 客户端是 **Lettuce**，而 Lettuce 本身基于 Netty 实现，**不需要**外部连接池（它内置连接管理）。
- 但如果你使用 **Jedis** 客户端（通过配置 `spring.redis.client-type=jedis`），或者某些旧版本依赖，**Jedis 依赖 `commons-pool2` 实现连接池**。
- 即使使用 Lettuce，如果配置了 `spring.redis.lettuce.pool` 相关参数，Spring Boot 也会自动引入 `commons-pool2` 来支持连接池功能。

---

### 53.3.3. **不引入 `commons-pool2` 可以吗？**
- **可以**，但需满足以下条件：
  - 使用 Lettuce 客户端且不配置连接池（用默认的单连接模式）。
  - 应用并发量低，无需连接池优化（例如测试环境）。
- **不建议省略**的原因：
  - 生产环境通常需要连接池来保证性能和稳定性。
  - 如果未来切换为 Jedis 或启用连接池配置，缺少 `commons-pool2` 会导致启动报错。

---

### 53.3.4. **Spring Boot 的自动依赖管理**
- 如果使用 Spring Boot 的父 POM（或 BOM），通常无需指定 `commons-pool2` 版本，Spring Boot 会自动管理兼容版本。例如：
  ```xml
  <!-- 版本由 Spring Boot 管理 -->
  <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-pool2</artifactId>
  </dependency>
  ```

---

### 53.3..5 总结
- **推荐引入** `commons-pool2`，以适应生产环境的连接池需求，避免潜在兼容性问题。
- 如果只是本地测试且使用 Lettuce 单连接模式，可以暂时不引入，但需注意未来扩展性。
# 五十四、SpringBoot集成Redis - 基于RedisTemplate+Lettuce数据类封装
> 前两篇文章介绍了SpringBoot基于RedisTemplate的数据操作，那么如何对这些操作进行封装呢？本文主要介绍基于RedisTemplate的封装。
## 54.1 知识准备
### 54.1.1 有了RedisTemplate为什么还要进一步封装？
RedisTemplate中的操作和方法众多，为了程序保持方法使用的一致性，屏蔽一些无关的方法以及对使用的方法进一步封装。

PS：同样的类似思路也体现在很多场景中，比如Tomcat Request利用外观模式改造。
## 54.2 实现案例
### 54.2.1 RedisService封装
- RedisService接口类
```java
package tech.pdai.springboot.redis.lettuce.enclosure.service;

import org.springframework.data.redis.core.RedisCallback;

import java.util.Collection;
import java.util.Set;

/**
 * Redis Service.
 *
 * @author pdai
 */
public interface IRedisService<T> {

    void set(String key, T value);

    void set(String key, T value, long time);

    T get(String key);

    void delete(String key);

    void delete(Collection<String> keys);

    boolean expire(String key, long time);

    Long getExpire(String key);

    boolean hasKey(String key);

    Long increment(String key, long delta);

    Long decrement(String key, long delta);

    void addSet(String key, T value);

    Set<T> getSet(String key);

    void deleteSet(String key, T value);

    T execute(RedisCallback<T> redisCallback);
}
```
- RedisService的实现类
```java
package tech.pdai.springboot.redis.lettuce.enclosure.service.impl;

import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.redis.lettuce.enclosure.service.IRedisService;

import javax.annotation.Resource;
import java.util.Collection;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @author pdai
 */
@Service
public class RedisServiceImpl<T> implements IRedisService<T> {

    @Resource
    private RedisTemplate<String, T> redisTemplate;

    @Override
    public void set(String key, T value, long time) {
        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
    }

    @Override
    public void set(String key, T value) {
        redisTemplate.opsForValue().set(key, value);
    }

    @Override
    public T get(String key) {
        return redisTemplate.opsForValue().get(key);
    }

    @Override
    public void delete(String key) {
        redisTemplate.delete(key);
    }

    @Override
    public void delete(Collection<String> keys) {
        redisTemplate.delete(keys);
    }

    @Override
    public boolean expire(String key, long time) {
        return redisTemplate.expire(key, time, TimeUnit.SECONDS);
    }

    @Override
    public Long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }

    @Override
    public boolean hasKey(String key) {
        return redisTemplate.hasKey(key);
    }

    @Override
    public Long increment(String key, long delta) {
        return redisTemplate.opsForValue().increment(key, delta);
    }

    @Override
    public Long decrement(String key, long delta) {
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    @Override
    public void addSet(String key, T value) {
        redisTemplate.opsForSet().add(key, value);
    }

    @Override
    public Set<T> getSet(String key) {
        return redisTemplate.opsForSet().members(key);
    }

    @Override
    public void deleteSet(String key, T value) {
        redisTemplate.opsForSet().remove(key, value);
    }

    @Override
    public T execute(RedisCallback<T> redisCallback) {
        return redisTemplate.execute(redisCallback);
    }

}
```
### 54.2.2 RedisService的调用
UserController类中调用RedisService
```java
package tech.pdai.springboot.redis.lettuce.enclosure.controller;


import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.redis.lettuce.enclosure.entity.User;
import tech.pdai.springboot.redis.lettuce.enclosure.entity.response.ResponseResult;
import tech.pdai.springboot.redis.lettuce.enclosure.service.IRedisService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IRedisService<User> redisService;

    /**
     * @param user user param
     * @return user
     */
    @ApiOperation("Add")
    @PostMapping("add")
    public ResponseResult<User> add(User user) {
        redisService.set(String.valueOf(user.getId()), user);
        return ResponseResult.success(redisService.get(String.valueOf(user.getId())));
    }

    /**
     * @return user list
     */
    @ApiOperation("Find")
    @GetMapping("find/{userId}")
    public ResponseResult<User> edit(@PathVariable("userId") String userId) {
        return ResponseResult.success(redisService.get(userId));
    }

}
```
## 54.3 补充
### 54.3.1 另一种封装方式(全部以字符串为主)
```java
public class BaseCacheService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    protected <T> void put(String key, T value) {
        if (null == value) {
            return;
        }
        redisTemplate.opsForValue().set(key, JacksonTool.json2Str(value), 5L, TimeUnit.MINUTES);
    }

    protected <T> void put(String key, T value, long timeout, TimeUnit unit) {
        if (null == value) {
            return;
        }
        if (-1L == timeout) {
            redisTemplate.opsForValue().set(key, JacksonTool.json2Str(value));
        } else {
            redisTemplate.opsForValue().set(key, JacksonTool.json2Str(value), timeout, unit);
        }

    }

    protected <T> T get(String key, Class<T> clazz) {
        String result = redisTemplate.opsForValue().get(key);
        return null == result ? null : JacksonTool.json2Bean(result, clazz);
    }

    protected <T> List<T> multiGet(Collection<String> keys, Class<T> clazz) {
        List<T> result = new ArrayList<>();
        List<String> list = redisTemplate.opsForValue().multiGet(keys);
        if (CollectionUtils.isNotEmpty(list)) {
            for (String res : list) {
                T t = JacksonTool.json2Bean(res, clazz);
                result.add(t);
            }
        }
        return result;
    }

    protected boolean delete(String key) {
        Boolean deleteBoolean = redisTemplate.delete(key);
        return null == deleteBoolean ? false : deleteBoolean;
    }

    protected boolean delete(List<String> keys) {
        Long deleteSize = redisTemplate.delete(keys);
        return deleteSize > 0;
    }

    protected boolean exist(String key) {
        Boolean result = redisTemplate.hasKey(key);
        return result == null ? false : result;
    }

    protected Set<String> keys(String pattern) {
        return redisTemplate.keys(pattern);
    }
}
```
### 54.3.2 Redis 中对象的存储状态

当 `value` 是一个对象时，Redis 中存储的是**序列化后的字节数据**，而不是对象的原始形式。

#### 54.3.2.1. **存储过程（序列化）**
```java
// 当调用 set(key, value) 时
redisTemplate.opsForValue().set(key, value);
```
- RedisTemplate 会使用配置的 **ValueSerializer** 将对象序列化成字节数组
- 默认情况下，Spring Boot 使用 **JDK 序列化**（`JdkSerializationRedisSerializer`）
- 序列化后的数据以二进制形式存储在 Redis 中

#### 54.3.2.2. **查看 Redis 中的实际存储**
如果你连接到 Redis 查看，会看到类似这样的内容：
```
127.0.0.1:6379> get user:1
"\xac\xed\x00\x05sr\x00 com.example.User\xb2..."
```
这就是 JDK 序列化后的二进制数据。

#### 54.3.2.3. **为什么 get() 能获取到对象（反序列化）**
```java
// 当调用 get(key) 时
T value = redisTemplate.opsForValue().get(key);
```
- RedisTemplate 使用相同的 **ValueSerializer** 将字节数据反序列化成 Java 对象
- 序列化和反序列化必须使用相同的序列化器
- **JDK 序列化 必须实现 Serializable 接口**
### 54.3.3 序列化方式的配置
```java
package tech.pdai.springboot.redis.lettuce.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Redis configuration.
 *
 * @author pdai
 */
@Configuration
public class RedisConfig {

    /**
     * redis template.
     *
     * @param factory factory
     * @return RedisTemplate
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
}
```
这里的配置中
```java
template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
```

#### 54.3.3.1. **GenericJackson2JsonRedisSerializer 的特点**
- **JSON 序列化**：将对象序列化为 JSON 字符串
- **类型信息保留**：会在 JSON 中添加 `@class` 字段来记录原始类型信息
- **可读性强**：Redis 中存储的是可读的 JSON 格式

#### 54.3.3.2. **存储示例**
假设存储一个 User 对象：
```java
User user = new User(1L, "张三", 25);
redisTemplate.opsForValue().set("user:1", user);
```

**Redis 中实际存储的内容：**
```json
{
  "@class": "com.example.User",
  "id": 1,
  "name": "张三",
  "age": 25
}
```

#### 54.3.3.3. **反序列化过程**
当调用 `get("user:1")` 时：
- GenericJackson2JsonRedisSerializer 读取 JSON 数据
- 通过 `@class` 字段识别出原始类型 `com.example.User`
- 自动将 JSON 反序列化为 User 对象

#### 54.3.3.4 验证配置是否生效

你可以通过以下方式验证：

```java
@Autowired
private RedisTemplate<String, Object> redisTemplate;

@Test
public void testSerialization() {
    User user = new User(1L, "测试用户", 25);
    redisTemplate.opsForValue().set("test:user", user);
    
    // 直接使用 redis-cli 查看存储内容
    // 应该能看到 JSON 格式的数据，而不是二进制
}
```

#### 54.3.3.5 配置的优点

1. **数据可读**：可以在 Redis 中直接查看 JSON 内容
2. **跨语言兼容**：其他语言也可以读取这些数据
3. **类型安全**：自动处理类型转换
4. **调试方便**：便于排查问题

##### 54.3.3.6 注意事项

1. **类路径一致性**：`@class` 字段记录的类必须在反序列化时存在于 classpath 中
2. **无参构造函数**：反序列化的类需要有无参构造函数
3. **版本兼容**：类结构变化可能导致反序列化失败
### 54.3.4 Jackson2JsonRedisSerializer和GenericJackson2JsonRedisSerializer有什么区别
在设置redis的序列化类型时，存在两种json序列化的形式
1. Jackson2JsonRedisSerializer
```java
@Bean
    public RedisTemplate<String, Object> redisTemplate(RedisSerializer<Object> redisSerializer) {
        RedisTemplate<String, Object> template = new RedisTemplate();
        template.setConnectionFactory(this.connectionFactory);
        template.setDefaultSerializer(this.redisSerializer());
        RedisSerializer<String> stringSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringSerializer);
        template.setValueSerializer(redisSerializer);
        template.setHashKeySerializer(stringSerializer);
        template.setHashValueSerializer(redisSerializer);
        template.afterPropertiesSet();
        return template;
    }

    @Bean
    public RedisSerializer<Object> redisSerializer() {
        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        jackson2JsonRedisSerializer.setObjectMapper(this.objectMapper());
        return jackson2JsonRedisSerializer;
    }
```
2. GenericJackson2JsonRedisSerializer
```java
  @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    }
```
这两个序列化器的主要区别在于**是否在JSON中存储类型信息**。

#### 54.3.4.1 核心区别对比

| 特性 | Jackson2JsonRedisSerializer | GenericJackson2JsonRedisSerializer |
|------|----------------------------|-----------------------------------|
| **类型信息** | 不存储类型信息 | 存储类型信息（@class字段） |
| **反序列化** | 需要明确指定类型 | 自动识别原始类型 |
| **数据体积** | 较小 | 稍大（包含类型信息） |
| **灵活性** | 较低 | 较高 |

#### 54.3.4.2 详细分析

##### 54.3.4.2.1. **Jackson2JsonRedisSerializer**
```java
// 需要指定具体类型
Jackson2JsonRedisSerializer<User> serializer = 
    new Jackson2JsonRedisSerializer<>(User.class);

// 存储示例
User user = new User(1L, "张三");
redisTemplate.opsForValue().set("user:1", user);

// Redis中存储的内容：
{"id":1,"name":"张三"}  // 没有类型信息
```

**特点：**
- 必须指定具体的Class类型
- JSON中不包含类型元数据
- 反序列化时必须知道原始类型

##### 54.3.4.2.2. **GenericJackson2JsonRedisSerializer**（你正在使用的）
```java
// 不需要指定具体类型
GenericJackson2JsonRedisSerializer serializer = 
    new GenericJackson2JsonRedisSerializer();

// 存储示例
User user = new User(1L, "张三");
redisTemplate.opsForValue().set("user:1", user);

// Redis中存储的内容：
{
  "@class": "com.example.User",  // 包含类型信息
  "id": 1,
  "name": "张三"
}
```

**特点：**
- 自动在JSON中添加`@class`字段记录类型
- 反序列化时能自动识别并转换回原始类型
- 支持多态类型处理

#### 54.3.4.3 实际使用场景对比

##### 54.3.4.3.1 场景1：明确类型的简单使用
```java
// 使用 Jackson2JsonRedisSerializer（需要类型转换）
Jackson2JsonRedisSerializer<User> serializer = new Jackson2JsonRedisSerializer<>(User.class);
template.setValueSerializer(serializer);

User user = new User(1L, "张三");
redisTemplate.opsForValue().set("user:1", user);

// 读取时必须进行类型转换
User result = (User) redisTemplate.opsForValue().get("user:1");
```

##### 54.3.4.3.2 场景2：混合类型存储（你当前的配置更合适）
```java
// 使用 GenericJackson2JsonRedisSerializer
template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

// 可以存储不同类型的对象
redisTemplate.opsForValue().set("user:1", new User(1L, "张三"));
redisTemplate.opsForValue().set("product:1", new Product(100L, "手机"));
redisTemplate.opsForValue().set("config:timeout", 300);  // 甚至基本类型

// 读取时自动识别类型
Object userObj = redisTemplate.opsForValue().get("user:1");      // 自动转为User
Object productObj = redisTemplate.opsForValue().get("product:1"); // 自动转为Product
Object timeoutObj = redisTemplate.opsForValue().get("config:timeout"); // 自动转为Integer
```

#### 54.3.4.4 性能和安全考虑

##### 54.3.4.4.1 数据大小对比
```java
User user = new User(1L, "张三");

// Jackson2JsonRedisSerializer存储大小：约 30 bytes
{"id":1,"name":"张三"}

// GenericJackson2JsonRedisSerializer存储大小：约 60 bytes  
{
  "@class": "com.example.User",
  "id": 1,
  "name": "张三"
}
```

##### 54.3.4.4.2 安全考虑
**GenericJackson2JsonRedisSerializer** 可能存在反序列化安全问题，因为它会尝试实例化`@class`指定的任何类。

#### 54.3.4.5 推荐使用场景

##### 54.3.4.5.1 使用 Jackson2JsonRedisSerializer 当：
- 存储的数据类型单一明确
- 对存储空间有严格要求
- 需要与其他系统（非Java）共享数据

##### 54.3.4.5.2 使用 GenericJackson2JsonRedisSerializer 当：
- 需要存储多种类型的对象（你的场景）
- 方便开发和调试
- 类型安全更重要
### 54.3.5 关于54.3.1节的封装和54.2.1节封装的不同之处
上面的过程中我们提供了两种封装的案例，54.3.1节的封装和54.2.1节封装

但是这两种方式有着本质的不同就是对于RestTmplate的装配

- 54.3.1:
```java
 @Autowired 
 private RedisTemplate<String, String> redisTemplate; 
```
- 54.2.1:
```java
 @Autowired 
 private RedisTemplate<String, T> redisTemplate; 
```
这两者有着本质的不同就在于他们装配的不是同一个Bean实例。**因为 @Autowired 根据byType是考虑泛型的**。
具体可参考： https://blog.csdn.net/qq_41615959/article/details/130167035

这里涉及到 **Spring 依赖注入的类型匹配机制**，让我详细解释一下：

#### 54.3.5.1 核心原因：Spring 的泛型类型匹配

Spring 在依赖注入时**会考虑泛型信息**，而不仅仅是原始类型。这是通过 `ResolvableType` 机制实现的。

##### 54.3.5.1.1. **Spring 的类型匹配规则**

```java
// 你配置的 Bean
@Bean
public RedisTemplate<String, Object> redisTemplate(...) {
    // 这个 Bean 的类型是：RedisTemplate<String, Object>
}

// 注入时 Spring 会严格匹配泛型
@Autowired
private RedisTemplate<String, String> redisTemplate;  // ❌ 不匹配！泛型不同

@Autowired  
private RedisTemplate<String, Object> redisTemplate;  // ✅ 匹配！类型完全一致
```

##### 54.3.5.1.2. **为什么泛型信息被保留？**

虽然 Java 有泛型擦除，但 Spring 通过特殊机制保留了泛型信息：

```java
// Spring 内部使用 ResolvableType 来保留泛型信息
ResolvableType beanType = ResolvableType.forClassWithGenerics(
    RedisTemplate.class, String.class, Object.class
);

ResolvableType injectionType = ResolvableType.forClassWithGenerics(
    RedisTemplate.class, String.class, String.class
);

// beanType != injectionType，所以不匹配
```

#### 54.3.5.2 实际验证示例

你可以通过以下代码验证：

```java
@SpringBootTest
class RedisTemplateTest {
    
    @Autowired
    private ApplicationContext context;
    
    @Test
    void testTypeMatching() {
        // 查看所有 RedisTemplate Bean
        Map<String, RedisTemplate> beans = context.getBeansOfType(RedisTemplate.class);
        
        for (Map.Entry<String, RedisTemplate> entry : beans.entrySet()) {
            System.out.println("Bean name: " + entry.getKey());
            
            // 获取 Bean 的泛型信息
            ResolvableType type = ResolvableType.forClass(RedisTemplate.class, entry.getValue().getClass());
            System.out.println("Generic types: " + type.getGenerics());
        }
    }
}
```

#### 54.3.5.3 解决方案

##### 54.3.5.3.1 方案1：使用相同的泛型类型（推荐）
```java
// 配置
@Bean
public RedisTemplate<String, Object> redisTemplate(...) {
    // 配置 Object 类型的模板
}

// 使用
@Service
public class MyService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;  // ✅ 匹配
    
    public void storeString(String key, String value) {
        // 虽然配置的是 Object，但可以存储 String（String 也是 Object）
        redisTemplate.opsForValue().set(key, value);
    }
    
    public void storeObject(String key, MyObject value) {
        redisTemplate.opsForValue().set(key, value);
    }
}
```

##### 54.3.5.3.2 方案2：配置多个 RedisTemplate Bean
```java
@Configuration
public class RedisConfig {
    
    // 用于存储 Object 类型（自动序列化）
    @Bean
    public RedisTemplate<String, Object> objectRedisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        // ... 其他配置
        return template;
    }
    
    // 专门用于存储 String 类型
    @Bean  
    public RedisTemplate<String, String> stringRedisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, String> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new StringRedisSerializer());  // 直接存储字符串
        template.afterPropertiesSet();
        return template;
    }
}
```

然后按需注入：
```java
@Service
public class MyService {
    
    @Autowired
    private RedisTemplate<String, Object> objectRedisTemplate;  // 用于对象
    
    @Autowired
    private RedisTemplate<String, String> stringRedisTemplate;  // 用于字符串
    
    public void demo() {
        // 存储对象
        objectRedisTemplate.opsForValue().set("user:1", new User("张三"));
        
        // 存储纯字符串
        stringRedisTemplate.opsForValue().set("config:timeout", "300");
    }
}
```

##### 54.3.5.3.3 方案3：使用 StringRedisTemplate（Spring Boot 内置）
```java
@Service
public class MyService {
    
    // Spring Boot 自动配置的 StringRedisTemplate
    @Autowired
    private StringRedisTemplate stringRedisTemplate;  // RedisTemplate<String, String>
    
    public void storeString(String key, String value) {
        stringRedisTemplate.opsForValue().set(key, value);
    }
}
```

#### 54.3.5.4 为什么你的 RedisServiceImpl 能工作？

回顾你的代码：
```java
@Service
public class RedisServiceImpl<T> implements IRedisService<T> {
    
    @Resource
    private RedisTemplate<String, T> redisTemplate;  // 运行时：RedisTemplate<String, Object>
    
    // 由于泛型擦除，T 被擦除为 Object
    // 所以实际上注入的是 RedisTemplate<String, Object>
    // 正好匹配你配置的 Bean！
}
```

**编译时泛型检查** + **运行时泛型擦除** + **Spring 的类型匹配** = 完美工作！

#### 54.3.6 最佳实践建议

##### 54.3.5.6.1. **统一使用 RedisTemplate<String, Object>**
```java
// 配置一个通用的模板
@Bean
public RedisTemplate<String, Object> redisTemplate(...) {
    // 使用 GenericJackson2JsonRedisSerializer
}

// 所有服务都使用这个模板
@Autowired
private RedisTemplate<String, Object> redisTemplate;
```

##### 54.3.5.6.2. **按场景区分使用**
```java
// 存储对象（自动序列化）
redisTemplate.opsForValue().set("user:1", userObject);

// 存储字符串（同样可以工作，因为 String 也是 Object）
redisTemplate.opsForValue().set("config:name", "myapp");
```

#### 54.3.5.7 总结

**你的 Bean 配置是正确的！** 无法注入 `RedisTemplate<String, String>` 的原因是：

1. ✅ **Spring 严格匹配泛型类型**
2. ✅ **你配置的是 `RedisTemplate<String, Object>`**
3. ✅ **注入 `RedisTemplate<String, String>` 时类型不匹配**
4. ✅ **你的 RedisServiceImpl 能工作是因为泛型擦除后匹配**

建议统一使用 `RedisTemplate<String, Object>`，它可以处理所有类型（包括 String），更加灵活通用！
#### 54.3.6 项目中遇到的关于@Resource的问题
我的一个项目中常使用@Resource注解装配Bean，然后我的ORM框架使用的是mybatis。这就会造成一个问题是，如果mybatis配置的扫描路径太多，可能会把我的service层也创建mybatis的代理对象，而mybatis代理对象刚好名字是和接口一致。导致最终所有的service层接口的代理对象都装配成了mybatis的代理对象，出现问题。
![222.Image20251126142752996.png](../../assets/images/04-主流框架/spring/222.Image20251126142752996.png)

![223.Image20251126143120909.png](../../assets/images/04-主流框架/spring/223.Image20251126143120909.png)

![224.Image20251126143213868.png](../../assets/images/04-主流框架/spring/224.Image20251126143213868.png)
# 五十五、SpringBoot集成Redis - Redis分布式锁的实现
## 55.1 知识准备
> 要了解为何要用分布式锁，以及分布式锁常见的实现方式；以及如何通过Redis实现分布式锁的几种方式。

### 55.1.1 什么是分布式锁，分布式锁有哪些实现方式？
#### 55.1.1.1 什么是分布式锁
> 要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。
- `线程锁`：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。
- `进程锁`：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。
- `分布式锁`：当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问。
#### 55.1.1.2 分布式锁的设计原则
> 分布式锁的最小设计原则：安全性和有效性
Redis的官网上对使用分布式锁提出至少需要满足如下三个要求：
- 互斥（属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。
- 无死锁（属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。
- 容错性（属于有效性）：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。

除此之外，分布式锁的设计中还可以/需要考虑：加
- 锁解锁的同源性：A加的锁，不能被B解锁
- 获取锁是非阻塞的：如果获取不到锁，不能无限期等待；
- 高性能：加锁解锁是高性能的
## 55.2 实现方案
目前主流更倾向于**Redisson + Lua**方案，以下是详细对比和原因分析：

### 55.2.1. **Jedis + Lua 方案**
- **实现方式**：手动编写Lua脚本保证原子性（如SETNX+EXPIRE组合操作）。
- **优点**：
  - 轻量级，依赖少，适合简单场景。
  - 直接控制底层Redis命令，灵活性高。
- **缺点**：
  - **复杂度高**：需自行处理锁续期（看门狗）、重试、可重入等逻辑，易出错。
  - **可靠性挑战**：如未妥善处理过期时间或网络问题，可能导致死锁或锁失效。
  - **功能缺失**：缺乏现成的公平锁、联锁（MultiLock）等高级特性。

### 55.2.2. **Redisson + Lua 方案**
- **实现方式**：基于Netty的异步框架，内置Lua脚本封装分布式锁。
- **优点**：
  - **开箱即用**：直接提供`RLock`接口，支持自动续期、可重入、公平锁等。
  - **高可靠性**：默认集成看门狗机制（默认30秒续期），避免业务未完成时锁过期。
  - **扩展功能**：支持红锁（RedLock）、读写锁、联锁等分布式场景。
  - **社区活跃**：持续更新，兼容Redis集群和哨兵模式。
- **缺点**：
  - 依赖较重（引入Netty等）。
  - 需学习Redisson的API设计。

### 55.2.3. **主流选择趋势**
- **企业级应用**：多数选择**Redisson**，因其降低了复杂度，提供了生产级可靠性。
- **简单场景**：若仅需基础锁功能且希望轻量，可选用Jedis+Lua，但需自行处理边缘情况。
- **性能考量**：Redisson的异步特性在高并发下表现更优，Jedis在简单命令下可能更轻快。

### 55.2.4. 示例对比
#### 55.2.4.1 Jedis + Lua 实现：
```lua
if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then
    redis.call('pexpire', KEYS[1], ARGV[2])
    return 1
else
    return 0
end
```
需自行管理参数和错误处理。

#### 55.2.4.2 Redisson 实现：
```java
RLock lock = redissonClient.getLock("myLock");
lock.lock(); // 自动续期、可重入
try {
    // 业务逻辑
} finally {
    lock.unlock();
}
```

### 55.2.5 总结
**Redisson + Lua 是当前主流推荐方案**，尤其适合需要高可靠性的生产环境。若项目仅需临时锁且不愿引入额外依赖，可考虑Jedis，但需充分测试边缘情况。
## 55.3 实现案例 - Jedis(setNXPX+Lua)
> 本案例主要介绍 基于Jedis客户端下通过： setnx(key,当前时间+过期时间) + Lua 实现分布式锁

### 55.3.1 定义Redis的分布式锁类
- `加锁`： set NX PX + 重试 + 重试间隔

向Redis发起如下命令:` SET productId:lock 0xx9p03001 NX PX 30000` 其中，"productId"由自己定义，可以是与本次业务有关的id，"0xx9p03001"是一串随机值，必须保证全局唯一(原因在后文中会提到)，“NX"指的是当且仅当key(也就是案例中的"productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。"PX 30000"指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。
- `解锁`：采用lua脚本

在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。如果贸然使用服务A持有的key来删除锁，则会误将服务B的锁释放掉。
```lua
if redis.call("get", KEYS[1])==ARGV[1] then
	return redis.call("del", KEYS[1])
else
	return 0
end
```
具体的封装类RedisDistributedLock如下：
```java
package tech.pdai.springboot.redis.jedis.lock.lock;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisCluster;
import redis.clients.jedis.commands.JedisCommands;
import redis.clients.jedis.params.SetParams;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * @author pdai
 */
@Slf4j
public class RedisDistributedLock {

    /**
     * lua script for unlock.
     */
    private static final String UNLOCK_LUA;

    static {
        StringBuilder sb = new StringBuilder();
        sb.append("if redis.call(\"get\",KEYS[1]) == ARGV[1] ");
        sb.append("then ");
        sb.append("    return redis.call(\"del\",KEYS[1]) ");
        sb.append("else ");
        sb.append("    return 0 ");
        sb.append("end ");
        UNLOCK_LUA = sb.toString();
    }

    /**
     * unique lock flag based on thread local.
     */
    private final ThreadLocal<String> lockFlag = new ThreadLocal<>();

    private final StringRedisTemplate redisTemplate;

    public RedisDistributedLock(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public boolean lock(String key, long expire, int retryTimes, long retryDuration) {
        // use JedisCommands instead of setIfAbsense
        boolean result = setRedis(key, expire);

        // retry if needed
        while ((!result) && retryTimes-- > 0) {
            try {
                log.debug("lock failed, retrying..." + retryTimes);
                Thread.sleep(retryDuration);
            } catch (Exception e) {
                return false;
            }

            // use JedisCommands instead of setIfAbsense
            result = setRedis(key, expire);
        }
        return result;
    }

    private boolean setRedis(String key, long expire) {
        try {
            RedisCallback<String> redisCallback = connection -> {
                JedisCommands commands = (JedisCommands) connection.getNativeConnection();
                String uuid = UUID.randomUUID().toString(); // change to distribute UUID generation.
                lockFlag.set(uuid);
                return commands.set(key, uuid, SetParams.setParams().nx().px(expire));
            };
            String result = redisTemplate.execute(redisCallback);
            return !StringUtils.isEmpty(result);
        } catch (Exception e) {
            log.error("set redis occurred an exception", e);
        }
        return false;
    }

    public boolean unlock(String key) {
        boolean success = false;
        try {
            List<String> keys = new ArrayList<>();
            keys.add(key);
            List<String> args = new ArrayList<>();
            args.add(lockFlag.get());

            // use lua script
            RedisCallback<Long> redisCallback = connection -> {
                Object nativeConnection = connection.getNativeConnection();

                if (nativeConnection instanceof JedisCluster) { // cluster mode
                    return (Long) ((JedisCluster) nativeConnection).eval(UNLOCK_LUA, keys, args);
                } else if (nativeConnection instanceof Jedis) { // single mode
                    return (Long) ((Jedis) nativeConnection).eval(UNLOCK_LUA, keys, args);
                }
                return 0L;
            };
            Long result = redisTemplate.execute(redisCallback);
            success = result != null && result > 0;
        } catch (Exception e) {
            log.error("release lock occurred an exception", e);
        } finally {
            if (success) {
                lockFlag.remove();
            }
        }
        return success;
    }

}
```
### 55.3.2 定义AOP拦截点
- 定义RedisLock注解
```java
package tech.pdai.springboot.redis.jedis.lock.annotation;

import java.lang.annotation.*;

/**
 * @author pdai
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface RedisLock {

    /**
     * redis lock key as value.
     *
     * @return lock key
     */
    String value() default "";

    /**
     * how long we hold the lock.
     *
     * @return mills
     */
    long expireMills() default 30000;

    /**
     * if lock failed, do we need to retry, default retry 0 means NO retry.
     *
     * @return retry times
     */
    int retryTimes() default 0;

    /**
     * when we retry to get lock, what's the duration for next retry.
     *
     * @return mills
     */
    long retryDurationMills() default 200;

}
```
### 55.3.3 定义AOP切面
定义AOP切面类RedisLockAspect，用来拦截@RedisLock注解方法，并调用RedisDistributedLock对方法加锁处理。
```java
package tech.pdai.springboot.redis.jedis.lock.lock;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.context.annotation.Configuration;
import tech.pdai.springboot.redis.jedis.lock.annotation.RedisLock;

import javax.annotation.Resource;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * @author pdai
 */
@Slf4j
@Aspect
@Configuration
public class RedisLockAspect {

    /**
     * lock impl.
     */
    @Resource
    private RedisDistributedLock distributedLock;

    /**
     * AOP, around PJP.
     *
     * @param pjp ProceedingJoinPoint
     * @return Object
     * @throws Throwable Throwable
     */
    @Around("@annotation(tech.pdai.springboot.redis.jedis.lock.annotation.RedisLock)")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        // get attribute through annotation
        Method method = ((MethodSignature) pjp.getSignature()).getMethod();
        RedisLock redisLock = method.getAnnotation(RedisLock.class);
        String key = redisLock.value();
        if (StringUtils.isEmpty(key)) {
            Object[] args = pjp.getArgs();
            key = Arrays.toString(args);
        }

        // do lock
        boolean lock = distributedLock.lock(key, redisLock.expireMills(), redisLock.retryTimes(),
                redisLock.retryDurationMills());
        if (!lock) {
            log.debug("get lock failed, key: {}", key);
            return null;
        }

        // execute method, and unlock
        log.debug("get lock success, key: {}", key);
        try {
            // execute
            return pjp.proceed();
        } catch (Exception e) {
            log.error("execute locked method occurred an exception", e);
        } finally {
            // unlock
            boolean releaseResult = distributedLock.unlock(key);
            log.debug("release lock: {}, success: {}", key, releaseResult);
        }

        return null;
    }

}
```
### 55.3.4 切面使用
只需要添加@RedisLock注解即可：
```java
@RedisLock
public void xxxMethod() {

}
```
# 五十六、▶SpringBoot集成MongoDB - 基于MongoTemplate的数据操作 
> MongoDB是一个文档型NoSQL数据库，Spring通过模板方式（MongoTemplate）提供了对MongoDB的数据查询和操作功能。本文主要介绍基于MongoTemplate方式对MongoDB进行数据操作的案例。

## 56.1 知识准备

### 56.1.1 MongoDB基础和核心概念
MongoDB是一个基于分布式文件存储的文档数据库，使用BSON（类似JSON）格式存储数据。核心概念包括数据库（Database）、集合（Collection）和文档（Document），其中集合相当于关系型数据库中的表，文档相当于行。

| 概念 | 说明 | 类比关系型数据库 |
| :--- | :--- | :--- |
| **数据库（Database）** | 物理容器，包含多个集合 | 数据库 |
| **集合（Collection）** | 一组文档的容器，无需固定结构 | 表 |
| **文档（Document）** | 键值对的数据单元，使用BSON格式 | 行 |
| **字段（Field）** | 文档中的键值对 | 列 |

### 56.1.2 什么是MongoTemplate
MongoTemplate是Spring Data MongoDB提供的核心类，用于简化MongoDB的操作。它封装了常见的CRUD（增删改查）方法，支持面向对象的方式操作文档数据。

### 56.1.3 Spring中的模板模式和MongoTemplate
- **模板方法模式**：与RedisTemplate类似，MongoTemplate也基于模板模式，定义了数据操作的骨架，具体实现由Spring处理。
- **Spring中的模板类**：除了MongoTemplate，还有JdbcTemplate、RedisTemplate等。
- **MongoTemplate的常见操作**：
```java
mongoTemplate.save(object); // 插入或更新文档
mongoTemplate.find(query, entityClass); // 查询文档
mongoTemplate.updateFirst(query, update, entityClass); // 更新文档
mongoTemplate.remove(query, entityClass); // 删除文档
```

## 56.2 实现案例
> 本例子基于SpringBoot 2.x+，使用MongoTemplate操作MongoDB数据。

### 56.2.1 包依赖
在pom.xml中引入spring-boot-starter-data-mongodb依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

### 56.2.2 yml配置
在application.yml中配置MongoDB连接信息：
```yml
spring:
  data:
    mongodb:
      host: localhost
      port: 27017
      database: testdb
      # 或使用URI方式：uri: mongodb://user:password@host:port/database
```

### 56.2.3 MongoConfig配置（可选）
如果需自定义配置，可通过@Bean定义MongoTemplate，但SpringBoot通常自动配置：
```java
package tech.pdai.springboot.mongo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.core.MongoTemplate;
import com.mongodb.client.MongoClient;

@Configuration
public class MongoConfig {
    @Bean
    public MongoTemplate mongoTemplate(MongoClient mongoClient) {
        return new MongoTemplate(mongoClient, "testdb");
    }
}
```

### 56.2.4 MongoTemplate的使用
以User实体为例，演示增删改查操作：
```java
package tech.pdai.springboot.mongo.controller;

import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.mongo.entity.User;
import tech.pdai.springboot.mongo.entity.response.ResponseResult;
import javax.annotation.Resource;

@RestController
@RequestMapping("/user")
public class UserController {
    @Resource
    private MongoTemplate mongoTemplate;

    @PostMapping("add")
    public ResponseResult<User> add(@RequestBody User user) {
        User savedUser = mongoTemplate.save(user); // 保存文档，自动生成_id
        return ResponseResult.success(savedUser);
    }

    @GetMapping("find/{id}")
    public ResponseResult<User> findById(@PathVariable String id) {
        User user = mongoTemplate.findById(id, User.class); // 根据ID查询
        return ResponseResult.success(user);
    }
}
```

### 56.2.5 简单测试
- **插入数据**：访问POST /user/add，Body传入JSON如{"name":"张三","age":25}，MongoTemplate.save()会自动插入到User集合。
- **查询数据**：访问GET /user/find/{id}，返回对应文档。
- **效果**：数据以BSON格式存储在MongoDB的testdb数据库的user集合中。
# 五十七、SpringBoot集成MongoDB - 基于MongoRepository的数据操作  
> MongoRepository是Spring Data MongoDB提供的声明式数据访问接口，通过方法命名约定或注解简化MongoDB的CRUD操作。本文主要介绍基于MongoRepository方式对MongoDB进行数据操作的案例。

## 57.1 知识准备  
### 57.1.1 什么是MongoRepository  
MongoRepository是Spring Data MongoDB的核心接口之一，继承自PagingAndSortingRepository和CrudRepository。它通过**接口声明+方法命名规则**自动生成查询逻辑，无需编写实现代码，极大提升了开发效率。  
- **优势**：  
  - 减少样板代码，只需定义接口即可获得标准CRUD方法。  
  - 支持方法名自动推导查询（如`findByName`）、分页排序、自定义注解查询。  
- **与MongoTemplate的关系**：  
  - MongoTemplate提供底层灵活操作，MongoRepository专注于声明式简化。  
  - 实际项目中常结合使用：简单CRUD用MongoRepository，复杂查询用MongoTemplate。  

### 57.1.2 Spring Data Repository模式  
Spring Data的Repository模式是数据访问层的抽象，核心接口层次如下：  
```  
Repository (标记接口)  
  └─ CrudRepository (基础CRUD)  
       └─ PagingAndSortingRepository (分页排序)  
            └─ MongoRepository (MongoDB特化接口)  
```  
**常用方法示例**：  
```java  
// 自动提供的方法  
save(S entity);                 // 保存或更新  
findById(ID id);               // 根据ID查询  
findAll();                     // 查询全部  
deleteById(ID id);             // 根据ID删除  
count();                       // 统计数量  
```  

### 57.1.3 方法命名约定与查询推导  
MongoRepository支持通过方法名自动生成查询条件，规则如下：  
- **关键词**：`findBy`、`deleteBy`、`countBy`等。  
- **属性名**：实体字段名（如`name`对应`findByName`）。  
- **条件词**：`And`、`Or`、`Between`、`Like`等。  
**示例**：  
```java  
// 根据名称查询  
List<User> findByName(String name);  
// 多条件查询  
List<User> findByNameAndAge(String name, int age);  
// 模糊查询  
List<User> findByNameLike(String pattern);  
// 分页查询  
Page<User> findByAgeGreaterThan(int age, Pageable pageable);  
```  
> 注意：属性名需与实体字段一致，严格遵循驼峰命名法。  

## 57.2 实现案例  
> 本案例基于SpringBoot 2.x+，使用MongoRepository实现MongoDB的声明式数据操作。  

### 57.2.1 包依赖  
与MongoTemplate相同，引入`spring-boot-starter-data-mongodb`：  
```xml  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-mongodb</artifactId>  
</dependency>  
```  

### 57.2.2 yml配置  
配置MongoDB连接信息（与MongoTemplate案例一致）：  
```yml  
spring:  
  data:  
    mongodb:  
      host: localhost  
      port: 27017  
      database: testdb  
      # 或使用URI方式：uri: mongodb://user:password@host:port/database  
```  

### 57.2.3 定义实体和Repository接口  
**实体类**（需添加`@Document`注解）：  
```java  
package tech.pdai.springboot.mongo.entity;  

import org.springframework.data.annotation.Id;  
import org.springframework.data.mongodb.core.mapping.Document;  

@Document(collection = "user") // 指定集合名  
public class User {  
    @Id  
    private String id;  
    private String name;  
    private Integer age;  
    // getter/setter省略  
}  
```  

**Repository接口**（继承MongoRepository）：  
```java  
package tech.pdai.springboot.mongo.dao;  

import org.springframework.data.mongodb.repository.MongoRepository;  
import tech.pdai.springboot.mongo.entity.User;  
import java.util.List;  

public interface UserRepository extends MongoRepository<User, String> {  
    // 自动推导方法：根据名称查询  
    List<User> findByName(String name);  

    // 自定义条件查询：年龄大于指定值  
    List<User> findByAgeGreaterThan(int age);  
}  
```  

### 57.2.4 在Controller中使用Repository  
通过注入Repository接口调用方法：  
```java  
package tech.pdai.springboot.mongo.controller;  

import org.springframework.data.domain.Page;  
import org.springframework.data.domain.PageRequest;  
import org.springframework.web.bind.annotation.*;  
import tech.pdai.springboot.mongo.dao.UserRepository;  
import tech.pdai.springboot.mongo.entity.User;  
import tech.pdai.springboot.mongo.entity.response.ResponseResult;  
import javax.annotation.Resource;  
import java.util.List;  

@RestController  
@RequestMapping("/user")  
public class UserController {  
    @Resource  
    private UserRepository userRepository;  

    @PostMapping("add")  
    public ResponseResult<User> add(@RequestBody User user) {  
        User savedUser = userRepository.save(user); // 自动生成ID并保存  
        return ResponseResult.success(savedUser);  
    }  

    @GetMapping("find/{id}")  
    public ResponseResult<User> findById(@PathVariable String id) {  
        return userRepository.findById(id)  
                .map(ResponseResult::success)  
                .orElse(ResponseResult.fail("用户不存在"));  
    }  

    @GetMapping("list")  
    public ResponseResult<List<User>> list() {  
        return ResponseResult.success(userRepository.findAll());  
    }  

    @GetMapping("search")  
    public ResponseResult<List<User>> search(@RequestParam String name) {  
        return ResponseResult.success(userRepository.findByName(name));  
    }  
}  
```  

### 57.2.5 简单测试  
- **插入数据**：访问 `POST /user/add`，Body传入`{"name":"李四","age":30}`，Repository自动保存到MongoDB的`user`集合。  
- **查询数据**：  
  - `GET /user/find/1`：根据ID查询。  
  - `GET /user/list`：查询所有用户。  
  - `GET /user/search?name=李四`：根据名称查询。  
- **效果**：数据通过声明式接口操作，无需编写具体实现代码。  

> 提示：复杂查询（如聚合操作）仍需结合MongoTemplate实现，MongoRepository更适合标准化CRUD场景。
# 五十八、▶SpringBoot集成ElasticSearch - 基于ElasticsearchTemplate的数据操作
> Elasticsearch是一个分布式、RESTful风格的搜索和分析引擎，Spring Data Elasticsearch通过ElasticsearchTemplate提供了强大的数据操作能力。本文主要介绍基于ElasticsearchTemplate方式对Elasticsearch进行数据操作的案例。

## 58.1 知识准备

### 58.1.1 Elasticsearch基础和核心概念
Elasticsearch是基于Lucene的分布式搜索引擎，使用JSON格式存储数据。核心概念包括索引（Index）、类型（Type，7.x后已废弃）、文档（Document）和映射（Mapping）。

| 概念 | 说明 | 类比关系型数据库 |
| :--- | :--- | :--- |
| **索引（Index）** | 文档的集合，相当于数据库 | 数据库 |
| **类型（Type）** | 索引中的逻辑分类（7.x后已废弃） | 表 |
| **文档（Document）** | 索引中的基本数据单元，JSON格式 | 行 |
| **映射（Mapping）** | 文档字段的类型定义 | 表结构 |
| **分片（Shard）** | 索引的分区，支持水平扩展 | 分区表 |

### 58.1.2 什么是ElasticsearchTemplate
ElasticsearchTemplate是Spring Data Elasticsearch提供的核心模板类，封装了Elasticsearch的CRUD操作、复杂查询、聚合分析等功能。它简化了与Elasticsearch集群的交互，提供面向对象的操作方式。

### 58.1.3 Spring中的模板模式和ElasticsearchTemplate
- **模板方法模式**：与MongoTemplate类似，ElasticsearchTemplate基于模板模式，定义了搜索操作的通用流程。
- **主要功能**：
  - 文档的索引、更新、删除操作
  - 复杂的查询构建（QueryBuilder、BoolQueryBuilder等）
  - 聚合分析（AggregationBuilder）
  - 高亮显示、排序、分页等搜索特性

## 58.2 实现案例
> 本案例基于SpringBoot 2.x+，使用ElasticsearchTemplate操作Elasticsearch数据。

### 58.2.1 包依赖
在pom.xml中引入Spring Data Elasticsearch依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>
```

### 58.2.2 yml配置
在application.yml中配置Elasticsearch连接信息：
```yml
spring:
  elasticsearch:
    uris: http://localhost:9200  # Elasticsearch服务器地址
    # 可选配置
    connection-timeout: 1s       # 连接超时时间
    socket-timeout: 30s          # socket超时时间
    username: elastic            # 用户名（如果启用安全认证）
    password: password           # 密码
```

### 58.2.3 ElasticsearchConfig配置（可选）
如需自定义配置，可通过@Bean定义ElasticsearchTemplate：
```java
package tech.pdai.springboot.elasticsearch.config;

import org.elasticsearch.client.RestHighLevelClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;
import org.springframework.data.elasticsearch.client.ClientConfiguration;
import org.springframework.data.elasticsearch.client.RestClients;

@Configuration
public class ElasticsearchConfig {
    
    @Bean
    public RestHighLevelClient elasticsearchClient() {
        ClientConfiguration clientConfiguration = ClientConfiguration.builder()
            .connectedTo("localhost:9200")
            .build();
        return RestClients.create(clientConfiguration).rest();
    }
    
    @Bean
    public ElasticsearchRestTemplate elasticsearchTemplate() {
        return new ElasticsearchRestTemplate(elasticsearchClient());
    }
}
```

> **注意**：Spring Boot 2.3+版本推荐使用`ElasticsearchRestTemplate`替代旧的`ElasticsearchTemplate`。

### 58.2.4 定义实体类
使用注解定义Elasticsearch文档映射：
```java
package tech.pdai.springboot.elasticsearch.entity;

import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;

@Document(indexName = "user_index") // 指定索引名称
public class User {
    @Id
    private String id;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word") // 使用IK分词器
    private String name;
    
    @Field(type = FieldType.Integer)
    private Integer age;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String description;
    
    // getter/setter省略
}
```

### 58.2.5 ElasticsearchTemplate的使用
演示基本的CRUD和搜索操作：
```java
package tech.pdai.springboot.elasticsearch.controller;

import org.elasticsearch.index.query.QueryBuilders;
import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;
import org.springframework.data.elasticsearch.core.SearchHits;
import org.springframework.data.elasticsearch.core.query.*;
import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.elasticsearch.entity.User;
import tech.pdai.springboot.elasticsearch.entity.response.ResponseResult;
import javax.annotation.Resource;
import java.util.List;

@RestController
@RequestMapping("/user")
public class UserController {
    
    @Resource
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    // 创建索引（如果不存在）
    @PostMapping("/create-index")
    public ResponseResult<Boolean> createIndex() {
        boolean created = elasticsearchTemplate.indexOps(User.class).create();
        return ResponseResult.success(created);
    }
    
    // 添加/更新文档
    @PostMapping("/save")
    public ResponseResult<User> save(@RequestBody User user) {
        IndexQuery indexQuery = new IndexQueryBuilder()
            .withObject(user)
            .build();
        String documentId = elasticsearchTemplate.index(indexQuery, elasticsearchTemplate.getIndexCoordinatesFor(User.class));
        user.setId(documentId);
        return ResponseResult.success(user);
    }
    
    // 根据ID查询
    @GetMapping("/{id}")
    public ResponseResult<User> findById(@PathVariable String id) {
        User user = elasticsearchTemplate.get(id, User.class);
        return ResponseResult.success(user);
    }
    
    // 全文搜索
    @GetMapping("/search")
    public ResponseResult<List<User>> search(@RequestParam String keyword) {
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
            .withQuery(QueryBuilders.multiMatchQuery(keyword, "name", "description"))
            .build();
        
        SearchHits<User> searchHits = elasticsearchTemplate.search(searchQuery, User.class);
        List<User> users = searchHits.getSearchHits().stream()
            .map(hit -> hit.getContent())
            .collect(Collectors.toList());
            
        return ResponseResult.success(users);
    }
    
    // 删除文档
    @DeleteMapping("/{id}")
    public ResponseResult<String> delete(@PathVariable String id) {
        elasticsearchTemplate.delete(id, User.class);
        return ResponseResult.success("删除成功");
    }
}
```

### 58.2.6 复杂查询示例
演示更复杂的查询场景：
```java
// 多条件组合查询
@GetMapping("/advanced-search")
public ResponseResult<List<User>> advancedSearch(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) Integer minAge,
        @RequestParam(required = false) Integer maxAge) {
    
    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
    
    if (StringUtils.hasText(name)) {
        boolQuery.must(QueryBuilders.matchQuery("name", name));
    }
    
    if (minAge != null && maxAge != null) {
        boolQuery.must(QueryBuilders.rangeQuery("age").gte(minAge).lte(maxAge));
    }
    
    NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
        .withQuery(boolQuery)
        .withSort(SortBuilders.fieldSort("age").order(SortOrder.ASC))
        .withPageable(PageRequest.of(0, 10)) // 分页
        .build();
    
    SearchHits<User> searchHits = elasticsearchTemplate.search(searchQuery, User.class);
    // ... 处理结果
}
```

### 58.2.7 简单测试
- **创建索引**：访问 `POST /user/create-index`，创建user_index索引。
- **添加文档**：访问 `POST /user/save`，Body传入`{"name":"张三","age":25,"description":"软件工程师"}`。
- **搜索文档**：访问 `GET /user/search?keyword=软件`，返回包含"软件"关键词的用户。
- **效果**：数据存储在Elasticsearch中，支持高效的全文搜索和复杂查询。

> **注意事项**：
> 1. Elasticsearch需要先安装并启动（默认端口9200）
> 2. 建议安装IK分词器以支持中文搜索
> 3. 生产环境需要配置集群信息和安全认证
# 五十九、SpringBoot集成ElasticSearch - 多种集成方式详解
> SpringBoot集成Elasticsearch有多种方式，每种方式各有优劣，适用于不同的场景。本文详细总结Elasticsearch的三种主要集成方式及其适用场景。

## 59.1 Spring Data Elasticsearch 集成方式概览

### 59.1.1 三种主要集成方式对比

| 集成方式 | 版本要求 | 特点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **ElasticsearchRepository** | Spring Boot 2.x+ | 声明式接口，方法命名约定，开发效率高 | 标准CRUD、简单查询、快速开发 |
| **ElasticsearchRestTemplate** | Spring Boot 2.3+ | 灵活性强，支持复杂查询和聚合操作 | 复杂业务逻辑、动态查询、聚合分析 |
| **原生RestHighLevelClient** | 所有版本 | 最底层控制，与ES版本兼容性最好 | 需要精细控制、特定版本需求 |

## 59.2 方式一：ElasticsearchRepository（声明式接口）

### 59.2.1 核心概念
ElasticsearchRepository是Spring Data Elasticsearch提供的声明式数据访问接口，类似于JPA Repository模式。

**优势：**
- 减少样板代码，自动实现基础CRUD
- 支持方法名自动推导查询
- 内置分页、排序支持
- 易于单元测试

### 59.2.2 实现示例

**实体类定义：**
```java
package tech.pdai.springboot.elasticsearch.entity;

import org.springframework.data.annotation.Id;
import org.springframework.data.elasticsearch.annotations.Document;
import org.springframework.data.elasticsearch.annotations.Field;
import org.springframework.data.elasticsearch.annotations.FieldType;

@Document(indexName = "user_index")
public class User {
    @Id
    private String id;
    
    @Field(type = FieldType.Text, analyzer = "ik_max_word")
    private String name;
    
    @Field(type = FieldType.Keyword)
    private String email;
    
    @Field(type = FieldType.Integer)
    private Integer age;
    
    // getter/setter
}
```

**Repository接口：**
```java
package tech.pdai.springboot.elasticsearch.repository;

import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;
import tech.pdai.springboot.elasticsearch.entity.User;
import java.util.List;

public interface UserRepository extends ElasticsearchRepository<User, String> {
    
    // 根据名称查询（自动分词）
    List<User> findByName(String name);
    
    // 根据邮箱精确查询
    User findByEmail(String email);
    
    // 年龄范围查询
    List<User> findByAgeBetween(Integer minAge, Integer maxAge);
    
    // 名称模糊查询 + 分页
    List<User> findByNameContaining(String name, org.springframework.data.domain.Pageable pageable);
    
    // 自定义查询
    @Query("{\"match\": {\"name\": \"?0\"}}")
    List<User> findByNameCustom(String name);
}
```

**Service层使用：**
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User saveUser(User user) {
        return userRepository.save(user);
    }
    
    public Optional<User> findById(String id) {
        return userRepository.findById(id);
    }
    
    public List<User> searchUsers(String keyword, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return userRepository.findByNameContaining(keyword, pageable);
    }
}
```

## 59.3 方式二：ElasticsearchRestTemplate（模板方式）

### 59.3.1 核心概念
ElasticsearchRestTemplate是Spring Data Elasticsearch提供的模板类，提供更灵活的操作方式。

**优势：**
- 支持复杂的查询构建
- 完整的聚合分析功能
- 动态查询条件
- 批量操作支持

### 59.3.2 实现示例

**复杂查询示例：**
```java
@Service
public class UserTemplateService {
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    // 多条件组合查询
    public List<User> advancedSearch(UserSearchCriteria criteria) {
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder();
        
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        if (StringUtils.hasText(criteria.getKeyword())) {
            boolQuery.should(QueryBuilders.matchQuery("name", criteria.getKeyword()))
                     .should(QueryBuilders.matchQuery("description", criteria.getKeyword()));
        }
        
        if (criteria.getMinAge() != null && criteria.getMaxAge() != null) {
            boolQuery.must(QueryBuilders.rangeQuery("age")
                         .gte(criteria.getMinAge())
                         .lte(criteria.getMaxAge()));
        }
        
        if (criteria.getCreateTimeStart() != null) {
            boolQuery.must(QueryBuilders.rangeQuery("createTime")
                         .gte(criteria.getCreateTimeStart()));
        }
        
        NativeSearchQuery searchQuery = queryBuilder.withQuery(boolQuery)
                                                   .withPageable(PageRequest.of(0, 100))
                                                   .build();
        
        SearchHits<User> searchHits = elasticsearchTemplate.search(searchQuery, User.class);
        return searchHits.getSearchHits().stream()
                        .map(SearchHit::getContent)
                        .collect(Collectors.toList());
    }
    
    // 聚合分析
    public Map<String, Long> aggregateByAgeGroup() {
        TermsAggregationBuilder aggregation = AggregationBuilders.terms("age_group")
                                                                .field("age")
                                                                .size(10);
        
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
            .addAggregation(aggregation)
            .build();
        
        SearchHits<User> searchHits = elasticsearchTemplate.search(searchQuery, User.class);
        Terms terms = searchHits.getAggregations().get("age_group");
        
        return terms.getBuckets().stream()
                   .collect(Collectors.toMap(
                       Terms.Bucket::getKeyAsString,
                       Terms.Bucket::getDocCount
                   ));
    }
}
```

## 59.4 方式三：原生RestHighLevelClient（底层控制）

### 59.4.1 核心概念
直接使用Elasticsearch官方提供的RestHighLevelClient，提供最底层的控制能力。

**适用场景：**
- 需要与特定ES版本紧密集成
- 使用ES最新特性
- 性能要求极高的场景
- 复杂的索引管理操作

### 59.4.2 实现示例

**配置类：**
```java
@Configuration
public class ElasticsearchConfig {
    
    @Value("${spring.elasticsearch.uris}")
    private String esUrl;
    
    @Bean
    public RestHighLevelClient restHighLevelClient() {
        RestClientBuilder builder = RestClient.builder(
            HttpHost.create(esUrl)
        );
        
        // 可选：配置连接池、超时时间等
        builder.setRequestConfigCallback(requestConfigBuilder -> 
            requestConfigBuilder
                .setConnectTimeout(5000)
                .setSocketTimeout(60000)
        );
        
        return new RestHighLevelClient(builder);
    }
}
```

**使用示例：**
```java
@Service
public class NativeElasticsearchService {
    
    @Autowired
    private RestHighLevelClient client;
    
    // 索引文档
    public IndexResponse indexDocument(User user) throws IOException {
        IndexRequest request = new IndexRequest("user_index")
            .id(user.getId())
            .source(convertToMap(user), XContentType.JSON);
        
        return client.index(request, RequestOptions.DEFAULT);
    }
    
    // 复杂搜索
    public List<User> nativeSearch(UserSearchCriteria criteria) throws IOException {
        SearchRequest searchRequest = new SearchRequest("user_index");
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // 构建查询条件
        if (StringUtils.hasText(criteria.getKeyword())) {
            MultiMatchQueryBuilder multiMatchQuery = QueryBuilders.multiMatchQuery(
                criteria.getKeyword(), "name", "description")
                .type(MultiMatchQueryBuilder.Type.BEST_FIELDS);
            boolQuery.must(multiMatchQuery);
        }
        
        sourceBuilder.query(boolQuery)
                     .from(0)
                     .size(100)
                     .timeout(new TimeValue(60, TimeUnit.SECONDS));
        
        searchRequest.source(sourceBuilder);
        
        SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);
        
        return Arrays.stream(response.getHits().getHits())
                    .map(hit -> convertToUser(hit.getSourceAsString()))
                    .collect(Collectors.toList());
    }
    
    // 批量操作
    public BulkResponse bulkIndex(List<User> users) throws IOException {
        BulkRequest request = new BulkRequest();
        
        for (User user : users) {
            request.add(new IndexRequest("user_index")
                .id(user.getId())
                .source(convertToMap(user), XContentType.JSON));
        }
        
        return client.bulk(request, RequestOptions.DEFAULT);
    }
    
    private Map<String, Object> convertToMap(User user) {
        // 转换逻辑
        return Map.of(
            "name", user.getName(),
            "email", user.getEmail(),
            "age", user.getAge()
        );
    }
}
```

## 59.5 版本兼容性与选择建议

### 59.5.1 版本兼容性矩阵
| Spring Boot版本 | Spring Data ES版本 | ES客户端 | 推荐方式 |
| :--- | :--- | :--- | :--- |
| 2.3.x - 2.7.x | 4.x | RestHighLevelClient | ElasticsearchRestTemplate |
| 3.0.x+ | 5.x | ElasticsearchClient | 新版本客户端 |

### 59.5.2 选择建议

**1. 新项目推荐组合：**
```yaml
# 适用场景：大多数业务场景
主要使用：ElasticsearchRepository（80%场景）
辅助使用：ElasticsearchRestTemplate（20%复杂场景）
```

**2. 根据复杂度选择：**
- **简单CRUD** → ElasticsearchRepository
- **中等复杂度** → ElasticsearchRestTemplate  
- **高性能要求/复杂特性** → RestHighLevelClient

**3. 实际项目中的混合使用：**
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;          // 简单操作
    
    @Autowired
    private ElasticsearchRestTemplate template;     // 复杂查询
    
    @Autowired
    private RestHighLevelClient nativeClient;       // 特殊需求
    
    public UserStatistics getComplexStatistics() {
        // 使用Repository进行基础查询
        long totalCount = userRepository.count();
        
        // 使用Template进行聚合分析
        Map<String, Long> ageStats = template.aggregateAgeGroups();
        
        // 使用原生客户端进行高性能操作
        // ... 特殊逻辑
        
        return new UserStatistics(totalCount, ageStats);
    }
}
```

## 59.6 总结

SpringBoot集成Elasticsearch提供了多种方式，每种方式都有其独特的优势和适用场景：

- **ElasticsearchRepository**：开发效率最高，适合标准业务场景
- **ElasticsearchRestTemplate**：灵活性强，适合复杂查询需求  
- **RestHighLevelClient**：控制力最强，适合特殊需求和高性能场景

**最佳实践建议：**
1. 新项目优先使用ElasticsearchRepository + ElasticsearchRestTemplate组合
2. 根据业务复杂度选择合适的集成方式
3. 关注版本兼容性，特别是SpringBoot 3.0+的版本变化
4. 在生产环境中做好连接池配置和超时设置

通过合理选择集成方式，可以充分发挥Elasticsearch的强大功能，同时保持代码的简洁性和可维护性。
# 六十、▶SpringBoot集成Socket - 基础的Websocket实现

> WebSocket是一种在单个TCP连接上进行全双工通信的协议，能够实现客户端和服务器之间的实时双向数据传输。本文主要介绍SpringBoot中基于WebSocket的基础实现方案。

## 60.1 知识准备

### 60.1.1 WebSocket协议概述
WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议，解决了HTTP协议无法实现服务器主动推送的问题。

**与HTTP轮询对比：**
| 特性 | HTTP轮询 | WebSocket |
| :--- | :--- | :--- |
| **连接方式** | 短连接，频繁建立断开 | 长连接，一次建立持续通信 |
| **实时性** | 延迟高，依赖轮询间隔 | 实时双向通信 |
| **服务器开销** | 高，频繁处理连接请求 | 低，连接复用 |
| **适用场景** | 简单消息推送 | 实时交互应用（聊天、游戏等） |

### 60.1.2 Spring WebSocket支持
Spring Framework 4.0+提供了完整的WebSocket支持，主要包括：
- **WebSocket API**：底层WebSocket连接处理
- **STOMP协议**：基于帧的简单文本消息协议
- **SockJS**：WebSocket的备选方案，兼容老浏览器

### 60.1.3 核心组件
```mermaid
graph TB
    A[客户端] --> B[WebSocket连接]
    B --> C[WebSocketHandler]
    C --> D[消息处理逻辑]
    D --> E[业务服务]
    E --> C
    C --> B
    B --> A
```

## 60.2 基础WebSocket实现

### 60.2.1 包依赖
在pom.xml中引入WebSocket依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

### 60.2.2 WebSocket配置类
创建WebSocket配置，注册WebSocket处理器和拦截器：
```java
package tech.pdai.springboot.websocket.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import tech.pdai.springboot.websocket.handler.ChatWebSocketHandler;
import tech.pdai.springboot.websocket.interceptor.WebSocketHandshakeInterceptor;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new ChatWebSocketHandler(), "/websocket/chat")
                .addInterceptors(new WebSocketHandshakeInterceptor())
                .setAllowedOrigins("*"); // 生产环境应限制具体域名
    }
}
```

### 60.2.3 WebSocket处理器
实现WebSocketHandler接口处理连接和消息：
```java
package tech.pdai.springboot.websocket.handler;

import org.springframework.web.socket.*;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;

public class ChatWebSocketHandler extends TextWebSocketHandler {
    
    // 保存所有连接的会话
    private static final ConcurrentHashMap<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    
    /**
     * 连接建立后触发
     */
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String userId = (String) session.getAttributes().get("userId");
        sessions.put(userId, session);
        System.out.println("用户 " + userId + " 连接成功，当前在线人数: " + sessions.size());
        
        // 发送欢迎消息
        sendMessageToUser(userId, "连接成功，欢迎使用WebSocket聊天室！");
    }
    
    /**
     * 处理文本消息
     */
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String userId = (String) session.getAttributes().get("userId");
        String payload = message.getPayload();
        
        System.out.println("收到来自用户 " + userId + " 的消息: " + payload);
        
        // 处理不同类型的消息
        handleMessage(userId, payload);
    }
    
    /**
     * 连接关闭后触发
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String userId = (String) session.getAttributes().get("userId");
        sessions.remove(userId);
        System.out.println("用户 " + userId + " 断开连接，当前在线人数: " + sessions.size());
    }
    
    /**
     * 处理传输错误
     */
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        System.err.println("WebSocket传输错误: " + exception.getMessage());
    }
    
    /**
     * 向指定用户发送消息
     */
    public void sendMessageToUser(String userId, String message) {
        WebSocketSession session = sessions.get(userId);
        if (session != null && session.isOpen()) {
            try {
                session.sendMessage(new TextMessage(message));
            } catch (IOException e) {
                System.err.println("向用户 " + userId + " 发送消息失败: " + e.getMessage());
            }
        }
    }
    
    /**
     * 向所有用户广播消息
     */
    public void broadcastMessage(String message) {
        sessions.values().forEach(session -> {
            if (session.isOpen()) {
                try {
                    session.sendMessage(new TextMessage(message));
                } catch (IOException e) {
                    System.err.println("广播消息失败: " + e.getMessage());
                }
            }
        });
    }
    
    /**
     * 处理业务消息
     */
    private void handleMessage(String userId, String message) {
        // 简单的消息处理逻辑
        if (message.startsWith("@all ")) {
            // 广播消息
            String content = message.substring(5);
            broadcastMessage("用户 " + userId + " 说: " + content);
        } else if (message.startsWith("@user ")) {
            // 私聊消息格式: @user targetUserId messageContent
            String[] parts = message.split(" ", 3);
            if (parts.length == 3) {
                String targetUserId = parts[1];
                String content = parts[2];
                sendMessageToUser(targetUserId, "用户 " + userId + " 对你说: " + content);
            }
        } else {
            // 默认处理
            sendMessageToUser(userId, "服务器回复: 收到你的消息 - " + message);
        }
    }
}
```

### 60.2.4 WebSocket拦截器
实现握手拦截器，可以在连接建立前后进行拦截处理：
```java
package tech.pdai.springboot.websocket.interceptor;

import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;
import java.util.Map;

public class WebSocketHandshakeInterceptor extends HttpSessionHandshakeInterceptor {
    
    /**
     * 握手前拦截
     */
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, 
                                   WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {
        
        // 从请求参数中获取用户ID（实际项目中应从token或session中获取）
        String query = request.getURI().getQuery();
        if (query != null && query.contains("userId=")) {
            String userId = query.substring(query.indexOf("userId=") + 7);
            attributes.put("userId", userId);
            System.out.println("用户 " + userId + " 正在建立WebSocket连接");
            return true;
        }
        
        return false; // 拒绝连接
    }
    
    /**
     * 握手后拦截
     */
    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, 
                               WebSocketHandler wsHandler, Exception exception) {
        if (exception == null) {
            System.out.println("WebSocket握手成功");
        } else {
            System.err.println("WebSocket握手失败: " + exception.getMessage());
        }
    }
}
```

### 60.2.5 消息控制器（可选）
提供HTTP接口来主动推送消息：
```java
package tech.pdai.springboot.websocket.controller;

import org.springframework.web.bind.annotation.*;
import tech.pdai.springboot.websocket.handler.ChatWebSocketHandler;
import tech.pdai.springboot.websocket.entity.response.ResponseResult;
import javax.annotation.Resource;

@RestController
@RequestMapping("/websocket")
public class WebSocketController {
    
    @Resource
    private ChatWebSocketHandler chatWebSocketHandler;
    
    /**
     * 向指定用户推送消息
     */
    @PostMapping("/sendToUser")
    public ResponseResult<String> sendToUser(@RequestParam String userId, 
                                           @RequestParam String message) {
        chatWebSocketHandler.sendMessageToUser(userId, message);
        return ResponseResult.success("消息发送成功");
    }
    
    /**
     * 广播消息
     */
    @PostMapping("/broadcast")
    public ResponseResult<String> broadcast(@RequestParam String message) {
        chatWebSocketHandler.broadcastMessage(message);
        return ResponseResult.success("广播消息发送成功");
    }
}
```

### 60.2.6 前端HTML示例
创建简单的WebSocket客户端页面：
```html
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket聊天室</title>
    <style>
        #messageArea { height: 300px; border: 1px solid #ccc; overflow-y: scroll; padding: 10px; }
        #inputArea { margin-top: 10px; }
        .system-msg { color: #999; font-style: italic; }
        .user-msg { color: #333; }
    </style>
</head>
<body>
    <h2>WebSocket聊天室</h2>
    <div id="messageArea"></div>
    <div id="inputArea">
        <input type="text" id="messageInput" placeholder="输入消息..." style="width: 300px;">
        <button onclick="sendMessage()">发送</button>
        <button onclick="connect()">连接</button>
        <button onclick="disconnect()">断开</button>
    </div>

    <script>
        let websocket = null;
        const userId = 'user_' + Math.random().toString(36).substr(2, 9);
        
        function connect() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                addMessage('系统', '已经连接了');
                return;
            }
            
            // 建立WebSocket连接
            websocket = new WebSocket('ws://localhost:8080/websocket/chat?userId=' + userId);
            
            websocket.onopen = function(event) {
                addMessage('系统', '连接成功');
            };
            
            websocket.onmessage = function(event) {
                addMessage('服务器', event.data);
            };
            
            websocket.onclose = function(event) {
                addMessage('系统', '连接断开');
            };
            
            websocket.onerror = function(event) {
                addMessage('系统', '连接错误: ' + event.data);
            };
        }
        
        function disconnect() {
            if (websocket) {
                websocket.close();
            }
        }
        
        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            if (message && websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(message);
                addMessage('我', message);
                messageInput.value = '';
            }
        }
        
        function addMessage(sender, content) {
            const messageArea = document.getElementById('messageArea');
            const messageDiv = document.createElement('div');
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${content}`;
            messageArea.appendChild(messageDiv);
            messageArea.scrollTop = messageArea.scrollHeight;
        }
        
        // 回车发送消息
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // 页面加载时自动连接
        window.onload = connect;
    </script>
</body>
</html>
```

## 60.3 测试与验证

### 60.3.1 启动应用
1. 启动SpringBoot应用
2. 访问 `http://localhost:8080/websocket.html`（需要将HTML文件放在static目录）

### 60.3.2 功能测试
- **连接测试**：打开页面自动建立WebSocket连接
- **消息发送**：输入消息点击发送，查看服务器回复
- **广播测试**：打开多个浏览器标签，测试广播功能
- **异常测试**：断开网络测试重连机制

### 60.3.3 接口测试
使用Postman测试HTTP推送接口：
```bash
# 向指定用户推送消息
POST /websocket/sendToUser?userId=user123&message=Hello

# 广播消息
POST /websocket/broadcast?message=系统通知
```

## 60.4 扩展与优化建议

### 60.4.1 生产环境优化
```java
// 1. 连接数限制
@Bean
public ServletServerContainerFactoryBean createWebSocketContainer() {
    ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
    container.setMaxTextMessageBufferSize(8192);
    container.setMaxBinaryMessageBufferSize(8192);
    container.setMaxSessionIdleTimeout(300000L); // 5分钟超时
    return container;
}

// 2. 心跳检测
@Component
public class WebSocketHeartbeatTask {
    @Scheduled(fixedRate = 30000) // 30秒心跳
    public void heartbeat() {
        // 发送心跳包，检测连接状态
    }
}
```

### 60.4.2 高级特性
- **STOMP协议**：使用@MessageMapping注解简化消息路由
- **SockJS支持**：兼容不支持WebSocket的浏览器
- **集群支持**：使用Redis Pub/Sub实现多实例消息同步
- **安全认证**：集成Spring Security进行连接认证

> **总结**：SpringBoot提供了简洁的WebSocket集成方案，通过WebSocketHandler可以快速实现实时通信功能。在实际项目中，需要根据业务需求选择合适的协议和优化策略。
# 六十一、▶SpringBoot集成SSE - 基础的SSE实现

> Server-Sent Events（SSE）是一种基于HTTP的服务器向客户端推送事件的技术，在大模型时代尤为重要。本文介绍SpringBoot中SSE的基础实现，并重点阐述SSE与大模型流式输出的紧密关系。

## 61.1 知识准备

### 61.1.1 SSE协议概述
SSE是HTML5标准的一部分，允许服务器通过HTTP长连接向客户端推送文本事件。相比WebSocket，SSE是单向通信（服务器→客户端），更适合消息推送场景。

**SSE与WebSocket对比：**
| 特性 | SSE | WebSocket |
| :--- | :--- | :--- |
| **通信方向** | 单向（服务器→客户端） | 双向全双工 |
| **协议基础** | 基于HTTP，兼容性好 | 独立协议，需要升级 |
| **重连机制** | 内置自动重连 | 需要手动实现 |
| **适用场景** | 新闻推送、股票行情、大模型流式输出 | 实时聊天、在线游戏 |
| **大模型集成** | ⭐⭐⭐⭐⭐（天然适合流式响应） | ⭐⭐（需要额外处理） |

### 61.1.2 SSE与大模型的关系
在大模型应用场景中，SSE技术发挥着关键作用：

**核心价值：**
- **流式响应**：大模型生成内容时往往是逐词(token)输出，SSE支持分块传输
- **实时体验**：用户能够立即看到生成过程，减少等待焦虑
- **资源优化**：服务器可以边生成边推送，避免一次性计算完整响应
- **错误恢复**：SSE内置重连机制，网络中断后可继续接收

**典型应用场景：**
- ChatGPT类应用的对话流式输出
- 代码生成工具的实时预览
- 长文本生成的进度展示
- 多模态模型的渐进式响应

### 61.1.3 Spring中的SSE支持
Spring Framework 4.2+ 提供了完整的SSE支持：
- **SseEmitter**：核心类，用于创建和管理SSE连接
- **ResponseBodyEmitter**：SSE的父类，支持异步响应
- **@CrossOrigin**：解决前端跨域问题

## 61.2 基础SSE实现

### 61.2.1 包依赖
Spring Boot已内置SSE支持，无需额外依赖：
```xml
<!-- Spring Boot Web Starter已包含SSE支持 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

### 61.2.2 SSE配置类
配置SSE相关的跨域和异步支持：
```java
package tech.pdai.springboot.sse.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class SseConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/sse/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST")
                .allowCredentials(false)
                .maxAge(3600);
    }
}
```

### 61.2.3 SSE服务类
创建SSE服务，管理连接和消息推送：
```java
package tech.pdai.springboot.sse.service;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Service
public class SseService {
    
    // 存储所有活跃的SSE连接
    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    /**
     * 创建新的SSE连接
     */
    public SseEmitter createConnection(String clientId) {
        // 设置超时时间（建议根据业务调整）
        SseEmitter emitter = new SseEmitter(5 * 60 * 1000L); // 5分钟超时
        
        // 存储连接
        emitters.put(clientId, emitter);
        
        // 设置完成和超时回调
        emitter.onCompletion(() -> {
            System.out.println("SSE连接完成: " + clientId);
            emitters.remove(clientId);
        });
        
        emitter.onTimeout(() -> {
            System.out.println("SSE连接超时: " + clientId);
            emitters.remove(clientId);
        });
        
        emitter.onError((e) -> {
            System.err.println("SSE连接错误: " + clientId + ", " + e.getMessage());
            emitters.remove(clientId);
        });
        
        // 发送连接成功事件
        try {
            emitter.send(SseEmitter.event()
                    .name("connected")
                    .data("SSE连接建立成功，客户端ID: " + clientId));
        } catch (IOException e) {
            emitter.completeWithError(e);
        }
        
        System.out.println("创建SSE连接，客户端ID: " + clientId + ", 当前连接数: " + emitters.size());
        return emitter;
    }
    
    /**
     * 向指定客户端发送消息
     */
    public void sendMessageToClient(String clientId, String message) {
        SseEmitter emitter = emitters.get(clientId);
        if (emitter != null) {
            try {
                emitter.send(SseEmitter.event()
                        .name("message")
                        .data(message));
            } catch (IOException e) {
                System.err.println("向客户端 " + clientId + " 发送消息失败: " + e.getMessage());
                emitters.remove(clientId);
            }
        }
    }
    
    /**
     * 向所有客户端广播消息
     */
    public void broadcastMessage(String message) {
        emitters.forEach((clientId, emitter) -> {
            if (emitter != null) {
                try {
                    emitter.send(SseEmitter.event()
                            .name("broadcast")
                            .data(message));
                } catch (IOException e) {
                    System.err.println("广播消息到客户端 " + clientId + " 失败: " + e.getMessage());
                    emitters.remove(clientId);
                }
            }
        });
    }
    
    /**
     * 模拟大模型流式输出
     */
    @Async
    public void simulateModelStreaming(String clientId, String prompt) {
        SseEmitter emitter = emitters.get(clientId);
        if (emitter == null) {
            return;
        }
        
        // 模拟大模型生成过程
        String[] responseParts = {
            "思考中", "...", "正在分析您的问题", "...", 
            "根据我的知识", "这个问题涉及多个方面", 
            "首先", "让我们从基础概念开始", "...",
            "总结来说", prompt + "的答案是：这是一个需要深入探讨的话题"
        };
        
        // 分块发送，模拟流式输出
        scheduler.scheduleAtFixedRate(new Runnable() {
            private int index = 0;
            
            @Override
            public void run() {
                if (index < responseParts.length && emitter != null) {
                    try {
                        // 发送数据事件
                        emitter.send(SseEmitter.event()
                                .name("model-response")
                                .id(String.valueOf(index)) // 事件ID，用于重连时定位
                                .data(responseParts[index])
                                .reconnectTime(3000L)); // 重连时间建议
                        
                        System.out.println("向客户端 " + clientId + " 发送模型响应片段: " + responseParts[index]);
                        index++;
                    } catch (IOException e) {
                        System.err.println("流式输出中断: " + e.getMessage());
                        scheduler.shutdown();
                    }
                } else {
                    // 发送结束事件
                    try {
                        emitter.send(SseEmitter.event()
                                .name("model-complete")
                                .data("模型生成完成"));
                        System.out.println("模型流式输出完成");
                    } catch (IOException e) {
                        System.err.println("发送完成事件失败: " + e.getMessage());
                    }
                    scheduler.shutdown();
                }
            }
        }, 0, 1, TimeUnit.SECONDS); // 每秒发送一个片段
    }
    
    /**
     * 关闭连接
     */
    public void closeConnection(String clientId) {
        SseEmitter emitter = emitters.get(clientId);
        if (emitter != null) {
            emitter.complete();
            emitters.remove(clientId);
            System.out.println("关闭SSE连接: " + clientId);
        }
    }
    
    /**
     * 获取当前连接数
     */
    public int getConnectionCount() {
        return emitters.size();
    }
}
```

### 61.2.4 SSE控制器
创建REST控制器提供SSE端点：
```java
package tech.pdai.springboot.sse.controller;

import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import tech.pdai.springboot.sse.service.SseService;
import tech.pdai.springboot.sse.entity.response.ResponseResult;
import javax.annotation.Resource;

@RestController
@RequestMapping("/sse")
@CrossOrigin(origins = "*") // 允许跨域访问
public class SseController {
    
    @Resource
    private SseService sseService;
    
    /**
     * 建立SSE连接
     */
    @GetMapping(value = "/connect", produces = "text/event-stream")
    public SseEmitter connect(@RequestParam String clientId) {
        return sseService.createConnection(clientId);
    }
    
    /**
     * 发送消息到指定客户端
     */
    @PostMapping("/send")
    public ResponseResult<String> sendMessage(@RequestParam String clientId, 
                                            @RequestParam String message) {
        sseService.sendMessageToClient(clientId, message);
        return ResponseResult.success("消息发送成功");
    }
    
    /**
     * 广播消息
     */
    @PostMapping("/broadcast")
    public ResponseResult<String> broadcast(@RequestParam String message) {
        sseService.broadcastMessage(message);
        return ResponseResult.success("广播消息发送成功");
    }
    
    /**
     * 模拟大模型流式对话（核心功能）
     */
    @PostMapping("/chat/stream")
    public ResponseResult<String> streamChat(@RequestParam String clientId,
                                           @RequestParam String message) {
        sseService.simulateModelStreaming(clientId, message);
        return ResponseResult.success("开始流式对话");
    }
    
    /**
     * 关闭连接
     */
    @PostMapping("/disconnect")
    public ResponseResult<String> disconnect(@RequestParam String clientId) {
        sseService.closeConnection(clientId);
        return ResponseResult.success("连接已关闭");
    }
    
    /**
     * 获取连接状态
     */
    @GetMapping("/status")
    public ResponseResult<Integer> getStatus() {
        return ResponseResult.success(sseService.getConnectionCount());
    }
}
```

### 61.2.5 大模型集成示例（真实场景）
演示如何集成真实的大模型API进行流式输出：
```java
package tech.pdai.springboot.sse.integration;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import java.io.IOException;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

@Component
public class ModelIntegrationService {
    
    /**
     * 集成真实大模型API的流式调用
     */
    public void streamModelResponse(String clientId, String prompt, SseEmitter emitter) {
        // 模拟调用大模型API（如OpenAI GPT、文心一言等）
        // 实际项目中替换为真实的API调用
        
        new Thread(() -> {
            try {
                // 模拟API调用过程
                emitter.send(SseEmitter.event()
                        .name("model-start")
                        .data("开始调用大模型API..."));
                
                // 分块处理模型响应
                processModelStream(clientId, prompt, emitter);
                
            } catch (Exception e) {
                try {
                    emitter.send(SseEmitter.event()
                            .name("model-error")
                            .data("模型调用失败: " + e.getMessage()));
                } catch (IOException ex) {
                    // 忽略发送错误
                }
            }
        }).start();
    }
    
    private void processModelStream(String clientId, String prompt, SseEmitter emitter) 
            throws IOException, InterruptedException {
        
        // 模拟大模型流式响应（实际项目中替换为真实的流式HTTP调用）
        String simulatedResponse = "大模型正在思考您的问题：'" + prompt + "'。这是一个复杂的问题，让我逐步分析...";
        
        // 将响应拆分为多个token模拟流式输出
        String[] tokens = simulatedResponse.split("(?<=[。！？,.!?])|(?=\\s)");
        
        for (int i = 0; i < tokens.length; i++) {
            if (!tokens[i].trim().isEmpty()) {
                emitter.send(SseEmitter.event()
                        .name("model-token")
                        .id(String.valueOf(i))
                        .data(tokens[i].trim()));
                
                // 模拟网络延迟
                Thread.sleep(100 + (long) (Math.random() * 200));
            }
        }
        
        // 发送完成事件
        emitter.send(SseEmitter.event()
                .name("model-complete")
                .data("模型响应完成"));
    }
}
```

### 61.2.6 前端HTML示例
创建SSE客户端页面，展示大模型流式输出效果：
```html
<!DOCTYPE html>
<html>
<head>
    <title>SSE大模型流式对话演示</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #chatArea { height: 400px; border: 1px solid #ddd; padding: 10px; overflow-y: auto; margin-bottom: 10px; }
        .user-msg { color: #0066cc; margin: 5px 0; }
        .model-msg { color: #333; margin: 5px 0; background: #f5f5f5; padding: 5px; border-radius: 3px; }
        .system-msg { color: #999; font-style: italic; margin: 5px 0; }
        #inputArea { display: flex; gap: 10px; }
        #messageInput { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 3px; }
        button { padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .status { margin-top: 10px; color: #666; }
    </style>
</head>
<body>
    <h2>大模型流式对话演示 (基于SSE)</h2>
    <div class="status">连接状态: <span id="status">未连接</span></div>
    <div id="chatArea"></div>
    <div id="inputArea">
        <input type="text" id="messageInput" placeholder="输入您的问题..." />
        <button onclick="sendMessage()">发送</button>
        <button onclick="connectSSE()">连接SSE</button>
        <button onclick="disconnectSSE()">断开连接</button>
    </div>

    <script>
        let eventSource = null;
        const clientId = 'user_' + Math.random().toString(36).substr(2, 8);
        let modelResponseBuffer = ''; // 用于累积模型响应
        
        function connectSSE() {
            if (eventSource) {
                addMessage('系统', '已经连接了');
                return;
            }
            
            // 建立SSE连接
            eventSource = new EventSource(`/sse/connect?clientId=${clientId}`);
            
            eventSource.onopen = function(event) {
                document.getElementById('status').textContent = '已连接';
                addMessage('系统', 'SSE连接建立成功');
            };
            
            // 监听不同类型的事件
            eventSource.addEventListener('connected', function(event) {
                addMessage('系统', event.data);
            });
            
            eventSource.addEventListener('message', function(event) {
                addMessage('服务器', event.data);
            });
            
            eventSource.addEventListener('model-response', function(event) {
                // 大模型流式响应 - 逐词显示效果
                modelResponseBuffer += event.data;
                updateModelResponse(modelResponseBuffer);
            });
            
            eventSource.addEventListener('model-token', function(event) {
                // 更细粒度的token级流式输出
                modelResponseBuffer += event.data;
                updateModelResponse(modelResponseBuffer);
            });
            
            eventSource.addEventListener('model-complete', function(event) {
                addMessage('系统', '模型生成完成');
                modelResponseBuffer = ''; // 清空缓冲区
            });
            
            eventSource.addEventListener('model-error', function(event) {
                addMessage('系统', '错误: ' + event.data, 'error');
            });
            
            eventSource.onerror = function(event) {
                document.getElementById('status').textContent = '连接错误';
                addMessage('系统', 'SSE连接错误，尝试重连...');
            };
        }
        
        function disconnectSSE() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
                document.getElementById('status').textContent = '已断开';
                addMessage('系统', 'SSE连接已关闭');
                
                // 通知服务器关闭连接
                fetch(`/sse/disconnect?clientId=${clientId}`, { method: 'POST' });
            }
        }
        
        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            if (message) {
                addMessage('我', message);
                messageInput.value = '';
                
                // 发送到服务器，触发大模型流式响应
                fetch(`/sse/chat/stream?clientId=${clientId}&message=${encodeURIComponent(message)}`, {
                    method: 'POST'
                }).then(response => {
                    if (!response.ok) {
                        throw new Error('请求失败');
                    }
                    return response.json();
                }).then(data => {
                    console.log('流式对话开始:', data);
                }).catch(error => {
                    addMessage('系统', '发送失败: ' + error.message, 'error');
                });
            }
        }
        
        function addMessage(sender, content, type = 'info') {
            const chatArea = document.getElementById('chatArea');
            const messageDiv = document.createElement('div');
            
            let className = 'system-msg';
            if (sender === '我') className = 'user-msg';
            else if (sender === '模型') className = 'model-msg';
            
            messageDiv.className = className;
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${content}`;
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        function updateModelResponse(content) {
            const chatArea = document.getElementById('chatArea');
            let modelMsg = document.getElementById('current-model-response');
            
            if (!modelMsg) {
                modelMsg = document.createElement('div');
                modelMsg.id = 'current-model-response';
                modelMsg.className = 'model-msg';
                modelMsg.innerHTML = '<strong>模型:</strong> ';
                chatArea.appendChild(modelMsg);
            }
            
            modelMsg.innerHTML = `<strong>模型:</strong> ${content}`;
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        // 回车发送消息
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // 页面加载时自动连接
        window.onload = connectSSE;
        
        // 页面关闭时断开连接
        window.addEventListener('beforeunload', disconnectSSE);
    </script>
</body>
</html>
```

## 61.3 测试与验证

### 61.3.1 启动应用
1. 启动SpringBoot应用（默认端口8080）
2. 访问 `http://localhost:8080/sse-demo.html` 测试SSE功能

### 61.3.2 功能测试
- **连接测试**：点击"连接SSE"按钮，观察连接状态
- **大模型流式对话**：输入问题，观察逐词输出的流式效果
- **多客户端测试**：打开多个浏览器标签模拟多用户场景
- **网络中断测试**：断开网络后重连，验证自动恢复机制

### 61.3.3 API测试
使用curl命令测试SSE端点：
```bash
# 建立SSE连接
curl -N -H "Accept:text/event-stream" "http://localhost:8080/sse/connect?clientId=test123"

# 发送消息触发大模型流式响应
curl -X POST "http://localhost:8080/sse/chat/stream?clientId=test123&message=什么是人工智能"
```

## 61.4 扩展与优化建议

### 61.4.1 生产环境优化
```java
// 1. 连接管理优化
@Component
public class SseConnectionManager {
    private final Map<String, SseEmitter> connections = new ConcurrentHashMap<>();
    private final ScheduledExecutorService heartbeatExecutor = 
        Executors.newScheduledThreadPool(2);
    
    @PostConstruct
    public void init() {
        // 心跳检测，清理僵尸连接
        heartbeatExecutor.scheduleAtFixedRate(this::checkConnections, 30, 30, TimeUnit.SECONDS);
    }
    
    private void checkConnections() {
        connections.entrySet().removeIf(entry -> {
            try {
                entry.getValue().send(SseEmitter.event().name("heartbeat").data("ping"));
                return false;
            } catch (IOException e) {
                return true; // 连接已失效
            }
        });
    }
}

// 2. 大模型集成优化
@Service
public class ModelStreamingService {
    private final WebClient webClient;
    
    public ModelStreamingService() {
        this.webClient = WebClient.builder()
            .baseUrl("https://api.openai.com/v1/chat/completions")
            .defaultHeader("Authorization", "Bearer YOUR_API_KEY")
            .build();
    }
    
    public void streamModelResponse(String prompt, SseEmitter emitter) {
        webClient.post()
            .bodyValue(Map.of(
                "model", "gpt-4",
                "messages", List.of(Map.of("role", "user", "content", prompt)),
                "stream", true
            ))
            .accept(MediaType.TEXT_EVENT_STREAM)
            .retrieve()
            .bodyToFlux(String.class)
            .subscribe(
                data -> {
                    try {
                        // 解析大模型流式响应
                        if (data.startsWith("data: ")) {
                            String jsonData = data.substring(6);
                            if (!jsonData.equals("[DONE]")) {
                                // 提取模型输出内容
                                String content = extractContent(jsonData);
                                emitter.send(SseEmitter.event()
                                    .name("model-token")
                                    .data(content));
                            }
                        }
                    } catch (IOException e) {
                        // 处理发送错误
                    }
                },
                error -> {
                    try {
                        emitter.send(SseEmitter.event()
                            .name("model-error")
                            .data("模型调用失败"));
                    } catch (IOException e) {
                        // 忽略错误
                    }
                },
                () -> {
                    try {
                        emitter.send(SseEmitter.event()
                            .name("model-complete")
                            .data("生成完成"));
                    } catch (IOException e) {
                        // 忽略错误
                    }
                }
            );
    }
}
```

### 61.4.2 大模型集成最佳实践
1. **流式控制**：设置合适的chunk大小，平衡实时性和性能
2. **错误处理**：实现重试机制和降级方案
3. **速率限制**：控制请求频率，避免API限制
4. **上下文管理**：维护对话历史，支持多轮对话
5. **性能监控**：记录响应时间、token数量等指标

### 61.4.3 高级特性集成
- **分片传输**：大响应内容的分片处理
- **优先级队列**：重要请求优先处理
- **缓存策略**：常见问题的缓存响应
- **多模型路由**：根据场景选择不同的大模型

> **总结**：SSE技术为大模型应用提供了理想的流式输出方案。SpringBoot通过SseEmitter简化了SSE集成，结合大模型的token级流式输出，能够显著提升用户体验。在实际项目中，建议根据业务需求选择合适的优化策略，充分发挥SSE在大模型场景中的优势。
# 六十一、▶SpringBoot定时任务 - Timer实现方式
> 定时任务在实际开发中有着广泛的用途，本文主要帮助你构建定时任务的知识体系，同时展示Timer 的schedule和scheduleAtFixedRate例子；后续的文章中我们将逐一介绍其它常见的与SpringBoot的集成。
## 61.1 知识准备
> 需要对定时任务的使用场景和常见的实现方式。
### 61.1.1 什么样的场景会使用定时任务？
比如每天/每周/每月生成日志汇总，定时发送推送信息，定时生成数据表格等

### 61.1.2 定时任务有哪些实现方式？
> 首先你需要构建如下实现定时任务的知识体系。在后续的文章中我们将逐一介绍在SpringBoot下的集成。
- 定时任务基础
  - Cron表达式
  - Linux定时任务工具crontab
- JDK内置
  - Timer
  - ScheduleExecutorService
- Netty
  - HashedWheelTimer
- Spring
  - Spring自带Schedule
  - Spring集成Quartz
- 分布式集群
  - Quartz持久化JDBC方式
  - Elastic-job
  - xxl-job
## 61.2 Timer实现案例
> Timer 的schedule和scheduleAtFixedRate例子如下。
### 61.2.1 schedule延迟任务
执行定时任务，延迟1秒开始执行。
```java
@SneakyThrows
public static void timer() {
    // start timer
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
        public void run() {
            log.info("timer-task @{}", LocalDateTime.now());
        }
    }, 1000);

    // waiting to process(sleep to mock)
    Thread.sleep(3000);

    // stop timer
    timer.cancel();
}
```
输出
```sh
10:05:47.440 [Timer-0] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-task @2021-10-01T20:05:47.436
```
### 61.2.2 schedule周期任务
延迟0.5秒开始执行，每秒执行一次， 10秒后停止。
```java
@SneakyThrows
public static void timerPeriod() {
    // start timer
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
        @SneakyThrows
        public void run() {
            log.info("timer-period-task @{}", LocalDateTime.now());
            Thread.sleep(100); // 可以设置的执行时间, 来测试当执行时间大于执行周期时任务执行的变化 
        }
    }, 500, 1000);

    // waiting to process(sleep to mock)
    Thread.sleep(10000);

    // stop timer
    timer.cancel();
}
```
输出
```java
10:05:49.781 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:49.781
10:05:50.781 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:50.781
10:05:51.781 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:51.781
10:05:52.781 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:52.781
10:05:53.782 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:53.782
10:05:54.783 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:54.783
10:05:55.783 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:55.783
10:05:56.784 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:56.784
10:05:57.785 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:57.785
10:05:58.786 [Timer-1] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-period-task @2021-10-01T10:05:58.786
```
### 61.2.3 scheduleAtFixedRate
延迟0.5秒开始执行，每秒执行一次， 10秒后停止。

同时测试某次任务执行时间大于周期时间的变化。
```java
@SneakyThrows
public static void timerFixedRate() {
    // start timer
    Timer timer = new Timer();
    timer.scheduleAtFixedRate(new TimerTask() {
        int count = 0;

        @SneakyThrows
        public void run() {
            if (count++==2) {
                Thread.sleep(5000); // 某一次执行时间超过了period(执行周期）
            }
            log.info("timer-fixedRate-task @{}", LocalDateTime.now());

        }
    }, 500, 1000);

    // waiting to process(sleep to mock)
    Thread.sleep(10000);

    // stop timer
    timer.cancel();
}
```
输出
```sh
10:05:59.781 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:05:59.781
10:06:00.782 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:00.782
10:06:06.783 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:06.783
10:06:06.783 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:06.783
10:06:06.783 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:06.783
10:06:06.783 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:06.783
10:06:06.783 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:06.783
10:06:06.783 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:06.783
10:06:07.781 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:07.781
10:06:08.781 [Timer-2] INFO tech.pdai.springboot.schedule.timer.timertest.TimerTester - timer-fixedRate-task @2021-10-01T10:06:08.781
```
（你会发现周期执行1秒中执行一次，但是某次执行了5秒，这时候，后续的任务会加快执行进度，一次性就执行了，执行的时间都是10:06:06.783， 所以scheduleAtFixedRate最大的特点是**保证了总时间段内的执行次数**）
## 61.3 进一步理解
### 61.3.1 schedule 和 scheduleAtFixedRate 有何区别？
- schedule：每次执行完当前任务后，然后间隔一个period的时间再执行下一个任务； 当某个任务执行周期大于时间间隔时，依然按照间隔时间执行下个任务，即它**保证了任务之间执行的间隔**。
- scheduleAtFixedRate：每次执行时间为上一次任务开始起向后推一个period间隔，也就是说下次执行时间相对于上一次任务开始的时间点；按照上述的例子，它**保证了总时间段内的任务的执行次数**。
### 61.3.2 为什么几乎很少使用Timer这种方式？
- Timer底层是使用一个单线来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行，意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。
- 如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。
- PS：在这点上你可以看到，定时任务Job中**异常**和**超时**等一般都是要自行处理的，以防止对其它任务的影响。
# 六十二、SpringBoot定时任务 - ScheduleExecutorService实现方式
> 上文介绍的Timer在实际开发中很少被使用， 因为Timer底层是使用一个单线程来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行。而ScheduledExecutorService是基于线程池的，可以开启多个线程进行执行多个任务，每个任务开启一个线程； 这样任务的延迟和未处理异常就不会影响其它任务的执行了。
## 62.1 知识准备
> 需要对ScheduledExecutorService 代替 Timer的原因以及ScheduledExecutorService所在的知识体系有了解。
### 62.1.1 为什么用ScheduledExecutorService 代替 Timer？
上文我们说到Timer底层是使用一个单线程来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行，意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。

如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。

而ScheduledExecutorService是基于线程池的，可以开启多个线程进行执行多个任务，每个任务开启一个线程； 这样任务的延迟和未处理异常就不会影响其它任务的执行了。
### 62.1.2 ScheduledExecutorService所在的线程池的知识体系？
![225.java-thread-x-juc-overview-1-u.png](../../assets/images/04-主流框架/spring/225.java-thread-x-juc-overview-1-u.png)
## 62.2 ScheduledExecutorService实现案例
ScheduledExecutorService使用例子如下。

### 62.2.1 schedule
延迟1秒执行一个进程任务。
```java
@SneakyThrows
public static void schedule() {
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    executor.schedule(
            new Runnable() {
                @Override
                @SneakyThrows
                public void run() {
                    log.info("run schedule @ {}", LocalDateTime.now());
                }
            },
            1000,
            TimeUnit.MILLISECONDS);
    // waiting to process(sleep to mock)
    Thread.sleep(10000);

    // stop
    executor.shutdown();
}
```
输出
```sh
21:07:02.047 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run schedule @ 2022-03-10T21:07:02.046
```
### 62.2.2 scheduleAtFixedRate
延迟0.5秒开始执行，每秒执行一次， 10秒后停止。

同时测试某次任务执行时间大于周期时间的变化。
```java
/**
    * 每秒执行一次，延迟0.5秒执行。
    */
@SneakyThrows
public static void scheduleAtFixedRate() {
    AtomicInteger count = new AtomicInteger(0);
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    executor.scheduleAtFixedRate(
            new Runnable() {
                @Override
                @SneakyThrows
                public void run() {
                    if (count.getAndIncrement()==2) {
                        Thread.sleep(5000); // 执行时间超过执行周期
                    }
                    log.info("run scheduleAtFixedRate @ {}", LocalDateTime.now());
                }
            },
            500,
            1000, // 每隔多久执行
            TimeUnit.MILLISECONDS);
    // waiting to process(sleep to mock)
    Thread.sleep(10000);

    // stop
    executor.shutdown();
}
```
输出：
```java
20:51:47.626 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:47.624
20:51:48.575 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:48.575
20:51:54.579 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:54.579
20:51:54.579 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:54.579
20:51:54.579 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:54.579
20:51:54.580 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:54.580
20:51:54.580 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:54.580
20:51:54.580 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:54.580
20:51:55.574 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:55.574
20:51:56.578 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleAtFixedRate @ 2022-03-10T20:51:56.578
```
（你会发现周期执行1秒中执行一次，但是某次执行了5秒，这时候，后续的任务会加快执行进度，一次性就执行了，执行的时间都是20:51:54，所以scheduleAtFixedRate最大的特点是保证了总时间段内的执行次数）
### 62.2.3 scheduleWithFixedDelay
延迟0.5秒开始执行，每秒执行一次， 10秒后停止。

同时测试某次任务执行时间大于周期时间的变化。
```java
/**
    * 每秒执行一次，延迟0.5秒执行。
    */
@SneakyThrows
public static void scheduleWithFixedDelay() {
    AtomicInteger count = new AtomicInteger(0);
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    executor.scheduleWithFixedDelay(
            new Runnable() {
                @Override
                @SneakyThrows
                public void run() {
                    if (count.getAndIncrement()==2) {
                        Thread.sleep(5000); // 执行时间超过执行周期
                    }
                    log.info("run scheduleWithFixedDelay @ {}", LocalDateTime.now());
                }
            },
            500,
            1000, // 上次执行完成后，延迟多久执行
            TimeUnit.MILLISECONDS);

    // waiting to process(sleep to mock)
    Thread.sleep(10000);

    // stop
    executor.shutdown();
}
```
输出：
```sh
20:50:03.559 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleWithFixedDelay @ 2022-03-10T20:50:03.557
20:50:04.564 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleWithFixedDelay @ 2022-03-10T20:50:04.564
20:50:10.568 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleWithFixedDelay @ 2022-03-10T20:50:10.568
20:50:11.569 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleWithFixedDelay @ 2022-03-10T20:50:11.569
20:50:12.571 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.executorservice.ScheduleExecutorServiceDemo - run scheduleWithFixedDelay @ 2022-03-10T20:50:12.571
```
## 62.3 进一步理解
### 62.3.1 schedule 和 scheduleAtFixedRate和 scheduleWithFixedDelay有何区别？
- schedule：延迟执行一个任务。
- scheduleAtFixedRate：每次执行时间为上一次任务开始起向后推一个period间隔，也就是说下次执行时间相对于上一次任务开始的时间点；按照上述的例子，**它保证了总时间段内的任务的执行次数**
- scheduleAtFixedDelay：每次执行完当前任务后，然后间隔一个period的时间再执行下一个任务； 当某个任务执行周期大于时间间隔时，依然按照间隔时间执行下个任务，即**它保证了任务之间执行的间隔,注意这里的间隔是包含任务执行时间，即需要等前一个任务结束然后间隔1S再执行下一个任务**。
  
（PS：和timer对比下，timer中没有scheduleAtFixedDelay，它的schedule等同于scheduleAtFixedDelay）
### 62.3.1 ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);1代表什么?
#### 62.3.1.1 先说答案
**先说答案：Executors.newScheduledThreadPool(1) ，则永远都会只有一个线程被创建，其他定时任务的线程都会被放到阻塞队列中等待**
#### 62.3.1.2 基础概念
首先需要明确一些概念：
- 线程池核心线程数和最大线程数之间关系

当提交一个新任务到线程池时：

1. 首先线程池判断基本线程池(corePoolSize)是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程；
2. 其次线程池判断工作队列(workQueue)是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程；
3. 最后线程池判断整个线程池(maximumPoolSize)是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；
4. 如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止。
5. 只有当阻塞队列满了后，才会触发非核心线程的创建。所以非核心线程只是临时过来打杂的。直到空闲了，然后自己关闭了。
#### 62.3.1.3 进一步解释
`Executors.newScheduledThreadPool(1)` 中的参数 `1` 确实设置的是**核心线程数（corePoolSize）**，而**最大线程数（maximumPoolSize）** 被设置为 `Integer.MAX_VALUE`（即整形的最大值）。这是 `ScheduledThreadPoolExecutor` 的标准配置。

然而，在实际行为中，**这个线程池通常只会使用核心线程数（即1个线程）来执行任务**，不会创建更多线程。原因在于 `ScheduledThreadPoolExecutor` 使用了一个**无界队列（DelayedWorkQueue）**。让我详细解释一下：

##### 62.3.1.3.1 源码分析：
- `Executors.newScheduledThreadPool(1)` 的源码如下（基于 OpenJDK）：
  ```java
  public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
      return new ScheduledThreadPoolExecutor(corePoolSize);
  }
  ```
- `ScheduledThreadPoolExecutor` 的构造函数：
  ```java
  public ScheduledThreadPoolExecutor(int corePoolSize) {
      super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());
  }
  ```
- 这里，`super` 调用的是 `ThreadPoolExecutor` 的构造函数，参数为：
  - `corePoolSize`：1（核心线程数）
  - `maximumPoolSize`：`Integer.MAX_VALUE`（最大线程数）
  - `workQueue`：`DelayedWorkQueue`（一个无界延迟队列）

##### 62.3.1.3.2 为什么实际只用一个线程？
在 `ThreadPoolExecutor` 的工作机制中：
1. 当提交新任务时，如果当前线程数小于核心线程数，会创建新线程。
2. 如果线程数已达到核心线程数，任务会被放入队列。
3. **只有当队列满时**，才会创建新线程（直到达到最大线程数）。

但由于 `DelayedWorkQueue` 是一个**无界队列**（容量理论上无限），它永远不会满。因此：
- 任务总是被放入队列，而不会触发创建额外线程。
- 线程数会稳定在核心线程数（1个），不会增加到 `Integer.MAX_VALUE`。

##### 62.3.1.3.3 在您的代码中的影响：
- 您使用 `scheduleWithFixedDelay` 调度了一个周期性任务。由于线程池只有1个核心线程，所有任务都会由这个单线程顺序执行。
- 当任务执行时间超过延迟时间（如您的示例中休眠5秒），下一个任务会等待当前任务完成后再开始计算延迟（因为 `scheduleWithFixedDelay` 是“固定延迟”模式）。
- 即使有多个任务堆积在队列中，也只有一个线程处理它们，不会创建新线程。

##### 62.3.1.3.4 验证行为：
如果您运行代码，输出会类似这样（时间间隔示例）：
```
run scheduleWithFixedDelay @ 开始后0.5秒
run scheduleWithFixedDelay @ 开始后1.5秒
run scheduleWithFixedDelay @ 开始后2.5秒（这里休眠5秒）
run scheduleWithFixedDelay @ 开始后7.5秒（2.5秒开始 + 5秒休眠 + 1秒延迟）
run scheduleWithFixedDelay @ 开始后8.5秒
```
这证实了任务由单线程顺序执行。

##### 62.3.1.3.5 如果真想创建多个线程？
- 只有当任务提交速度极快，且队列“几乎满”时（但无界队列不会满），才可能触发创建新线程，但这在现实中很少发生。
- 如果您需要并行执行，应增加核心线程数（如 `newScheduledThreadPool(5)`），或使用其他线程池类型。

总结：**虽然最大线程数设置为 `Integer.MAX_VALUE`，但由于无界队列的存在，实际线程数不会超过核心线程数（1个）**。
# 六十三、SpringBoot定时任务 - Netty HashedWheelTimer方式
> Timer和ScheduledExecutorService是JDK内置的定时任务方案，而业内还有一个经典的定时任务的设计叫时间轮(Timing Wheel), Netty内部基于时间轮实现了一个HashedWheelTimer来优化百万量级I/O超时的检测，它是一个高性能，低消耗的数据结构，它适合用非准实时，延迟的短平快任务，例如心跳检测。本文主要介绍时间轮(Timing Wheel)及其使用。
## 63.1 知识准备
### 63.1.1 什么是时间轮(Timing Wheel)
> 时间轮(Timing Wheel)是George Varghese和Tony Lauck在1996年的论文'<a href='https://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt'>Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a>'实现的，它在Linux内核中使用广泛，是Linux内核定时器的实现方法和基础之一。

时间轮(Timing Wheel)是一种环形的数据结构，就像一个时钟可以分成很多格子(Tick)，每个格子代表时间的间隔，它指向存储的具体任务（timerTask）的一个链表。
![226.spring-framework-introduce-4.png](../../assets/images/04-主流框架/spring/226.spring-framework-introduce-4.png)

以上述在论文中的图片例子，这里一个轮子包含8个格子(Tick), 每个tick是一秒钟；
- 任务的添加：如果一个任务要在17秒后执行，那么它需要转2轮，最终加到Tick=1位置的链表中。
- 任务的执行：在时钟转2Round到Tick=1的位置，开始执行这个位置指向的链表中的这个任务。（# 这里表示剩余需要转几轮再执行这个任务）
### 63.1.2 Netty的HashedWheelTimer要解决什么问题
> HashedWheelTimer是Netty根据时间轮(Timing Wheel)开发的工具类，它要解决什么问题呢？这里面有两个要点：`延迟任务` + `低时效性`。

在Netty中的一个典型应用场景是判断某个连接是否idle，如果idle（如客户端由于网络原因导致到服务器的心跳无法送达），则服务器会主动断开连接，释放资源。判断连接是否idle是通过定时任务完成的，但是Netty可能维持数百万级别的长连接，对每个连接去定义一个定时任务是不可行的，所以如何提升I/O超时调度的效率呢？

Netty根据时间轮(Timing Wheel)开发了HashedWheelTimer工具类，用来优化I/O超时调度(本质上是延迟任务)；之所以采用时间轮(Timing Wheel)的结构还有一个很重要的原因是I/O超时这种类型的任务对时效性不需要非常精准。
### 63.1.3 HashedWheelTimer的使用方式
> 在了解时间轮(Timing Wheel)和Netty的HashedWheelTimer要解决的问题后，我们看下HashedWheelTimer的使用方式
- 通过构造函数看主要参数
```java
public HashedWheelTimer(
        ThreadFactory threadFactory,
        long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection,
        long maxPendingTimeouts, Executor taskExecutor) {

}
```
- 具体参数说明如下：
    - `threadFactory`：线程工厂，用于创建工作线程， 默认是Executors.defaultThreadFactory()
    - `tickDuration`：tick的周期，即多久tick一次(也就是说从一个格子切换到下一个格子需要消耗的时间是多少)
    - `unit`: tick周期的单位
    - `ticksPerWheel`：时间轮的长度，一圈下来有多少格
    - `leakDetection`：是否开启内存泄漏检测，默认是true
    - `maxPendingTimeouts`：最多执行的任务数，默认是-1，即不限制。在高并发量情况下才会设置这个参数。
## 63.2 实现案例
### 63.2.1 Pom依赖
```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.77.Final</version>
</dependency>
```
### 36.2.2 2个简单例子
例子1：5秒后执行TimerTask
```java
@SneakyThrows
public static void simpleHashedWheelTimer() {
    log.info("init task 1...");
    
    HashedWheelTimer timer = new HashedWheelTimer(1, TimeUnit.SECONDS, 8);

    // add a new timeout
    timer.newTimeout(timeout -> {
        log.info("running task 1...");
    }, 5, TimeUnit.SECONDS);
}
```
执行结果如下：
```sh
23:32:21.364 [main] INFO tech.pdai.springboot.schedule.timer.netty.HashedWheelTimerTester - init task 1...
...
23:32:27.454 [pool-1-thread-1] INFO tech.pdai.springboot.schedule.timer.netty.HashedWheelTimerTester - running task 1...
```
例子2：任务失效后cancel并让它重新在3秒后执行。
```java
@SneakyThrows
public static void reScheduleHashedWheelTimer() {
    log.info("init task 2...");

    HashedWheelTimer timer = new HashedWheelTimer(1, TimeUnit.SECONDS, 8);

    Thread.sleep(5000);

    // add a new timeout
    Timeout tm = timer.newTimeout(timeout -> {
        log.info("running task 2...");
    }, 5, TimeUnit.SECONDS);

    // cancel
    if (!tm.isExpired()) {
        log.info("cancel task 2...");
        tm.cancel();
    }

    // reschedule
    timer.newTimeout(tm.task(), 3, TimeUnit.SECONDS);
}
```
```sh
23:28:36.408 [main] INFO tech.pdai.springboot.schedule.timer.netty.HashedWheelTimerTester - init task 2...
23:28:41.412 [main] INFO tech.pdai.springboot.schedule.timer.netty.HashedWheelTimerTester - cancel task 2...
23:28:45.414 [pool-2-thread-1] INFO tech.pdai.springboot.schedule.timer.netty.HashedWheelTimerTester - running task 2...
```
## 63.3 进一步理解
### 63.3.1 HashedWheelTimer是如何实现的?
![227.springboot-timer-timewheel-3.png](../../assets/images/04-主流框架/spring/227.springboot-timer-timewheel-3.png)

- Worker：worker工作线程主要负责任务调度触发，单线程运行。
- HashedWheelBucket： 时间轮上面的格子，内部持有HashedWheelTimeout组成的链表结构的头尾节点，多个格子组成的时间轮形成一圈又一圈的任务环
- HashedWheelTimeout： 往时间轮里面提交的任务会被封装成HashedWheelTimeout

构造函数
```java
public HashedWheelTimer(
        ThreadFactory threadFactory,
        long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection,
        long maxPendingTimeouts, Executor taskExecutor) {

    checkNotNull(threadFactory, "threadFactory");
    checkNotNull(unit, "unit");
    checkPositive(tickDuration, "tickDuration");
    checkPositive(ticksPerWheel, "ticksPerWheel");
    this.taskExecutor = checkNotNull(taskExecutor, "taskExecutor");

    // Normalize ticksPerWheel to power of two and initialize the wheel.
    wheel = createWheel(ticksPerWheel);
    mask = wheel.length - 1;

    // Convert tickDuration to nanos.
    long duration = unit.toNanos(tickDuration);

    // Prevent overflow.
    if (duration >= Long.MAX_VALUE / wheel.length) {
        throw new IllegalArgumentException(String.format(
                "tickDuration: %d (expected: 0 < tickDuration in nanos < %d",
                tickDuration, Long.MAX_VALUE / wheel.length));
    }

    if (duration < MILLISECOND_NANOS) {
        logger.warn("Configured tickDuration {} smaller than {}, using 1ms.",
                    tickDuration, MILLISECOND_NANOS);
        this.tickDuration = MILLISECOND_NANOS;
    } else {
        this.tickDuration = duration;
    }

    workerThread = threadFactory.newThread(worker);

    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(this) : null;

    this.maxPendingTimeouts = maxPendingTimeouts;

    if (INSTANCE_COUNTER.incrementAndGet() > INSTANCE_COUNT_LIMIT &&
        WARNED_TOO_MANY_INSTANCES.compareAndSet(false, true)) {
        reportTooManyInstances();
    }
}
```
创建wheel
```java
private static HashedWheelBucket[] createWheel(int ticksPerWheel) {
    //ticksPerWheel may not be greater than 2^30
    checkInRange(ticksPerWheel, 1, 1073741824, "ticksPerWheel");

    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);
    HashedWheelBucket[] wheel = new HashedWheelBucket[ticksPerWheel];
    for (int i = 0; i < wheel.length; i ++) {
        wheel[i] = new HashedWheelBucket();
    }
    return wheel;
}

private static int normalizeTicksPerWheel(int ticksPerWheel) {
    int normalizedTicksPerWheel = 1;
    while (normalizedTicksPerWheel < ticksPerWheel) {
        normalizedTicksPerWheel <<= 1;
    }
    return normalizedTicksPerWheel;
}
```
任务的添加
```java
@Override
public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
    checkNotNull(task, "task");
    checkNotNull(unit, "unit");

    long pendingTimeoutsCount = pendingTimeouts.incrementAndGet();

    if (maxPendingTimeouts > 0 && pendingTimeoutsCount > maxPendingTimeouts) {
        pendingTimeouts.decrementAndGet();
        throw new RejectedExecutionException("Number of pending timeouts ("
            + pendingTimeoutsCount + ") is greater than or equal to maximum allowed pending "
            + "timeouts (" + maxPendingTimeouts + ")");
    }

    start();

    // Add the timeout to the timeout queue which will be processed on the next tick.
    // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.
    long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;

    // Guard against overflow.
    if (delay > 0 && deadline < 0) {
        deadline = Long.MAX_VALUE;
    }
    HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);
    timeouts.add(timeout);
    return timeout;
}

```
执行方法
```java
/**
    * Starts the background thread explicitly.  The background thread will
    * start automatically on demand even if you did not call this method.
    *
    * @throws IllegalStateException if this timer has been
    *                               {@linkplain #stop() stopped} already
    */
public void start() {
    switch (WORKER_STATE_UPDATER.get(this)) {
        case WORKER_STATE_INIT:
            if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {
                workerThread.start();
            }
            break;
        case WORKER_STATE_STARTED:
            break;
        case WORKER_STATE_SHUTDOWN:
            throw new IllegalStateException("cannot be started once stopped");
        default:
            throw new Error("Invalid WorkerState");
    }

    // Wait until the startTime is initialized by the worker.
    while (startTime == 0) {
        try {
            startTimeInitialized.await();
        } catch (InterruptedException ignore) {
            // Ignore - it will be ready very soon.
        }
    }
}
```
停止方法
```java
@Override
public Set<Timeout> stop() {
    if (Thread.currentThread() == workerThread) {
        throw new IllegalStateException(
                HashedWheelTimer.class.getSimpleName() +
                        ".stop() cannot be called from " +
                        TimerTask.class.getSimpleName());
    }

    if (!WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {
        // workerState can be 0 or 2 at this moment - let it always be 2.
        if (WORKER_STATE_UPDATER.getAndSet(this, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) {
            INSTANCE_COUNTER.decrementAndGet();
            if (leak != null) {
                boolean closed = leak.close(this);
                assert closed;
            }
        }

        return Collections.emptySet();
    }

    try {
        boolean interrupted = false;
        while (workerThread.isAlive()) {
            workerThread.interrupt();
            try {
                workerThread.join(100);
            } catch (InterruptedException ignored) {
                interrupted = true;
            }
        }

        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    } finally {
        INSTANCE_COUNTER.decrementAndGet();
        if (leak != null) {
            boolean closed = leak.close(this);
            assert closed;
        }
    }
    return worker.unprocessedTimeouts();
}
```
### 63.2.2 什么是多级Timing Wheel?
多级的时间轮是比较好理解的，时钟是有小时，分钟，秒的，秒转一圈(Round)分钟就转一个格（Tick）, 分钟转一圈(Round)小时就转一格（Tick）。
![228.springboot-timer-timewheel-2.png](../../assets/images/04-主流框架/spring/228.springboot-timer-timewheel-2.png)


PS：显然HashedWheelTimer是一层时间轮。
# 六十四、SpringBoot定时任务 - Spring Schedule实现方式
> 前文我们介绍了Timer和ScheduledExecutorService是JDK内置的定时任务方案以及Netty内部基于时间轮实现的HashedWheelTimer；而主流的SpringBoot集成方案有两种，一种是Spring Sechedule, 另一种是Spring集成Quartz； 本文主要介绍Spring Schedule实现方式。
## 64.1 准备知识点
### 64.1.1 什么是cron表达式
定时任务和CRON表达式在开发中使用也非常广泛；在学习时，总体上理解，对常用的知悉，开发时可以快速查询使用即可。
#### 64.1.1.1 什么是Cron
Cron来自百度百科（在新窗口打开），计划任务是指任务在约定的时间执行已经计划好的工作，这是表面的意思。在Linux中，我们经常用到cron服务器来完成这项工作。cron服务器可以根据配置文件约定的时间来执行特定的任务。

Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义。Cron有如下两种语法格式：
- Seconds Minutes Hours DayofMonth Month DayofWeek Year
- Seconds Minutes Hours DayofMonth Month DayofWeek

#### 64.1.1.2 Cron表达式的结构
Cron表达式是一个具有时间含义的字符串，字符串以5个空格隔开，分为6个域，格式为X X X X X X。其中X是一个域的占位符。单个域有多个取值时，使用半角逗号,隔开取值。每个域可以是确定的取值，也可以是具有逻辑意义的特殊字符。

#### 64.1.1.3 域取值
下表为Cron表达式中六个域能够取的值以及支持的特殊字符。

| 域 | 是否必需 | 取值范围 | 特殊字符 |
|----|----------|----------|----------|
| 秒 (Seconds) | 是 | [0, 59] | * , - / |
| 分钟 (Minutes) | 是 | [0, 59] | * , - / |
| 小时 (Hours) | 是 | [0, 23] | * , - / |
| 日期 (DayofMonth) | 是 | [1, 31] | * , - / ? L W |
| 月份 (Month) | 是 | [1, 12] 或 [JAN, DEC] | * , - / |
| 星期 (DayofWeek) | 是 | [1, 7] 或 [MON, SUN]。若使用[1, 7]表达方式，1代表星期一，7代表星期日。 | * , - / ? L # |
| 年 (Year) | 否 | 1970+ | * , - / |

#### 64.1.1.4 特殊字符
每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：
- `*`：表示匹配该域的任意值。假如在Minutes域使用`*`，即表示每分钟都会触发事件。
- `?`：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法：`13 13 15 20 * ?`，其中最后一位只能用`?`，而不能使用`*`，如果使用`*`表示不管星期几都会触发，实际上并不是这样。
- `-`：表示范围。例如在Minutes域使用`5-20`，表示从5分到20分钟每分钟触发一次。
- `/`：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用`5/20`，则意味着5分钟触发一次，而25、45等分别触发一次。
- `,`：表示列出枚举值。例如：在Minutes域使用`5,20`，则意味着在5和20分每分钟触发一次。
- `L`：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用`5L`，意味着在最后的一个星期四触发。
- `W`：表示有效工作日（周一到周五），只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在DayofMonth使用`5W`，如果5日是星期六，则将在最近的工作日：星期五，即4日触发；如果5日是星期天，则在6日（周一）触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份。
- `LW`：这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。
- `#`：用于确定每个月第几个星期几，只能出现在DayofWeek域。例如在`3#2`，表示某月的第二个星期三。

#### 64.1.1.5 常用表达式例子
以下是一些常用的Cron表达式例子：
- `0 0 2 1 * ? *`：表示在每月的1日的凌晨2点调整任务。
- `0 15 10 ? * MON-FRI`：表示周一到周五每天上午10:15执行作业。
- `0 15 10 ? 6L 2002-2006`：表示2002-2006年的每个月的最后一个星期五上午10:15执行作业。
- `0 0 10,14,16 * * ?`：每天上午10点，下午2点，4点。
- `0 0/30 9-17 * * ?`：朝九晚五工作时间内每半小时。
- `0 0 12 ? * WED`：表示每个星期三中午12点。
- `0 0 12 * * ?`：每天中午12点触发。
- `0 15 10 ? * *`：每天上午10:15触发。
- `0 15 10 * * ?`：每天上午10:15触发。
- `0 15 10 * * ? *`：每天上午10:15触发。
- `0 15 10 * * ? 2005`：2005年的每天上午10:15触发。
- `0 * 14 * * ?`：在每天下午2点到下午2:59期间的每1分钟触发。
- `0 0/5 14 * * ?`：在每天下午2点到下午2:55期间的每5分钟触发。
- `0 0/5 14,18 * * ?`：在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发。
- `0 0-5 14 * * ?`：在每天下午2点到下午2:05期间的每1分钟触发。
- `0 10,44 14 ? 3 WED`：每年三月的星期三的下午2:10和2:44触发。
- `0 15 10 ? * MON-FRI`：周一至周五的上午10:15触发。
- `0 15 10 15 * ?`：每月15日上午10:15触发。
- `0 15 10 L * ?`：每月最后一日的上午10:15触发。
- `0 15 10 ? * 6L`：每月的最后一个星期五上午10:15触发。
- `0 15 10 ? * 6L 2002-2005`：2002年至2005年的每月的最后一个星期五上午10:15触发。
- `0 15 10 ? * 6#3`：每月的第三个星期五上午10:15触发。

#### 64.1.1.6 注释
注：有些子表达式能包含一些范围或列表，例如：子表达式（天（星期））可以为“MON-FRI”、“MON，WED，FRI”、“MON-WED,SAT”。
- `*`字符代表所有可能的值。因此，`*`在子表达式（月）里表示每个月的含义，`*`在子表达式（天（星期））表示星期的每一天。
- `/`字符用来指定数值的增量。例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟；在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”的含义一样）。
- `?`字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值。当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“?”。
- `L`字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写。但是它在两个子表达式里的含义是不同的：在天（月）子表达式中，“L”表示一个月的最后一天；在天（星期）子表达式中，“L”表示一个星期的最后一天，也就是SAT。如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”表示这个月的倒数第6天，“FRIL”表示这个月的最一个星期五。注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题。
## 64.2 实现案例
> SpringTask封装的比较好，使用非常简单。

### 64.2.1 @EnableScheduling+@Scheduled
- 通过@EnableScheduling启用定时任务，@Scheduled定义任务
```java
@EnableScheduling
@Configuration
public class ScheduleDemo {

    /**
     * 每隔1分钟执行一次。
     */
    @Scheduled(fixedRate = 1000 * 60 * 1)
    public void runScheduleFixedRate() {
        log.info("runScheduleFixedRate: current DateTime, {}", LocalDateTime.now());
    }

    /**
     * 每个整点小时执行一次。
     */
    @Scheduled(cron = "0 0 */1 * * ?")
    public void runScheduleCron() {
        log.info("runScheduleCron: current DateTime, {}", LocalDateTime.now());
    }

}
```
- @Scheduled所支持的参数：
    - `cron`：cron表达式，指定任务在特定时间执行；
    - `fixedDelay`：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；f
    - `ixedDelayString`：与fixedDelay含义一样，只是参数类型变为String；
    - `fixedRate`：表示按一定的频率执行任务，参数类型为long，单位ms；
    - `fixedRateString`: 与fixedRate的含义一样，只是将参数类型变为String；
    - `initialDelay`：表示延迟多久再第一次执行任务，参数类型为long，单位ms；
    - `initialDelayString`：与initialDelay的含义一样，只是将参数类型变为String；
    - `zone`：时区，默认为当前时区，一般没有用到。
## 64.3 进一步理解
### 64.3.1 使用Spring Schedule要注意什么？
- 关于异常处理

建议自行处理异常
- 关于超时处理

在实际的开发中，这个问题经常会出现，比如执行一段时间后定时任务不再执行了； 这种情况会发生在，比如你调用一个第三方接口，没有设置调用超时，继而引发异常，这时候当前任务便阻塞了。
### 64.3.2 SpringTask的原理？
> SpringTask的源码在这里：
![229.springboot-task-2.png](../../assets/images/04-主流框架/spring/229.springboot-task-2.png)
#### 64.3.2.1 @EnableScheduling注解
添加@EnableScheduling注解会自动注入SchedulingConfiguration
```java
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.1
 * @see Scheduled
 * @see SchedulingConfiguration
 * @see SchedulingConfigurer
 * @see ScheduledTaskRegistrar
 * @see Trigger
 * @see ScheduledAnnotationBeanPostProcessor
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(SchedulingConfiguration.class)
@Documented
public @interface EnableScheduling {

}
```
#### 64.3.2.2 SchedulingConfiguration中初始化ScheduledAnnotationBeanPostProcessor
SchedulingConfiguration配置中自动初始化ScheduledAnnotationBeanPostProcessor
```java
@Configuration(proxyBeanMethods = false)
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
public class SchedulingConfiguration {

	@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() {
		return new ScheduledAnnotationBeanPostProcessor();
	}

}
```
- Spring 容器中 Bean 的生命周期流程
![230.spring-framework-ioc-source-102.png](../../assets/images/04-主流框架/spring/230.spring-framework-ioc-source-102.png)
#### 64.3.2.3 ScheduledTaskRegistrar注册task
在ScheduledAnnotationBeanPostProcessor构造函数中初始化了ScheduledTaskRegistrar
```java
/**
    * Create a default {@code ScheduledAnnotationBeanPostProcessor}.
    */
public ScheduledAnnotationBeanPostProcessor() {
    this.registrar = new ScheduledTaskRegistrar();
}
```
ScheduledTaskRegistrar最主要的是注册各种类型的task （这种方式在新的版本中已经废弃了）
```java
protected void scheduleTasks() {
    if (this.taskScheduler == null) {
        this.localExecutor = Executors.newSingleThreadScheduledExecutor();
        this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);
    }
    if (this.triggerTasks != null) {
        for (TriggerTask task : this.triggerTasks) {
            addScheduledTask(scheduleTriggerTask(task));
        }
    }
    if (this.cronTasks != null) {
        for (CronTask task : this.cronTasks) {
            addScheduledTask(scheduleCronTask(task));
        }
    }
    if (this.fixedRateTasks != null) {
        for (IntervalTask task : this.fixedRateTasks) {
            addScheduledTask(scheduleFixedRateTask(task));
        }
    }
    if (this.fixedDelayTasks != null) {
        for (IntervalTask task : this.fixedDelayTasks) {
            addScheduledTask(scheduleFixedDelayTask(task));
        }
    }
}
```
注册哪些Task，怎么设计类的呢？
![231.springboot-task-1.png](../../assets/images/04-主流框架/spring/231.springboot-task-1.png)
#### 64.3.2.4 ScheduledAnnotationBeanPostProcessor加载Scheduled注解
在BeanPostProcessor的postProcessAfterInitialization阶段加载Scheduled注解
```java
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) {
    if (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler ||
            bean instanceof ScheduledExecutorService) {
        // Ignore AOP infrastructure such as scoped proxies.
        return bean;
    }

    Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);
    if (!this.nonAnnotatedClasses.contains(targetClass) &&
            AnnotationUtils.isCandidateClass(targetClass, Arrays.asList(Scheduled.class, Schedules.class))) {
        Map<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,
                (MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {
                    Set<Scheduled> scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(
                            method, Scheduled.class, Schedules.class);
                    return (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null);
                });
        if (annotatedMethods.isEmpty()) {
            this.nonAnnotatedClasses.add(targetClass);
            if (logger.isTraceEnabled()) {
                logger.trace("No @Scheduled annotations found on bean class: " + targetClass);
            }
        }
        else {
            // Non-empty set of methods
            annotatedMethods.forEach((method, scheduledAnnotations) ->
                    scheduledAnnotations.forEach(scheduled -> processScheduled(scheduled, method, bean)));
            if (logger.isTraceEnabled()) {
                logger.trace(annotatedMethods.size() + " @Scheduled methods processed on bean '" + beanName +
                        "': " + annotatedMethods);
            }
        }
    }
    return bean;
}
```
Scheduled注解是添加到方法级别，具体如下
```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(Schedules.class)
public @interface Scheduled {

	/**
	 * A special cron expression value that indicates a disabled trigger: {@value}.
	 * <p>This is primarily meant for use with <code>${...}</code> placeholders,
	 * allowing for external disabling of corresponding scheduled methods.
	 * @since 5.1
	 * @see ScheduledTaskRegistrar#CRON_DISABLED
	 */
	String CRON_DISABLED = ScheduledTaskRegistrar.CRON_DISABLED;


	/**
	 * A cron-like expression, extending the usual UN*X definition to include triggers
	 * on the second, minute, hour, day of month, month, and day of week.
	 * <p>For example, {@code "0 * * * * MON-FRI"} means once per minute on weekdays
	 * (at the top of the minute - the 0th second).
	 * <p>The fields read from left to right are interpreted as follows.
	 * <ul>
	 * <li>second</li>
	 * <li>minute</li>
	 * <li>hour</li>
	 * <li>day of month</li>
	 * <li>month</li>
	 * <li>day of week</li>
	 * </ul>
	 * <p>The special value {@link #CRON_DISABLED "-"} indicates a disabled cron
	 * trigger, primarily meant for externally specified values resolved by a
	 * <code>${...}</code> placeholder.
	 * @return an expression that can be parsed to a cron schedule
	 * @see org.springframework.scheduling.support.CronExpression#parse(String)
	 */
	String cron() default "";

	/**
	 * A time zone for which the cron expression will be resolved. By default, this
	 * attribute is the empty String (i.e. the server's local time zone will be used).
	 * @return a zone id accepted by {@link java.util.TimeZone#getTimeZone(String)},
	 * or an empty String to indicate the server's default time zone
	 * @since 4.0
	 * @see org.springframework.scheduling.support.CronTrigger#CronTrigger(String, java.util.TimeZone)
	 * @see java.util.TimeZone
	 */
	String zone() default "";

	/**
	 * Execute the annotated method with a fixed period between the end of the
	 * last invocation and the start of the next.
	 * <p>The time unit is milliseconds by default but can be overridden via
	 * {@link #timeUnit}.
	 * @return the delay
	 */
	long fixedDelay() default -1;

	/**
	 * Execute the annotated method with a fixed period between the end of the
	 * last invocation and the start of the next.
	 * <p>The time unit is milliseconds by default but can be overridden via
	 * {@link #timeUnit}.
	 * @return the delay as a String value &mdash; for example, a placeholder
	 * or a {@link java.time.Duration#parse java.time.Duration} compliant value
	 * @since 3.2.2
	 */
	String fixedDelayString() default "";

	/**
	 * Execute the annotated method with a fixed period between invocations.
	 * <p>The time unit is milliseconds by default but can be overridden via
	 * {@link #timeUnit}.
	 * @return the period
	 */
	long fixedRate() default -1;

	/**
	 * Execute the annotated method with a fixed period between invocations.
	 * <p>The time unit is milliseconds by default but can be overridden via
	 * {@link #timeUnit}.
	 * @return the period as a String value &mdash; for example, a placeholder
	 * or a {@link java.time.Duration#parse java.time.Duration} compliant value
	 * @since 3.2.2
	 */
	String fixedRateString() default "";

	/**
	 * Number of units of time to delay before the first execution of a
	 * {@link #fixedRate} or {@link #fixedDelay} task.
	 * <p>The time unit is milliseconds by default but can be overridden via
	 * {@link #timeUnit}.
	 * @return the initial
	 * @since 3.2
	 */
	long initialDelay() default -1;

	/**
	 * Number of units of time to delay before the first execution of a
	 * {@link #fixedRate} or {@link #fixedDelay} task.
	 * <p>The time unit is milliseconds by default but can be overridden via
	 * {@link #timeUnit}.
	 * @return the initial delay as a String value &mdash; for example, a placeholder
	 * or a {@link java.time.Duration#parse java.time.Duration} compliant value
	 * @since 3.2.2
	 */
	String initialDelayString() default "";

	/**
	 * The {@link TimeUnit} to use for {@link #fixedDelay}, {@link #fixedDelayString},
	 * {@link #fixedRate}, {@link #fixedRateString}, {@link #initialDelay}, and
	 * {@link #initialDelayString}.
	 * <p>Defaults to {@link TimeUnit#MICROSECONDS}.
	 * <p>This attribute is ignored for {@linkplain #cron() cron expressions}
	 * and for {@link java.time.Duration} values supplied via {@link #fixedDelayString},
	 * {@link #fixedRateString}, or {@link #initialDelayString}.
	 * @return the {@code TimeUnit} to use
	 * @since 5.3.10
	 */
	TimeUnit timeUnit() default TimeUnit.MILLISECONDS;

}
```
获取到方法上Scheduled注解（对任务的定义），通过processScheduled处理具体类型的task
```java
/**
    * Process the given {@code @Scheduled} method declaration on the given bean.
    * @param scheduled the {@code @Scheduled} annotation
    * @param method the method that the annotation has been declared on
    * @param bean the target bean instance
    * @see #createRunnable(Object, Method)
    */
protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
    try {
        Runnable runnable = createRunnable(bean, method);
        boolean processedSchedule = false;
        String errorMessage =
                "Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required";

        Set<ScheduledTask> tasks = new LinkedHashSet<>(4);

        // Determine initial delay
        long initialDelay = convertToMillis(scheduled.initialDelay(), scheduled.timeUnit());
        String initialDelayString = scheduled.initialDelayString();
        if (StringUtils.hasText(initialDelayString)) {
            Assert.isTrue(initialDelay < 0, "Specify 'initialDelay' or 'initialDelayString', not both");
            if (this.embeddedValueResolver != null) {
                initialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);
            }
            if (StringUtils.hasLength(initialDelayString)) {
                try {
                    initialDelay = convertToMillis(initialDelayString, scheduled.timeUnit());
                }
                catch (RuntimeException ex) {
                    throw new IllegalArgumentException(
                            "Invalid initialDelayString value \"" + initialDelayString + "\" - cannot parse into long");
                }
            }
        }

        // Check cron expression
        String cron = scheduled.cron();
        if (StringUtils.hasText(cron)) {
            String zone = scheduled.zone();
            if (this.embeddedValueResolver != null) {
                cron = this.embeddedValueResolver.resolveStringValue(cron);
                zone = this.embeddedValueResolver.resolveStringValue(zone);
            }
            if (StringUtils.hasLength(cron)) {
                Assert.isTrue(initialDelay == -1, "'initialDelay' not supported for cron triggers");
                processedSchedule = true;
                if (!Scheduled.CRON_DISABLED.equals(cron)) {
                    TimeZone timeZone;
                    if (StringUtils.hasText(zone)) {
                        timeZone = StringUtils.parseTimeZoneString(zone);
                    }
                    else {
                        timeZone = TimeZone.getDefault();
                    }
                    tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));
                }
            }
        }

        // At this point we don't need to differentiate between initial delay set or not anymore
        if (initialDelay < 0) {
            initialDelay = 0;
        }

        // Check fixed delay
        long fixedDelay = convertToMillis(scheduled.fixedDelay(), scheduled.timeUnit());
        if (fixedDelay >= 0) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));
        }

        String fixedDelayString = scheduled.fixedDelayString();
        if (StringUtils.hasText(fixedDelayString)) {
            if (this.embeddedValueResolver != null) {
                fixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);
            }
            if (StringUtils.hasLength(fixedDelayString)) {
                Assert.isTrue(!processedSchedule, errorMessage);
                processedSchedule = true;
                try {
                    fixedDelay = convertToMillis(fixedDelayString, scheduled.timeUnit());
                }
                catch (RuntimeException ex) {
                    throw new IllegalArgumentException(
                            "Invalid fixedDelayString value \"" + fixedDelayString + "\" - cannot parse into long");
                }
                tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay)));
            }
        }

        // Check fixed rate
        long fixedRate = convertToMillis(scheduled.fixedRate(), scheduled.timeUnit());
        if (fixedRate >= 0) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));
        }
        String fixedRateString = scheduled.fixedRateString();
        if (StringUtils.hasText(fixedRateString)) {
            if (this.embeddedValueResolver != null) {
                fixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);
            }
            if (StringUtils.hasLength(fixedRateString)) {
                Assert.isTrue(!processedSchedule, errorMessage);
                processedSchedule = true;
                try {
                    fixedRate = convertToMillis(fixedRateString, scheduled.timeUnit());
                }
                catch (RuntimeException ex) {
                    throw new IllegalArgumentException(
                            "Invalid fixedRateString value \"" + fixedRateString + "\" - cannot parse into long");
                }
                tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));
            }
        }

        // Check whether we had any attribute set
        Assert.isTrue(processedSchedule, errorMessage);

        // Finally register the scheduled tasks
        synchronized (this.scheduledTasks) {
            Set<ScheduledTask> regTasks = this.scheduledTasks.computeIfAbsent(bean, key -> new LinkedHashSet<>(4));
            regTasks.addAll(tasks);
        }
    }
    catch (IllegalArgumentException ex) {
        throw new IllegalStateException(
                "Encountered invalid @Scheduled method '" + method.getName() + "': " + ex.getMessage());
    }
}
```
#### 64.3.2.5 ScheduledTaskRegistrar 中解析task
以CronTask为例，如果定义了taskScheduler则由taskScheduler执行，如果没有放到unresolvedTasks中。
```java
/**
    * Schedule the specified cron task, either right away if possible
    * or on initialization of the scheduler.
    * @return a handle to the scheduled task, allowing to cancel it
    * (or {@code null} if processing a previously registered task)
    * @since 4.3
    */
@Nullable
public ScheduledTask scheduleCronTask(CronTask task) {
    ScheduledTask scheduledTask = this.unresolvedTasks.remove(task);
    boolean newTask = false;
    if (scheduledTask == null) {
        scheduledTask = new ScheduledTask(task);
        newTask = true;
    }
    if (this.taskScheduler != null) {
        scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger());
    }
    else {
        addCronTask(task);
        this.unresolvedTasks.put(task, scheduledTask);
    }
    return (newTask ? scheduledTask : null);
}
```
#### 64.3.2.6 TaskScheduler对Task处理
默认是ConcurrentTaskScheduler， 处理方法如下
```java
@Override
@Nullable
public ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {
    try {
        if (this.enterpriseConcurrentScheduler) {
            return new EnterpriseConcurrentTriggerScheduler().schedule(decorateTask(task, true), trigger);
        }
        else {
            ErrorHandler errorHandler =
                    (this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true));
            return new ReschedulingRunnable(task, trigger, this.clock, this.scheduledExecutor, errorHandler).schedule();
        }
    }
    catch (RejectedExecutionException ex) {
        throw new TaskRejectedException("Executor [" + this.scheduledExecutor + "] did not accept task: " + task, ex);
    }
}
```
EnterpriseConcurrentTriggerScheduler 是 JSR-236 Trigger标准，它的处理方法如下
```java
/**
    * Delegate that adapts a Spring Trigger to a JSR-236 Trigger.
    * Separated into an inner class in order to avoid a hard dependency on the JSR-236 API.
    */
private class EnterpriseConcurrentTriggerScheduler {

    public ScheduledFuture<?> schedule(Runnable task, final Trigger trigger) {
        ManagedScheduledExecutorService executor = (ManagedScheduledExecutorService) scheduledExecutor;
        return executor.schedule(task, new javax.enterprise.concurrent.Trigger() {
            @Override
            @Nullable
            public Date getNextRunTime(@Nullable LastExecution le, Date taskScheduledTime) {
                return (trigger.nextExecutionTime(le != null ?
                        new SimpleTriggerContext(le.getScheduledStart(), le.getRunStart(), le.getRunEnd()) :
                        new SimpleTriggerContext()));
            }
            @Override
            public boolean skipRun(LastExecution lastExecution, Date scheduledRunTime) {
                return false;
            }
        });
    }
}
```
如果没有使用EnterpriseConcurrentTriggerScheduler, 则使用ReschedulingRunnable，本质上由ScheduledExecutorService处理
```java
public ReschedulingRunnable(Runnable delegate, Trigger trigger, Clock clock,
			ScheduledExecutorService executor, ErrorHandler errorHandler) {

    super(delegate, errorHandler);
    this.trigger = trigger;
    this.triggerContext = new SimpleTriggerContext(clock);
    this.executor = executor;
}


@Nullable
public ScheduledFuture<?> schedule() {
    synchronized (this.triggerContextMonitor) {
        this.scheduledExecutionTime = this.trigger.nextExecutionTime(this.triggerContext);
        if (this.scheduledExecutionTime == null) {
            return null;
        }
        long initialDelay = this.scheduledExecutionTime.getTime() - this.triggerContext.getClock().millis();
        this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS);
        return this;
    }
}
```
### 64.3.3 进一步解释
SpringTask 是 Spring 框架提供的定时任务调度模块，其核心原理基于 Spring 的 Bean 生命周期管理和 JDK 的 `ScheduledExecutorService`。下面我将从底层实现、任务解析与触发机制、以及 BeanPostProcessor 的作用三个方面详细解释。

---

##### **64.3.3.1 底层实现原理：定时任务如何执行？**
SpringTask 的底层依赖于 **JDK 的 `ScheduledExecutorService`**（特别是 `ScheduledThreadPoolExecutor`）来实现定时任务的调度。具体流程如下：
1. **任务封装**：当使用 `@Scheduled` 注解标记方法时，Spring 会将该方法封装为一个 `Runnable` 任务。
2. **调度器核心**：通过 `TaskScheduler`（默认实现是 `ConcurrentTaskScheduler`）来管理任务调度。`ConcurrentTaskScheduler` 内部持有一个 `ScheduledExecutorService` 实例。
3. **触发执行**：
   - 对于 `cron` 表达式任务，Spring 使用 `CronTrigger` 计算下一次执行时间，然后通过 `ScheduledExecutorService.schedule()` 方法安排任务。
   - 对于 `fixedDelay`/`fixedRate` 任务，直接使用 `ScheduledExecutorService.scheduleAtFixedRate()` 或 `scheduleWithFixedDelay()` 方法。
4. **底层线程池**：所有定时任务都由一个共享的线程池（默认单线程）执行，确保任务按计划运行，但需注意长时间任务可能阻塞后续任务（需异步优化）。

**关键代码段**（来自您提供的源码）：
```java
// 在 ConcurrentTaskScheduler 中，最终委托给 ScheduledExecutorService
public ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {
    // ... 
    return new ReschedulingRunnable(task, trigger, this.clock, this.scheduledExecutor, errorHandler).schedule();
}

// ReschedulingRunnable 内部使用 ScheduledExecutorService 调度
public ScheduledFuture<?> schedule() {
    long initialDelay = this.scheduledExecutionTime.getTime() - this.triggerContext.getClock().millis();
    this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS);
    return this;
}
```
**总结**：底层通过 JDK 原生定时线程池实现，Spring 只是封装了任务解析和触发逻辑。

---

##### **64.3.3.2 Spring 如何解析任务并保证定时触发？**
Spring 通过 **任务注册表（ScheduledTaskRegistrar）** 和 **触发器（Trigger）** 机制来解析和调度任务，确保定时触发：
1. **任务解析**：
   - 在 Bean 初始化阶段（`postProcessAfterInitialization`），`ScheduledAnnotationBeanPostProcessor` 扫描所有 `@Scheduled` 注解的方法。
   - 根据注解属性（如 `cron`、`fixedDelay`），将方法解析为具体的任务类型（`CronTask`、`FixedDelayTask` 等）。
2. **任务注册**：
   - 解析后的任务被注册到 `ScheduledTaskRegistrar` 中。如果 `TaskScheduler` 已就绪，直接调度；否则暂存到 `unresolvedTasks`，待 `TaskScheduler` 初始化后处理。
3. **定时触发保证**：
   - **Cron 任务**：使用 `CronTrigger` 计算下次执行时间。`CronTrigger` 基于 Spring 的 `CronExpression` 解析表达式，并返回准确的下一时间点。
   - **固定延迟/速率任务**：通过 `ScheduledExecutorService` 的内置机制（如 `scheduleAtFixedRate`）确保周期执行。
   - **容错机制**：任务执行异常时，Spring 提供了 `ErrorHandler` 处理，避免任务中断。

**关键代码段**：
```java
// 处理 @Scheduled 注解的方法
protected void processScheduled(Scheduled scheduled, Method method, Object bean) {
    Runnable runnable = createRunnable(bean, method);
    // 解析 cron 表达式
    if (StringUtils.hasText(cron)) {
        CronTrigger trigger = new CronTrigger(cron, timeZone);
        tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, trigger)));
    }
    // 固定速率任务
    if (fixedRate >= 0) {
        tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay)));
    }
}
```
**总结**：Spring 将任务解析为统一格式，利用 JDK 线程池的调度能力，结合触发器计算执行时间，从而保证定时触发。

---

##### **64.3.3.3 为什么使用 BeanPostProcessor？**
`BeanPostProcessor` 是 Spring 容器中 Bean 生命周期管理的核心接口，SpringTask 使用 `ScheduledAnnotationBeanPostProcessor`（实现了 `BeanPostProcessor`）主要出于以下原因：
1. **注解扫描时机**：Bean 的初始化后阶段（`postProcessAfterInitialization`）是扫描 `@Scheduled` 注解的理想时机。此时 Bean 已完全实例化，依赖注入完成，可以安全地提取方法信息。
2. **非侵入式设计**：通过 `BeanPostProcessor`，Spring 无需修改原有 Bean 的定义，即可动态添加定时任务逻辑。这符合 Spring 的 AOP 思想，解耦业务代码和调度逻辑。
3. **集中管理**：所有 Bean 的定时任务都由同一个后处理器处理，便于统一注册到 `ScheduledTaskRegistrar`，避免重复代码。
4. **灵活性**：允许在 Bean 生命周期中动态调整任务（例如，根据配置启用/禁用任务）。

**关键代码段**：
```java
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) {
    // 忽略基础设施 Bean
    if (bean instanceof AopInfrastructureBean || ...) {
        return bean;
    }
    // 扫描 @Scheduled 注解的方法
    Map<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(...);
    annotatedMethods.forEach((method, scheduledAnnotations) -> 
        scheduledAnnotations.forEach(scheduled -> processScheduled(scheduled, method, bean)));
    return bean;
}
```
**总结**：使用 `BeanPostProcessor` 是为了在 Bean 生命周期的合适阶段自动发现和处理 `@Scheduled` 注解，实现定时任务的无缝集成。

---

##### 64.3.3.4 **整体流程总结**
1. **启动阶段**：`@EnableScheduling` 导入 `SchedulingConfiguration`，注册 `ScheduledAnnotationBeanPostProcessor`。
2. **Bean 初始化**：后处理器扫描 Bean 的 `@Scheduled` 方法，解析为任务对象。
3. **任务调度**：任务被注册到 `ScheduledTaskRegistrar`，由 `TaskScheduler`（底层是 `ScheduledExecutorService`）调度执行。
4. **定时触发**：通过触发器（如 `CronTrigger`）或固定延迟机制，确保任务按计划运行。

这种方式结合了 Spring 的依赖注入和 JDK 并发工具，实现了高效、可扩展的定时任务管理。如果您有具体代码场景需要进一步分析，欢迎提供更多细节！

##### 64.3.3.5 SpringTask 如何解析 Cron 表达式并保证准时触发？

问题涉及 SpringTask 的核心调度机制，特别是对于复杂 Cron 表达式（如“每个月第二个星期三”）的处理。下面我将结合 Spring 源码详细解释整个流程，包括表达式解析、时间计算和触发机制。

---

###### **64.3.3.5.1. Cron 表达式的解析与时间计算**
SpringTask 使用 **`CronTrigger`** 类来处理 Cron 表达式。`CronTrigger` 基于 Spring 自带的 **`CronExpression`** 解析器，该解析器支持标准 Cron 语法（包括特殊字符如 `#`）。

- **解析过程**：
  - 当 Spring 扫描到 `@Scheduled(cron = "0 0 0 ? * 3#2")` 时（假设 `3#2` 表示第二个星期三），会创建一个 `CronTrigger` 实例。
  - `CronTrigger` 内部调用 `CronExpression.parse("0 0 0 ? * 3#2")` 将字符串转换为可执行的调度规则。`CronExpression` 会解析每个域（秒、分、时、日期、月份、星期），并验证逻辑（例如，避免日期和星期的冲突）。
  - 对于 `3#2`，解析器会识别：
    - `3`：星期三（根据您的定义，1=星期一，7=星期日）。
    - `#2`：第二个。
    - 最终规则：计算每个月的第二个星期三的具体日期。

- **时间计算**：
  - `CronTrigger` 实现了 `Trigger` 接口，核心方法是 `nextExecutionTime(TriggerContext context)`。
  - 该方法基于当前时间（从 `TriggerContext` 获取）和 Cron 规则，计算下一次执行的时间点。例如：
    - 假设当前时间是 2023-10-01（星期日），`CronTrigger` 会遍历当前月份的日期，找到第二个星期三（如 2023-10-11），并返回该日期的 00:00:00 作为下次执行时间。
    - 每次任务执行后，`TriggerContext` 会更新最后一次执行时间，供下次计算使用。

**关键代码段**（来自 Spring 源码）：
```java
// CronTrigger 的 nextExecutionTime 方法
public Date nextExecutionTime(TriggerContext triggerContext) {
    Date lastExecution = triggerContext.lastScheduledExecutionTime();
    Date lastCompletion = triggerContext.lastCompletionTime();
    CronExpression expression = this.expression;
    if (expression == null) {
        expression = CronExpression.parse(this.sequence);
    }
    return expression.next(lastExecution != null ? lastExecution : new Date());
}
```

---

###### **64.3.3.5.2. 任务触发机制：如何“提醒”代码执行？**
SpringTask 的触发机制依赖于 **JDK 的 `ScheduledExecutorService`**，其底层通过 **延迟队列和线程池** 实现精准定时。具体流程如下：

1. **任务封装**：
   - Spring 将 `@Scheduled` 方法封装为一个 `Runnable`（例如 `ScheduledMethodRunnable`）。
   - 对于 Cron 任务，Spring 创建一个 `CronTask`，包含 `Runnable` 和 `CronTrigger`。

2. **调度执行**：
   - `TaskScheduler`（默认 `ConcurrentTaskScheduler`）接收任务后，使用 `ReschedulingRunnable` 来管理调度。
   - `ReschedulingRunnable.schedule()` 方法调用 `CronTrigger.nextExecutionTime()` 获取下次执行时间，然后计算当前时间与目标时间的差值（初始延迟）。
   - 通过 `ScheduledExecutorService.schedule(this, initialDelay, TimeUnit.MILLISECONDS)` 将任务提交到线程池。线程池内部使用 **优先级队列（DelayedWorkQueue）** 存储任务，按执行时间排序。

3. **底层“提醒”机制**：
   - `ScheduledThreadPoolExecutor` 的工作线程会定期检查队列中的任务。当任务的延迟时间到达时，线程池唤醒并执行任务。
   - 任务执行后，`ReschedulingRunnable` 会 **递归调用** `schedule()` 方法：
     - 再次计算下一次执行时间（例如，下个月的第二个星期三）。
     - 重新提交任务到线程池，形成持续调度。

**关键代码段**（简化版）：
```java
// ReschedulingRunnable 的调度逻辑
public void run() {
    try {
        // 执行实际任务
        super.run();
    } finally {
        // 执行完成后，重新计算下次时间并再次调度
        if (!this.executor.isShutdown()) {
            schedule();
        }
    }
}

public ScheduledFuture<?> schedule() {
    Date nextExecutionTime = this.trigger.nextExecutionTime(this.triggerContext);
    long delay = nextExecutionTime.getTime() - System.currentTimeMillis();
    this.currentFuture = this.executor.schedule(this, delay, TimeUnit.MILLISECONDS);
    return this.currentFuture;
}
```

---

###### **64.3.3.5.3. 为什么能保证准时触发？**
- **精确的时间计算**：`CronExpression` 考虑了闰年、月份天数、星期规则等，确保日期计算准确。
- **系统时钟依赖**：底层使用 `System.currentTimeMillis()` 或 `Clock` 类获取当前时间，与系统时间同步。
- **线程池调度精度**：JDK 的 `ScheduledThreadPoolExecutor` 使用高精度计时器（底层依赖操作系统时钟中断），误差通常在毫秒级。
- **容错处理**：如果任务执行时间过长，Spring 提供了配置选项（如 `@Async`）避免阻塞后续任务。

---

###### **64.3.3.5.4 示例：处理“每个月第二个星期三”**
假设 Cron 表达式为 `0 0 0 ? * 3#2`：
1. **解析**：Spring 识别出“第二个星期三”的规则。
2. **计算**：每次执行后，`CronTrigger` 会计算下个月的第二个星期三（例如，从 10月11日 跳到 11月8日）。
3. **触发**：线程池在目标日期的 00:00:00 唤醒任务并执行。

---

###### **64.3.3.5..5 总结**
- **解析**：Spring 通过 `CronExpression` 解析复杂表达式（如 `#`），转换为可计算的时间规则。
- **调度**：利用 `ScheduledExecutorService` 的延迟队列机制，实现“睡眠-唤醒”式触发。
- **保证准时**：基于系统时间和递归调度，确保任务在精确时间点执行。

这种设计使得 SpringTask 能够高效处理周期性、复杂时间规则的任务，同时保持低资源消耗。如果您有具体表达式或场景需要测试，我可以进一步分析！
### 64.3.4 SpringTask扩展：@Async/@Scheduled注解配合使用-异步定时任务执行
#### 64.3.4.1 `@Async` 配合 `@Scheduled` 的实现效果分析

当 `@Async` 和 `@Scheduled` 同时使用时，会产生**异步定时任务**的效果。让我详细解释这种组合的工作原理和实际效果：

---

##### **1. 单独使用 `@Scheduled` 的问题**
```java
@Scheduled(cron = "0 0 3 * * ?")
public void syncData() {
    // 同步操作，可能很耗时
    organizationService.updateOrganization();
    userService.updateUserByAccount();
}
```
**问题**：
- SpringTask 默认使用**单线程**执行所有定时任务
- 如果该任务执行时间较长（如几分钟），会**阻塞其他定时任务**
- 任务本身是**同步执行**的，调用线程需要等待任务完成

---

##### **2. `@Async + @Scheduled` 的组合效果**
```java
@Async("threadPool")
@Scheduled(cron = "0 0 3 * * ?")
public void asyncUpdateOrganizationAndUser() {
    // 异步执行
}
```

#### 64.3.4.2 **执行流程**：
1. **定时触发**：Spring 的定时任务调度器在每天凌晨3点触发方法调用
2. **异步执行**：由于有 `@Async` 注解，Spring 不会直接执行方法体，而是：
   - 将方法调用封装为 `Runnable` 任务
   - 提交到指定的线程池（`threadPool`）
   - 立即返回，不阻塞调度线程
3. **并发处理**：线程池中的工作线程实际执行数据同步逻辑

#### 64.3.4.3 **具体优势**：

| 方面 | 单独 `@Scheduled` | `@Async + @Scheduled` |
|------|-------------------|----------------------|
| **调度线程** | 阻塞等待任务完成 | 立即返回，不阻塞 |
| **任务执行** | 同步，单线程顺序执行 | 异步，线程池并发执行 |
| **其他任务** | 被当前任务阻塞 | 不受影响，按时触发 |
| **资源利用** | 低效 | 高效利用多线程 |

---

#### **64.3.4.4 . 线程池配置分析**
您的线程池配置：
```java
@Bean("threadPool")
public ThreadPoolTaskExecutor getThreadPool(){
    threadPoolTaskExecutor.setCorePoolSize(10);    // 核心线程数
    threadPoolTaskExecutor.setMaxPoolSize(20);     // 最大线程数  
    threadPoolTaskExecutor.setQueueCapacity(100);  // 队列容量
    threadPoolTaskExecutor.setKeepAliveSeconds(30);// 空闲线程存活时间
}
```

**对于定时任务的应用场景**：
- **核心线程10个**：可以同时处理10个定时任务
- **队列容量100**：当核心线程忙时，新任务进入队列等待
- **最大线程20个**：队列满时创建新线程，避免任务拒绝

---

#### **64.3.4.5. 实际执行时序示例**
假设凌晨3点有多个定时任务需要执行：

```
时间轴：
03:00:00 - 调度线程触发 asyncUpdateOrganizationAndUser()
          ↓
          任务提交到 threadPool，调度线程立即返回
          ↓
03:00:00 - 调度线程继续触发其他定时任务
03:00:01 - threadPool 的工作线程开始执行数据同步
03:02:30 - 数据同步完成（耗时2.5分钟）
```

**关键点**：
- 调度线程只负责**触发**任务，不负责**执行**
- 长时间任务在后台线程池中运行，不影响系统其他定时任务
- 即使本次任务未完成，下次触发时仍会提交新任务到线程池

---

#### **64.3.4.6. 注意事项和最佳实践**

##### **潜在问题**：
1. **任务堆积**：如果任务执行时间 > 触发间隔，会导致任务在线程池中堆积
2. **资源竞争**：多个异步任务可能竞争数据库连接等资源
3. **异常处理**：异步任务的异常需要特殊处理，不会传播到调度线程

##### **建议的改进**：
```java
@Async("threadPool")
@Scheduled(cron = "0 0 3 * * ?")
public void asyncUpdateOrganizationAndUser() {
    try {
        logger.info("开始同步组织信息...");
        organizationService.updateOrganization();
        logger.info("同步组织信息结束！");
        
        logger.info("开始同步人员信息...");
        userService.updateUserByAccount();
        logger.info("同步人员信息结束！");
    } catch (Exception e) {
        logger.error("同步组织/人员信息失败", e);
        // 异步任务需要显式处理异常
        // 可以考虑发送告警通知
    }
}
```

##### **监控建议**：
```java
// 添加任务执行监控
@Async("threadPool")
@Scheduled(cron = "0 0 3 * * ?")
public void asyncUpdateOrganizationAndUser() {
    long startTime = System.currentTimeMillis();
    try {
        // 业务逻辑
    } finally {
        long cost = System.currentTimeMillis() - startTime;
        logger.info("数据同步任务执行完成，耗时: {}ms", cost);
        
        // 如果耗时过长，可以发出警告
        if (cost > 300000) { // 5分钟
            logger.warn("数据同步任务执行时间过长，请检查性能");
        }
    }
}
```

---

#### 64.3.4.7 **总结**
`@Async + @Scheduled` 的组合实现了：
- ✅ **非阻塞调度**：调度线程快速返回，不等待任务完成
- ✅ **并发执行**：利用线程池提高任务处理能力  
- ✅ **资源隔离**：耗时任务在独立线程池中运行，不影响系统稳定性
- ✅ **弹性扩展**：通过线程池参数调整应对不同负载场景

这种模式特别适合执行时间长、资源消耗大的后台定时任务，是生产环境中的推荐做法。
### 64.3.5 `@Async` 配合 `@Scheduled` 源码解析
#### **源码追踪：`@Async` 的异步执行机制**

##### **1. 核心入口：`AsyncExecutionInterceptor`**

`@Async` 的功能主要通过 AOP 拦截器实现，核心类是 **`AsyncExecutionInterceptor`**：

```java
// org.springframework.aop.interceptor.AsyncExecutionInterceptor
public class AsyncExecutionInterceptor extends AsyncExecutionAspectSupport {
    
    @Override
    @Nullable
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 关键方法：判断是否需要异步执行
        if (isAsyncCall(invocation)) {
            // 这里就是异步执行的入口
            return doSubmit(invocation);
        }
        
        // 同步执行
        return invocation.proceed();
    }
}
```

##### **2. 核心实现：`doSubmit` 方法**

```java
// org.springframework.aop.interceptor.AsyncExecutionAspectSupport
protected Object doSubmit(Callable<Object> task, AsyncTaskExecutor executor, Class<?> returnType) {
    // 关键逻辑：将方法调用提交到线程池
    if (CompletableFuture.class.isAssignableFrom(returnType)) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return task.call();
            } catch (Throwable ex) {
                throw new CompletionException(ex);
            }
        }, executor);
    }
    else if (ListenableFuture.class.isAssignableFrom(returnType)) {
        return ((AsyncListenableTaskExecutor) executor).submitListenable(task);
    }
    else if (Future.class.isAssignableFrom(returnType)) {
        return executor.submit(task);
    }
    else {
        // 无返回值的情况 - 这就是您代码中的场景！
        executor.submit(task);
        return null;  // 立即返回null，不等待任务执行
    }
}
```

##### **3. 具体的任务封装过程**

让我们看看 `MethodInvocation` 如何被封装为 `Runnable`：

```java
// 在 AsyncExecutionAspectSupport 中
protected Callable<Object> createCallable(MethodInvocation invocation) {
    return () -> {
        try {
            // 这里就是实际的方法调用
            Object result = invocation.proceed();
            if (result instanceof Future) {
                return ((Future<?>) result).get();
            }
            return result;
        } catch (Throwable ex) {
            // 异常处理
            handleError(ex, invocation.getMethod(), invocation.getArguments());
            throw ex;
        }
    };
}

// 在 doSubmit 中会调用：
Callable<Object> callable = createCallable(invocation);
executor.submit(callable);  // 提交到线程池
```

##### **4. 结合 `@Scheduled` 的完整调用链**

当 `@Async` 和 `@Scheduled` 一起使用时：

```java
// 1. ScheduledAnnotationBeanPostProcessor 触发定时任务
// org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor
private void processScheduled(Scheduled scheduled, Method method, Object bean) {
    // 创建任务
    Runnable task = createRunnable(bean, method);
    
    // 调度执行 - 这里会调用被 @Async 代理的方法
    taskScheduler.schedule(task, new CronTrigger(scheduled.cron()));
}

// 2. 由于方法有 @Async 注解，实际调用的是代理对象
// 代理对象会进入 AsyncExecutionInterceptor.invoke()

// 3. AsyncExecutionInterceptor 拦截调用并提交到线程池
public Object invoke(MethodInvocation invocation) {
    // 判断是否需要异步执行
    Method method = invocation.getMethod();
    if (isAsyncCall(invocation)) {
        // 获取指定的线程池（"threadPool"）
        AsyncTaskExecutor executor = getDefaultExecutor(method);
        
        // 封装为 Callable 并提交
        Callable<Object> task = () -> {
            try {
                return invocation.proceed(); // 实际方法执行
            } catch (Throwable ex) {
                throw new ExecutionException(ex);
            }
        };
        
        // 提交到线程池，立即返回
        executor.submit(task);
        return null;  // 立即返回，不阻塞
    }
    
    return invocation.proceed();
}
```

##### **5. 线程池提交的具体实现**

在 `ThreadPoolTaskExecutor` 中：

```java
// org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor
@Override
public Future<?> submit(Runnable task) {
    // 委托给 JDK 的 ThreadPoolExecutor
    return this.threadPoolExecutor.submit(task);
}

// 实际提交逻辑在 ThreadPoolExecutor 中
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    
    // 将 Runnable 封装为 FutureTask
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    
    // 执行提交 - 这里就是立即返回的关键
    execute(ftask);
    return ftask;
}

public void execute(Runnable command) {
    // 线程池的核心提交逻辑
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;  // 立即返回！
    }
    if (workQueue.offer(command)) {
        // 进入队列，立即返回！
        return;
    }
    // ... 其他逻辑
}
```

#### **实际调试示例**

您可以通过以下方式在 IDE 中调试验证：

##### **1. 设置断点位置：**
- `AsyncExecutionInterceptor.invoke()`
- `ThreadPoolTaskExecutor.submit()`
- `ThreadPoolExecutor.execute()`

##### **2. 调试观察调用栈：**
```
Thread [taskScheduler-1] (调度线程)
    AsyncExecutionInterceptor.invoke() 
    → 提交任务到线程池
    → 立即返回 null
    
Thread [taskExecutor-1] (工作线程)  
    → 实际执行 asyncUpdateOrganizationAndUser() 方法
```

##### **3. 关键验证点：**
1. **调度线程**：看到 `AsyncExecutionInterceptor` 提交任务后立即返回
2. **工作线程**：看到不同的线程执行实际业务逻辑
3. **时间差**：调度触发时间和实际执行时间可能有微小差异

#### **总结**

源码层面的关键证据：

1. **`AsyncExecutionInterceptor.invoke()`**：检测到 `@Async` 注解，拦截方法调用
2. **`doSubmit()`**：将方法调用封装为 `Callable/Runnable`
3. **`executor.submit(task)`**：提交到指定线程池，**该方法立即返回**
4. **调度线程继续执行**：不等待任务完成，可以立即触发下一个定时任务

这就是 `@Async` 实现"立即返回，不阻塞调度线程"的完整源码路径。调度线程只负责触发和提交，实际执行由线程池的工作线程完成，实现了真正的异步执行。
### 64.3.6 识别一个误区：@Async是可以让方法异步执行的注解，与@Scheduled并无关系

**`@Async` 和 `@Scheduled` 确实是两个完全独立的注解**，它们可以单独使用，也可以组合使用。

#### **`@Async` 的独立用途**

`@Async` 的主要作用是将**任何方法调用**改为异步执行，不仅仅限于定时任务：

##### **1. 在 Controller/Service 中的异步调用**
```java
@RestController
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping("/users/batch")
    public String createUsersBatch(@RequestBody List<User> users) {
        // 同步返回响应，后台异步处理
        userService.asyncCreateUsers(users);
        return "批量创建任务已提交，正在后台处理";
    }
}

@Service
public class UserService {
    
    @Async("threadPool")
    public void asyncCreateUsers(List<User> users) {
        // 异步批量创建用户，避免阻塞HTTP请求
        users.forEach(user -> {
            // 耗时操作
            userRepository.save(user);
            sendWelcomeEmail(user); // 发送欢迎邮件
        });
    }
}
```

##### **2. 事件监听器的异步处理**
```java
@Component
public class OrderEventListener {
    
    @Async("threadPool")
    @EventListener
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        // 异步处理订单创建后的后续操作
        inventoryService.updateStock(event.getOrder());
        notificationService.sendOrderConfirm(event.getOrder());
        analyticsService.trackOrderEvent(event.getOrder());
    }
}
```

##### **3. 消息队列消费的异步处理**
```java
@Component
public class MessageConsumer {
    
    @Async("threadPool")
    @RabbitListener(queues = "order.queue")
    public void processOrderMessage(OrderMessage message) {
        // 异步处理消息，提高消费能力
        orderService.processOrder(message);
    }
}
```

---

#### **`@Scheduled` 的独立用途**

同样，`@Scheduled` 也可以单独使用：

##### **1. 简单的定时任务（无需异步）**
```java
@Component
public class CacheScheduler {
    
    @Scheduled(fixedRate = 300000) // 5分钟执行一次
    public void refreshCache() {
        // 快速缓存刷新，不需要异步
        cacheManager.refreshAll();
    }
    
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点
    public void cleanupTempFiles() {
        // 清理临时文件，执行时间短
        fileService.cleanupTempFiles();
    }
}
```

---

#### **`@Async` 和 `@Scheduled` 的关系分析**

##### **它们确实是独立的：**

| 特性 | `@Async` | `@Scheduled` |
|------|----------|--------------|
| **主要功能** | 异步执行 | 定时触发 |
| **适用场景** | 任何方法调用 | 周期性任务 |
| **依赖关系** | 不依赖 `@Scheduled` | 不依赖 `@Async` |
| **组合效果** | 让定时任务异步执行 | 为异步方法提供触发时机 |

##### **组合使用的场景判断：**

```java
// 需要组合使用的情况：
@Async("threadPool")
@Scheduled(cron = "0 0 3 * * ?")
public void dataSyncTask() {
    // 执行时间长（几分钟到几小时）
    // 涉及外部系统调用
    // 资源消耗大
    syncExternalData();
    generateReports();
    backupDatabase();
}

// 不需要组合使用的情况：
@Scheduled(fixedRate = 60000) // 1分钟
public void healthCheck() {
    // 快速健康检查，执行时间短（几秒钟）
    healthService.checkServices();
}
```

---

#### **实际项目中的使用建议**

##### **应该使用 `@Async + @Scheduled` 的场景：**
1. **数据同步任务**：从外部系统同步数据，可能耗时较长
2. **报表生成**：生成复杂的业务报表
3. **批量处理**：处理大量数据的任务
4. **外部API调用**：调用可能响应慢的外部服务

##### **可以单独使用 `@Scheduled` 的场景：**
1. **缓存刷新**：快速的缓存更新操作
2. **状态检查**：服务健康检查
3. **简单清理**：日志文件清理、临时文件删除
4. **监控指标收集**：收集系统指标数据

##### **应该单独使用 `@Async` 的场景：**
1. **Web请求中的耗时操作**：文件上传处理、邮件发送
2. **事件驱动的后台任务**：订单处理后的后续操作
3. **消息队列消费**：提高消息处理吞吐量

---

#### **配置示例：明确的职责分离**

```java
@Configuration
@EnableAsync
@EnableScheduling
public class AsyncSchedulingConfig {
    
    // 专门用于定时任务的线程池
    @Bean("scheduledTaskExecutor")
    public ThreadPoolTaskExecutor scheduledTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("scheduled-task-");
        return executor;
    }
    
    // 专门用于普通异步任务的线程池
    @Bean("commonAsyncExecutor") 
    public ThreadPoolTaskExecutor commonAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-task-");
        return executor;
    }
}

// 定时任务使用专门的线程池
@Async("scheduledTaskExecutor")
@Scheduled(cron = "0 0 3 * * ?")
public void heavyScheduledTask() {
    // 耗时定时任务
}

// 普通异步方法使用通用线程池  
@Async("commonAsyncExecutor")
public void asyncBusinessMethod() {
    // 业务异步方法
}
```
# 六十五、SpringBoot定时任务 - 基础quartz实现方式
> 除了SpringTask，最为常用的Quartz，并且Spring也集成了Quartz的框架。本文主要介绍Quartz和基础的Quartz的集成案例。
## 65.1 准备知识点
### 65.1.1 什么是Quartz
> 官网地址：http://www.quartz-scheduler.org/

Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或 EJBs。

**它的特点如下**

- 纯java实现，可以作为独立的应用程序，也可以嵌入在另一个独立式应用程序运行
- 强大的调度功能，Spring默认的调度框架，灵活可配置；
- 作业持久化，调度环境持久化机制，可以保存并恢复调度现场。系统关闭数据不会丢失；灵活的应用方式，可以任意定义触发器的调度时间表，支持任务和调度各种组合，组件式监听器、各种插件、线程池等功能，多种存储方式等；
- 分布式和集群能力，可以被实例化，一个Quartz集群中的每个节点作为一个独立的Quartz使用，通过相同的数据库表来感知到另一个Quartz应用
### 65.1.2 Quartz的体系结构
![232.springboot-job-quartz-1.png](../../assets/images/04-主流框架/spring/232.springboot-job-quartz-1.png)
- Job 表示一个工作，要执行的具体内容。
- JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。
- Trigger 代表一个调度参数的配置，什么时候去调。
- Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。
## 65.2 实现案例
- 引入POM依赖
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```
- 定义Job

只需要继承QuartzJobBean，并重载executeInternal方法即可定义你自己的Job执行逻辑。
```java
@Slf4j
public class HelloJob extends QuartzJobBean {

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        // get parameters
        context.getJobDetail().getJobDataMap().forEach(
                (k, v) -> log.info("param, key:{}, value:{}", k, v)
        );
        // your logics
        log.info("Hello Job执行时间: " + new Date());
    }
}
```
- 配置Job

JobDetail, Trigger, Schedule(这里采用CronScheduleBuilder)
```java
/**
 * @author pdai
 */
@Configuration
public class QuartzConfig {

    @Bean("helloJob")
    public JobDetail helloJobDetail() {
        return JobBuilder.newJob(HelloJob.class)
                .withIdentity("DateTimeJob")
                .usingJobData("msg", "Hello Quartz")
                .storeDurably()//即使没有Trigger关联时，也不需要删除该JobDetail
                .build();
    }

    @Bean
    public Trigger printTimeJobTrigger() {
        // 每秒执行一次
        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule("0/1 * * * * ?");
        return TriggerBuilder.newTrigger()
                .forJob(helloJobDetail())
                .withIdentity("quartzTaskService")
                .withSchedule(cronScheduleBuilder)
                .build();
    }
}
```
- 执行测试
```sh
2021-10-01 13:09:00.380  INFO 38484 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-10-01 13:09:00.391  INFO 38484 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-10-01 13:09:00.392  INFO 38484 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50]
2021-10-01 13:09:00.526  INFO 38484 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-10-01 13:09:00.526  INFO 38484 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1424 ms
2021-10-01 13:09:00.866  INFO 38484 --- [           main] org.quartz.impl.StdSchedulerFactory      : Using default implementation for ThreadExecutor
2021-10-01 13:09:00.877  INFO 38484 --- [           main] org.quartz.core.SchedulerSignalerImpl    : Initialized Scheduler Signaller of type: class org.quartz.core.SchedulerSignalerImpl
2021-10-01 13:09:00.877  INFO 38484 --- [           main] org.quartz.core.QuartzScheduler          : Quartz Scheduler v.2.3.2 created.
2021-10-01 13:09:00.878  INFO 38484 --- [           main] org.quartz.simpl.RAMJobStore             : RAMJobStore initialized.
2021-10-01 13:09:00.878  INFO 38484 --- [           main] org.quartz.core.QuartzScheduler          : Scheduler meta-data: Quartz Scheduler (v2.3.2) 'quartzScheduler' with instanceId 'NON_CLUSTERED'
  Scheduler class: 'org.quartz.core.QuartzScheduler' - running locally.
  NOT STARTED.
  Currently in standby mode.
  Number of jobs executed: 0
  Using thread pool 'org.quartz.simpl.SimpleThreadPool' - with 10 threads.
  Using job-store 'org.quartz.simpl.RAMJobStore' - which does not support persistence. and is not clustered.

2021-10-01 13:09:00.878  INFO 38484 --- [           main] org.quartz.impl.StdSchedulerFactory      : Quartz scheduler 'quartzScheduler' initialized from an externally provided properties instance.
2021-10-01 13:09:00.879  INFO 38484 --- [           main] org.quartz.impl.StdSchedulerFactory      : Quartz scheduler version: 2.3.2
2021-10-01 13:09:00.879  INFO 38484 --- [           main] org.quartz.core.QuartzScheduler          : JobFactory set to: org.springframework.scheduling.quartz.SpringBeanJobFactory@6075b2d3
2021-10-01 13:09:00.922  INFO 38484 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-10-01 13:09:00.923  INFO 38484 --- [           main] o.s.s.quartz.SchedulerFactoryBean        : Starting Quartz Scheduler now
2021-10-01 13:09:00.923  INFO 38484 --- [           main] org.quartz.core.QuartzScheduler          : Scheduler quartzScheduler_$_NON_CLUSTERED started.
2021-10-01 13:09:00.933  INFO 38484 --- [           main] tech.pdai.springboot.quartz.App          : Started App in 2.64 seconds (JVM running for 3.621)
2021-10-01 13:09:00.931  INFO 38484 --- [eduler_Worker-1] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:00.933  INFO 38484 --- [eduler_Worker-1] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:00 CST 2021
2021-10-01 13:09:01.001  INFO 38484 --- [eduler_Worker-2] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:01.001  INFO 38484 --- [eduler_Worker-2] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:01 CST 2021
2021-10-01 13:09:02.000  INFO 38484 --- [eduler_Worker-3] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:02.000  INFO 38484 --- [eduler_Worker-3] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:02 CST 2021
2021-10-01 13:09:03.000  INFO 38484 --- [eduler_Worker-4] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:03.001  INFO 38484 --- [eduler_Worker-4] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:03 CST 2021
2021-10-01 13:09:04.001  INFO 38484 --- [eduler_Worker-5] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:04.001  INFO 38484 --- [eduler_Worker-5] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:04 CST 2021
2021-10-01 13:09:05.002  INFO 38484 --- [eduler_Worker-6] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:05.003  INFO 38484 --- [eduler_Worker-6] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:05 CST 2021
2021-10-01 13:09:06.000  INFO 38484 --- [eduler_Worker-7] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:06.001  INFO 38484 --- [eduler_Worker-7] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:06 CST 2021
2021-10-01 13:09:07.002  INFO 38484 --- [eduler_Worker-8] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:07.002  INFO 38484 --- [eduler_Worker-8] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:07 CST 2021
2021-10-01 13:09:08.002  INFO 38484 --- [eduler_Worker-9] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:08.003  INFO 38484 --- [eduler_Worker-9] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:08 CST 2021
2021-10-01 13:09:09.000  INFO 38484 --- [duler_Worker-10] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:09.000  INFO 38484 --- [duler_Worker-10] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:09 CST 2021
2021-10-01 13:09:10.001  INFO 38484 --- [eduler_Worker-1] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:10.002  INFO 38484 --- [eduler_Worker-1] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:10 CST 2021
2021-10-01 13:09:11.014  INFO 38484 --- [eduler_Worker-2] t.pdai.springboot.quartz.job.HelloJob    : param, key:msg, value:Hello Quartz
2021-10-01 13:09:11.014  INFO 38484 --- [eduler_Worker-2] t.pdai.springboot.quartz.job.HelloJob    : Hello Job执行时间: Wed Oct 27 13:09:11 CST 2021
```
参考：https://www.cnblogs.com/jijm123/p/14240320.html

# 六十六、SpringBoot定时任务 - 分布式quartz cluster方式

## 66.1 准备知识点

需要理解Quartz的持久化。

## 66.2 什么是Quartz持久化

### 66.2.1 为什么要持久化？

当程序突然被中断时，如断电，内存超出时，很有可能造成任务的丢失。可以将调度信息存储到数据库里面，进行持久化，当程序被中断后，再次启动，仍然会保留中断之前的数据，继续执行，而并不是重新开始。

### 66.2.2 Quartz提供了两种持久化方式

Quartz提供两种基本作业存储类型：

**RAMJobStore**
在默认情况下Quartz将任务调度的运行信息保存在内存中，这种方法提供了最佳的性能，因为内存中数据访问最快。不足之处是缺乏数据的持久性，当程序路途停止或系统崩溃时，所有运行的信息都会丢失。

**JobStoreTX**
所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务。

## 66.3 实现案例

本例将展示quartz实现基于数据库的分布式任务管理，和控制job生命周期。

整体项目结构如下：

```
项目结构
├── src
│   ├── main
│   │   ├── java
│   │   │   └── tech
│   │   │       └── pdai
│   │   │           └── springboot
│   │   │               └── quartz
│   │   │                   └── cluster
│   │   │                       ├── controller
│   │   │                       ├── entity
│   │   │                       ├── job
│   │   │                       └── manager
│   │   └── resources
│   │       └── application.yml
│   └── test
└── pom.xml
```

## 66.4 后端实现

### 66.4.1 pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <groupId>tech.pdai</groupId>
    <artifactId>423-springboot-demo-schedule-quartz-cluster</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.42</version><!--$NO-MVN-MAN-VER$-->
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper</artifactId>
            <version>5.0.0</version>
        </dependency>
    </dependencies>
</project>
```

### 66.4.2 创建Schema

需要提前在MySQL中创建schema: quartz_jobs

```sql
-- DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;
-- DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;
-- DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;
-- DROP TABLE IF EXISTS QRTZ_LOCKS;
-- DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;
-- DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;
-- DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;
-- DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;
-- DROP TABLE IF EXISTS QRTZ_TRIGGERS;
-- DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;
-- DROP TABLE IF EXISTS QRTZ_CALENDARS;
-- DROP TABLE IF EXISTS QRTZ_TASK_HISTORY;

CREATE TABLE QRTZ_JOB_DETAILS(
  SCHED_NAME VARCHAR(120) NOT NULL,
  JOB_NAME VARCHAR(200) NOT NULL,
  JOB_GROUP VARCHAR(200) NOT NULL,
  DESCRIPTION VARCHAR(250) NULL,
  JOB_CLASS_NAME VARCHAR(250) NOT NULL,
  IS_DURABLE VARCHAR(1) NOT NULL,
  IS_NONCONCURRENT VARCHAR(1) NOT NULL,
  IS_UPDATE_DATA VARCHAR(1) NOT NULL,
  REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
  JOB_DATA BLOB NULL,
  PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_TRIGGERS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  JOB_NAME VARCHAR(200) NOT NULL,
  JOB_GROUP VARCHAR(200) NOT NULL,
  DESCRIPTION VARCHAR(250) NULL,
  NEXT_FIRE_TIME BIGINT(13) NULL,
  PREV_FIRE_TIME BIGINT(13) NULL,
  PRIORITY INTEGER NULL,
  TRIGGER_STATE VARCHAR(16) NOT NULL,
  TRIGGER_TYPE VARCHAR(8) NOT NULL,
  START_TIME BIGINT(13) NOT NULL,
  END_TIME BIGINT(13) NULL,
  CALENDAR_NAME VARCHAR(200) NULL,
  MISFIRE_INSTR SMALLINT(2) NULL,
  JOB_DATA BLOB NULL,
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
  REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_SIMPLE_TRIGGERS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  REPEAT_COUNT BIGINT(7) NOT NULL,
  REPEAT_INTERVAL BIGINT(12) NOT NULL,
  TIMES_TRIGGERED BIGINT(10) NOT NULL,
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_CRON_TRIGGERS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  CRON_EXPRESSION VARCHAR(120) NOT NULL,
  TIME_ZONE_ID VARCHAR(80),
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_SIMPROP_TRIGGERS
(
  SCHED_NAME VARCHAR(120) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  STR_PROP_1 VARCHAR(512) NULL,
  STR_PROP_2 VARCHAR(512) NULL,
  STR_PROP_3 VARCHAR(512) NULL,
  INT_PROP_1 INT NULL,
  INT_PROP_2 INT NULL,
  LONG_PROP_1 BIGINT NULL,
  LONG_PROP_2 BIGINT NULL,
  DEC_PROP_1 NUMERIC(13,4) NULL,
  DEC_PROP_2 NUMERIC(13,4) NULL,
  BOOL_PROP_1 VARCHAR(1) NULL,
  BOOL_PROP_2 VARCHAR(1) NULL,
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_BLOB_TRIGGERS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  BLOB_DATA BLOB NULL,
  PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
  INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_CALENDARS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  CALENDAR_NAME VARCHAR(200) NOT NULL,
  CALENDAR BLOB NOT NULL,
  PRIMARY KEY (SCHED_NAME,CALENDAR_NAME))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_FIRED_TRIGGERS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  ENTRY_ID VARCHAR(95) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  INSTANCE_NAME VARCHAR(200) NOT NULL,
  FIRED_TIME BIGINT(13) NOT NULL,
  SCHED_TIME BIGINT(13) NOT NULL,
  PRIORITY INTEGER NOT NULL,
  STATE VARCHAR(16) NOT NULL,
  JOB_NAME VARCHAR(200) NULL,
  JOB_GROUP VARCHAR(200) NULL,
  IS_NONCONCURRENT VARCHAR(1) NULL,
  REQUESTS_RECOVERY VARCHAR(1) NULL,
  PRIMARY KEY (SCHED_NAME,ENTRY_ID))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_SCHEDULER_STATE (
  SCHED_NAME VARCHAR(120) NOT NULL,
  INSTANCE_NAME VARCHAR(200) NOT NULL,
  LAST_CHECKIN_TIME BIGINT(13) NOT NULL,
  CHECKIN_INTERVAL BIGINT(13) NOT NULL,
  PRIMARY KEY (SCHED_NAME,INSTANCE_NAME))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_LOCKS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  LOCK_NAME VARCHAR(40) NOT NULL,
  PRIMARY KEY (SCHED_NAME,LOCK_NAME))
  ENGINE=InnoDB;

CREATE TABLE QRTZ_TASK_HISTORY (
  SCHED_NAME VARCHAR(120) NOT NULL,
  INSTANCE_ID VARCHAR(200) NOT NULL,
  FIRE_ID VARCHAR(95) NOT NULL,
  TASK_NAME VARCHAR(200) NULL,
  TASK_GROUP VARCHAR(200) NULL,
  FIRED_TIME BIGINT(13) NULL,
  FIRED_WAY VARCHAR(8) NULL,
  COMPLETE_TIME BIGINT(13) NULL,
  EXPEND_TIME BIGINT(13) NULL,
  REFIRED INT NULL,
  EXEC_STATE VARCHAR(10) NULL,
  LOG TEXT NULL,
  PRIMARY KEY (FIRE_ID)
)ENGINE=InnoDB;

CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);
CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);

CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);
CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);
CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);

CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);
CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);
CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);
CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);
CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);

CREATE INDEX IDX_QRTZ_TK_S ON QRTZ_TASK_HISTORY(SCHED_NAME);

commit;
```

### 66.4.3 application.yml

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/quartz_jobs?useUnicode=true&useSSL=false
    username: root
    password: xxxxxxxx
    driver-class-name: com.mysql.jdbc.Driver
  quartz:
    #相关属性配置
    properties:
      org:
        quartz:
          scheduler:
            instanceName: clusteredScheduler
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_
            isClustered: true
            clusterCheckinInterval: 10000
            useProperties: false
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 10
            threadPriority: 5
            threadsInheritContextClassLoaderOfInitializingThread: true
    #数据库方式
    job-store-type: jdbc
```

### 66.4.4 定义JobDetails实体

```java
@Data
public class JobDetails{
    private String cronExpression;	
    private String jobClassName;	
    private String triggerGroupName;
    private String triggerName;
    private String jobGroupName;
    private String jobName;
    private Date nextFireTime;
    private Date previousFireTime;
    private Date startTime;
    private String timeZone;
    private String status;
}
```

### 66.4.5 Job管理类

```java
package tech.pdai.springboot.quartz.cluster.manager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import org.quartz.CronScheduleBuilder;
import org.quartz.CronTrigger;
import org.quartz.DateBuilder;
import org.quartz.DateBuilder.IntervalUnit;
import org.quartz.Job;
import org.quartz.JobBuilder;
import org.quartz.JobDetail;
import org.quartz.JobExecutionContext;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SimpleScheduleBuilder;
import org.quartz.Trigger;
import org.quartz.TriggerBuilder;
import org.quartz.TriggerKey;
import org.quartz.impl.matchers.GroupMatcher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.quartz.QuartzJobBean;
import org.springframework.stereotype.Component;
import tech.pdai.springboot.quartz.cluster.entity.JobDetails;

@Component
public class QuartzManager {

    @Autowired
    private Scheduler sched;

    /**
     * 创建or更新任务，存在则更新不存在创建
     *
     * @param jobClass     任务类
     * @param jobName      任务名称
     * @param jobGroupName 任务组名称
     * @param jobCron      cron表达式
     */
    public void addOrUpdateJob(Class<? extends QuartzJobBean> jobClass, String jobName, String jobGroupName, String jobCron) {
        try {
            TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupName);
            CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey);
            if (trigger==null) {
                addJob(jobClass, jobName, jobGroupName, jobCron);
            } else {
                if (trigger.getCronExpression().equals(jobCron)) {
                    return;
                }
                updateJob(jobName, jobGroupName, jobCron);
            }
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    /**
     * 增加一个job
     *
     * @param jobClass     任务实现类
     * @param jobName      任务名称
     * @param jobGroupName 任务组名
     * @param jobCron      cron表达式(如：0/5 * * * * ? )
     */
    public void addJob(Class<? extends QuartzJobBean> jobClass, String jobName, String jobGroupName, String jobCron) {
        try {
            JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobName, jobGroupName).build();
            Trigger trigger = TriggerBuilder.newTrigger().withIdentity(jobName, jobGroupName)
                    .startAt(DateBuilder.futureDate(1, IntervalUnit.SECOND))
                    .withSchedule(CronScheduleBuilder.cronSchedule(jobCron)).startNow().build();

            sched.scheduleJob(jobDetail, trigger);
            if (!sched.isShutdown()) {
                sched.start();
            }
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    /**
     * @param jobClass
     * @param jobName
     * @param jobGroupName
     * @param jobTime
     */
    public void addJob(Class<? extends Job> jobClass, String jobName, String jobGroupName, int jobTime) {
        addJob(jobClass, jobName, jobGroupName, jobTime, -1);
    }

    public void addJob(Class<? extends Job> jobClass, String jobName, String jobGroupName, int jobTime, int jobTimes) {
        try {
            JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobName, jobGroupName)// 任务名称和组构成任务key
                    .build();
            // 使用simpleTrigger规则
            Trigger trigger;
            if (jobTimes < 0) {
                trigger = TriggerBuilder.newTrigger().withIdentity(jobName, jobGroupName)
                        .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(1).withIntervalInSeconds(jobTime))
                        .startNow().build();
            } else {
                trigger = TriggerBuilder
                        .newTrigger().withIdentity(jobName, jobGroupName).withSchedule(SimpleScheduleBuilder
                                .repeatSecondlyForever(1).withIntervalInSeconds(jobTime).withRepeatCount(jobTimes))
                        .startNow().build();
            }
            sched.scheduleJob(jobDetail, trigger);
            if (!sched.isShutdown()) {
                sched.start();
            }
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    public void updateJob(String jobName, String jobGroupName, String jobTime) {
        try {
            TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupName);
            CronTrigger trigger = (CronTrigger) sched.getTrigger(triggerKey);
            trigger = trigger.getTriggerBuilder().withIdentity(triggerKey)
                    .withSchedule(CronScheduleBuilder.cronSchedule(jobTime)).build();
            // 重启触发器
            sched.rescheduleJob(triggerKey, trigger);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    /**
     * 删除任务一个job
     *
     * @param jobName      任务名称
     * @param jobGroupName 任务组名
     */
    public void deleteJob(String jobName, String jobGroupName) {
        try {
            sched.pauseTrigger(TriggerKey.triggerKey(jobName, jobGroupName));
            sched.unscheduleJob(TriggerKey.triggerKey(jobName, jobGroupName));
            sched.deleteJob(new JobKey(jobName, jobGroupName));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 暂停一个job
     *
     * @param jobName
     * @param jobGroupName
     */
    public void pauseJob(String jobName, String jobGroupName) {
        try {
            JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);
            sched.pauseJob(jobKey);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    /**
     * 恢复一个job
     *
     * @param jobName
     * @param jobGroupName
     */
    public void resumeJob(String jobName, String jobGroupName) {
        try {
            JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);
            sched.resumeJob(jobKey);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    /**
     * 立即执行一个job
     *
     * @param jobName
     * @param jobGroupName
     */
    public void runAJobNow(String jobName, String jobGroupName) {
        try {
            JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);
            sched.triggerJob(jobKey);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }

    public PageInfo<JobDetails> queryAllJobBean(int pageNum, int pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<JobDetails> jobList = null;
        try {
            GroupMatcher<JobKey> matcher = GroupMatcher.anyJobGroup();
            Set<JobKey> jobKeys = sched.getJobKeys(matcher);
            jobList = new ArrayList<>();
            for (JobKey jobKey : jobKeys) {
                List<? extends Trigger> triggers = sched.getTriggersOfJob(jobKey);
                for (Trigger trigger : triggers) {
                    JobDetails jobDetails = new JobDetails();
                    if (trigger instanceof CronTrigger) {
                        CronTrigger cronTrigger = (CronTrigger) trigger;
                        jobDetails.setCronExpression(cronTrigger.getCronExpression());
                        jobDetails.setTimeZone(cronTrigger.getTimeZone().getDisplayName());
                    }
                    jobDetails.setTriggerGroupName(trigger.getKey().getName());
                    jobDetails.setTriggerName(trigger.getKey().getGroup());
                    jobDetails.setJobGroupName(jobKey.getGroup());
                    jobDetails.setJobName(jobKey.getName());
                    jobDetails.setStartTime(trigger.getStartTime());
                    jobDetails.setJobClassName(sched.getJobDetail(jobKey).getJobClass().getName());
                    jobDetails.setNextFireTime(trigger.getNextFireTime());
                    jobDetails.setPreviousFireTime(trigger.getPreviousFireTime());
                    jobDetails.setStatus(sched.getTriggerState(trigger.getKey()).name());
                    jobList.add(jobDetails);
                }
            }
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
        return new PageInfo<>(jobList);
    }

    /**
     * 获取所有计划中的任务列表
     *
     * @return
     */
    public List<Map<String, Object>> queryAllJob() {
        List<Map<String, Object>> jobList = null;
        try {
            GroupMatcher<JobKey> matcher = GroupMatcher.anyJobGroup();
            Set<JobKey> jobKeys = sched.getJobKeys(matcher);
            jobList = new ArrayList<>();
            for (JobKey jobKey : jobKeys) {
                List<? extends Trigger> triggers = sched.getTriggersOfJob(jobKey);
                for (Trigger trigger : triggers) {
                    Map<String, Object> map = new HashMap<>();
                    map.put("jobName", jobKey.getName());
                    map.put("jobGroupName", jobKey.getGroup());
                    map.put("description", "trigger:" + trigger.getKey());
                    Trigger.TriggerState triggerState = sched.getTriggerState(trigger.getKey());
                    map.put("jobStatus", triggerState.name());
                    if (trigger instanceof CronTrigger) {
                        CronTrigger cronTrigger = (CronTrigger) trigger;
                        String cronExpression = cronTrigger.getCronExpression();
                        map.put("jobTime", cronExpression);
                    }
                    jobList.add(map);
                }
            }
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
        return jobList;
    }

    /**
     * 获取所有正在运行的job
     *
     * @return
     */
    public List<Map<String, Object>> queryRunJon() {
        List<Map<String, Object>> jobList = null;
        try {
            List<JobExecutionContext> executingJobs = sched.getCurrentlyExecutingJobs();
            jobList = new ArrayList<>(executingJobs.size());
            for (JobExecutionContext executingJob : executingJobs) {
                Map<String, Object> map = new HashMap<>();
                JobDetail jobDetail = executingJob.getJobDetail();
                JobKey jobKey = jobDetail.getKey();
                Trigger trigger = executingJob.getTrigger();
                map.put("jobName", jobKey.getName());
                map.put("jobGroupName", jobKey.getGroup());
                map.put("description", "trigger:" + trigger.getKey());
                Trigger.TriggerState triggerState = sched.getTriggerState(trigger.getKey());
                map.put("jobStatus", triggerState.name());
                if (trigger instanceof CronTrigger) {
                    CronTrigger cronTrigger = (CronTrigger) trigger;
                    String cronExpression = cronTrigger.getCronExpression();
                    map.put("jobTime", cronExpression);
                }
                jobList.add(map);
            }
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
        return jobList;
    }
}
```

### 66.4.6 Job控制器接口

```java
package tech.pdai.springboot.quartz.cluster.controller;

import java.util.HashMap;
import java.util.Map;

import com.github.pagehelper.PageInfo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.quartz.QuartzJobBean;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.quartz.cluster.entity.JobDetails;
import tech.pdai.springboot.quartz.cluster.manager.QuartzManager;

@RestController
@RequestMapping(value = "/job")
public class JobController {

    @Autowired
    private QuartzManager qtzManager;

    @SuppressWarnings("unchecked")
    private static Class<? extends QuartzJobBean> getClass(String classname) throws Exception {
        Class<?> class1 = Class.forName(classname);
        return (Class<? extends QuartzJobBean>) class1;
    }

    /**
     * @param jobClassName
     * @param jobGroupName
     * @param cronExpression
     * @throws Exception
     */
    @PostMapping(value = "/addjob")
    public void addjob(@RequestParam(value = "jobClassName") String jobClassName,
                       @RequestParam(value = "jobGroupName") String jobGroupName,
                       @RequestParam(value = "cronExpression") String cronExpression) throws Exception {
        qtzManager.addOrUpdateJob(getClass(jobClassName), jobClassName, jobGroupName, cronExpression);
    }

    /**
     * @param jobClassName
     * @param jobGroupName
     * @throws Exception
     */
    @PostMapping(value = "/pausejob")
    public void pausejob(@RequestParam(value = "jobClassName") String jobClassName,
                         @RequestParam(value = "jobGroupName") String jobGroupName) throws Exception {
        qtzManager.pauseJob(jobClassName, jobGroupName);
    }

    /**
     * @param jobClassName
     * @param jobGroupName
     * @throws Exception
     */
    @PostMapping(value = "/resumejob")
    public void resumejob(@RequestParam(value = "jobClassName") String jobClassName,
                          @RequestParam(value = "jobGroupName") String jobGroupName) throws Exception {
        qtzManager.resumeJob(jobClassName, jobGroupName);
    }

    /**
     * @param jobClassName
     * @param jobGroupName
     * @param cronExpression
     * @throws Exception
     */
    @PostMapping(value = "/reschedulejob")
    public void rescheduleJob(@RequestParam(value = "jobClassName") String jobClassName,
                              @RequestParam(value = "jobGroupName") String jobGroupName,
                              @RequestParam(value = "cronExpression") String cronExpression) throws Exception {
        qtzManager.addOrUpdateJob(getClass(jobClassName), jobClassName, jobGroupName, cronExpression);
    }

    /**
     * @param jobClassName
     * @param jobGroupName
     * @throws Exception
     */
    @PostMapping(value = "/deletejob")
    public void deletejob(@RequestParam(value = "jobClassName") String jobClassName,
                          @RequestParam(value = "jobGroupName") String jobGroupName) throws Exception {
        qtzManager.deleteJob(jobClassName, jobGroupName);
    }

    /**
     * @param pageNum
     * @param pageSize
     * @return
     */
    @GetMapping(value = "/queryjob")
    public Map<String, Object> queryjob(@RequestParam(value = "pageNum") Integer pageNum,
                                        @RequestParam(value = "pageSize") Integer pageSize) {
        PageInfo<JobDetails> jobAndTrigger = qtzManager.queryAllJobBean(pageNum, pageSize);
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("JobAndTrigger", jobAndTrigger);
        map.put("number", jobAndTrigger.getTotal());
        return map;
    }
}
```

### 66.4.7 定义具体的Job

```java
package tech.pdai.springboot.quartz.cluster.job;

import java.util.Date;

import lombok.extern.slf4j.Slf4j;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.scheduling.quartz.QuartzJobBean;

@Slf4j
public class HelloJob extends QuartzJobBean {

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        // get parameters
        context.getJobDetail().getJobDataMap().forEach(
                (k, v) -> log.info("param, key:{}, value:{}", k, v)
        );
        // your logics
        log.info("Hello Job执行时间: " + new Date());
    }
}
```

## 66.5 前端实现

简单用VueJS 写个页面测试

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
    <title>QuartzDemo</title>
    <link rel="stylesheet" href="https://unpkg.com/element-ui@2.0.5/lib/theme-chalk/index.css">
    <script src="https://unpkg.com/vue/dist/vue.js"></script>
    <script src="http://cdn.bootcss.com/vue-resource/1.3.4/vue-resource.js"></script>
    <script src="https://unpkg.com/element-ui@2.0.5/lib/index.js"></script>
    
    <style>      
      #top {
          background:#20A0FF;
          padding:5px;
          overflow:hidden
      }
    </style>
    
</head>
<body>
    <div id="test">		        

        <div id="top">			
                <el-button type="text" @click="search" style="color:white">查询</el-button>	
                <el-button type="text" @click="handleadd" style="color:white">添加</el-button>	
            </span>						
        </div>	
                
        <br/>

        <div style="margin-top:15px">	

          <el-table
            ref="testTable"		  
            :data="tableData"
            style="width:100%"
            border
            >
            <el-table-column
              prop="status"
              label="任务状态"
              sortable
              show-overflow-tooltip>
            </el-table-column>
            
            <el-table-column
              prop="jobName"
              label="任务名称"
              sortable
              show-overflow-tooltip>
            </el-table-column>
            
            <el-table-column
              prop="jobGroupName"
              label="任务所在组"
              sortable>
            </el-table-column>
            
               <el-table-column
              prop="jobClassName"
              label="任务类名"
              sortable>
            </el-table-column>
            
               <el-table-column
              prop="triggerName"
              label="触发器名称"
              sortable>
            </el-table-column>
            
            <el-table-column
              prop="triggerGroupName"
              label="触发器所在组"
              sortable>
            </el-table-column>
            
            <el-table-column
              prop="cronExpression"
              label="表达式"
              sortable>
            </el-table-column>
            
            <el-table-column
              prop="timeZone"
              label="时区"
              sortable>
            </el-table-column>
            
            <el-table-column label="操作" width="300">
              <template scope="scope">
                  <el-button
                  size="small"
                  type="warning"
                  @click="handlePause(scope.$index, scope.row)">暂停</el-button>
                  
                <el-button
                  size="small"
                  type="info"
                  @click="handleResume(scope.$index, scope.row)">恢复</el-button>
                  
                <el-button
                  size="small"
                  type="danger"
                  @click="handleDelete(scope.$index, scope.row)">删除</el-button>
                  
                <el-button
                  size="small"
                  type="success"
                  @click="handleUpdate(scope.$index, scope.row)">修改</el-button>
              </template>
            </el-table-column>
          </el-table>
          
          <div align="center">
              <el-pagination
                  @size-change="handleSizeChange"
                  @current-change="handleCurrentChange"
                  :current-page="currentPage"
                  :page-sizes="[10, 20, 30, 40]"
                  :page-size="pagesize"
                  layout="total, sizes, prev, pager, next, jumper"
                  :total="totalCount">
              </el-pagination>
          </div>
        </div> 
        
        <el-dialog title="添加任务" :visible.sync="dialogFormVisible">
          <el-form :model="form">
            <el-form-item label="任务名称" label-width="120px" style="width:35%">
              <el-input v-model="form.jobName" auto-complete="off"></el-input>
            </el-form-item>	    
            <el-form-item label="任务分组" label-width="120px" style="width:35%">
              <el-input v-model="form.jobGroup" auto-complete="off"></el-input>
            </el-form-item>
            <el-form-item label="表达式" label-width="120px" style="width:35%">
              <el-input v-model="form.cronExpression" auto-complete="off"></el-input>
            </el-form-item>
          </el-form>
          <div slot="footer" class="dialog-footer">
            <el-button @click="dialogFormVisible = false">取 消</el-button>
            <el-button type="primary" @click="add">确 定</el-button>
          </div>
        </el-dialog>
        
        <el-dialog title="修改任务" :visible.sync="updateFormVisible">
          <el-form :model="updateform">
            <el-form-item label="表达式" label-width="120px" style="width:35%">
              <el-input v-model="updateform.cronExpression" auto-complete="off"></el-input>
            </el-form-item>
          </el-form>
          <div slot="footer" class="dialog-footer">
            <el-button @click="updateFormVisible = false">取 消</el-button>
            <el-button type="primary" @click="update">确 定</el-button>
          </div>
        </el-dialog>
        
    </div>
    
    <footer align="center">
        <p>&copy; Quartz 任务管理</p>
    </footer>

    <script>
    var vue = new Vue({			
            el:"#test",
            data: {		  
                //表格当前页数据
                tableData: [],
                
                //请求的URL
                url:'job/queryjob',
                
                //默认每页数据量
                pagesize: 10,		        
                
                //当前页码
                currentPage: 1,
                
                //查询的页码
                start: 1,
                
                //默认数据总数
                totalCount: 1000,
                
                //添加对话框默认可见性
                dialogFormVisible: false,
                
                //修改对话框默认可见性
                updateFormVisible: false,
                
                //提交的表单
                form: {
                    jobName: '',
                    jobGroup: '',
                    cronExpression: '',
                  },
                  
                updateform: {
                    jobName: '',
                    jobGroup: '',
                    cronExpression: '',
                },
            },

            methods: {
                
                //从服务器读取数据
                loadData: function(pageNum, pageSize){					
                    this.$http.get('job/queryjob?' + 'pageNum=' +  pageNum + '&pageSize=' + pageSize).then(function(res){
                        console.log(res)
                        this.tableData = res.body.JobAndTrigger.list;
                        this.totalCount = res.body.number;
                    },function(){
                          console.log('failed');
                    });					
                },			    		        
                      
                //单行删除
                handleDelete: function(index, row) {
                    this.$http.post('job/deletejob',{"jobClassName":row.jobName,"jobGroupName":row.jobGroupName},{emulateJSON: true}).then(function(res){
                        this.loadData( this.currentPage, this.pagesize);
                    },function(){
                        console.log('failed');
                    });
                },
                
                //暂停任务
                handlePause: function(index, row){
                    this.$http.post('job/pausejob',{"jobClassName":row.jobName,"jobGroupName":row.jobGroupName},{emulateJSON: true}).then(function(res){
                        this.loadData( this.currentPage, this.pagesize);
                    },function(){
                        console.log('failed');
                    });
                },
                
                //恢复任务
                handleResume: function(index, row){
                    this.$http.post('job/resumejob',{"jobClassName":row.jobName,"jobGroupName":row.jobGroupName},{emulateJSON: true}).then(function(res){
                        this.loadData( this.currentPage, this.pagesize);
                    },function(){
                        console.log('failed');
                    });
                },
                
                //搜索
                search: function(){
                    this.loadData(this.currentPage, this.pagesize);
                },
                
                //弹出对话框
                handleadd: function(){		                
                    this.dialogFormVisible = true;	              
                },
                
                //添加
                add: function(){
                    this.$http.post('job/addjob',{"jobClassName":this.form.jobName,"jobGroupName":this.form.jobGroup,"cronExpression":this.form.cronExpression},{emulateJSON: true}).then(function(res){
                        this.loadData(this.currentPage, this.pagesize);
                        this.dialogFormVisible = false;
                    },function(){
                        console.log('failed');
                    });
                },
                
                //更新
                handleUpdate: function(index, row){
                    console.log(row)
                    this.updateFormVisible = true;
                    this.updateform.jobName = row.jobClassName;
                    this.updateform.jobGroup = row.jobGroupName;
                },
                
                //更新任务
                update: function(){
                    this.$http.post
                    ('job/reschedulejob',
                            {"jobClassName":this.updateform.jobName,
                             "jobGroupName":this.updateform.jobGroup,
                             "cronExpression":this.updateform.cronExpression
                             },{emulateJSON: true}
                    ).then(function(res){
                        this.loadData(this.currentPage, this.pagesize);
                        this.updateFormVisible = false;
                    },function(){
                        console.log('failed');
                    });
            
                },
              
                //每页显示数据量变更
                handleSizeChange: function(val) {
                    this.pagesize = val;
                    this.loadData(this.currentPage, this.pagesize);
                },
                
                //页码变更
                handleCurrentChange: function(val) {
                    this.currentPage = val;
                    this.loadData(this.currentPage, this.pagesize);
                },	      
                        
            },	    
            
            
          });
    
          //载入数据
          vue.loadData(vue.currentPage, vue.pagesize);
    </script>  
    
</body>
</html>
```

## 66.6 测试效果

(PS: 这里的任务名称需要改成你自己的完整类名称)

展示正在运行的Jobs:
![233.springboot-data-quartz-1.png](../../assets/images/04-主流框架/spring/233.springboot-data-quartz-1.png)

增加新的Job:
![234.springboot-data-quartz-2.png](../../assets/images/04-主流框架/spring/234.springboot-data-quartz-2.png)

Jobs持久化在数据库:
![235.springboot-data-quartz-3.png](../../assets/images/04-主流框架/spring/235.springboot-data-quartz-3.png)
## 66.7 解读
### 66.7.1. 任务定义方式 ✅

**是的，您需要继承 `QuartzJobBean`：**

```java
@Component
public class MyScheduledJob extends QuartzJobBean {
    
    @Autowired
    private SomeService someService;  // 可以注入Spring Bean
    
    @Override
    protected void executeInternal(JobExecutionContext context) {
        // 您的业务逻辑
        someService.processData();
        log.info("任务执行时间: " + new Date());
    }
}
```

**QuartzJobBean 的优势：**
- ✅ 支持 Spring Bean 注入
- ✅ Spring 对 Quartz Job 的封装
- ✅ 更好的异常处理机制

### 66.7.2. 动态任务管理 ✅

**是的，可以通过接口动态管理任务：**

```java
@RestController
@RequestMapping("/api/jobs")
public class JobController {
    
    @Autowired
    private QuartzManager quartzManager;
    
    // 添加任务
    @PostMapping("/add")
    public void addJob(@RequestParam String jobName, 
                      @RequestParam String jobGroup,
                      @RequestParam String cronExpression) {
        quartzManager.addJob(MyScheduledJob.class, jobName, jobGroup, cronExpression);
    }
    
    // 暂停任务
    @PostMapping("/pause")
    public void pauseJob(@RequestParam String jobName, 
                        @RequestParam String jobGroup) {
        quartzManager.pauseJob(jobName, jobGroup);
    }
    
    // 删除任务
    @PostMapping("/delete")
    public void deleteJob(@RequestParam String jobName, 
                         @RequestParam String jobGroup) {
        quartzManager.deleteJob(jobName, jobGroup);
    }
}
```

### 66.7.3. 数据库格式问题 ✅

**是的，Quartz 的数据库表结构是固定的！**

#### 66.7.3.1 核心表说明：

| 表名 | 用途 |
|------|------|
| `QRTZ_JOB_DETAILS` | 存储 Job 详细信息 |
| `QRTZ_TRIGGERS` | 存储触发器信息 |
| `QRTZ_CRON_TRIGGERS` | 存储 Cron 表达式 |
| `QRTZ_FIRED_TRIGGERS` | 存储正在执行的任务 |
| `QRTZ_SCHEDULER_STATE` | 存储调度器节点状态（集群关键） |

#### 66.7.3.2 为什么格式固定？

1. **Quartz 标准规范**：这些表是 Quartz 框架设计的一部分
2. **SQL 操作依赖**：Quartz 通过固定的 SQL 语句操作这些表
3. **集群协调**：多节点通过数据库表进行任务协调和锁管理
4. **数据一致性**：确保不同节点读取的数据格式一致

#### 66.7.3.3 必须的表（最小集）：
```sql
-- 必须创建的核心表
QRTZ_JOB_DETAILS
QRTZ_TRIGGERS  
QRTZ_CRON_TRIGGERS
QRTZ_FIRED_TRIGGERS
QRTZ_SCHEDULER_STATE
QRTZ_LOCKS
```

### 66.7.4. 完整工作流程

#### 66.7.4.1 定义任务类：
```java
public class DataSyncJob extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext context) {
        // 您的业务代码
        log.info("执行数据同步任务");
    }
}
```

#### 66.7.4.2 通过 API 动态创建任务：
```http
POST /api/jobs/add
Content-Type: application/x-www-form-urlencoded

jobName=dataSyncJob
jobGroup=systemJobs
cronExpression=0 0/5 * * * ?
```

#### 66.7.4.3 数据库中的效果：
- `QRTZ_JOB_DETAILS` 表会插入一条记录
- `QRTZ_TRIGGERS` 表会插入触发器记录
- 任务会按照 Cron 表达式定时执行

### 66.7.5. 集群配置关键点

**application.yml 配置：**
```yaml
spring:
  quartz:
    properties:
      org:
        quartz:
          scheduler:
            instanceName: clusteredScheduler
            instanceId: AUTO  # 自动生成实例ID
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            isClustered: true  # 开启集群
            clusterCheckinInterval: 10000  # 集群检查间隔
```

### 66.7.6 总结

- 任务类需要继承 `QuartzJobBean`
- 可以通过 REST API 动态管理任务生命周期
- Quartz 数据库表结构是固定的，必须按规范创建
# 六十七、SpringBoot定时任务 - 分布式elastic-job方式
> 前文展示quartz实现基于数据库的分布式任务管理和job生命周期的控制，那在分布式场景下如何解决弹性调度、资源管控、以及作业治理等呢？针对这些功能前当当团队开发了ElasticJob，2020 年 5 月 28 日ElasticJob成为 Apache ShardingSphere 的子项目；本文介绍ElasticJob以及SpringBoot的集成
## 67.1 知识准备
### 67.1.1 什么是ElasticJob
> ElasticJob 是面向互联网生态和海量任务的分布式调度解决方案，由两个相互独立的子项目 ElasticJob-Lite 和 ElasticJob-Cloud 组成。 它通过弹性调度、资源管控、以及作业治理的功能，打造一个适用于互联网场景的分布式调度解决方案，并通过开放的架构设计，提供多元化的作业生态。 它的各个产品使用统一的作业 API，开发者仅需一次开发，即可随意部署。ElasticJob 已于 2020 年 5 月 28 日成为 Apache ShardingSphere 的子项目。

使用 ElasticJob 能够让开发工程师不再担心任务的线性吞吐量提升等非功能需求，使他们能够更加专注于面向业务编码设计； 同时，它也能够解放运维工程师，使他们不必再担心任务的可用性和相关管理需求，只通过轻松的增加服务节点即可达到自动化运维的目的。
- ElasticJob-Lite: 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务。
![236.springboot-elasticjob-lite-1.png](../../assets/images/04-主流框架/spring/236.springboot-elasticjob-lite-1.png)
- ElasticJob-Cloud： 采用自研 Mesos Framework 的解决方案，额外提供资源治理、应用分发以及进程隔离等功能。
![237.springboot-elasticjob-cloud-1.png](../../assets/images/04-主流框架/spring/237.springboot-elasticjob-cloud-1.png)
- ElasticJob-Lite和ElasticJob-Cloud的区别

| 特性       | ElasticJob-Lite | ElasticJob-Cloud   |
|------------|----------------|-------------------|
| 无中心化   | 是             | 否                |
| 资源分配   | 不支持         | 支持              |
| 作业模式   | 常驻           | 常驻 + 瞬时       |
| 部署依赖   | ZooKeeper      | ZooKeeper + Mesos |
## 67.2 实现案例

> 本例将展示ElasticJob-Lite集成Springboot的案例，案例参考自ElasticJob的官网，同时做了一些调整和issue修复。

### 67.2.1 POM依赖

ElaticJob针对SpringBoot集成的starter依赖，针对错误通知的依赖elasticjob-error-handler-xxx（如果需要的话）。对任务的记录和追踪是存放在DB的，所以需要配置JPA和MySQL/H2等。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<dependency>
    <groupId>org.apache.shardingsphere.elasticjob</groupId>
    <artifactId>elasticjob-lite-spring-boot-starter</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>org.apache.shardingsphere.elasticjob</groupId>
    <artifactId>elasticjob-error-handler-dingtalk</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>org.apache.shardingsphere.elasticjob</groupId>
    <artifactId>elasticjob-error-handler-wechat</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>org.apache.shardingsphere.elasticjob</groupId>
    <artifactId>elasticjob-error-handler-email</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-test</artifactId>
    <version>5.2.0</version>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.42</version><!--$NO-MVN-MAN-VER$-->
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

### 67.2.2 基础Entity和Dao

#### Foo Entity
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.entity;

import java.io.Serializable;

public final class Foo implements Serializable {

    private static final long serialVersionUID = 2706842871078949451L;

    private final long id;

    private final String location;

    private Status status;

    public Foo(final long id, final String location, final Status status) {
        this.id = id;
        this.location = location;
        this.status = status;
    }

    public long getId() {
        return id;
    }

    public String getLocation() {
        return location;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(final Status status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("id: %s, location: %s, status: %s", id, location, status);
    }

    public enum Status {
        TODO,
        COMPLETED
    }
}
```

#### FooRepository Dao
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.repository;

import org.springframework.stereotype.Repository;
import tech.pdai.springboot.elasticjob.lite.entity.Foo;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Repository
public class FooRepository {
    
    private final Map<Long, Foo> data = new ConcurrentHashMap<>(300, 1);
    
    public FooRepository() {
        init();
    }
    
    private void init() {
        addData(0L, 100L, "Beijing");
        addData(100L, 200L, "Shanghai");
        addData(200L, 300L, "Guangzhou");
    }
    
    private void addData(final long idFrom, final long idTo, final String location) {
        for (long i = idFrom; i < idTo; i++) {
            data.put(i, new Foo(i, location, Foo.Status.TODO));
        }
    }
    
    public List<Foo> findTodoData(final String location, final int limit) {
        List<Foo> result = new ArrayList<>(limit);
        int count = 0;
        for (Map.Entry<Long, Foo> each : data.entrySet()) {
            Foo foo = each.getValue();
            if (foo.getLocation().equals(location) && foo.getStatus() == Foo.Status.TODO) {
                result.add(foo);
                count++;
                if (count == limit) {
                    break;
                }
            }
        }
        return result;
    }
    
    public void setCompleted(final long id) {
        data.get(id).setStatus(Foo.Status.COMPLETED);
    }
}
```

### 67.2.3 Job定义

#### 基本Job（实现SimpleJob接口）
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.job;

import java.time.LocalDateTime;
import java.util.List;

import org.apache.shardingsphere.elasticjob.api.ShardingContext;
import org.apache.shardingsphere.elasticjob.simple.job.SimpleJob;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import tech.pdai.springboot.elasticjob.lite.entity.Foo;
import tech.pdai.springboot.elasticjob.lite.repository.FooRepository;

@Component
public class SpringBootSimpleJob implements SimpleJob {

    private final Logger logger = LoggerFactory.getLogger(SpringBootSimpleJob.class);

    @Autowired
    private FooRepository fooRepository;

    @Override
    public void execute(final ShardingContext shardingContext) {
        logger.info("Item: {} | Time: {} | Thread: {} | {}",
                shardingContext.getShardingItem(), LocalDateTime.now(), Thread.currentThread().getId(), "SIMPLE");
        List<Foo> data = fooRepository.findTodoData(shardingContext.getShardingParameter(), 10);
        for (Foo each : data) {
            fooRepository.setCompleted(each.getId());
        }
    }
}
```

#### 数据流处理Job（实现DataflowJob接口）
包含两个主要方法：fetchData（获取数据）和processData（处理数据）。
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.job;

import java.time.LocalDateTime;
import java.util.List;

import javax.annotation.Resource;

import org.apache.shardingsphere.elasticjob.api.ShardingContext;
import org.apache.shardingsphere.elasticjob.dataflow.job.DataflowJob;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import tech.pdai.springboot.elasticjob.lite.entity.Foo;
import tech.pdai.springboot.elasticjob.lite.repository.FooRepository;

@Component
public class SpringBootDataflowJob implements DataflowJob<Foo> {

    private final Logger logger = LoggerFactory.getLogger(SpringBootDataflowJob.class);

    @Resource
    private FooRepository fooRepository;

    @Override
    public List<Foo> fetchData(final ShardingContext shardingContext) {
        logger.info("Item: {} | Time: {} | Thread: {} | {}",
                shardingContext.getShardingItem(), LocalDateTime.now(), Thread.currentThread().getId(), "DATAFLOW FETCH");
        return fooRepository.findTodoData(shardingContext.getShardingParameter(), 10);
    }

    @Override
    public void processData(final ShardingContext shardingContext, final List<Foo> data) {
        logger.info("Item: {} | Time: {} | Thread: {} | {}",
                shardingContext.getShardingItem(), LocalDateTime.now(), Thread.currentThread().getId(), "DATAFLOW PROCESS");
        for (Foo each : data) {
            fooRepository.setCompleted(each.getId());
        }
    }
}
```

#### 错误通知处理Job - Email
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.job;

import org.apache.shardingsphere.elasticjob.api.ShardingContext;
import org.apache.shardingsphere.elasticjob.simple.job.SimpleJob;
import org.springframework.stereotype.Component;

@Component
public class SpringBootOccurErrorNoticeEmailJob implements SimpleJob {
    
    @Override
    public void execute(final ShardingContext shardingContext) {
        throw new RuntimeException(String.format("An exception has occurred in Job, The parameter is %s", shardingContext.getShardingParameter()));
    }
}
```

#### 错误通知处理Job - Wechat
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.job;

import org.apache.shardingsphere.elasticjob.api.ShardingContext;
import org.apache.shardingsphere.elasticjob.simple.job.SimpleJob;
import org.springframework.stereotype.Component;

@Component
public class SpringBootOccurErrorNoticeWechatJob implements SimpleJob {
    
    @Override
    public void execute(final ShardingContext shardingContext) {
        throw new RuntimeException(String.format("An exception has occurred in Job, The parameter is %s", shardingContext.getShardingParameter()));
    }
}
```

#### 错误通知处理Job - Dingtalk
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.job;

import org.apache.shardingsphere.elasticjob.api.ShardingContext;
import org.apache.shardingsphere.elasticjob.simple.job.SimpleJob;
import org.springframework.stereotype.Component;

@Component
public class SpringBootOccurErrorNoticeDingtalkJob implements SimpleJob {
    
    @Override
    public void execute(final ShardingContext shardingContext) {
        throw new RuntimeException(String.format("An exception has occurred in Job, The parameter is %s", shardingContext.getShardingParameter()));
    }
}
```

### 67.2.4 装载配置

Spring Boot配置文件（application.yml）示例：
```yaml
spring:
  profiles:
    active: dev

elasticjob:
  tracing:
    type: RDB
  regCenter:
    serverLists: localhost:6181
    namespace: elasticjob-lite-springboot
  jobs:
    simpleJob:
      elasticJobClass: tech.pdai.springboot.elasticjob.lite.job.SpringBootSimpleJob
      cron: 0/5 * * * * ?
      shardingTotalCount: 3
      shardingItemParameters: 0=Beijing,1=Shanghai,2=Guangzhou
    dataflowJob:
      elasticJobClass: tech.pdai.springboot.elasticjob.lite.job.SpringBootDataflowJob
      cron: 0/5 * * * * ?
      shardingTotalCount: 3
      shardingItemParameters: 0=Beijing,1=Shanghai,2=Guangzhou
    scriptJob:
      elasticJobType: SCRIPT
      cron: 0/10 * * * * ?
      shardingTotalCount: 3
      props:
        script.command.line: "echo SCRIPT Job: "
    occurErrorNoticeDingtalkJob:
      elasticJobClass: tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeDingtalkJob
      overwrite: true
      shardingTotalCount: 3
      shardingItemParameters: 0=Beijing,1=Shanghai,2=Guangzhou
      jobErrorHandlerType: DINGTALK
      jobBootstrapBeanName: occurErrorNoticeDingtalkBean
      props:
        dingtalk:
          webhook: you_webhook
          keyword: you_keyword
          secret: you_secret
          connectTimeout: 3000
          readTimeout: 5000
    occurErrorNoticeWechatJob:
      elasticJobClass: tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeWechatJob
      overwrite: true
      shardingTotalCount: 3
      shardingItemParameters: 0=Beijing,1=Shanghai,2=Guangzhou
      jobErrorHandlerType: WECHAT
      jobBootstrapBeanName: occurErrorNoticeWechatBean
      props:
        wechat:
          webhook: you_webhook
          connectTimeout: 3000
          readTimeout: 5000
    occurErrorNoticeEmailJob:
      elasticJobClass: tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeEmailJob
      overwrite: true
      shardingTotalCount: 3
      shardingItemParameters: 0=Beijing,1=Shanghai,2=Guangzhou
      jobErrorHandlerType: EMAIL
      jobBootstrapBeanName: occurErrorNoticeEmailBean
      props:
        email:
          host: host
          port: 465
          username: username
          password: password
          useSsl: true
          subject: ElasticJob error message
          from: from@xxx.xx
          to: to1@xxx.xx,to2@xxx.xx
          cc: cc@xxx.xx
          bcc: bcc@xxx.xx
          debug: false
  dump:
    port: 9888

knife4j:
  enable: true
  setting:
    # default lang
    language: en-US
    # footer
    enableFooter: false
    enableFooterCustom: true
    footerCustomContent: MIT | [Java 全栈]()
    # models
    enableSwaggerModels: true
    swaggerModelName: My Models
```

### 67.2.5 注册中心

注册中心主要依赖ZooKeeper，采用内置的ZK服务器（仅用于示例）。
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite;

import java.io.File;
import java.io.IOException;

import org.apache.curator.test.TestingServer;

/**
 * Embed ZooKeeper.
 *
 * <p>
 * Only used for examples
 * </p>
 */
public final class EmbedZookeeperServer {

    private static TestingServer testingServer;

    /**
     * Embed ZooKeeper.
     *
     * @param port ZooKeeper port
     */
    public static void start(final int port) {
        try {
            testingServer = new TestingServer(port, new File(String.format("target/test_zk_data/%s/", System.nanoTime())));
        } catch (final Exception ex) {
            ex.printStackTrace();
        } finally {
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                try {
                    Thread.sleep(1000L);
                    testingServer.close();
                } catch (final InterruptedException | IOException ignore) {
                }
            }));
        }
    }
}
```

### 67.2.6 任务持久化

任务持久化在本地环境配置，使用H2内存数据库（如application.yml中配置的tracing.type: RDB）。

### 67.2.7 测试触发

通过Controller接口触发测试异常通知功能。注意：需要添加@Lazy注解以避免启动问题（参考issue: https://github.com/apache/shardingsphere-elasticjob/issues/2014）。
```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tech.pdai.springboot.elasticjob.lite.controller;

import javax.annotation.Resource;

import io.swagger.annotations.ApiOperation;
import org.apache.shardingsphere.elasticjob.lite.api.bootstrap.impl.OneOffJobBootstrap;
import org.springframework.context.annotation.Lazy;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.elasticjob.lite.entity.response.ResponseResult;

/**
 * 这里需要加上@Lazy, 请看这个issue:https://github.com/apache/shardingsphere-elasticjob/issues/2014
 */
@Lazy
@RestController
public class OneOffJobController {

    @Resource(name = "occurErrorNoticeDingtalkBean")
    private OneOffJobBootstrap occurErrorNoticeDingtalkJob;

    @Resource(name = "occurErrorNoticeWechatBean")
    private OneOffJobBootstrap occurErrorNoticeWechatJob;

    @Resource(name = "occurErrorNoticeEmailBean")
    private OneOffJobBootstrap occurErrorNoticeEmailJob;

    @ApiOperation("Test occurErrorNoticeDingtalkJob")
    @GetMapping("/execute/occurErrorNoticeDingtalkJob")
    public ResponseResult<String> executeOneOffJob() {
        occurErrorNoticeDingtalkJob.execute();
        return ResponseResult.success();
    }

    @ApiOperation("Test executeOccurErrorNoticeWechatJob")
    @GetMapping("/execute/occurErrorNoticeWechatJob")
    public ResponseResult<String> executeOccurErrorNoticeWechatJob() {
        occurErrorNoticeWechatJob.execute();
        return ResponseResult.success();
    }

    @ApiOperation("Test executeOccurErrorNoticeEmailJob")
    @GetMapping("/execute/occurErrorNoticeEmailJob")
    public ResponseResult<String> executeOccurErrorNoticeEmailJob() {
        occurErrorNoticeEmailJob.execute();
        return ResponseResult.success();
    }
}
```

### 67.2.8 简单测试

非OneOff的任务可以通过控制台查看日志。以下为示例日志输出（部分）：
```
[WARN ] 2022-06-06 20:03:49,828 --Thread-1-- [org.apache.zookeeper.server.ServerCnxnFactory] maxCnxns is not configured, using default value 0. 

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.5.3)

[INFO ] 2022-06-06 20:03:50,380 --main-- [tech.pdai.springboot.elasticjob.lite.SpringBootMain] Starting SpringBootMain using Java 1.8.0_181 on MacBook-Pro.local with PID 6275 (/Users/pdai/pdai/www/tech-pdai-spring-demos/424-springboot-demo-schedule-elastic-job-lite/target/classes started by pdai in /Users/pdai/pdai/www/tech-pdai-spring-demos) 
[INFO ] 2022-06-06 20:03:50,380 --main-- [tech.pdai.springboot.elasticjob.lite.SpringBootMain] The following profiles are active: dev 
... (日志继续，显示任务执行详情)
```

OneOff的任务通过Controller API访问。由于未配置正确的错误通知参数（如webhook），会报异常日志：
```
[INFO ] 2022-06-06 20:05:00,818 --Curator-SafeNotifyService-0-- [org.quartz.core.QuartzScheduler] Scheduler occurErrorNoticeDingtalkJob_$_NON_CLUSTERED started. 
[ERROR] 2022-06-06 20:05:00,908 --elasticjob-occurErrorNoticeDingtalkJob-3-- [org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler] An exception has occurred in Job 'occurErrorNoticeDingtalkJob', but failed to send dingtalk because of 
java.lang.RuntimeException: An exception has occurred in Job, The parameter is Guangzhou
	at tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeDingtalkJob.execute(SpringBootOccurErrorNoticeDingtalkJob.java:29)
	... (异常堆栈跟踪)
```
OneOff的任务，通过controller api访问
![238.springboot-elasticjob-lite-3.png](../../assets/images/04-主流框架/spring/238.springboot-elasticjob-lite-3.png)

由于这里没有配置正确的，这里会报异常日志
```sh
[INFO ] 2022-06-06 20:05:00,818 --Curator-SafeNotifyService-0-- [org.quartz.core.QuartzScheduler] Scheduler occurErrorNoticeDingtalkJob_$_NON_CLUSTERED started. 
[ERROR] 2022-06-06 20:05:00,908 --elasticjob-occurErrorNoticeDingtalkJob-3-- [org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler] An exception has occurred in Job 'occurErrorNoticeDingtalkJob', but failed to send dingtalk because of 
java.lang.RuntimeException: An exception has occurred in Job, The parameter is Guangzhou
	at tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeDingtalkJob.execute(SpringBootOccurErrorNoticeDingtalkJob.java:29)
	at org.apache.shardingsphere.elasticjob.simple.executor.SimpleJobExecutor.process(SimpleJobExecutor.java:33)
	at org.apache.shardingsphere.elasticjob.simple.executor.SimpleJobExecutor.process(SimpleJobExecutor.java:29)
	at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.process(ElasticJobExecutor.java:172)
	at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.lambda$process$0(ElasticJobExecutor.java:153)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
	at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:57)
	at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
	Suppressed: org.apache.http.client.ClientProtocolException: null
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:187)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)
		at org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler.handleException(DingtalkJobErrorHandler.java:80)
		at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.process(ElasticJobExecutor.java:183)
		... 8 common frames omitted
	Caused by: org.apache.http.ProtocolException: Target host is not specified
		at org.apache.http.impl.conn.DefaultRoutePlanner.determineRoute(DefaultRoutePlanner.java:71)
		at org.apache.http.impl.client.InternalHttpClient.determineRoute(InternalHttpClient.java:125)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
		... 12 common frames omitted
[ERROR] 2022-06-06 20:05:00,908 --elasticjob-occurErrorNoticeDingtalkJob-2-- [org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler] An exception has occurred in Job 'occurErrorNoticeDingtalkJob', but failed to send dingtalk because of 
java.lang.RuntimeException: An exception has occurred in Job, The parameter is Shanghai
	at tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeDingtalkJob.execute(SpringBootOccurErrorNoticeDingtalkJob.java:29)
	at org.apache.shardingsphere.elasticjob.simple.executor.SimpleJobExecutor.process(SimpleJobExecutor.java:33)
	at org.apache.shardingsphere.elasticjob.simple.executor.SimpleJobExecutor.process(SimpleJobExecutor.java:29)
	at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.process(ElasticJobExecutor.java:172)
	at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.lambda$process$0(ElasticJobExecutor.java:153)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
	at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:57)
	at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
	Suppressed: org.apache.http.client.ClientProtocolException: null
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:187)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)
		at org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler.handleException(DingtalkJobErrorHandler.java:80)
		at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.process(ElasticJobExecutor.java:183)
		... 8 common frames omitted
	Caused by: org.apache.http.ProtocolException: Target host is not specified
		at org.apache.http.impl.conn.DefaultRoutePlanner.determineRoute(DefaultRoutePlanner.java:71)
		at org.apache.http.impl.client.InternalHttpClient.determineRoute(InternalHttpClient.java:125)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
		... 12 common frames omitted
[ERROR] 2022-06-06 20:05:00,908 --elasticjob-occurErrorNoticeDingtalkJob-1-- [org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler] An exception has occurred in Job 'occurErrorNoticeDingtalkJob', but failed to send dingtalk because of 
java.lang.RuntimeException: An exception has occurred in Job, The parameter is Beijing
	at tech.pdai.springboot.elasticjob.lite.job.SpringBootOccurErrorNoticeDingtalkJob.execute(SpringBootOccurErrorNoticeDingtalkJob.java:29)
	at org.apache.shardingsphere.elasticjob.simple.executor.SimpleJobExecutor.process(SimpleJobExecutor.java:33)
	at org.apache.shardingsphere.elasticjob.simple.executor.SimpleJobExecutor.process(SimpleJobExecutor.java:29)
	at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.process(ElasticJobExecutor.java:172)
	at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.lambda$process$0(ElasticJobExecutor.java:153)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
	at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:57)
	at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
	Suppressed: org.apache.http.client.ClientProtocolException: null
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:187)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:108)
		at org.apache.shardingsphere.elasticjob.error.handler.dingtalk.DingtalkJobErrorHandler.handleException(DingtalkJobErrorHandler.java:80)
		at org.apache.shardingsphere.elasticjob.executor.ElasticJobExecutor.process(ElasticJobExecutor.java:183)
		... 8 common frames omitted
	Caused by: org.apache.http.ProtocolException: Target host is not specified
		at org.apache.http.impl.conn.DefaultRoutePlanner.determineRoute(DefaultRoutePlanner.java:71)
		at org.apache.http.impl.client.InternalHttpClient.determineRoute(InternalHttpClient.java:125)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
		... 12 common frames omitted
```
## 67.3 运维控制台
> ElasticJob 也提供了UI控制台的功能，包括作业操作和作业历史。可以在<a href='https://dlcdn.apache.org/shardingsphere/'>这里</a>下载。

### 67.3.1 启动运行
比如这里，我下载了apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin.tar.gz。需要通过如下工具解压，因为某些解压缩工具在解压ShardingSphere-ElasticJob-UI二进制包时可能将文件名截断，导致找不到某些类。
```sh
tar zxvf apache-shardingsphere-elasticjob-${RELEASE.VERSION}-lite-ui-bin.tar.gz
```
解压完以后，在conf目录配置JDBC（只需要与application-xx.yml中的datasource配置一致即可， 比如这里我们配置h2内存数据库）
```sh
server.port=8088

auth.root_username=root
auth.root_password=root
auth.guest_username=guest
auth.guest_password=guest
auth.token_expires_after_seconds=3600

spring.datasource.default.driver-class-name=org.h2.Driver
spring.datasource.default.url=jdbc:h2:mem:job_event_storage # 看这里
spring.datasource.default.username=sa
spring.datasource.default.password=
spring.jpa.show-sql=false
```
配置完后，启动
```sh
pdai@MacBook-Pro apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin % vi bin/start.sh 
pdai@MacBook-Pro apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin % bin/start.sh       
Starting the ShardingSphere-ElasticJob-UI ...
Please check the STDOUT file: /Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/logs/stdout.log
pdai@MacBook-Pro apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin % cat logs/stdout.log
20:20:30,474 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]
20:20:30,475 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]
20:20:30,476 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [file:/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/conf/logback.xml]
20:20:30,476 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs multiple times on the classpath.
20:20:30,476 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs at [file:/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/conf/logback.xml]
20:20:30,476 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs at [jar:file:/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/lib/shardingsphere-elasticjob-lite-ui-bin-distribution-3.0.1.jar!/logback.xml]
20:20:30,476 |-WARN in ch.qos.logback.classic.LoggerContext[default] - Resource [logback.xml] occurs at [jar:file:/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/lib/shardingsphere-elasticjob-lite-ui-backend-3.0.1.jar!/logback.xml]
20:20:30,588 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - debug attribute not set
20:20:30,588 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender]
20:20:30,593 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [console]
20:20:30,598 |-INFO in ch.qos.logback.core.joran.action.NestedComplexPropertyIA - Assuming default type [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for [encoder] property
20:20:30,653 |-INFO in ch.qos.logback.classic.joran.action.LoggerAction - Setting level of logger [org.apache.shardingsphere] to INFO
20:20:30,653 |-INFO in ch.qos.logback.classic.joran.action.LoggerAction - Setting additivity of logger [org.apache.shardingsphere] to false
20:20:30,653 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [console] to Logger[org.apache.shardingsphere]
20:20:30,653 |-INFO in ch.qos.logback.classic.joran.action.LevelAction - ROOT level set to INFO
20:20:30,653 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [console] to Logger[ROOT]
20:20:30,653 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - End of configuration.
20:20:30,656 |-INFO in ch.qos.logback.classic.joran.JoranConfigurator@3835c46 - Registering current configuration as safe fallback point


  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::       (v1.5.21.RELEASE)

[INFO ] 20:20:31.061 [main] o.a.s.elasticjob.lite.ui.Bootstrap - Starting Bootstrap v3.0.1 on MacBook-Pro.local with PID 7642 (/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/lib/shardingsphere-elasticjob-lite-ui-backend-3.0.1.jar started by pdai in /Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin)
[INFO ] 20:20:31.063 [main] o.a.s.elasticjob.lite.ui.Bootstrap - No active profile set, falling back to default profiles: default
[INFO ] 20:20:31.105 [main] o.s.b.c.e.AnnotationConfigEmbeddedWebApplicationContext - Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@5454d35e: startup date [Mon Jun 06 20:20:31 CST 2022]; root of context hierarchy
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils$1 (file:/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/lib/spring-core-4.3.24.RELEASE.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)
WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
[INFO ] 20:20:32.093 [main] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$89f6cb55] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
[INFO ] 20:20:32.367 [main] o.s.b.c.e.t.TomcatEmbeddedServletContainer - Tomcat initialized with port(s): 8088 (http)
[INFO ] 20:20:32.384 [main] o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8088"]
[INFO ] 20:20:32.407 [main] o.a.catalina.core.StandardService - Starting service [Tomcat]
[INFO ] 20:20:32.408 [main] o.a.catalina.core.StandardEngine - Starting Servlet Engine: Apache Tomcat/8.5.40
[INFO ] 20:20:32.514 [localhost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
[INFO ] 20:20:32.515 [localhost-startStop-1] o.s.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 1417 ms
[INFO ] 20:20:32.657 [localhost-startStop-1] o.s.b.w.s.FilterRegistrationBean - Mapping filter: 'characterEncodingFilter' to: [/*]
[INFO ] 20:20:32.657 [localhost-startStop-1] o.s.b.w.s.FilterRegistrationBean - Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
[INFO ] 20:20:32.657 [localhost-startStop-1] o.s.b.w.s.FilterRegistrationBean - Mapping filter: 'httpPutFormContentFilter' to: [/*]
[INFO ] 20:20:32.658 [localhost-startStop-1] o.s.b.w.s.FilterRegistrationBean - Mapping filter: 'requestContextFilter' to: [/*]
[INFO ] 20:20:32.658 [localhost-startStop-1] o.s.b.w.s.FilterRegistrationBean - Mapping filter: 'CORSFilter' to urls: [/api/*]
[INFO ] 20:20:32.658 [localhost-startStop-1] o.s.b.w.s.FilterRegistrationBean - Mapping filter: 'authenticationFilter' to urls: [/api/*]
[INFO ] 20:20:32.658 [localhost-startStop-1] o.s.b.w.s.ServletRegistrationBean - Mapping servlet: 'dispatcherServlet' to [/]
[INFO ] 20:20:32.990 [main] o.s.o.j.LocalContainerEntityManagerFactoryBean - Building JPA container EntityManagerFactory for persistence unit 'default'
[WARN ] 20:20:33.086 [main] openjpa.Runtime - The configuration property named "openjpa.ClassLoadEnhancement" was not recognized and will be ignored, although the name closely matches a valid property called "openjpa.PostLoadOnMerge".
[WARN ] 20:20:33.164 [main] openjpa.Runtime - The configuration property named "openjpa.ClassLoadEnhancement" was not recognized and will be ignored, although the name closely matches a valid property called "openjpa.PostLoadOnMerge".
[WARN ] 20:20:33.179 [main] openjpa.Runtime - An error occurred while registering a ClassTransformer with PersistenceUnitInfo: name 'default', root URL [file:/Users/pdai/apache-shardingsphere-elasticjob-3.0.1-lite-ui-bin/lib/shardingsphere-elasticjob-lite-ui-backend-3.0.1.jar]. The error has been consumed. To see it, set your openjpa.Runtime log level to TRACE. Load-time class transformation will not be available.
[INFO ] 20:20:33.193 [main] o.s.o.j.LocalContainerEntityManagerFactoryBean - Initialized JPA EntityManagerFactory for persistence unit 'default'
[INFO ] 20:20:33.273 [main] openjpa.jdbc.JDBC - Using dictionary class "org.apache.openjpa.jdbc.sql.H2Dictionary" (H2 1.4.196 (2017-06-10) ,H2 JDBC Driver 1.4.196 (2017-06-10)).
[INFO ] 20:20:33.322 [main] openjpa.jdbc.JDBC - Connected to H2 version 1.4 using JDBC driver H2 JDBC Driver version 1.4.196 (2017-06-10).
[INFO ] 20:20:33.326 [main] openjpa.Runtime - Starting OpenJPA 3.1.2
[WARN ] 20:20:33.531 [main] openjpa.Enhance - Creating subclass for "[class org.apache.shardingsphere.elasticjob.lite.ui.domain.TaskResultStatistics, class org.apache.shardingsphere.elasticjob.lite.ui.domain.JobRegisterStatistics, class org.apache.shardingsphere.elasticjob.lite.ui.domain.JobRunningStatistics, class org.apache.shardingsphere.elasticjob.lite.ui.domain.JobStatusTraceLog, class org.apache.shardingsphere.elasticjob.lite.ui.domain.JobExecutionLog, class org.apache.shardingsphere.elasticjob.lite.ui.domain.TaskRunningStatistics]". This means that your application will be less efficient and will consume more memory than it would if you ran the OpenJPA enhancer. Additionally, lazy loading will not be available for one-to-one and many-to-one persistent attributes in types using field access; they will be loaded eagerly instead.
[INFO ] 20:20:34.321 [main] o.s.w.s.m.m.a.RequestMappingHandlerAdapter - Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@5454d35e: startup date [Mon Jun 06 20:20:31 CST 2022]; root of context hierarchy
[INFO ] 20:20:34.374 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/count],methods=[GET]}" onto public int org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.getJobsTotalCount()
[INFO ] 20:20:34.375 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/getAllJobsBriefInfo],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<org.apache.shardingsphere.elasticjob.lite.lifecycle.domain.JobBriefInfo>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.getAllJobsBriefInfo()
[INFO ] 20:20:34.375 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/shutdown],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.shutdownJob(java.lang.String)
[INFO ] 20:20:34.376 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/sharding],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<org.apache.shardingsphere.elasticjob.lite.lifecycle.domain.ShardingInfo>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.getShardingInfo(java.lang.String)
[INFO ] 20:20:34.376 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/sharding/{item}/disable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.disableSharding(java.lang.String,java.lang.String)
[INFO ] 20:20:34.376 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/sharding/{item}/enable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.enableSharding(java.lang.String,java.lang.String)
[INFO ] 20:20:34.376 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/trigger],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.triggerJob(java.lang.String)
[INFO ] 20:20:34.376 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/disable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.disableJob(java.lang.String)
[INFO ] 20:20:34.376 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/{jobName}/enable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobOperationController.enableJob(java.lang.String)
[INFO ] 20:20:34.378 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/event-trace/status/jobNames || /api/event-trace/status/jobNames/{jobNamePrefix:.+}],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.List<java.lang.String>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceHistoryController.findJobNamesByPrefixInStatusTraceLog(java.lang.String)
[INFO ] 20:20:34.378 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/event-trace/execution],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<org.apache.shardingsphere.elasticjob.lite.ui.dto.response.BasePageResponse<org.apache.shardingsphere.elasticjob.tracing.event.JobExecutionEvent>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceHistoryController.findJobExecutionEvents(org.apache.shardingsphere.elasticjob.lite.ui.dto.request.FindJobExecutionEventsRequest)
[INFO ] 20:20:34.378 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/event-trace/execution/jobNames || /api/event-trace/execution/jobNames/{jobNamePrefix:.+}],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.List<java.lang.String>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceHistoryController.findJobNamesByPrefix(java.lang.String)
[INFO ] 20:20:34.378 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/event-trace/execution/ip || /api/event-trace/execution/ip/{ipPrefix:.+}],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.List<java.lang.String>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceHistoryController.findIpByPrefix(java.lang.String)
[INFO ] 20:20:34.379 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/event-trace/status],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<org.apache.shardingsphere.elasticjob.lite.ui.dto.response.BasePageResponse<org.apache.shardingsphere.elasticjob.tracing.event.JobStatusTraceEvent>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceHistoryController.findJobStatusTraceEvents(org.apache.shardingsphere.elasticjob.lite.ui.dto.request.FindJobStatusTraceEventsRequest)
[INFO ] 20:20:34.382 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/count],methods=[GET]}" onto public int org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.getServersTotalCount()
[INFO ] 20:20:34.382 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/getAllServersBriefInfo],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<org.apache.shardingsphere.elasticjob.lite.lifecycle.domain.ServerBriefInfo>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.getAllServersBriefInfo()
[INFO ] 20:20:34.382 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/disable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.disableServer(java.lang.String)
[INFO ] 20:20:34.382 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/enable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.enableServer(java.lang.String)
[INFO ] 20:20:34.383 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/shutdown],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.shutdownServer(java.lang.String)
[INFO ] 20:20:34.383 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp:.+}],methods=[DELETE]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.removeServer(java.lang.String)
[INFO ] 20:20:34.383 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/jobs/{jobName}/disable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.disableServerJob(java.lang.String,java.lang.String)
[INFO ] 20:20:34.383 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/jobs/{jobName}/enable],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.enableServerJob(java.lang.String,java.lang.String)
[INFO ] 20:20:34.383 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/jobs/{jobName}/shutdown],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.shutdownServerJob(java.lang.String,java.lang.String)
[INFO ] 20:20:34.383 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/jobs/{jobName:.+}],methods=[DELETE]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.removeServerJob(java.lang.String,java.lang.String)
[INFO ] 20:20:34.384 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/servers/{serverIp}/jobs],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<org.apache.shardingsphere.elasticjob.lite.lifecycle.domain.JobBriefInfo>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.ServerOperationController.getJobs(java.lang.String)
[INFO ] 20:20:34.387 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/registry-center/activated],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<org.apache.shardingsphere.elasticjob.lite.ui.domain.RegistryCenterConfiguration> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.RegistryCenterController.activated()
[INFO ] 20:20:34.387 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/registry-center/add],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.RegistryCenterController.add(org.apache.shardingsphere.elasticjob.lite.ui.domain.RegistryCenterConfiguration)
[INFO ] 20:20:34.387 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/registry-center/load],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<org.apache.shardingsphere.elasticjob.lite.ui.domain.RegistryCenterConfiguration>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.RegistryCenterController.load(javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.387 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/registry-center],methods=[DELETE]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult org.apache.shardingsphere.elasticjob.lite.ui.web.controller.RegistryCenterController.delete(org.apache.shardingsphere.elasticjob.lite.ui.domain.RegistryCenterConfiguration)
[INFO ] 20:20:34.387 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/registry-center/connect],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.RegistryCenterController.connect(org.apache.shardingsphere.elasticjob.lite.ui.domain.RegistryCenterConfiguration,javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.389 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source/drivers],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<java.lang.String>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.availableDrivers()
[INFO ] 20:20:34.389 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source/connectTest],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.connectTest(org.apache.shardingsphere.elasticjob.lite.ui.domain.EventTraceDataSourceConfiguration,javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.389 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source/activated],methods=[GET]}" onto public boolean org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.activated(javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.389 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source/add],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.add(org.apache.shardingsphere.elasticjob.lite.ui.domain.EventTraceDataSourceConfiguration)
[INFO ] 20:20:34.390 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source/load],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.util.Collection<org.apache.shardingsphere.elasticjob.lite.ui.domain.EventTraceDataSourceConfiguration>> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.load(javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.390 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source],methods=[DELETE]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.delete(org.apache.shardingsphere.elasticjob.lite.ui.domain.EventTraceDataSourceConfiguration)
[INFO ] 20:20:34.390 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/data-source/connect],methods=[POST]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.EventTraceDataSourceController.connect(org.apache.shardingsphere.elasticjob.lite.ui.domain.EventTraceDataSourceConfiguration,javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.392 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/config/{jobName:.+}],methods=[GET]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<org.apache.shardingsphere.elasticjob.infra.pojo.JobConfigurationPOJO> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobConfigController.getJobConfig(java.lang.String)
[INFO ] 20:20:34.392 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/config],methods=[PUT]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobConfigController.updateJobConfig(org.apache.shardingsphere.elasticjob.infra.pojo.JobConfigurationPOJO)
[INFO ] 20:20:34.392 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/api/jobs/config/{jobName:.+}],methods=[DELETE]}" onto public org.apache.shardingsphere.elasticjob.lite.ui.web.response.ResponseResult<java.lang.Boolean> org.apache.shardingsphere.elasticjob.lite.ui.web.controller.JobConfigController.removeJob(java.lang.String)
[INFO ] 20:20:34.393 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
[INFO ] 20:20:34.393 [main] o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
[INFO ] 20:20:34.412 [main] o.s.w.s.h.SimpleUrlHandlerMapping - Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
[INFO ] 20:20:34.412 [main] o.s.w.s.h.SimpleUrlHandlerMapping - Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
[INFO ] 20:20:34.422 [main] o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - Detected @ExceptionHandler methods in restExceptionHandler
[INFO ] 20:20:34.438 [main] o.s.w.s.h.SimpleUrlHandlerMapping - Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
[INFO ] 20:20:34.453 [main] o.s.b.a.w.WebMvcAutoConfiguration$WelcomePageHandlerMapping - Adding welcome page: class path resource [public/index.html]
[INFO ] 20:20:34.624 [main] o.s.j.e.a.AnnotationMBeanExporter - Registering beans for JMX exposure on startup
[INFO ] 20:20:34.634 [main] o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8088"]
[INFO ] 20:20:34.655 [main] o.a.tomcat.util.net.NioSelectorPool - Using a shared selector for servlet write/read
[INFO ] 20:20:34.666 [main] o.s.b.c.e.t.TomcatEmbeddedServletContainer - Tomcat started on port(s): 8088 (http)
[INFO ] 20:20:34.670 [main] o.a.s.elasticjob.lite.ui.Bootstrap - Started Bootstrap in 3.898 seconds (JVM running for 4.52)
```
打开http://localhost:8088，输入我们配置的root/root账号
![239.springboot-elasticjob-lite-4.png](../../assets/images/04-主流框架/spring/239.springboot-elasticjob-lite-4.png)
### 67.3.2 全局配置
- 配置zk
![240.springboot-elasticjob-lite-5.png](../../assets/images/04-主流框架/spring/240.springboot-elasticjob-lite-5.png)
- 配置数据源
![241.springboot-elasticjob-lite-6.png](../../assets/images/04-主流框架/spring/241.springboot-elasticjob-lite-6.png)
### 67.3.3 作业操作
- 作业维度
![242.springboot-elasticjob-lite-7.png](../../assets/images/04-主流框架/spring/242.springboot-elasticjob-lite-7.png)
- 服务器维度
![243.springboot-elasticjob-lite-8.png](../../assets/images/04-主流框架/spring/243.springboot-elasticjob-lite-8.png)

### 67.3.4 作业历史
作业历史本质上就是从H2中获取数据，你也可以访问H2-Console查看

- 历史轨迹
![244.springboot-elasticjob-lite-9.png](../../assets/images/04-主流框架/spring/244.springboot-elasticjob-lite-9.png)
- 历史状态
![245.springboot-elasticjob-lite-10.png](../../assets/images/04-主流框架/spring/245.springboot-elasticjob-lite-10.png)
# 六十八、SpringBoot定时任务 - 分布式xxl-job方式
> 除了前文介绍的ElasticJob，xxl-job在很多中小公司有着应用（虽然其代码和设计等质量并不太高，License不够开放，有着个人主义色彩，但是其具体开箱使用的便捷性和功能相对完善性，这是中小团队采用的主要原因）；XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。本文介绍XXL-JOB以及SpringBoot的集成。
## 68.1 知识准备
### 68.1.1 什么是xxl-job
> XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。如下内容来源于<a href='https://www.xuxueli.com/xxl-job/'>xxl-job官网</a>

支持如下特性：
- 1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；
- 2、动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效；
- 3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；
- 4、执行器HA（分布式）：任务分布式执行，任务"执行器"支持集群部署，可保证任务执行HA；
- 5、注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；
- 6、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；
- 7、触发策略：提供丰富的任务触发策略，包括：Cron触发、固定间隔触发、固定延时触发、API（事件）触发、人工触发、父子任务触发；
- 8、调度过期策略：调度中心错过调度时间的补偿处理策略，包括：忽略、立即补偿触发一次等；
- 9、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；
- 10、任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；
- 11、任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；
- 12、任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式；
- 13、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；
- 14、分片广播任务：执行器集群部署时，任务路由策略选择"分片广播"情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；
- 15、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。
- 16、故障转移：任务路由策略选择"故障转移"情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。
- 17、任务进度监控：支持实时监控任务进度；
- 18、Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；
- 19、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。
- 20、脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本;
- 21、命令行任务：原生提供通用命令行任务Handler（Bean任务，"CommandJobHandler"）；业务方只需要提供命令行即可；
- 22、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；
- 23、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；
- 24、自定义任务参数：支持在线配置调度任务入参，即时生效；
- 25、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；
- 26、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；
- 27、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；
- 28、推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;
- 29、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；
- 30、全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行；
- 31、跨语言：调度中心与执行器提供语言无关的 RESTful API 服务，第三方任意语言可据此对接调度中心或者实现执行器。除此之外，还提供了 “多任务模式”和“httpJobHandler”等其他跨语言方案；
- 32、国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文；
- 33、容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用；
- 34、线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入"Slow"线程池，避免耗尽调度线程，提高系统稳定性；
- 35、用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色；
- 36、权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作；
### 68.1.2 xxl-job的架构设计
#### 68.1.2.1 设计思想
将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。

将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。

因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；
#### 68.1.2.2 系统组成
1. 调度模块（调度中心） 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。
2. 执行模块（执行器）： 负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；接收“调度中心”的执行请求、终止请求和日志请求等。
#### 68.1.2.3 架构图 
![246.springboot-xxl-job-8.png](../../assets/images/04-主流框架/spring/246.springboot-xxl-job-8.png)
## 68.2 实现案例

本文主要介绍SpringBoot集成xxl-job的方式：Bean模式（基于方法和基于类），以及基于在线配置代码/脚本的GLUE模式。

### Bean模式（基于方法）

Bean模式任务支持基于方法的开发方式，每个任务对应一个方法。基于方法开发的任务，底层会生成JobHandler代理，和基于类的方式一样，任务也会以JobHandler的形式存在于执行器任务容器中。

**优点**：
- 每个任务只需要开发一个方法，并添加`@XxlJob`注解即可，更加方便、快速。
- 支持自动扫描任务并注入到执行器容器。

**缺点**：
- 要求Spring容器环境。

#### Job的开发环境依赖

**Maven依赖**：
```xml
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
    <version>2.3.1</version>
</dependency>
```

**application.properties配置**：
```properties
# web port
server.port=8081
# no web
#spring.main.web-environment=false

# log config
logging.config=classpath:logback.xml

### xxl-job admin address list, such as "http://address" or "http://address01,http://address02"
xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin

### xxl-job, access token
xxl.job.accessToken=default_token

### xxl-job executor appname
xxl.job.executor.appname=xxl-job-executor-sample
### xxl-job executor registry-address: default use address to registry , otherwise use ip:port if address is null
xxl.job.executor.address=
### xxl-job executor server-info
xxl.job.executor.ip=
xxl.job.executor.port=9999
### xxl-job executor log-path
xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler
### xxl-job executor log-retention-days
xxl.job.executor.logretentiondays=30
```

**Config配置**（PS：这里直接使用xxl-job demo中的配置，实际开发中可以封装一个starter自动注入）：
```java
package tech.pdai.springboot.xxljob.config;

import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * xxl-job config
 */
@Configuration
public class XxlJobConfig {
    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);

    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;

    @Value("${xxl.job.accessToken}")
    private String accessToken;

    @Value("${xxl.job.executor.appname}")
    private String appname;

    @Value("${xxl.job.executor.address}")
    private String address;

    @Value("${xxl.job.executor.ip}")
    private String ip;

    @Value("${xxl.job.executor.port}")
    private int port;

    @Value("${xxl.job.executor.logpath}")
    private String logPath;

    @Value("${xxl.job.executor.logretentiondays}")
    private int logRetentionDays;

    @Bean
    public XxlJobSpringExecutor xxlJobExecutor() {
        logger.info(">>>>>>>>>>> xxl-job config init.");
        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
        xxlJobSpringExecutor.setAppname(appname);
        xxlJobSpringExecutor.setAddress(address);
        xxlJobSpringExecutor.setIp(ip);
        xxlJobSpringExecutor.setPort(port);
        xxlJobSpringExecutor.setAccessToken(accessToken);
        xxlJobSpringExecutor.setLogPath(logPath);
        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);
        return xxlJobSpringExecutor;
    }
}
```

#### Job的开发

**开发步骤**：
1. **任务开发**：在Spring Bean实例中，开发Job方法。
2. **注解配置**：为Job方法添加注解`@XxlJob(value="自定义jobhandler名称", init = "JobHandler初始化方法", destroy = "JobHandler销毁方法")`，注解value值对应调度中心新建任务的JobHandler属性的值。
3. **执行日志**：需要通过`XxlJobHelper.log`打印执行日志。
4. **任务结果**：默认任务结果为"成功"状态，不需要主动设置；如有诉求，可通过`XxlJobHelper.handleFail/handleSuccess`自主设置任务结果。

**Job开发示例**：
```java
package tech.pdai.springboot.xxljob.job;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Arrays;

import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.handler.annotation.XxlJob;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * XxlJob开发示例（Bean模式 - 方法）
 */
@Slf4j
@Component
public class BeanMethodDemoJob {

    /**
     * 1、简单任务示例（Bean模式）
     */
    @XxlJob("demoJobHandler")
    public void demoJobHandler() {
        XxlJobHelper.log("demoJobHandler execute...");
    }

    /**
     * 2、分片广播任务
     */
    @XxlJob("shardingJobHandler")
    public void shardingJobHandler() throws Exception {
        log.info("shardingJobHandler execute...");
        XxlJobHelper.log("shardingJobHandler execute...");
        int shardIndex = XxlJobHelper.getShardIndex();
        int shardTotal = XxlJobHelper.getShardTotal();
        XxlJobHelper.log("分片参数：当前分片序号 = {}, 总分片数 = {}", shardIndex, shardTotal);
        for (int i = 0; i < shardTotal; i++) {
            if (i == shardIndex) {
                XxlJobHelper.log("第 {} 片, 命中分片开始处理", i);
            } else {
                XxlJobHelper.log("第 {} 片, 忽略", i);
            }
        }
    }

    /**
     * 3、命令行任务
     */
    @XxlJob("commandJobHandler")
    public void commandJobHandler() throws Exception {
        XxlJobHelper.log("commandJobHandler execute...");
        String command = XxlJobHelper.getJobParam();
        int exitValue = -1;
        BufferedReader bufferedReader = null;
        try {
            ProcessBuilder processBuilder = new ProcessBuilder();
            processBuilder.command(command);
            processBuilder.redirectErrorStream(true);
            Process process = processBuilder.start();
            BufferedInputStream bufferedInputStream = new BufferedInputStream(process.getInputStream());
            bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream));
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                XxlJobHelper.log(line);
            }
            process.waitFor();
            exitValue = process.exitValue();
        } catch (Exception e) {
            XxlJobHelper.log(e);
        } finally {
            if (bufferedReader != null) {
                bufferedReader.close();
            }
        }
        if (exitValue != 0) {
            XxlJobHelper.handleFail("command exit value(" + exitValue + ") is failed");
        }
    }

    /**
     * 4、跨平台Http任务
     * 参数示例：
     * "url: http://www.baidu.com\n" +
     * "method: get\n" +
     * "data: content\n";
     */
    @XxlJob("httpJobHandler")
    public void httpJobHandler() throws Exception {
        XxlJobHelper.log("httpJobHandler execute...");
        String param = XxlJobHelper.getJobParam();
        if (param == null || param.trim().length() == 0) {
            XxlJobHelper.log("param[" + param + "] invalid.");
            XxlJobHelper.handleFail();
            return;
        }
        String[] httpParams = param.split("\n");
        String url = null;
        String method = null;
        String data = null;
        for (String httpParam : httpParams) {
            if (httpParam.startsWith("url:")) {
                url = httpParam.substring(httpParam.indexOf("url:") + 4).trim();
            }
            if (httpParam.startsWith("method:")) {
                method = httpParam.substring(httpParam.indexOf("method:") + 7).trim().toUpperCase();
            }
            if (httpParam.startsWith("data:")) {
                data = httpParam.substring(httpParam.indexOf("data:") + 5).trim();
            }
        }
        if (url == null || url.trim().length() == 0) {
            XxlJobHelper.log("url[" + url + "] invalid.");
            XxlJobHelper.handleFail();
            return;
        }
        if (method == null || !Arrays.asList("GET", "POST").contains(method)) {
            XxlJobHelper.log("method[" + method + "] invalid.");
            XxlJobHelper.handleFail();
            return;
        }
        boolean isPostMethod = method.equals("POST");
        HttpURLConnection connection = null;
        BufferedReader bufferedReader = null;
        try {
            URL realUrl = new URL(url);
            connection = (HttpURLConnection) realUrl.openConnection();
            connection.setRequestMethod(method);
            connection.setDoOutput(isPostMethod);
            connection.setDoInput(true);
            connection.setUseCaches(false);
            connection.setReadTimeout(5 * 1000);
            connection.setConnectTimeout(3 * 1000);
            connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("Content-Type", "application/json;charset=UTF-8");
            connection.setRequestProperty("Accept-Charset", "application/json;charset=UTF-8");
            connection.connect();
            if (isPostMethod && data != null && data.trim().length() > 0) {
                DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());
                dataOutputStream.write(data.getBytes("UTF-8"));
                dataOutputStream.flush();
                dataOutputStream.close();
            }
            int statusCode = connection.getResponseCode();
            if (statusCode != 200) {
                throw new RuntimeException("Http Request StatusCode(" + statusCode + ") Invalid.");
            }
            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
            StringBuilder result = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                result.append(line);
            }
            String responseMsg = result.toString();
            XxlJobHelper.log(responseMsg);
        } catch (Exception e) {
            XxlJobHelper.log(e);
            XxlJobHelper.handleFail();
        } finally {
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
                if (connection != null) {
                    connection.disconnect();
                }
            } catch (Exception e2) {
                XxlJobHelper.log(e2);
            }
        }
    }

    /**
     * 5、生命周期任务示例
     */
    @XxlJob(value = "demoJobHandler2", init = "init", destroy = "destroy")
    public void demoJobHandler2() throws Exception {
        XxlJobHelper.log("demoJobHandler2, execute...");
    }

    public void init() {
        log.info("init");
    }

    public void destroy() {
        log.info("destroy");
    }
}
```

（@pdai: 从设计的角度，xxl-job可以对上述不同类型进行细分）

#### Job的调度配置和执行

新增Job, 并把上述的@XxlJob(value="自定义jobhandler名称", init = "JobHandler初始化方法", destroy = "JobHandler销毁方法")中 自定义jobhandler名称 填写到JobHandler中。

其它配置如下：
![247.springboot-xxl-job-1.png](../../assets/images/04-主流框架/spring/247.springboot-xxl-job-1.png)

可以选择操作中执行一次任务，或者启动(按照Cron执行)
![248.springboot-xxl-job-2.png](../../assets/images/04-主流框架/spring/248.springboot-xxl-job-2.png)

可以查看执行的记录
![249.springboot-xxl-job-3.png](../../assets/images/04-主流框架/spring/249.springboot-xxl-job-3.png)

进一步可以看每个执行记录的执行日志
![250.springboot-xxl-job-4.png](../../assets/images/04-主流框架/spring/****250.springboot-xxl-job-4.png)

### Bean模式（基于类）

Bean模式任务支持基于类的开发方式，每个任务对应一个Java类。

**优点**：
- 不限制项目环境，兼容性好。即使是无框架项目，如main方法直接启动的项目也可以提供支持。

**缺点**：
- 每个任务需要占用一个Java类，造成类的浪费。
- 不支持自动扫描任务并注入到执行器容器，需要手动注入。

#### Job的开发环境依赖

同Bean模式（基于方法）。

#### Job的开发

**开发步骤**：
1. 开发一个继承自`com.xxl.job.core.handler.IJobHandler`的JobHandler类，实现`execute`方法。
2. 手动注入到执行器容器：`XxlJobExecutor.registJobHandler("自定义名称", new JobHandler实例)`。

**Job开发示例**：
```java
package tech.pdai.springboot.xxljob.job;

import com.xxl.job.core.handler.IJobHandler;
import lombok.extern.slf4j.Slf4j;

/**
 * Bean类模式示例
 */
@Slf4j
public class BeanClassDemoJob extends IJobHandler {

    @Override
    public void execute() throws Exception {
        log.info("BeanClassDemoJob, execute...");
    }
}
```

**注册JobHandler**（@pdai: 这里xxl-job设计的不好，是可以通过IJobHandler来自动注册的）：
在配置类中添加注册代码：
```java
// 注册Bean类模式
XxlJobExecutor.registJobHandler("beanClassDemoJobHandler", new BeanClassDemoJob());
```

启动SpringBoot应用后，日志显示注册成功：
```
20:34:15.385 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - >>>>>>>>>>> xxl-job register jobhandler success, name:beanClassDemoJobHandler, jobHandler:tech.pdai.springboot.xxljob.job.BeanClassDemoJob@640ab13c
```

#### Job的调度配置和执行

同Bean模式（基于方法）。在调度中心配置后，执行日志如下：
```
20:41:00.021 logback [xxl-job, EmbedServer bizThreadPool-1023773196] INFO  c.x.job.core.executor.XxlJobExecutor - >>>>>>>>>>> xxl-job regist JobThread success, jobId:5, handler:tech.pdai.springboot.xxljob.job.BeanClassDemoJob@640ab13c
20:41:00.022 logback [xxl-job, JobThread-5-1654681260021] INFO  t.p.s.xxljob.job.BeanClassDemoJob - BeanClassDemoJob, execute...
```

### GLUE模式

任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定JobHandler。

#### 配置和启动流程

1. 在调度中心创建GLUE类型的Job（以Java为例）。
![251.springboot-xxl-job-5.png](../../assets/images/04-主流框架/spring/251.springboot-xxl-job-5.png)
2. 选中指定任务，点击该任务右侧“GLUE”按钮，将会前往GLUE任务的Web IDE界面，在该界面支持对任务代码进行开发（也可以在IDE中开发完成后，复制粘贴到编辑中）。
3. 版本回溯功能（支持30个版本的版本回溯）：在GLUE任务的Web IDE界面，选择右上角下拉框“版本回溯”，会列出该GLUE的更新历史，选择相应版本即可显示该版本代码，保存后GLUE代码即回退到对应的历史版本；
![252.springboot-xxl-job-6.png](../../assets/images/04-主流框架/spring/252.springboot-xxl-job-6.png)
4. 执行后查看记录。
![253.springboot-xxl-job-7.png](../../assets/images/04-主流框架/spring/253.springboot-xxl-job-7.png)

#### 支持的GLUE模式

xxl-job支持多种GLUE模式：
- **GLUE模式(Java)**：任务是一段继承自`IJobHandler`的Java类代码，以"groovy"源码方式维护。
- **GLUE模式(Shell)**：任务是一段Shell脚本。
- **GLUE模式(Python)**：任务是一段Python脚本。
- **GLUE模式(PHP)**：任务是一段PHP脚本。
- **GLUE模式(NodeJS)**：任务是一段NodeJS脚本。
- **GLUE模式(PowerShell)**：任务是一段PowerShell脚本。

### 更多配置的说明

#### 基础配置
- **执行器**：任务绑定的执行器，实现任务自动发现功能。
- **任务描述**：任务的描述信息。
- **负责人**：任务的负责人。
- **报警邮件**：任务失败时通知的邮箱地址，支持多邮箱。

#### 触发配置
- **调度类型**：
  - 无：不主动触发。
  - CRON：通过CRON表达式触发。
  - 固定速度：按固定间隔时间周期性触发。
  - 固定延迟：从上次调度结束后计算延迟时间触发。
- **CRON**：Cron表达式。
- **固定速度**：间隔时间（秒）。
- **固定延迟**：延迟时间（秒）。

#### 高级配置
- **路由策略**：
  - FIRST（第一个）
  - LAST（最后一个）
  - ROUND（轮询）
  - RANDOM（随机）
  - CONSISTENT_HASH（一致性HASH）
  - LEAST_FREQUENTLY_USED（最不经常使用）
  - LEAST_RECENTLY_USED（最近最久未使用）
  - FAILOVER（故障转移）
  - BUSYOVER（忙碌转移）
  - SHARDING_BROADCAST（分片广播）
- **子任务**：任务成功时触发子任务ID对应的任务。
- **调度过期策略**：
  - 忽略：重新计算下次触发时间。
  - 立即执行一次：立即执行并重新计算。
- **阻塞处理策略**：
  - 单机串行（默认）：FIFO队列串行运行。
  - 丢弃后续调度：丢弃并标记失败。
  - 覆盖之前调度：终止运行中的任务并运行新任务。
- **任务超时时间**：自定义超时时间，超时中断任务。
- **失败重试次数**：自定义失败重试次数。
# 六十九、▶SpringBoot集成文件 - 基础的文件上传和下载
> 项目中常见的功能是需要将数据文件(比如Excel,csv)上传到服务器端进行处理，亦或是将服务器端的数据以某种文件形式(比如excel,pdf,csv,word)下载到客户端。本文主要介绍基于SpringBoot的对常规文件的上传和下载，以及常见的问题等。
## 69.1 知识准备
> 需要理解文件上传和下载的常见场景和技术手段。
### 69.1.1 哪些场景需要文件上传和下
载项目中常见的功能是需要将数据文件(比如Excel,csv)上传到服务器端进行处理，亦或是将服务器端的数据以某种文件形式(比如excel,pdf,csv,word)下载到客户端。
## 69.2 实现案例
本例子主要展示文件的上传和文件的下载。
### 69.2.1 Pom依赖
引入spring-boot-starter-web即可
```pom
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```
### 69.2.2 文件上传
上传一个文件，并保存到本地文件夹中
```java
@PostMapping("/upload")
public ResponseResult<String> upload(@RequestParam(value = "file", required = true) MultipartFile file) {
    try {
        // 本地文件保存位置
        String uploadPath = "/Users/pdai/uploadFile"; // 改这里
        File uploadDir = new File(uploadPath);
        if (!uploadDir.exists()) {
            uploadDir.mkdir();
        }
        log.info(uploadDir.getAbsolutePath());

        // 本地文件
        File localFile = new File(uploadPath + File.separator + file.getOriginalFilename());

        // transfer to local
        file.transferTo(localFile);
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseResult.fail(e.getMessage());
    }
    return ResponseResult.success();
}
```
通过postman，模拟上传的请求
![254.springboot-file-updownload-2.png](../../assets/images/04-主流框架/spring/254.springboot-file-updownload-2.png)

上传文件结果：
![255.springboot-file-updownload-1.png](../../assets/images/04-主流框架/spring/255.springboot-file-updownload-1.png)
### 69.2.3 文件下载
从本地文件夹中读取文件，并通过http下载
```java
@GetMapping("/download")
public void download(HttpServletResponse response) {
    response.reset();
    response.setContentType("application/octet-stream");
    response.setHeader("Content-disposition",
            "attachment;filename=file_" + System.currentTimeMillis() + ".hprof");

    // 从文件读到servlet response输出流中
    File file = new File("/Users/pdai/pdai_heap_dump_test.hprof"); // 改这里
    try (FileInputStream inputStream = new FileInputStream(file);) { // try-with-resources
        byte[] b = new byte[1024];
        int len;
        while ((len = inputStream.read(b)) > 0) {
            response.getOutputStream().write(b, 0, len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
下载文件
![256.springboot-file-updownload-3.png](../../assets/images/04-主流框架/spring/256.springboot-file-updownload-3.png)
注：

如果使用postman下载文件，默认的response大小是50MB，下载大于50MB的文件需要在这里自行设置。
![257.springboot-file-updownload-4.png](../../assets/images/04-主流框架/spring/257.springboot-file-updownload-4.png)
## 69.3 进一步理解
## 69.3.1 SpringBoot文件上传大小参数？
SpringBoot对上传的文件大小有限制，默认的最大每个文件配置最大为1MB，默认多个文件上传（上传目标文件夹）总大小是10MB。
```yml
spring:
  servlet:
    multipart:
      max-file-size: 1024MB # 单个文件大小
      max-request-size: 10240MB # 总文件大小（允许存储文件的文件夹大小）
```
更多其它的参数可以参看MultipartProperties类
```java
@ConfigurationProperties(prefix = "spring.servlet.multipart", ignoreUnknownFields = false)
public class MultipartProperties {

	/**
	 * Whether to enable support of multipart uploads.
	 */
	private boolean enabled = true;

	/**
	 * Intermediate location of uploaded files.
	 */
	private String location;

	/**
	 * Max file size.
	 */
	private DataSize maxFileSize = DataSize.ofMegabytes(1);

	/**
	 * Max request size.
	 */
	private DataSize maxRequestSize = DataSize.ofMegabytes(10);

	/**
	 * Threshold after which files are written to disk.
	 */
	private DataSize fileSizeThreshold = DataSize.ofBytes(0);

	/**
	 * Whether to resolve the multipart request lazily at the time of file or parameter
	 * access.
	 */
	private boolean resolveLazily = false;

}
```
### 69.3.2 多个文件上传？
Spring支持接收多个文件的，只需要用MultipartFile接收即可
```java
@PostMapping("/upload")
public ResponseResult<String> upload(MultipartFile[] files) {

}
```
# 七十、SpringBoot集成文件 - 大文件的上传(异步，分片，断点续传和秒传)
> 上文中介绍的是常规文件的上传和下载，而超大文件的上传技术手段和普通文件上传是有差异的，主要通过基于分片的断点续传和秒传和异步上传等技术手段解决。本文主要介绍SpringBoot集成大文件上传的案例。
## 70.1 知识准备
### 70.1.1 基于分片的断点续传和秒传
> 当我们上传的文件很大时，对大文件的处理通常通过`分片上传、断点续传和秒传`技术手段实现。
- 分片上传

分片上传就是将一个大文件分成若干份大小相等的小块文件，等所有小块文件上传成功后，再将文件进行合并成完整的原始文件。
- 断点续传

断点续传就是重新上传文件时先判断哪些文件块已经上传过了(比如将分片的chuck md5等信息保存在DB中)，如果上传过了则跳过这些块，否则上传没有上传的块。
- 秒传
  
当用户选择上传一个文件时，服务端检测该文件之前是否已经被上传过，如果服务器已经存有该文件（完全一样），就立马返回前端 “文件已上传成功”。前端随即将进度条更新至100%。 这样给用户的感觉就是 “秒传” 的感觉。


对于分片上传，前后端分别需要怎么做呢？

1. 前端：需要将文件file.slice()成多个文件块，并计算每一块的md5值，每次请求上传都是传一个小文件块。
2. 后端：需要接收每次上传的文件块并保存文件块的信息(比如md5), 如果已经上传则跳过；最后等所有文件上传完成之后，将所有的文件块合并成一个大文件。
### 70.1.2 异步上传
> 当我们上传的文件很大，后台需要处理的时间很长，用户期望切换到其它页面继续工作，而不需要等待完成。这时候我们可以采用异步上传的方式。

在SpringBoot中将一个方法声明为异步方法非常简单，只需两个注解即可@EnableAsync和@Async。
1. @EnableAsync用于开启SpringBoot支持异步的功能，用在SpringBoot的启动类上。
```java
@SpringBootApplication
@EnableAsync // 这里
public class App {
 
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```
2. @Async用于方法上，标记该方法为异步处理方法。
```java
@Service
public class UserServiceImpl {
 
    @Async // 这里带@Async的方法，会被当成一个子线程
    public void processFile(InputStream inputStream) {
        
    }
}
```
## 70.3 实现案例

### 70.3.1 分片

#### 前端实现（Vue2 + Element UI）

```vue
<template>
  <div class="upload-container">
    <el-upload
      class="upload-demo"
      drag
      :auto-upload="false"
      :on-change="handleFileChange"
      :file-list="fileList">
      <i class="el-icon-upload"></i>
      <div class="el-upload__text">将文件拖到此处，或<em>点击上传</em></div>
    </el-upload>
    
    <el-progress 
      :percentage="uploadProgress" 
      :status="uploadStatus"
      v-if="uploadProgress > 0">
    </el-progress>
    
    <el-button 
      type="primary" 
      @click="startUpload" 
      :disabled="!currentFile">
      开始上传
    </el-button>
  </div>
</template>

<script>
import SparkMD5 from 'spark-md5'

export default {
  name: 'BigFileUpload',
  data() {
    return {
      fileList: [],
      currentFile: null,
      chunkSize: 2 * 1024 * 1024, // 2MB每片
      uploadedChunks: new Set(),
      uploadProgress: 0,
      uploadStatus: ''
    }
  },
  methods: {
    handleFileChange(file) {
      this.currentFile = file.raw
    },
    
    // 计算文件MD5（用于秒传和分片标识）
    async calculateFileMD5(file) {
      return new Promise((resolve, reject) => {
        const spark = new SparkMD5.ArrayBuffer()
        const fileReader = new FileReader()
        const chunkSize = 2 * 1024 * 1024
        const chunks = Math.ceil(file.size / chunkSize)
        let currentChunk = 0
        
        fileReader.onload = e => {
          spark.append(e.target.result)
          currentChunk++
          
          if (currentChunk < chunks) {
            loadNext()
          } else {
            resolve(spark.end())
          }
        }
        
        fileReader.onerror = reject
        
        const loadNext = () => {
          const start = currentChunk * chunkSize
          const end = Math.min(start + chunkSize, file.size)
          fileReader.readAsArrayBuffer(file.slice(start, end))
        }
        
        loadNext()
      })
    },
    
    // 文件分片
    createFileChunks(file, chunkSize) {
      const chunks = []
      let cur = 0
      let index = 0
      
      while (cur < file.size) {
        chunks.push({
          index: index++,
          file: file.slice(cur, cur + chunkSize),
          start: cur,
          end: Math.min(cur + chunkSize, file.size)
        })
        cur += chunkSize
      }
      return chunks
    },
    
    async startUpload() {
      if (!this.currentFile) return
      
      try {
        // 1. 计算文件MD5
        const fileMD5 = await this.calculateFileMD5(this.currentFile)
        
        // 2. 检查秒传
        const quickUpload = await this.checkQuickUpload(fileMD5, this.currentFile.name)
        if (quickUpload) {
          this.uploadProgress = 100
          this.uploadStatus = 'success'
          this.$message.success('秒传成功！')
          return
        }
        
        // 3. 检查已上传分片
        await this.checkUploadedChunks(fileMD5)
        
        // 4. 分片上传
        const chunks = this.createFileChunks(this.currentFile, this.chunkSize)
        await this.uploadChunks(chunks, fileMD5)
        
        // 5. 合并文件
        await this.mergeChunks(fileMD5, this.currentFile.name)
        
        this.uploadStatus = 'success'
        this.$message.success('文件上传成功！')
      } catch (error) {
        this.uploadStatus = 'exception'
        this.$message.error('上传失败：' + error.message)
      }
    },
    
    async uploadChunks(chunks, fileMD5) {
      for (const chunk of chunks) {
        // 跳过已上传的分片
        if (this.uploadedChunks.has(chunk.index)) continue
        
        const formData = new FormData()
        formData.append('file', chunk.file)
        formData.append('chunkIndex', chunk.index)
        formData.append('chunkSize', this.chunkSize)
        formData.append('fileMD5', fileMD5)
        formData.append('totalChunks', chunks.length)
        formData.append('fileName', this.currentFile.name)
        
        try {
          await this.$http.post('/api/upload/chunk', formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
            timeout: 30000
          })
          
          this.uploadedChunks.add(chunk.index)
          this.uploadProgress = Math.round((this.uploadedChunks.size / chunks.length) * 100)
        } catch (error) {
          throw new Error(`分片${chunk.index}上传失败`)
        }
      }
    }
  }
}
</script>
```

#### 后端实现（SpringBoot）

```java
// 分片上传请求DTO
@Data
public class ChunkUploadDTO {
    private MultipartFile file;
    private Integer chunkIndex;
    private Long chunkSize;
    private String fileMD5;
    private Integer totalChunks;
    private String fileName;
}

// 分片上传服务
@Service
@Slf4j
public class ChunkUploadService {
    
    @Value("${file.upload.path}")
    private String uploadPath;
    
    @Value("${file.upload.temp-path}")
    private String tempPath;
    
    // 保存分片文件
    public void saveChunk(ChunkUploadDTO chunkDTO) throws IOException {
        String chunkDir = getChunkDir(chunkDTO.getFileMD5());
        File dir = new File(chunkDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        // 分片文件名格式：chunkIndex.fileMD5.chunk
        String chunkFilename = String.format("%d.%s.chunk", 
            chunkDTO.getChunkIndex(), chunkDTO.getFileMD5());
        File chunkFile = new File(dir, chunkFilename);
        
        // 保存分片
        chunkDTO.getFile().transferTo(chunkFile);
        
        log.info("分片保存成功：{}", chunkFilename);
    }
    
    // 获取分片目录
    private String getChunkDir(String fileMD5) {
        return tempPath + File.separator + "chunks" + File.separator + fileMD5;
    }
}

// 分片上传控制器
@RestController
@RequestMapping("/api/upload")
@Slf4j
public class ChunkUploadController {
    
    @Autowired
    private ChunkUploadService chunkUploadService;
    
    @PostMapping("/chunk")
    public ResponseEntity<Map<String, Object>> uploadChunk(ChunkUploadDTO chunkDTO) {
        try {
            chunkUploadService.saveChunk(chunkDTO);
            
            Map<String, Object> result = new HashMap<>();
            result.put("success", true);
            result.put("chunkIndex", chunkDTO.getChunkIndex());
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("分片上传失败", e);
            return ResponseEntity.status(500).body(
                Map.of("success", false, "message", e.getMessage()));
        }
    }
}
```

### 70.3.2 断点续传

#### 前端实现

```javascript
// 在Vue组件中添加断点续传相关方法
methods: {
    // 检查已上传的分片
    async checkUploadedChunks(fileMD5) {
        try {
            const response = await this.$http.post('/api/upload/check-chunks', {
                fileMD5: fileMD5
            })
            
            if (response.data.success) {
                this.uploadedChunks = new Set(response.data.uploadedChunks)
                this.$message.info(`发现${this.uploadedChunks.size}个分片已上传，继续上传剩余分片`)
            }
        } catch (error) {
            console.error('检查已上传分片失败:', error)
        }
    },
    
    // 暂停上传
    pauseUpload() {
        this.isPaused = true
        this.$message.info('上传已暂停')
    },
    
    // 继续上传
    async resumeUpload() {
        if (!this.currentFile || this.uploadProgress === 100) return
        
        this.isPaused = false
        await this.startUpload()
    }
}
```

#### 后端实现

```java
// 文件分片信息实体
@Entity
@Table(name = "file_chunk_info")
@Data
public class FileChunkInfo {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String fileMD5;
    
    @Column(nullable = false)
    private Integer chunkIndex;
    
    @Column(nullable = false)
    private String chunkMD5;
    
    @Column(nullable = false)
    private Long chunkSize;
    
    @Column(nullable = false)
    private String chunkPath;
    
    @Column(nullable = false)
    private Boolean uploaded = false;
    
    @CreationTimestamp
    private LocalDateTime createTime;
}

// 断点续传服务
@Service
@Slf4j
public class ResumeUploadService {
    
    @Autowired
    private FileChunkInfoRepository chunkInfoRepository;
    
    // 检查已上传的分片
    public List<Integer> getUploadedChunks(String fileMD5) {
        return chunkInfoRepository.findByFileMD5AndUploadedTrue(fileMD5)
            .stream()
            .map(FileChunkInfo::getChunkIndex)
            .collect(Collectors.toList());
    }
    
    // 记录分片上传信息
    @Transactional
    public void recordChunkUpload(ChunkUploadDTO chunkDTO, String chunkPath) {
        FileChunkInfo chunkInfo = chunkInfoRepository
            .findByFileMD5AndChunkIndex(chunkDTO.getFileMD5(), chunkDTO.getChunkIndex())
            .orElse(new FileChunkInfo());
        
        chunkInfo.setFileMD5(chunkDTO.getFileMD5());
        chunkInfo.setChunkIndex(chunkDTO.getChunkIndex());
        chunkInfo.setChunkSize(chunkDTO.getChunkSize());
        chunkInfo.setChunkPath(chunkPath);
        chunkInfo.setUploaded(true);
        
        try {
            chunkInfo.setChunkMD5(calculateChunkMD5(chunkDTO.getFile()));
        } catch (IOException e) {
            log.error("计算分片MD5失败", e);
        }
        
        chunkInfoRepository.save(chunkInfo);
    }
    
    private String calculateChunkMD5(MultipartFile file) throws IOException {
        return DigestUtils.md5DigestAsHex(file.getInputStream());
    }
}

// 断点续传控制器
@RestController
@RequestMapping("/api/upload")
@Slf4j
public class ResumeUploadController {
    
    @Autowired
    private ResumeUploadService resumeUploadService;
    
    @PostMapping("/check-chunks")
    public ResponseEntity<Map<String, Object>> checkUploadedChunks(
            @RequestBody CheckChunksRequest request) {
        
        try {
            List<Integer> uploadedChunks = resumeUploadService.getUploadedChunks(request.getFileMD5());
            
            Map<String, Object> result = new HashMap<>();
            result.put("success", true);
            result.put("uploadedChunks", uploadedChunks);
            result.put("uploadedCount", uploadedChunks.size());
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("检查已上传分片失败", e);
            return ResponseEntity.status(500).body(
                Map.of("success", false, "message", e.getMessage()));
        }
    }
}
```

### 70.3.3 秒传

#### 前端实现

```javascript
methods: {
    // 检查秒传
    async checkQuickUpload(fileMD5, fileName) {
        try {
            const response = await this.$http.post('/api/upload/quick-upload', {
                fileMD5: fileMD5,
                fileName: fileName,
                fileSize: this.currentFile.size
            })
            
            if (response.data.exists) {
                return true
            }
        } catch (error) {
            console.error('秒传检查失败:', error)
        }
        return false
    }
}
```

#### 后端实现

```java
// 文件信息实体
@Entity
@Table(name = "file_info")
@Data
public class FileInfo {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String fileMD5;
    
    @Column(nullable = false)
    private String fileName;
    
    @Column(nullable = false)
    private Long fileSize;
    
    @Column(nullable = false)
    private String filePath;
    
    @Column(nullable = false)
    private Boolean uploaded = false;
    
    @Column(nullable = false)
    private Integer chunkCount;
    
    @CreationTimestamp
    private LocalDateTime createTime;
    
    @UpdateTimestamp
    private LocalDateTime updateTime;
}

// 秒传服务
@Service
@Slf4j
public class QuickUploadService {
    
    @Autowired
    private FileInfoRepository fileInfoRepository;
    
    @Value("${file.upload.path}")
    private String uploadPath;
    
    // 检查文件是否已存在（秒传）
    public boolean checkFileExists(String fileMD5, String fileName, Long fileSize) {
        // 1. 检查数据库记录
        Optional<FileInfo> fileInfoOpt = fileInfoRepository.findByFileMD5AndUploadedTrue(fileMD5);
        if (fileInfoOpt.isPresent()) {
            log.info("文件已存在（数据库记录），可秒传：{}", fileName);
            return true;
        }
        
        // 2. 检查实际文件是否存在
        File file = new File(uploadPath, fileName);
        if (file.exists() && file.length() == fileSize) {
            // 验证文件完整性
            if (validateFileMD5(file, fileMD5)) {
                log.info("文件已存在（物理文件），可秒传：{}", fileName);
                // 创建数据库记录
                createFileRecord(fileMD5, fileName, fileSize, file.getAbsolutePath());
                return true;
            }
        }
        
        return false;
    }
    
    // 验证文件MD5
    private boolean validateFileMD5(File file, String expectedMD5) {
        try (FileInputStream fis = new FileInputStream(file)) {
            String actualMD5 = DigestUtils.md5DigestAsHex(fis);
            return expectedMD5.equals(actualMD5);
        } catch (IOException e) {
            log.error("验证文件MD5失败", e);
            return false;
        }
    }
    
    // 创建文件记录
    private void createFileRecord(String fileMD5, String fileName, Long fileSize, String filePath) {
        FileInfo fileInfo = new FileInfo();
        fileInfo.setFileMD5(fileMD5);
        fileInfo.setFileName(fileName);
        fileInfo.setFileSize(fileSize);
        fileInfo.setFilePath(filePath);
        fileInfo.setUploaded(true);
        fileInfo.setChunkCount(1); // 秒传文件视为一个完整分片
        
        fileInfoRepository.save(fileInfo);
    }
}

// 秒传控制器
@RestController
@RequestMapping("/api/upload")
@Slf4j
public class QuickUploadController {
    
    @Autowired
    private QuickUploadService quickUploadService;
    
    @PostMapping("/quick-upload")
    public ResponseEntity<Map<String, Object>> checkQuickUpload(
            @RequestBody QuickUploadRequest request) {
        
        try {
            boolean exists = quickUploadService.checkFileExists(
                request.getFileMD5(), 
                request.getFileName(), 
                request.getFileSize()
            );
            
            Map<String, Object> result = new HashMap<>();
            result.put("exists", exists);
            result.put("success", true);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("秒传检查失败", e);
            return ResponseEntity.status(500).body(
                Map.of("success", false, "message", e.getMessage()));
        }
    }
}
```

## 实现原理总结

### 分片上传原理
1. **前端分片**：使用File API的slice方法将大文件切割成小分片
2. **并发控制**：通过Promise.all或循环控制分片上传顺序
3. **后端存储**：每个分片单独存储，记录分片索引和文件标识

### 断点续传原理
1. **状态记录**：数据库记录每个分片的上传状态
2. **断点检测**：上传前检查哪些分片已经上传完成
3. **续传机制**：只上传未完成的分片，跳过已上传分片

### 秒传原理
1. **文件指纹**：通过MD5等哈希算法生成文件唯一标识
2. **快速比对**：上传前先比对服务器是否已有相同文件
3. **跳过上传**：如果文件已存在，直接创建文件引用而不实际传输

这种方案能够有效解决大文件上传的网络不稳定、服务器压力大、用户体验差等问题。
# 七十一、SpringBoot集成文件 - 集成POI之Excel导入导出
## 71.1 知识准备
> 需要了解POI工具，以及POI对Excel中的对象的封装对应关系。
### 71.1.1 什么是POI
> Apache POI 是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程序对Microsoft Office格式档案读和写的功能。POI为“Poor Obfuscation Implementation”的首字母缩写，意为“简洁版的模糊实现”。

Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。用它可以使用Java读取和创建,修改MS Excel文件.而且,还可以使用Java读取和创建MS Word和MSPowerPoint文件。更多请参考<a href='https://poi.apache.org/index.html'>官方文档</a>

### 71.1.2 POI中基础概念
> 生成xls和xlsx有什么区别？POI对Excel中的对象的封装对应关系？

生成xls和xlsx有什么区别呢？
![258.Image20251201103112130.png](../../assets/images/04-主流框架/spring/258.Image20251201103112130.png)

POI对Excel中的对象的封装对应关系如下：
![259.Image20251201103143306.png](../../assets/images/04-主流框架/spring/259.Image20251201103143306.png)
### 71.2.3 OOXML/OLE2协议

#### 71.2.3.1 核心摘要

-   **OLE2 (旧时代)：** 这是微软 Office 97 到 Office 2003 使用的默认二进制格式（如 `.doc`, `.xls`, `.ppt`）。它的核心是一个**复杂的“文件系统”**。
-   **OOXML (新时代)：** 这是微软 Office 2007 及之后版本使用的默认格式（如 `.docx`, `.xlsx`, `.pptx`）。它的核心是**一组基于 ZIP 和 XML 的规范**。

---

##### 71.2.3.1.1 OLE 2 复合文档格式 (OLE2)

OLE2 是一种**二进制复合文档格式**，可以理解为一个微型且复杂的“文件系统”存储在一个文件里。

-   **设计理念：** 模拟一个文件系统，用于存储和关联多种类型的数据（如文本、表格、图片、嵌入对象）。
-   **技术基础：**
    - **二进制结构：** 它不是人类可读的，必须用专门的解析器来读写。
    - **存储（Storages）和流（Streams）：** 类似于文件系统中的“目录”和“文件”。一个 OLE2 文件包含一个根存储，里面可以包含多个子存储和流。
    - **FAT（文件分配表）：** 内部使用一种类似 FAT 文件系统的机制来管理存储空间中数据块的位置，这使得其结构相当复杂。
-   **文件扩展名：** `.doc`, `.xls`, `.ppt` (Office 2003 及更早版本)。
-   **优缺点：**
    - **优点：** 在当时的硬件条件下，二进制格式处理效率较高。
    - **缺点：**
        - **格式封闭复杂：** 解析和生成非常困难，第三方兼容性差。
        - **安全性问题：** 复杂的二进制结构容易隐藏恶意代码（宏病毒等）。
        - **不易互操作：** 很难被其他非微软的办公软件完美支持。

##### 71.2.3.1.2 Office Open XML (OOXML)

OOXML 是微软为了响应开放标准趋势（特别是竞争对手的 OpenDocument Format, ODF）而推出的新一代格式。它本质上是一个**开放标准**（ECMA-376, ISO/IEC 29500）。

-   **设计理念：** 使用广泛支持的、现代的技术（ZIP, XML）来构建文档格式，提高互操作性和透明度。
-   **技术基础：**
    - **ZIP 压缩包：** 一个 `.docx` 文件实际上就是一个 ZIP 压缩包。你可以将其后缀改为 `.zip`，然后直接用解压软件打开，会看到里面清晰的目录和文件结构。
    - **XML 描述：** 包内的内容（文档结构、样式、设置、文本内容等）都是用良构的 XML 文件来描述的。
    - **分离关注点：** 不同的内容被分离到不同的 XML 文件中。例如，一个典型的 `.xlsx` 文件包含：
        - `[Content_Types].xml` (定义包内部件的类型)
        - `xl/workbook.xml` (工作簿结构)
        - `xl/worksheets/sheet1.xml` (工作表数据)
        - `xl/styles.xml` (样式信息)
        - `xl/sharedStrings.xml` (共享字符串池)
        - `_rels/` 目录 (定义部件之间的关系)
-   **文件扩展名：** `.docx`, `.xlsx`, `.pptx`。
-   **优缺点：**
    - **优点：**
        - **开放与可互操作：** 标准公开，任何开发者都可以依据标准实现读写功能，极大地改善了跨平台、跨应用的支持（如 LibreOffice, Google Docs, Apple Numbers 等）。
        - **人类可读（部分）：** 虽然压缩后不是直接可读，但解压后的 XML 内容是可读、可调试的。
        - **文件体积更小：** 得益于 ZIP 压缩。
        - **更安全：** XML 结构不易隐藏恶意代码，宏等内容被隔离存储。
        - **模块化：** 损坏的文件有更高几率被修复，因为可以单独替换损坏的部件。
    - **缺点：**
        - **处理开销：** 相对于直接读写二进制，需要解压/压缩和解析/生成 XML，对性能有一定影响（但现代硬件已基本无感）。
        - **复杂度：** 标准文档极其庞大，实现完整的兼容性依然是一项艰巨的任务。

---

#### 71.2.3.3 对比表格

| 特性 | OLE2 复合文档格式 | Office Open XML (OOXML) |
| :--- | :--- | :--- |
| **本质** | 二进制“文件系统” | 基于 ZIP 和 XML 的开放标准 |
| **文件扩展名** | `.doc`, `.xls`, `.ppt` | `.docx`, `.xlsx`, `.pptx` |
| **可读性** | 二进制，不可读 | 压缩包内为 XML，可读性强 |
| **标准状态** | 微软私有格式 | ECMA 和 ISO 国际标准 |
| **第三方支持** | 困难，兼容性差 | 容易，已成为事实标准 |
| **文件大小** | 相对较大 | 经 ZIP 压缩，相对较小 |
| **安全性** | 较低，易藏匿病毒 | 较高，结构清晰 |
| **复杂度** | 解析复杂 | 标准庞大，但结构清晰 |

#### 71.2.3.4 在 EasyPOI 中的体现

当你使用 EasyPOI 时，你会直接感受到这两种格式的区别：

-   当你导出文件为 **`.xlsx`** 格式时，EasyPOI 底层使用的是 **Apache POI 的 XSSF** 实现，该实现就是遵循 **OOXML** 标准来生成 ZIP 包和内部的 XML 文件。
-   当你导出文件为 **`.xls`** 格式时，EasyPOI 底层使用的是 **Apache POI 的 HSSF** 实现，该实现就是用于处理旧的 **OLE2** 二进制格式。

#### 71.2.3.5 结论

从 OLE2 到 OOXML 的转变，是文档格式从**封闭、复杂、私有**走向**开放、模块化、标准化**的标志。OOXML 凭借其技术优势和完善的生态系统，已经成为当今办公文档交换的**事实标准**。虽然 OLE2 格式正在逐渐退出历史舞台，但出于兼容旧系统的需求，像 POI 这样的库仍然需要同时支持这两种格式。
## 71.2 实现案例
### 71.2.1 Pom依赖
```xml
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>5.2.2</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.2</version>
</dependency>
```
### 71.2.2 导出Excel
UserController中导出的方法
```java
@ApiOperation("Download Excel")
@GetMapping("/excel/download")
public void download(HttpServletResponse response) {
    try {
        SXSSFWorkbook workbook = userService.generateExcelWorkbook();
        response.reset();
        response.setContentType("application/vnd.ms-excel");
        response.setHeader("Content-disposition",
                "attachment;filename=user_excel_" + System.currentTimeMillis() + ".xlsx");
        OutputStream os = response.getOutputStream();
        workbook.write(os);
        workbook.dispose();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
UserServiceImple中导出Excel的主方法
```java
private static final int POSITION_ROW = 1;
private static final int POSITION_COL = 1;

/**
  * @return SXSSFWorkbook
  */
@Override
public SXSSFWorkbook generateExcelWorkbook() {
    SXSSFWorkbook workbook = new SXSSFWorkbook();
    Sheet sheet = workbook.createSheet();

    int rows = POSITION_ROW;
    int cols = POSITION_COL;

    // 表头
    Row head = sheet.createRow(rows++);
    String[] columns = new String[]{"ID", "Name", "Email", "Phone", "Description"};
    int[] colWidths = new int[]{2000, 3000, 5000, 5000, 8000};
    CellStyle headStyle = getHeadCellStyle(workbook);
    for (int i = 0; i < columns.length; ++i) {
        sheet.setColumnWidth(cols, colWidths[i]);
        addCellWithStyle(head, cols++, headStyle).setCellValue(columns[i]);
    }

    // 表内容
    CellStyle bodyStyle = getBodyCellStyle(workbook);
    for (User user : getUserList()) {
        cols = POSITION_COL;
        Row row = sheet.createRow(rows++);
        addCellWithStyle(row, cols++, bodyStyle).setCellValue(user.getId());
        addCellWithStyle(row, cols++, bodyStyle).setCellValue(user.getUserName());
        addCellWithStyle(row, cols++, bodyStyle).setCellValue(user.getEmail());
        addCellWithStyle(row, cols++, bodyStyle).setCellValue(String.valueOf(user.getPhoneNumber()));
        addCellWithStyle(row, cols++, bodyStyle).setCellValue(user.getDescription());
    }
    return workbook;
}

private Cell addCellWithStyle(Row row, int colPosition, CellStyle cellStyle) {
    Cell cell = row.createCell(colPosition);
    cell.setCellStyle(cellStyle);
    return cell;
}

private List<User> getUserList() {
    return Collections.singletonList(User.builder()
            .id(1L).userName("pdai").email("pdai@pdai.tech").phoneNumber(121231231231L)
            .description("hello world")
            .build());
}

private CellStyle getHeadCellStyle(Workbook workbook) {
    CellStyle style = getBaseCellStyle(workbook);

    // fill
    style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
    style.setFillPattern(FillPatternType.SOLID_FOREGROUND);

    return style;
}

private CellStyle getBodyCellStyle(Workbook workbook) {
    return getBaseCellStyle(workbook);
}

private CellStyle getBaseCellStyle(Workbook workbook) {
    CellStyle style = workbook.createCellStyle();

    // font
    Font font = workbook.createFont();
    font.setBold(true);
    style.setFont(font);

    // align
    style.setAlignment(HorizontalAlignment.CENTER);
    style.setVerticalAlignment(VerticalAlignment.TOP);

    // border
    style.setBorderBottom(BorderStyle.THIN);
    style.setBottomBorderColor(IndexedColors.BLACK.getIndex());
    style.setBorderLeft(BorderStyle.THIN);
    style.setLeftBorderColor(IndexedColors.BLACK.getIndex());
    style.setBorderRight(BorderStyle.THIN);
    style.setRightBorderColor(IndexedColors.BLACK.getIndex());
    style.setBorderTop(BorderStyle.THIN);
    style.setTopBorderColor(IndexedColors.BLACK.getIndex());

    return style;
}
```
导出后的excel如下
![260.springboot-file-excel-poi-2.png](../../assets/images/04-主流框架/spring/260.springboot-file-excel-poi-2.png)
### 71.2.3 导入Excel
UserController中导入的方法
```java
@ApiOperation("Upload Excel")
@PostMapping("/excel/upload")
public ResponseResult<String> upload(@RequestParam(value = "file", required = true) MultipartFile file) {
    try {
        userService.upload(file.getInputStream());
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseResult.fail(e.getMessage());
    }
    return ResponseResult.success();
}
```
UserServiceImple中导入Excel的主方法
```java
@Override
public void upload(InputStream inputStream) throws IOException {
    XSSFWorkbook book = new XSSFWorkbook(inputStream);
    XSSFSheet sheet = book.getSheetAt(0);
    // add some validation here

    // parse data
    int cols;
    for (int i = POSITION_ROW; i < sheet.getLastRowNum(); i++) {
        XSSFRow row = sheet.getRow(i + 1); // 表头不算
        cols = POSITION_COL;
        User user = User.builder()
                .id(getCellLongValue(row.getCell(cols++)))
                .userName(getCellStringValue(row.getCell(cols++)))
                .email(getCellStringValue(row.getCell(cols++)))
                .phoneNumber(Long.parseLong(getCellStringValue(row.getCell(cols++))))
                .description(getCellStringValue(row.getCell(cols++)))
                .build();
        log.info(user.toString());
    }

    book.close();
}

private String getCellStringValue(XSSFCell cell) {
    try {
        if (null!=cell) {
            return String.valueOf(cell.getStringCellValue());
        }
    } catch (Exception e) {
        return String.valueOf(getCellIntValue(cell));
    }
    return "";
}

private long getCellLongValue(XSSFCell cell) {
    try {
        if (null!=cell) {
            return Long.parseLong("" + (long) cell.getNumericCellValue());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return 0L;
}

private int getCellIntValue(XSSFCell cell) {
    try {
        if (null!=cell) {
            return Integer.parseInt("" + (int) cell.getNumericCellValue());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return 0;
}
```
通过PostMan进行接口测试
![261.springboot-file-excel-poi-1.png](../../assets/images/04-主流框架/spring/261.springboot-file-excel-poi-1.png)

执行接口后，后台的日志如下
```sh
2022-06-10 21:36:01.720  INFO 15100 --- [nio-8080-exec-2] t.p.s.f.e.p.s.impl.UserServiceImpl       : User(id=1, userName=pdai, email=pdai@pdai.tech, phoneNumber=121231231231, description=hello world)
```
# 七十二、SpringBoot集成文件 - 集成EasyExcel之Excel导入导出
> EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。它能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。它是基于POI来封装实现的，主要解决其易用性，封装性和性能问题。本文主要介绍通过SpringBoot集成Excel实现Excel的导入，导出和填充模板等功能。
## 72.1 知识准备
> 需要了解EasyExcel，以及这个工具设计的初衷(为什么有了POI，还会需要EasyExcel?)。

### 72.1.1 什么是EasyExcel
> EasyExcel是阿里开源的基于POI封装的Excel处理工具，更多请参考<a href='https://easyexcel.opensource.alibaba.com/expert/question-history-14638'>官方文档</a>。

EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。它能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。
### 72.1.2 EasyExcel要解决POI什么问题？
> 因为EasyExcel是基于POI封装的，主要考虑的是易用性，封装性和性能问题。

Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，一个3M的excel用POI sax解析依然需要100M左右内存，改用easyexcel可以降低到几M，并且再大的excel也不会出现内存溢出；03版依赖POI的sax模式，在上层做了模型转换的封装，让使用者更加简单方便。
## 72.3 实现案例
### 72.3.1 Pom依赖
```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>easyexcel</artifactId>
    <version>3.1.1</version>
</dependency>
```
### 72.3.2 导出Excel
User类
```java
package tech.pdai.springboot.file.excel.easyexcel.entity;

import com.alibaba.excel.annotation.ExcelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author pdai
 */
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements BaseEntity {

    /**
     * user id.
     */
    @ExcelProperty("ID")
    private Long id;

    /**
     * username.
     */
    @ExcelProperty("Name")
    private String userName;

    /**
     * email.
     */
    @ExcelProperty("Email")
    private String email;

    /**
     * phoneNumber.
     */
    @ExcelProperty("Phone")
    private long phoneNumber;

    /**
     * description.
     */
    @ExcelProperty("Description")
    private String description;

}
```
UserController中导出的方法
```java
@ApiOperation("Download Excel")
@GetMapping("/excel/download")
public void download(HttpServletResponse response) {
    try {
        response.reset();
        response.setContentType("application/vnd.ms-excel");
        response.setHeader("Content-disposition",
                "attachment;filename=user_excel_" + System.currentTimeMillis() + ".xlsx");
        userService.downloadExcel(response.getOutputStream());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
UserServiceImple中导出Excel的主方法(是不是很简洁)
```java
@Override
public void downloadExcel(ServletOutputStream outputStream) {
    EasyExcelFactory.write(outputStream, User.class).sheet("User").doWrite(this::getUserList);
}
private List<User> getUserList() {
    return Collections.singletonList(User.builder()
            .id(1L).userName("pdai").email("pdai@pdai.tech").phoneNumber(121231231231L)
            .description("hello world")
            .build());
}
```
导出后的excel如下
![262.springboot-file-excel-easyexcel-1.png](../../assets/images/04-主流框架/spring/262.springboot-file-excel-easyexcel-1.png)
### 72.3.3 导入Excel
UserController中导入的方法

```java
@ApiOperation("Upload Excel")
@PostMapping("/excel/upload")
public ResponseResult<String> upload(@RequestParam(value = "file", required = true) MultipartFile file) {
    try {
        userService.upload(file.getInputStream());
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseResult.fail(e.getMessage());
    }
    return ResponseResult.success();
}
```
UserServiceImple中导入Excel的主方法
```java
@Override
public void upload(InputStream inputStream) throws IOException {
    // ReadListener不是必须的，它主要的设计是读取excel数据的后置处理(并考虑一次性读取到内存潜在的内存泄漏问题)
    EasyExcelFactory.read(inputStream, User.class, new ReadListener<User>() {

        @Override
        public void invoke(User user, AnalysisContext analysisContext) {
            cachedDataList.add(user);
        }

        @Override
        public void doAfterAllAnalysed(AnalysisContext analysisContext) {
            cachedDataList.forEach(user -> log.info(user.toString()));
        }
    }).sheet().doRead();
}
```
通过PostMan进行接口测试
![263.springboot-file-excel-easyexcel-2.png](../../assets/images/04-主流框架/spring/263.springboot-file-excel-easyexcel-2.png)

这里注意下，需要有字体的支持，比如如果没有字体支撑将会报如下告警：
```sh
Warning: the font "Times" is not available, so "Lucida Bright" has been substituted, but may have unexpected appearance or behavor. Re-enable the "Times" font to remove this warning.
```
### 72.3.4 填充Excel模板
我们先来准备一个excel模板，考虑了横向表和纵向列表，以及单一信息等，基本上能满足多数的应用场景。
![264.springboot-file-excel-easyexcel-4.png](../../assets/images/04-主流框架/spring/264.springboot-file-excel-easyexcel-4.png)

UserController中下载填充后的Excel方法
```java
@ApiOperation("Fill Excel Template")
@GetMapping("/excel/fill")
public void fillTemplate(HttpServletResponse response) {
    try {
        response.reset();
        response.setContentType("application/vnd.ms-excel");
        response.setHeader("Content-disposition",
                "attachment;filename=user_excel_template_" + System.currentTimeMillis() + ".xlsx");
        userService.fillExcelTemplate(response.getOutputStream());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
UserServiceImpl中填充excel模板的方法
```java
// 模板注意 用{} 来表示你要用的变量 如果本来就有"{","}" 特殊字符 用"\{","\}"代替
// {} 代表普通变量 {.} 代表是list的变量 {前缀.} 前缀可以区分不同的list
@Override
public void fillExcelTemplate(ServletOutputStream outputStream) {

    // 确保文件可访问，这个例子的excel模板，放在根目录下面
    String templateFileName = "/Users/pdai/Downloads/user_excel_template.xlsx";

    // 方案1
    try (ExcelWriter excelWriter = EasyExcelFactory.write(outputStream).withTemplate(templateFileName).build()) {
        WriteSheet writeSheet = EasyExcelFactory.writerSheet().build();
        FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();
        // 如果有多个list 模板上必须有{前缀.} 这里的前缀就是 userList，然后多个list必须用 FillWrapper包裹
        excelWriter.fill(new FillWrapper("userList", getUserList()), fillConfig, writeSheet);
        excelWriter.fill(new FillWrapper("userList", getUserList()), fillConfig, writeSheet);

        excelWriter.fill(new FillWrapper("userList2", getUserList()), writeSheet);
        excelWriter.fill(new FillWrapper("userList2", getUserList()), writeSheet);

        Map<String, Object> map = new HashMap<>();
        map.put("user", "pdai");
        map.put("date", new Date());

        excelWriter.fill(map, writeSheet);
    }
}
```
访问http://localhost:8080/user/excel/fill 下载
![265.springboot-file-excel-easyexcel-3.png](../../assets/images/04-主流框架/spring/265.springboot-file-excel-easyexcel-3.png)
# 七十三、SpringBoot集成文件 - 集成EasyPOI之Excel导入导出
> 除了POI和EasyExcel，国内还有一个EasyPOI框架较为常见，适用于没有使用过POI并希望快速操作Excel的入门项目，在中大型项目中并不推荐使用(为了保证知识体系的完整性，把EasyPOI也加了进来)。本文主要介绍SpringBoot集成EasyPOI实现Excel的导入，导出和填充模板等功能。
## 73.1 知识准备
### 73.1.1 什么是EasyPOI
独特的功能：
- 基于注解的导入导出,修改注解就可以修改Excel
- 支持常用的样式自定义
- 基于map可以灵活定义的表头字段
- 支持一堆多的导出,导入
- 支持模板的导出,一些常见的标签,自定义标签
- 支持HTML/Excel转换,如果模板还不能满足用户的变态需求,请用这个功能支持word的导出,
- 支持图片,Excel
### 73.1.2 如何看待EasyPOI
> 不建议在稍复杂的项目中使用EasyPOI。
- 简单的功能通过对POI的封装成本也不高，复杂的一点的适配性差；有点像为了做某件事方便，引入了一个工具，最后发现大量的时间都在迎合/修理这个工具
- 个人色彩，缺少稳定维护团队，潜在风险远大于节约的这点时间；同时个人开源又期望寻求盈利点，对开发者选择而言是要很慎重的。
- 封装的思路可以借鉴下，在自行根据业务封装时可以参考下
## 73.2 实现案例
### 73.2.1 Pom依赖
```xml
<dependency>
    <groupId>cn.afterturn</groupId>
    <artifactId>easypoi-spring-boot-starter</artifactId>
    <version>4.4.0</version>
</dependency>
```
### 73.2.2 导出Excel
User 类
```java
package tech.pdai.springboot.file.excel.easypoi.entity;

import cn.afterturn.easypoi.excel.annotation.Excel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author pdai
 */
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements BaseEntity {

    /**
     * user id.
     */
    @Excel(name = "ID")
    private Long id;

    /**
     * username.
     */
    @Excel(name = "Name")
    private String userName;

    /**
     * email.
     */
    @Excel(name = "Email")
    private String email;

    /**
     * phoneNumber.
     */
    @Excel(name = "Phone")
    private long phoneNumber;

    /**
     * description.
     */
    @Excel(name = "Description")
    private String description;


}
```
UserController中导出的方法
```java
@ApiOperation("Download Excel")
@GetMapping("/excel/download")
public void download(HttpServletResponse response) {
    try {
        response.reset();
        response.setContentType("application/vnd.ms-excel");
        response.setHeader("Content-disposition",
                "attachment;filename=user_excel_" + System.currentTimeMillis() + ".xlsx");
        userService.downloadExcel(response.getOutputStream());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
UserServiceImple中导出Excel的主方法
```java
@Override
public void downloadExcel(ServletOutputStream outputStream) throws IOException {
    ExportParams exportParams = new ExportParams();
    exportParams.setTitle("User Table");
    exportParams.setSheetName("User Sheet");
    Workbook workbook = ExcelExportUtil.exportExcel(exportParams, User.class, getUserList());
    workbook.write(outputStream);
    workbook.close();
}
```
导出后的excel如下
![266.springboot-file-excel-easypoi-1.png](../../assets/images/04-主流框架/spring/266.springboot-file-excel-easypoi-1.png)

当getUserList用 Collections.singletonList时是直接报错，看了下源码~
```java
private List<User> getUserList() {
    return Collections.singletonList(User.builder()
            .id(1L).userName("pdai").email("pdai@pdai.tech").phoneNumber(121231231231L)
            .description("hello world")
            .build());
}
```
默默改成ArrayList, 因为源代码是通过remove来迭代的，且只对Unmodified Collection做了处理，而没有对singletonList... 只能说不建议在稍复杂的项目中使用EasyPOI...
1. Collections.singletonList()
- **特点**：创建**单元素不可变集合**
- **内存**：最节省内存，专门为单个元素优化
- **修改操作**：**不支持**任何修改操作（add/remove/set等）
- **使用场景**：返回固定单元素集合，确保不被修改

```java
List<String> list = Collections.singletonList("single");
list.add("another");    // 抛出 UnsupportedOperationException
list.remove(0);         // 抛出 UnsupportedOperationException
```

2. new ArrayList()
- **特点**：标准的**可变数组列表**
- **内存**：初始容量10，动态扩容
- **修改操作**：**支持**所有修改操作
- **使用场景**：需要动态增删改的集合

```java
List<String> list = new ArrayList<>();
list.add("first");      // 正常
list.remove(0);         // 正常
```

3. Collections.unmodifiableList()
- **特点**：创建**不可变视图包装器**
- **内存**：额外包装层，轻微开销
- **修改操作**：**不支持**修改，但底层集合可变时，变化会反映到视图
- **使用场景**：返回只读视图，保护集合不被外部修改

```java
List<String> original = new ArrayList<>();
original.add("hello");
List<String> unmodifiable = Collections.unmodifiableList(original);

unmodifiable.add("world");  // 抛出 UnsupportedOperationException
original.add("world");      // 正常，unmodifiable也会看到这个变化
```

🔍 问题根源分析

EasyPOI内部代码可能类似：
```java
// EasyPOI内部可能这样处理
while (!list.isEmpty()) {
    Object item = list.remove(0);  // 这里调用了remove()
    // 处理item...
}
```

**Collections.singletonList()的remove()方法：**
```java
public E remove(int index) {
    throw new UnsupportedOperationException();
}
```

💡 解决方案

1. **使用ArrayList**（目前的方案）：
```java
private List<User> getUserList() {
    return new ArrayList<>(Collections.singletonList(User.builder()
            .id(1L).userName("pdai").build()));
}
```

2. **避免在工具类中使用破坏性迭代**：
```java
// 更好的做法 - 使用普通迭代
for (User user : list) {
    // 处理user...
}
// 或者
list.forEach(user -> { /* 处理 */ });
```

📌 总结对比

| 集合类型 | 可变性 | 内存效率 | 线程安全 | 使用场景 |
|---------|--------|----------|----------|----------|
| singletonList | 完全不可变 | 最优 | 是 | 单元素固定集合 |
| ArrayList | 完全可变 | 良好 | 否 | 需要增删改的动态集合 |
| unmodifiableList | 视图不可变 | 轻微开销 | 依赖底层 | 返回只读视图 |
### 73.2.3 导入Excel
UserController中导入的方法，（导入的文件在项目根目录）
```java
@ApiOperation("Upload Excel")
@PostMapping("/excel/upload")
public ResponseResult<String> upload(@RequestParam(value = "file", required = true) MultipartFile file) {
    try {
        userService.upload(file.getInputStream());
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseResult.fail(e.getMessage());
    }
    return ResponseResult.success();
}
```
UserServiceImple中导入Excel的主方法
```java
@Override
public void upload(InputStream inputStream) throws Exception {
    ImportParams importParams = new ImportParams();
    List<User> userList = ExcelImportUtil.importExcel(inputStream, User.class, importParams);
    userList.stream().forEach(user -> log.info(user.toString()));
}
```
通过PostMan进行接口测试
![267.springboot-file-excel-easypoi-2.png](../../assets/images/04-主流框架/spring/267.springboot-file-excel-easypoi-2.png)

日志如下
```sh
2022-06-15 22:20:48.145  INFO 52348 --- [nio-8080-exec-2] t.p.s.f.e.e.s.impl.UserServiceImpl       : User(id=1, userName=pdai, email=pdai@pdai.tech, phoneNumber=121231231231, description=hello world)
```
### 73.2.4 填充Excel模板
准备如下Excel模板
![268.springboot-file-excel-easypoi-3.png](../../assets/images/04-主流框架/spring/268.springboot-file-excel-easypoi-3.png)

UserController中下载填充后的Excel方法
```java
@ApiOperation("Fill Excel Template")
@GetMapping("/excel/fill")
public void fillTemplate(HttpServletResponse response) {
    try {
        response.reset();
        response.setContentType("application/vnd.ms-excel");
        response.setHeader("Content-disposition",
                "attachment;filename=user_excel_template_" + System.currentTimeMillis() + ".xlsx");
        userService.fillExcelTemplate(response.getOutputStream());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
UserServiceImpl中填充excel模板的方法
```java
@Override
public void fillExcelTemplate(ServletOutputStream outputStream) throws IOException {
    // 确保文件可访问，这个例子的excel模板，放在根目录下面
    String templateFileName = "/Users/pdai/Downloads/user_excel_template_easypoi.xlsx";
    TemplateExportParams params = new TemplateExportParams(templateFileName);

    Map<String, Object> map = new HashMap<>();
    map.put("user", "pdai");
    map.put("date", new Date());
    map.put("userList", getUserList());
    Workbook workbook = ExcelExportUtil.exportExcel(params, map);
    workbook.write(outputStream);
    workbook.close();
}

private List<User> getUserList() {
    List<User> userList = new ArrayList<>();
    userList.add(User.builder()
            .id(1L).userName("pdai").email("pdai@pdai.tech").phoneNumber(121231231231L)
            .description("hello world")
            .build());
    userList.add(User.builder()
            .id(2L).userName("pdai2").email("pdai2@pdai.tech").phoneNumber(1212312312312L)
            .description("hello world2")
            .build());
    return userList;
}
```
访问http://localhost:8080/user/excel/fill 下载
![269.springboot-file-excel-easypoi-4.png](../../assets/images/04-主流框架/spring/269.springboot-file-excel-easypoi-4.png)
# 七十四、SpringBoot集成文件 - 集成POI之Word导出
> 前文我们介绍了通过Apache POI导出excel，而Apache POI包含是操作Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。所以也是可以通过POI来导出word的。本文主要介绍通过SpringBoot集成POI工具实现Word的导出功能。
## 74.1 知识准备
> 需要理解Apache POI遵循的标准（Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2））， 这将对应着API的依赖包。
### 74.1.1 什么是POI
> Apache POI 是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程序对Microsoft Office格式档案读和写的功能。POI为“Poor Obfuscation Implementation”的首字母缩写，意为“简洁版的模糊实现”。

Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。更多请参考<a href='https://poi.apache.org/index.html'>官方文档</a>。
![270.springboot-file-word-poi-1.png](../../assets/images/04-主流框架/spring/270.springboot-file-word-poi-1.png)
## 74.2 实现案例
### 74.2.1 Pom依赖
```xml
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
    <version>5.2.2</version>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.2</version>
</dependency>
```
### 74.2.2 导出Word
UserController中导出的方法
```java
package tech.pdai.springboot.file.word.poi.controller;


import java.io.OutputStream;

import javax.servlet.http.HttpServletResponse;

import io.swagger.annotations.ApiOperation;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.file.word.poi.service.IUserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    @ApiOperation("Download Word")
    @GetMapping("/word/download")
    public void download(HttpServletResponse response) {
        try {
            XWPFDocument document = userService.generateWordXWPFDocument();
            response.reset();
            response.setContentType("application/vnd.ms-excel");
            response.setHeader("Content-disposition",
                    "attachment;filename=user_world_" + System.currentTimeMillis() + ".docx");
            OutputStream os = response.getOutputStream();
            document.write(os);
            os.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```
UserServiceImple中导出Word方法
```java
package tech.pdai.springboot.file.word.poi.service.impl;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

import lombok.extern.slf4j.Slf4j;
import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.util.Units;
import org.apache.poi.xwpf.usermodel.BreakType;
import org.apache.poi.xwpf.usermodel.Document;
import org.apache.poi.xwpf.usermodel.ParagraphAlignment;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.apache.poi.xwpf.usermodel.XWPFTable;
import org.apache.poi.xwpf.usermodel.XWPFTableCell;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblPr;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTblWidth;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import tech.pdai.springboot.file.word.poi.entity.User;
import tech.pdai.springboot.file.word.poi.service.IUserService;

/**
 * @author pdai
 */
@Slf4j
@Service
public class UserServiceImpl implements IUserService {

    @Override
    public XWPFDocument generateWordXWPFDocument() {
        XWPFDocument doc = new XWPFDocument();

        // Title
        createTitle(doc, "Java 全栈知识体系");

        // Chapter 1
        createChapterH1(doc, "1. 知识准备");
        createChapterH2(doc, "1.1 什么是POI");
        createParagraph(doc, "Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。用它可以使用Java读取和创建,修改MS Excel文件.而且,还可以使用Java读取和创建MS Word和MSPowerPoint文件。更多请参考[官方文档](https://poi.apache.org/index.html)");
        createChapterH2(doc, "1.2 POI中基础概念");
        createParagraph(doc, "生成xls和xlsx有什么区别？POI对Excel中的对象的封装对应关系？");

        // Chapter 2
        createChapterH1(doc, "2. 实现案例");
        createChapterH2(doc, "2.1 用户列表示例");
        createParagraph(doc, "以导出用户列表为例");

        // 表格
        List<User> userList = getUserList();
        XWPFParagraph paragraph = doc.createParagraph();
        XWPFTable table = paragraph.getDocument().createTable(userList.size(), 5);
        table.setWidth(500);
        table.setCellMargins(20, 20, 20, 20);

        //表格属性
        CTTblPr tablePr = table.getCTTbl().addNewTblPr();
        //表格宽度
        CTTblWidth width = tablePr.addNewTblW();
        width.setW(BigInteger.valueOf(8000));

        for(int i = 0; i< userList.size(); i++) {
            List<XWPFTableCell> tableCells = table.getRow(i).getTableCells();
            tableCells.get(0).setText(userList.get(i).getId()+"");
            tableCells.get(1).setText(userList.get(i).getUserName());
            tableCells.get(2).setText(userList.get(i).getEmail());
            tableCells.get(3).setText(userList.get(i).getPhoneNumber()+"");
            tableCells.get(4).setText(userList.get(i).getDescription());
        }

        createChapterH2(doc, "2.2 图片导出示例");
        createParagraph(doc, "以导出图片为例");
        // 图片
        InputStream stream = null;
        try {
            XWPFParagraph paragraph2 = doc.createParagraph();
            Resource resource = new ClassPathResource("pdai-guli.png");
            stream = new FileInputStream(resource.getFile());
            XWPFRun run = paragraph2.createRun();
            run.addPicture(stream, Document.PICTURE_TYPE_PNG, "Generated", Units.toEMU(256), Units.toEMU(256));
        } catch (IOException | InvalidFormatException e) {
            e.printStackTrace();
        }

        return doc;
    }

    private void createTitle(XWPFDocument doc, String content) {
        XWPFParagraph title = doc.createParagraph();
        title.setAlignment(ParagraphAlignment.CENTER);
        XWPFRun r1 = title.createRun();
        r1.setBold(true);
        r1.setFontFamily("宋体");
        r1.setText(content);
        r1.setFontSize(22);
    }

    private void createChapterH1(XWPFDocument doc, String content) {
        XWPFParagraph actTheme = doc.createParagraph();
        actTheme.setAlignment(ParagraphAlignment.LEFT);
        XWPFRun runText1 = actTheme.createRun();
        runText1.setBold(true);
        runText1.setText(content);
        runText1.setFontSize(18);
    }

    private void createChapterH2(XWPFDocument doc, String content) {
        XWPFParagraph actType = doc.createParagraph();
        XWPFRun runText2 = actType.createRun();
        runText2.setBold(true);
        runText2.setText(content);
        runText2.setFontSize(15);
    }

    private void createParagraph(XWPFDocument doc, String content) {
        XWPFParagraph actType = doc.createParagraph();
        XWPFRun runText2 = actType.createRun();
        runText2.setText(content);
        runText2.setFontSize(11);
    }

    private List<User> getUserList() {
        List<User> userList = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            userList.add(User.builder()
                    .id(Long.parseLong(i + "")).userName("pdai" + i).email("pdai@pdai.tech" + i).phoneNumber(121231231231L)
                    .description("hello world" + i)
                    .build());
        }
        return userList;
    }

}
```
导出后的word
![271.springboot-file-word-poi-3.png](../../assets/images/04-主流框架/spring/271.springboot-file-word-poi-3.png)
# 七十五、SpringBoot集成文件 - 集成POI-tl之基于模板的Word导出
> 前文我们介绍了通过Apache POI通过来导出word的例子；那如果是word模板方式，有没有开源库通过模板方式导出word呢？poi-tl是一个基于Apache POI的Word模板引擎，也是一个免费开源的Java类库，你可以非常方便的加入到你的项目中，并且拥有着让人喜悦的特性。本文主要介绍通过SpringBoot集成poi-tl实现模板方式的Word导出功能。
## 75.1 知识准备
### 75.1.1 什么是poi-tl
> <a href='http://deepoove.com/poi-tl'>官网</a>

poi-tl（poi template language）是Word模板引擎，使用Word模板和数据创建很棒的Word文档。
![272.springboot-file-word-poi-tl-5.png](../../assets/images/04-主流框架/spring/272.springboot-file-word-poi-tl-5.png)
它还支持自定义插件，如下是<a href='https://github.com/Sayi/poi-tl'>官网代码仓库</a>支持的特性
> poi-tl supports custom functions (plug-ins), functions can be executed anywhere in the Word template, do anything anywhere in the document is the goal of poi-tl.

|Feature |Description|
| ------------- |-------------|
|✅ Text |Render the tag as text|
|✅ Picture |Render the tag as a picture|
|✅ Table |Render the tag as a table|
|✅ Numbering |Render the tag as a numbering|
|✅ Chart|Bar chart (3D bar chart), column chart (3D column chart), area chart (3D area chart), line chart (3D line chart), radar chart, pie chart (3D pie Figure) and other chart rendering |
|✅ If Condition |Hide or display certain document content (including text, paragraphs, pictures, tables, lists, charts, etc.) according to conditions|
|✅ Foreach Loop | Loop through certain document content (including text, paragraphs, pictures, tables, lists, charts, etc.) according to the collection|
|✅ Loop table row | Loop to copy a row of the rendered table|
|✅ Loop table column | Loop copy and render a column of the table|
|✅ Loop ordered list |Support the loop of ordered list, and support multi-level list at the same time|
|✅ Highlight code |Word highlighting of code blocks, supporting 26 languages ​​and hundreds of coloring styles|
|✅ Markdown |Convert Markdown to a word document|
|✅ Word attachment |Insert attachment in Word|
|✅ Word Comments |Complete support comment, create comment, modify comment, etc.|
|✅ Word SDT |Complete support structured document tag |
|✅ Textbox |Tag support in text box|
|✅ Picture replacement |Replace the original picture with another picture|
|✅ bookmarks, anchors, hyperlinks |Support setting bookmarks, anchors and hyperlinks in documents|
|✅ Expression Language |Fully supports SpringEL expressions and can extend more expressions: OGNL, MVEL...|
|✅ Style |The template is the style, and the code can also set the style|
|✅ Template nesting |The template contains sub-templates, and the sub-templates then contain sub-templates|
|✅ Merge |Word merge Merge, you can also merge in the specified position|
|✅ custom functions (plug-ins) | Plug-in design, execute function anywhere in the document|
### 75.1.2 poi-tl的TDO模式
> TDO模式：Template + data-model = output

TDO模式：Template + data-model = output
```java
XWPFTemplate template = XWPFTemplate.compile("template.docx").render(
  new HashMap<String, Object>(){{
    put("title", "Hi, poi-tl Word模板引擎");
}});  
template.writeAndClose(new FileOutputStream("output.docx")); 
```
- compile 编译模板 - Template
- render 渲染数据 - data-model
- write 输出到流 - output
#### 75.1.2.1 Template：模板
模板是Docx格式的Word文档，你可以使用Microsoft office、WPS Office、Pages等任何你喜欢的软件制作模板，也可以使用Apache POI代码来生成模板。

所有的标签都是以`{{`开头，以`}}`结尾，标签可以出现在任何位置，包括页眉，页脚，表格内部，文本框等，表格布局可以设计出很多优秀专业的文档，推荐使用表格布局。


poi-tl模板遵循“所见即所得”的设计，模板和标签的样式会被完全保留。

#### 75.1.2.2 Data-model：数据
数据类似于哈希或者字典，可以是Map结构（key是标签名称）：
```java
Map<String, Object> data = new HashMap<>();
data.put("name", "Sayi");
data.put("start_time", "2019-08-04");
```
可以是对象（属性名是标签名称）：
```java
public class Data {
  private String name;
  private String startTime;
  private Author author;
}
```
数据可以是树结构，每级之间用点来分隔开，比如`{ {author.name} }`标签对应的数据是author对象的name属性值。

Word模板不是由简单的文本表示，所以在渲染图片、表格等元素时提供了数据模型，它们都实现了接口RenderData，比如图片数据模型PictureRenderData包含图片路径、宽、高三个属性。
#### 75.1.2.3 Output：输出
以流的方式进行输出：
```java
template.write(OutputStream stream);
```
可以写到任意输出流中，比如文件流：
```java
template.write(new FileOutputStream("output.docx"));
```
比如网络流：
```java
response.setContentType("application/octet-stream");
response.setHeader("Content-disposition","attachment;filename=\""+"out_template.docx"+"\"");

// HttpServletResponse response
OutputStream out = response.getOutputStream();
BufferedOutputStream bos = new BufferedOutputStream(out);
template.write(bos);
bos.flush();
out.flush();
PoitlIOUtils.closeQuietlyMulti(template, bos, out); // 最后不要忘记关闭这些流。
```
## 75.2 实现案例
这里展示SpringBoot集成poi-tl基于word模板导出Word， 以及导出markdown为word的例子。
### 75.2.1 Pom依赖
引入poi的依赖包

基础的包：
```xml
<dependency>
    <groupId>com.deepoove</groupId>
    <artifactId>poi-tl</artifactId>
    <version>1.12.0</version>
</dependency>
```
插件的包如下，比如highlight,markdown包
```xml
<dependency>
    <groupId>com.deepoove</groupId>
    <artifactId>poi-tl-plugin-highlight</artifactId>
    <version>1.0.0</version>
</dependency>
<dependency>
    <groupId>com.deepoove</groupId>
    <artifactId>poi-tl-plugin-markdown</artifactId>
    <version>1.0.3</version>
</dependency>
```
### 75.2.2 导出基于template的word
controller中的方法
```java
@ApiOperation("Download Word")
@GetMapping("/word/download")
public void download(HttpServletResponse response) {
    try {
        XWPFTemplate document = userService.generateWordXWPFTemplate();
        response.reset();
        response.setContentType("application/octet-stream");
        response.setHeader("Content-disposition",
                "attachment;filename=user_word_" + System.currentTimeMillis() + ".docx");
        OutputStream os = response.getOutputStream();
        document.write(os);
        os.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
Service中的实际方法
```java
@Override
public XWPFTemplate generateWordXWPFTemplate() throws IOException {
    Map<String, Object> content = new HashMap<>();
    content.put("title", "Java 全栈知识体系");
    content.put("author", "pdai");
    content.put("site", new HyperlinkTextRenderData("", ""));

    content.put("poiText", "Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。用它可以使用Java读取和创建,修改MS Excel文件.而且,还可以使用Java读取和创建MS Word和MSPowerPoint文件。更多请参考[官方文档](https://poi.apache.org/index.html)");

    content.put("poiText2", "生成xls和xlsx有什么区别？POI对Excel中的对象的封装对应关系？");
    content.put("poiList", Numberings.create("excel03只能打开xls格式，无法直接打开xlsx格式",
            "xls只有65536行、256列; xlsx可以有1048576行、16384列",
            "xls占用空间大, xlsx占用空间小，运算速度也会快一点"));

    RowRenderData headRow = Rows.of("ID", "Name", "Email", "TEL", "Description").textColor("FFFFFF")
            .bgColor("4472C4").center().create();
    TableRenderData table = Tables.create(headRow);
    getUserList()
            .forEach(a -> table.addRow(Rows.create(a.getId() + "", a.getUserName(), a.getEmail(), a.getPhoneNumber() + "", a.getDescription())));
    content.put("poiTable", table);

    Resource resource = new ClassPathResource("pdai-guli.png");
    content.put("poiImage", Pictures.ofStream(new FileInputStream(resource.getFile())).create());

    return XWPFTemplate.compile(new ClassPathResource("poi-tl-template.docx").getFile()).render(content);
}

private List<User> getUserList() {
    List<User> userList = new ArrayList<>();
    for (int i = 0; i < 5; i++) {
        userList.add(User.builder()
                .id(Long.parseLong(i + "")).userName("pdai" + i).email("pdai@pdai.tech" + i).phoneNumber(121231231231L)
                .description("hello world" + i)
                .build());
    }
    return userList;
}
```
准备模板
![273.springboot-file-word-poi-tl-3.png](../../assets/images/04-主流框架/spring/273.springboot-file-word-poi-tl-3.png)

导出word
![274.springboot-file-word-poi-tl-1.png](../../assets/images/04-主流框架/spring/274.springboot-file-word-poi-tl-1.png)
### 75.2.3 导出markdown为word
controller中的方法
```java
@ApiOperation("Download Word based on markdown")
@GetMapping("/word/downloadMD")
public void downloadMD(HttpServletResponse response) {
    try {
        XWPFTemplate document = userService.generateWordXWPFTemplateMD();
        response.reset();
        response.setContentType("application/octet-stream");
        response.setHeader("Content-disposition",
                "attachment;filename=user_word_" + System.currentTimeMillis() + ".docx");
        OutputStream os = response.getOutputStream();
        document.write(os);
        os.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
Service中实现的方法
```java

@Override
public XWPFTemplate generateWordXWPFTemplateMD() throws IOException {
    MarkdownRenderData code = new MarkdownRenderData();

    Resource resource = new ClassPathResource("test.md");
    code.setMarkdown(new String(Files.readAllBytes(resource.getFile().toPath())));
    code.setStyle(MarkdownStyle.newStyle());

    Map<String, Object> data = new HashMap<>();
    data.put("md", code);

    Configure config = Configure.builder().bind("md", new MarkdownRenderPolicy()).build();

    return XWPFTemplate.compile(new ClassPathResource("markdown_template.docx").getFile(), config).render(data);
}
```
test.md
![275.Image20251201170349950.png](../../assets/images/04-主流框架/spring/275.Image20251201170349950.png)

准备模板
![276.Image20251201170457996.png](../../assets/images/04-主流框架/spring/276.Image20251201170457996.png)

导出word
![277.springboot-file-word-poi-tl-2.png](../../assets/images/04-主流框架/spring/277.springboot-file-word-poi-tl-2.png)
# 七十六、SpringBoot集成文件 - 集成itextpdf之导出PDF
> 除了处理word, excel等文件外，最为常见的就是PDF的导出了。在java技术栈中，PDF创建和操作最为常用的itext了，但是使用itext一定要了解其版本历史和License问题，在早前版本使用的是MPL和LGPL双许可协议，在5.x以上版本中使用的是AGPLv3(这个协议意味着，只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的)。本文主要介绍通过SpringBoot集成itextpdf实现PDF导出功能。
## 76.1 知识准备
### 76.1.1 什么是itext
> 来源于百度百科：iText是著名的开放源码的站点sourceforge一个项目(由Bruno Lowagie编写)，是一个用Java和.NET语言写的库，用来创建和修改PDF文件。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。 iText的安装非常方便，下载iText.jar文件后，只需要在系统的CLASSPATH中加入iText.jar的路径，在程序中就可以使用iText类库了。

iText提供除了基本的创建、修改PDF文件外的其他高级的PDF特性，例如基于PKI的签名，40位和128位加密，颜色校正，带标签的PDF，PDF表单(AcroForms)，PDF/X,通过ICC配置文件和条形码进行颜色管理。这些特性被一些产品和服务中使用，包括Eclipse BIRT，Jasper Reports，JBoss Seam，Windward Reports和pdftk。

一般情况下，iText使用在有以下一个要求的项目中：
- 内容无法提前利用：取决于用户的输入或实时的数据库信息。
- 由于内容，页面过多，PDF文档不能手动生成。
- 文档需在无人参与，批处理模式下自动创建。
- 内容被定制或个性化；例如，终端客户的名字需要标记在大量的页面上。
### 76.1.2 itext的历史版本和License问题
> 使用itext一定要了解其版本历史，和License问题，在早前版本使用的是MPL和LGPL双许可协议，在5.x以上版本中使用的是AGPLv3(这个协议意味着，只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的)
- iText 0.x-2.x/iTextSharp 3.x-4.x
  - 更新时间是2000-2009
  - 使用的是MPL和LGPL双许可协议
  - 最近的更新是2009年，版本号是iText 2.1.7/iTextSharp 4.1.6.0
  - 此时引入包的GAV版本如下：
```xml
<dependency>
  <groupId>com.lowagie</groupId>
  <artifactId>itext</artifactId>
  <version>2.1.7</version>
</dependency>
```
- iText 5.x和iTextSharp 5.x
  - 更新时间是2009-2016, 公司化运作，并标准化和提高性能开始使用 <a href='https://github.com/itext/itextpdf/blob/develop/LICENSE.md'>**AGPLv3协议**</a> 
    - 只有个人用途和开源的项目才能使用itext这个库，否则是需要收费的
  - iTextSharp被设计成iText库的.NET版本，并且与iText版本号同步，iText 5.0.0和iTextSharp5.0.0同时发布
  - 新功能不在这里面增加，但是官方会修复重要的bug
  - 此时引入包的GAV版本如下：
```xml
<dependency>
  <groupId>com.itextpdf</groupId>
  <artifactId>itextpdf</artifactId>
  <version>5.5.13.3</version>
</dependency>
```
- iText 7.x
  - 更新时间是2016到现在
  - AGPLv3协议
  - 完全重写，重点关注可扩展性和模块化
  - 不适用iTextSharp这个名称，都统称为iText,有Java和.Net版本
  - JDK 1.7+
  - 此时引入包的GAV版本如下：
```xml
<dependency>
  <groupId>com.itextpdf</groupId>
  <artifactId>itext7-core</artifactId>
  <version>7.2.2</version>
</dependency>
```
注：iText变化后，GitHub上有团队基于4.x版本（MPL和LGPL双许可协议）fork了一个分支成为<a href='https://github.com/LibrePDF/OpenPDF/'>OpenPDF</a>，并继续维护该项目。

### 76.1.3 标准的itextpdf导出的步骤
itextpdf导出pdf主要包含如下几步：
```java
@Override
public Document generateItextPdfDocument(OutputStream os) throws Exception {
    // 1. 创建文档
    Document document = new Document(PageSize.A4);

    // 2. 绑定输出流（通过pdfwriter)
    PdfWriter.getInstance(document, os);

    // 3. 打开文档
    document.open();

    // 4. 往文档中添加内容
    document.add(xxx);

    // 5. 关闭文档
    document.close();
    return document;
}
```
document中添加的Element有哪些呢？
![278.springboot-file-pdf-itext-2.png](../../assets/images/04-主流框架/spring/278.springboot-file-pdf-itext-2.png)

需要说明下如下概念之前的差别：
- Chunk：文档的文本的最小块单位
- Phrase：一系列以特定间距（两行之间的距离）作为参数的块
- Paragraph：段落是一系列块和（或）短句。同短句一样，段落有确定的间距。用户还可以指定缩排；在边和（或）右边保留一定空白，段落可以左对齐、右对齐和居中对齐。添加到文档中的每一个段落将自动另起一行。
## 76.2 实现案例
### 76.2.1 Pom依赖
```xml
<dependency>
    <groupId>com.itextpdf</groupId>
    <artifactId>itextpdf</artifactId>
    <version>5.5.13.3</version>
</dependency>
<dependency>
    <groupId>com.itextpdf</groupId>
    <artifactId>itext-asian</artifactId>
    <version>5.2.0</version>
</dependency>
```
### 76.2.2 导出PDF
UserController中导出的方法
```java
package tech.pdai.springboot.file.word.poi.controller;


import java.io.OutputStream;

import javax.servlet.http.HttpServletResponse;

import io.swagger.annotations.ApiOperation;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pdai.springboot.file.word.poi.service.IUserService;

/**
 * @author pdai
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    @ApiOperation("Download Word")
    @GetMapping("/word/download")
    public void download(HttpServletResponse response) {
        try {
            XWPFDocument document = userService.generateWordXWPFDocument();
            response.reset();
            response.setContentType("application/vnd.ms-excel");
            response.setHeader("Content-disposition",
                    "attachment;filename=user_world_" + System.currentTimeMillis() + ".docx");
            OutputStream os = response.getOutputStream();
            document.write(os);
            os.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```
UserServiceImple中导出PDF方法
```java
@Override
public Document generateItextPdfDocument(OutputStream os) throws Exception {
    // document
    Document document = new Document(PageSize.A4);
    PdfWriter.getInstance(document, os);

    // open
    document.open();

    // add content - pdf meta information
    document.addAuthor("pdai");
    document.addCreationDate();
    document.addTitle("pdai-pdf-itextpdf");
    document.addKeywords("pdf-pdai-keyword");
    document.addCreator("pdai");

    // add content -  page content

    // Title
    document.add(createTitle("Java 全栈知识体系"));

    // Chapter 1
    document.add(createChapterH1("1. 知识准备"));
    document.add(createChapterH2("1.1 什么是POI"));
    document.add(createParagraph("Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。用它可以使用Java读取和创建,修改MS Excel文件.而且,还可以使用Java读取和创建MS Word和MSPowerPoint文件。更多请参考[官方文档](https://poi.apache.org/index.html)"));
    document.add(createChapterH2("1.2 POI中基础概念"));
    document.add(createParagraph("生成xls和xlsx有什么区别？POI对Excel中的对象的封装对应关系？"));

    // Chapter 2
    document.add(createChapterH1("2. 实现案例"));
    document.add(createChapterH2("2.1 用户列表示例"));
    document.add(createParagraph("以导出用户列表为例"));

    // 表格
    List<User> userList = getUserList();
    PdfPTable table = new PdfPTable(new float[]{20, 40, 50, 40, 40});
    table.setTotalWidth(500);
    table.setLockedWidth(true);
    table.setHorizontalAlignment(Element.ALIGN_CENTER);
    table.getDefaultCell().setBorder(1);

    for (int i = 0; i < userList.size(); i++) {
        table.addCell(createCell(userList.get(i).getId() + ""));
        table.addCell(createCell(userList.get(i).getUserName()));
        table.addCell(createCell(userList.get(i).getEmail()));
        table.addCell(createCell(userList.get(i).getPhoneNumber() + ""));
        table.addCell(createCell(userList.get(i).getDescription()));
    }
    document.add(table);

    document.add(createChapterH2("2.2 图片导出示例"));
    document.add(createParagraph("以导出图片为例"));
    // 图片
    Resource resource = new ClassPathResource("pdai-guli.png");
    Image image = Image.getInstance(resource.getURL());
    // Image image = Image.getInstance("/Users/pdai/pdai/www/tech-pdai-spring-demos/481-springboot-demo-file-pdf-itextpdf/src/main/resources/pdai-guli.png");
    image.setAlignment(Element.ALIGN_CENTER);
    image.scalePercent(60); // 缩放
    document.add(image);

    // close
    document.close();
    return document;
}

private List<User> getUserList() {
    List<User> userList = new ArrayList<>();
    for (int i = 0; i < 5; i++) {
        userList.add(User.builder()
                .id(Long.parseLong(i + "")).userName("pdai" + i).email("pdai@pdai.tech" + i).phoneNumber(121231231231L)
                .description("hello world" + i)
                .build());
    }
    return userList;
}
```
在实现时可以将如下创建文档内容的方法封装到Util工具类中
```java
private Paragraph createTitle(String content) throws IOException, DocumentException {
    Font font = new Font(getBaseFont(), 24, Font.BOLD);
    Paragraph paragraph = new Paragraph(content, font);
    paragraph.setAlignment(Element.ALIGN_CENTER);
    return paragraph;
}


private Paragraph createChapterH1(String content) throws IOException, DocumentException {
    Font font = new Font(getBaseFont(), 22, Font.BOLD);
    Paragraph paragraph = new Paragraph(content, font);
    paragraph.setAlignment(Element.ALIGN_LEFT);
    return paragraph;
}

private Paragraph createChapterH2(String content) throws IOException, DocumentException {
    Font font = new Font(getBaseFont(), 18, Font.BOLD);
    Paragraph paragraph = new Paragraph(content, font);
    paragraph.setAlignment(Element.ALIGN_LEFT);
    return paragraph;
}

private Paragraph createParagraph(String content) throws IOException, DocumentException {
    Font font = new Font(getBaseFont(), 12, Font.NORMAL);
    Paragraph paragraph = new Paragraph(content, font);
    paragraph.setAlignment(Element.ALIGN_LEFT);
    paragraph.setIndentationLeft(12); //设置左缩进
    paragraph.setIndentationRight(12); //设置右缩进
    paragraph.setFirstLineIndent(24); //设置首行缩进
    paragraph.setLeading(20f); //行间距
    paragraph.setSpacingBefore(5f); //设置段落上空白
    paragraph.setSpacingAfter(10f); //设置段落下空白
    return paragraph;
}

public PdfPCell createCell(String content) throws IOException, DocumentException {
    PdfPCell cell = new PdfPCell();
    cell.setVerticalAlignment(Element.ALIGN_MIDDLE);
    cell.setHorizontalAlignment(Element.ALIGN_CENTER);
    Font font = new Font(getBaseFont(), 12, Font.NORMAL);
    cell.setPhrase(new Phrase(content, font));
    return cell;
}

private BaseFont getBaseFont() throws IOException, DocumentException {
    return BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);
}
```
导出后的PDF
![279.springboot-file-pdf-itext-1.png](../../assets/images/04-主流框架/spring/279.springboot-file-pdf-itext-1.png)
### 76.2.3 添加页眉页脚和水印
> 在itextpdf 5.x 中可以利用PdfPageEvent来完成页眉页脚和水印。
```java
package tech.pdai.springboot.file.pdf.itextpdf.pdf;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Document;
import com.itextpdf.text.Element;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.ColumnText;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfGState;
import com.itextpdf.text.pdf.PdfPageEventHelper;
import com.itextpdf.text.pdf.PdfTemplate;
import com.itextpdf.text.pdf.PdfWriter;

/**
 * @author pdai
 */
public class MyHeaderFooterPageEventHelper extends PdfPageEventHelper {

    private String headLeftTitle;

    private String headRightTitle;

    private String footerLeft;

    private String waterMark;

    private PdfTemplate total;

    public MyHeaderFooterPageEventHelper(String headLeftTitle, String headRightTitle, String footerLeft, String waterMark) {
        this.headLeftTitle = headLeftTitle;
        this.headRightTitle = headRightTitle;
        this.footerLeft = footerLeft;
        this.waterMark = waterMark;
    }

    @Override
    public void onOpenDocument(PdfWriter writer, Document document) {
        total = writer.getDirectContent().createTemplate(30, 16);
    }

    @Override
    public void onEndPage(PdfWriter writer, Document document) {
        BaseFont bf = null;
        try {
            bf = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);
        } catch (Exception e) {
            e.printStackTrace();
        }

        // page header and footer
        addPageHeaderAndFooter(writer, document, bf);

        // watermark
        if (waterMark!=null) {
            addWaterMark(writer, document, bf);
        }
    }

    private void addPageHeaderAndFooter(PdfWriter writer, Document document, BaseFont bf) {
        PdfContentByte cb = writer.getDirectContent();
        cb.saveState();

        cb.beginText();

        cb.setColorFill(BaseColor.GRAY);
        cb.setFontAndSize(bf, 10);


        // header
        float x = document.top(-10);
        cb.showTextAligned(PdfContentByte.ALIGN_LEFT,
                headLeftTitle,
                document.left(), x, 0);
        cb.showTextAligned(PdfContentByte.ALIGN_RIGHT,
                headRightTitle,
                document.right(), x, 0);

        // footer
        float y = document.bottom(-10);
        cb.showTextAligned(PdfContentByte.ALIGN_LEFT,
                footerLeft,
                document.left(), y, 0);
        cb.showTextAligned(PdfContentByte.ALIGN_CENTER,
                String.format("- %d -", writer.getPageNumber()),
                (document.right() + document.left()) / 2,
                y, 0);

        cb.endText();

        cb.restoreState();
    }

    private void addWaterMark(PdfWriter writer, Document document, BaseFont bf) {
        for (int i = 1; i < 7; i++) {
            for (int j = 1; j < 10; j++) {
                PdfContentByte cb = writer.getDirectContent();
                cb.saveState();
                cb.beginText();
                cb.setColorFill(BaseColor.GRAY);
                PdfGState gs = new PdfGState();
                gs.setFillOpacity(0.1f);
                cb.setGState(gs);
                cb.setFontAndSize(bf, 12);
                cb.showTextAligned(Element.ALIGN_MIDDLE, waterMark, 75 * i,
                        80 * j, 30);
                cb.endText();
                cb.restoreState();
            }
        }
    }

    @Override
    public void onCloseDocument(PdfWriter writer, Document document) {
        ColumnText.showTextAligned(total, Element.ALIGN_LEFT, new Phrase(String.valueOf(writer.getPageNumber() - 1)), 2,
                2, 0);
    }
}
```
添加水印后导出后的PDF
![280.springboot-file-pdf-itext-3.png](../../assets/images/04-主流框架/spring/280.springboot-file-pdf-itext-3.png)
## 76.3 进一步理解
### 76.3.1 为何添加页眉页脚和水印是通过PdfPageEvent来完成
> 为何添加页眉页脚和水印是通过PdfPageEvent来完成？

举个例子，如果我们在上述例子中需要在页脚中显示 “Page 1 of 3", 即总页数怎么办呢？而itext是流模式的写入内容，只有写到最后，才能知道有多少页，那么显示总页数必须在内容写完之后（或者关闭之前）确定；这就是为什么在onEndPage方法时才会写每页的页眉页脚。

iText仅在调用释放模板方法后才将PdfTemplate写入到OutputStream中，否则对象将一直保存在内存中，直到关闭文档。所以我们可以在最后关闭文档前，使用PdfTemplate写入总页码。可以理解成先写个占位符，然后统一替换。
# 七十七、▶SpringBoot后端视图 - 基于Thymeleaf视图解析

Thymeleaf是SpringBoot中默认推荐的后端模板引擎，它允许开发者通过自然模板语法将动态数据渲染到HTML页面中。本部分将详细介绍Thymeleaf的基础知识、实现案例和深入理解，帮助您掌握其在SpringBoot中的应用。

## 77.1 知识准备
在使用Thymeleaf之前，需要理解SpringMVC的处理流程、模板引擎的基本概念，以及Thymeleaf的核心特性。SpringMVC负责处理用户请求，通过控制器（Controller）返回模型数据，然后由模板引擎（如Thymeleaf）结合模板文件生成最终的HTML响应。

### 77.1.1 什么是模板引擎
模板引擎是一种服务器端技术，用于将静态模板文件与动态数据结合，生成最终的输出内容（如HTML、XML或文本）。它的主要作用是分离业务逻辑和展示逻辑，提高代码的可维护性。模板引擎通常支持变量替换、条件判断、循环迭代等功能。常见的Java模板引擎包括：
- **JSP（JavaServer Pages）**：基于Servlet的旧式技术，需要容器支持。
- **Freemarker**：轻量级模板引擎，语法简洁。
- **Thymeleaf**：现代化引擎，支持自然模板（无需服务器即可预览）。
模板引擎的工作流程：控制器处理请求并准备数据模型，模板引擎读取模板文件，将数据填充到模板中，最终输出渲染后的内容。在SpringBoot中，Thymeleaf通过自动配置集成，无需手动设置解析器。

### 77.1.2 什么是Thymeleaf
Thymeleaf是一个开源的Java模板引擎，专为Web和独立环境设计。它支持HTML、XML、JavaScript等格式，语法自然易懂，允许模板在浏览器中直接预览（称为“自然模板”）。Thymeleaf 3.0版本引入了性能优化，如缓存机制和表达式改进。主要特点包括：
- **与Spring生态无缝集成**：支持Spring MVC、Spring Security等。
- **丰富的表达式语言**：如变量表达式 `${}`、链接表达式 `@{}` 等。
- **可扩展性**：可通过自定义方言扩展功能。
官方文档（3.0版本）：http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html。在SpringBoot中，只需添加`spring-boot-starter-thymeleaf`依赖即可自动配置。

## 77.2 实现案例
本节通过三个案例逐步介绍Thymeleaf的用法。每个案例均提供可运行的代码示例，基于SpringBoot 2.7+和Thymeleaf 3.0。建议使用IDE（如IntelliJ IDEA或Eclipse）创建SpringBoot项目进行实践。

### 77.2.1 简单的Hello World案例
本案例演示最基本的Thymeleaf使用：创建一个SpringBoot应用，通过控制器返回数据，并在HTML模板中显示“Hello World”。以下是完整步骤和代码。

**步骤1: 创建SpringBoot项目**
- 使用Spring Initializr（https://start.spring.io/）生成项目，选择依赖：Spring Web、Thymeleaf。
- 或手动创建Maven项目，添加以下依赖到`pom.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version> <!-- 使用稳定版本 -->
        <relativePath/>
    </parent>
    <groupId>com.example</groupId>
    <artifactId>thymeleaf-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>thymeleaf-demo</name>
    <description>Demo project for Thymeleaf</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

**步骤2: 创建控制器（Controller）**
在`src/main/java/com/example/demo/`目录下创建`HelloController.java`：

```java
package com.example.demo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HelloController {

    @GetMapping("/hello") // 处理GET请求，路径为/hello
    public String hello(Model model) {
        model.addAttribute("name", "World"); // 向模型添加属性"name"，值为"World"
        return "hello"; // 返回模板名称"hello"，对应src/main/resources/templates/hello.html
    }
}
```

**步骤3: 创建Thymeleaf模板**
在`src/main/resources/templates/`目录下创建`hello.html`：

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"> <!-- 引入Thymeleaf命名空间 -->
<head>
    <meta charset="UTF-8">
    <title>Hello Thymeleaf</title>
</head>
<body>
    <!-- 使用th:text表达式动态显示数据 -->
    <h1 th:text="'Hello, ' + ${name} + '!'">Hello, User!</h1> 
    <!-- 默认文本"Hello, User!"在浏览器中直接预览时显示，渲染后替换为动态数据 -->
</body>
</html>
```

**步骤4: 运行应用**
- 主类自动生成于`src/main/java/com/example/demo/ThymeleafDemoApplication.java`：

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ThymeleafDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(ThymeleafDemoApplication.class, args);
    }
}
```

- 运行主类，访问 http://localhost:8080/hello，页面将显示“Hello, World!”。

**说明**：此案例展示了Thymeleaf的基本用法：控制器通过`Model`传递数据，模板使用`th:text`表达式渲染。Thymeleaf自动配置模板解析路径（默认为`classpath:/templates/`）。

### 77.2.2 Thymeleaf各种语法案例
本案例介绍Thymeleaf核心语法，包括变量、条件、循环等。扩展Hello World案例，添加更多功能。

**步骤1: 更新控制器**
修改`HelloController.java`，添加更多数据：

```java
package com.example.demo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import java.util.Arrays;
import java.util.List;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(Model model) {
        model.addAttribute("name", "World");
        model.addAttribute("age", 25);
        model.addAttribute("isAdmin", true);
        List<String> hobbies = Arrays.asList("Reading", "Traveling", "Coding");
        model.addAttribute("hobbies", hobbies);
        return "hello";
    }
}
```

**步骤2: 更新模板**
修改`hello.html`，演示多种语法：

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Thymeleaf语法案例</title>
</head>
<body>
    <h1 th:text="'Hello, ' + ${name} + '!'">Hello, User!</h1>
    
    <!-- 条件判断：th:if -->
    <p th:if="${age > 18}" th:text="'年龄：' + ${age} + '（成年人）'">年龄显示</p>
    <p th:unless="${age > 18}" th:text="'年龄：' + ${age} + '（未成年人）'">年龄显示</p>
    
    <!-- 循环：th:each -->
    <h3>兴趣爱好：</h3>
    <ul>
        <li th:each="hobby : ${hobbies}" th:text="${hobby}">兴趣项</li>
    </ul>
    
    <!-- 链接表达式：@{...} 用于生成URL -->
    <a th:href="@{/about}">关于我们</a>
    
    <!-- 消息表达式（国际化）：#{...}，需配置消息文件 -->
    <p th:text="#{welcome.message}">欢迎消息</p>
</body>
</html>
```

**步骤3: 添加其他页面（可选）**
创建`about.html`在`templates`目录：

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>关于页面</title>
</head>
<body>
    <h1>关于Thymeleaf</h1>
    <a th:href="@{/hello}">返回首页</a>
</body>
</html>
```

并添加控制器方法：

```java
@GetMapping("/about")
public String about() {
    return "about";
}
```

运行应用，访问`/hello`查看语法效果。此案例覆盖了常用表达式，实际开发中可结合SpringBoot功能（如表单处理）扩展。

### 77.2.3 Thymeleaf增删查改应用案例
本案例模拟一个简单的用户管理CRUD（增删查改）应用，展示Thymeleaf在真实场景中的使用。由于代码较长，这里简化实现，重点展示Thymeleaf整合。

**步骤1: 项目结构**
- 实体类`User`、控制器`UserController`、模板文件（如`user-list.html`）。
- 使用内存列表模拟数据存储。

**步骤2: 代码示例**
- 实体类`src/main/java/com/example/demo/User.java`：

```java
package com.example.demo;

public class User {
    private Long id;
    private String name;
    private String email;
    
    // 构造器、getter和setter
    public User() {}
    
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // 省略getter/setter，实际中需完整生成
}
```

- 控制器`UserController.java`：

```java
package com.example.demo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

@Controller
@RequestMapping("/users")
public class UserController {
    private List<User> users = new ArrayList<>();
    private AtomicLong counter = new AtomicLong(1); // ID生成器
    
    // 初始数据
    public UserController() {
        users.add(new User(counter.getAndIncrement(), "Alice", "alice@example.com"));
        users.add(new User(counter.getAndIncrement(), "Bob", "bob@example.com"));
    }
    
    // 列表页面
    @GetMapping
    public String listUsers(Model model) {
        model.addAttribute("users", users);
        return "user-list";
    }
    
    // 添加用户表单
    @GetMapping("/add")
    public String addUserForm(Model model) {
        model.addAttribute("user", new User());
        return "user-form";
    }
    
    // 处理添加请求
    @PostMapping("/add")
    public String addUser(@ModelAttribute User user) {
        user.setId(counter.getAndIncrement());
        users.add(user);
        return "redirect:/users"; // 重定向到列表
    }
    
    // 删除用户
    @GetMapping("/delete/{id}")
    public String deleteUser(@PathVariable Long id) {
        users.removeIf(u -> u.getId().equals(id));
        return "redirect:/users";
    }
}
```

- 列表模板`src/main/resources/templates/user-list.html`：

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>用户列表</title>
</head>
<body>
    <h1>用户管理</h1>
    <a th:href="@{/users/add}">添加用户</a>
    <table border="1">
        <tr>
            <th>ID</th>
            <th>姓名</th>
            <th>邮箱</th>
            <th>操作</th>
        </tr>
        <tr th:each="user : ${users}">
            <td th:text="${user.id}">1</td>
            <td th:text="${user.name}">Alice</td>
            <td th:text="${user.email}">alice@example.com</td>
            <td>
                <a th:href="@{/users/delete/{id}(id=${user.id})}">删除</a>
            </td>
        </tr>
    </table>
</body>
</html>
```

- 表单模板`user-form.html`：

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>添加用户</title>
</head>
<body>
    <h1>添加用户</h1>
    <form th:action="@{/users/add}" th:object="${user}" method="post">
        <label>姓名：</label>
        <input type="text" th:field="*{name}" required/><br/>
        <label>邮箱：</label>
        <input type="email" th:field="*{email}" required/><br/>
        <button type="submit">提交</button>
    </form>
    <a th:href="@{/users}">返回列表</a>
</body>
</html>
```

**步骤3: 运行应用**
- 启动后访问 http://localhost:8080/users，可进行用户添加和删除操作。此案例展示了Thymeleaf与SpringBoot表单绑定、重定向等高级用法。

## 77.3 进一步理解
通过以下问题深入掌握Thymeleaf在SpringBoot中的最佳实践。

### 77.3.1 为什么SpringBoot中默认的后端模板引擎会是Thymeleaf？
SpringBoot选择Thymeleaf作为推荐模板引擎，主要基于以下原因：
- **无侵入性设计**：Thymeleaf支持自然模板，HTML文件可直接在浏览器中预览，无需启动服务器，便于前端开发。
- **与Spring生态深度集成**：自动配置简化了设置，支持Spring MVC、Spring Security等（如使用`sec:`标签进行权限控制）。
- **性能与现代化**：Thymeleaf 3.0优化了缓存和解析速度，相比JSP避免了Servlet容器依赖，更轻量。
- **语法友好**：表达式类似HTML属性，学习曲线平缓，社区活跃。相比之下，JSP已逐渐淘汰，Freemarker配置稍复杂。

### 77.3.2 Thymeleaf的生态？
Thymeleaf拥有成熟的生态系统：
- **核心模块**：支持标准方言，可处理HTML、XML等。
- **Spring集成**：官方提供`thymeleaf-spring`库，无缝整合Spring功能。
- **扩展模块**：如`thymeleaf-extras-springsecurity`用于安全标签，`thymeleaf-extras-java8time`处理日期。
- **工具支持**：IDE插件（如IntelliJ的Thymeleaf插件）、社区模板和文档。
- **持续更新**：兼容最新Java版本，广泛应用于企业级项目，如电商平台和管理系统。

### 77.3.3 Thymeleaf其它常见问题？
常见问题及解决方案：
- **性能问题**：Thymeleaf默认开启模板缓存，生产环境中可配置`spring.thymeleaf.cache=false`关闭缓存以方便调试，但上线后应启用缓存提升性能。
- **与前端框架冲突**：如与Vue.js共用时，可通过`th:inline="javascript"`避免语法冲突，或使用自然模板分离动态部分。
- **国际化支持**：通过`MessageSource`配置消息文件，模板中使用`#{key}`表达式实现多语言。
- **错误调试**：开启调试模式（`spring.thymeleaf.mode=HTML`），查看模板解析日志。

## 77.4 示例源码
完整可运行的示例代码已集成在上述案例中。建议通过Spring Initializr创建项目，复制代码进行测试。如需更复杂示例，可参考：
- Spring官方指南：https://spring.io/guides/gs/serving-web-content/
- Thymeleaf官方示例库：https://github.com/thymeleaf/thymeleaf-examples
实践时，注意依赖版本匹配，确保SpringBoot和Thymeleaf兼容。
# 七十八、SpringBoot后端视图 - 基于Freemarker视图解析

Freemarker是另一个广泛使用的Java模板引擎，尤其在传统企业级应用中常见。它与Thymeleaf类似，但语法和设计哲学有所不同。本部分将详细介绍Freemarker的基础知识、实现案例和深入理解，最后与Thymeleaf进行深度对比，并讨论当前流行趋势。所有案例基于SpringBoot 2.7+和Freemarker 2.3+，确保可运行。

## 78.1 知识准备
在使用Freemarker之前，需要理解其核心概念和与SpringBoot的集成方式。Freemarker通过模板文件（.ftl）和动态数据生成输出，适用于Web页面、邮件模板等场景。

### 78.1.1 什么是模板引擎
模板引擎是一种服务器端技术，用于将静态模板与动态数据结合，生成最终内容（如HTML、XML或文本）。它的核心目标是分离业务逻辑和展示逻辑，提高代码可维护性。模板引擎通常支持变量替换、条件判断、循环迭代等功能。在Java生态中，除了Thymeleaf，Freemarker也是一个轻量级且高性能的选择。与Thymeleaf的自然模板不同，Freemarker模板不能直接在浏览器中预览，需要服务器渲染，但其语法简洁，执行效率高。

### 78.1.2 什么是Freemarker
Freemarker是一个开源的Java模板引擎，由Apache软件基金会维护。它使用FTL（Freemarker Template Language）语法，专注于生成文本输出，如HTML、XML、代码文件等。主要特点包括：
- **高性能**：编译后的模板缓存到内存，减少解析开销。
- **逻辑强大**：支持复杂表达式、宏定义和自定义指令。
- **与Spring无缝集成**：SpringBoot提供自动配置，只需添加依赖即可使用。
- **轻量级**：无外部依赖，适用于嵌入式系统。
官方文档：https://freemarker.apache.org/docs/。在SpringBoot中，通过`spring-boot-starter-freemarker`依赖自动配置模板解析路径（默认为`classpath:/templates/`）。

## 78.2 实现案例
本节通过三个案例介绍Freemarker的用法，从基础Hello World到完整CRUD应用。案例基于SpringBoot项目，代码完整可运行。建议使用IDE创建项目实践。

### 78.2.1 简单的Hello World案例
本案例演示Freemarker的基本使用：创建SpringBoot应用，通过控制器返回数据，并在FTL模板中显示“Hello World”。

**步骤1: 创建SpringBoot项目**
- 使用Spring Initializr（https://start.spring.io/）生成项目，选择依赖：Spring Web、Freemarker。
- 或手动添加依赖到`pom.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
        <relativePath/>
    </parent>
    <groupId>com.example</groupId>
    <artifactId>freemarker-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>freemarker-demo</name>
    <description>Demo project for Freemarker</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-freemarker</artifactId>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

**步骤2: 创建控制器（Controller）**
在`src/main/java/com/example/demo/`目录下创建`HelloController.java`：

```java
package com.example.demo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HelloController {

    @GetMapping("/hello") // 处理GET请求，路径为/hello
    public String hello(Model model) {
        model.addAttribute("name", "World"); // 向模型添加属性"name"
        return "hello"; // 返回模板名称"hello"，对应src/main/resources/templates/hello.ftl
    }
}
```

**步骤3: 创建Freemarker模板**
在`src/main/resources/templates/`目录下创建`hello.ftl`（Freemarker模板文件扩展名为.ftl）：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hello Freemarker</title>
</head>
<body>
    <!-- 使用${}表达式显示动态数据 -->
    <h1>Hello, ${name}!</h1> 
    <!-- Freemarker表达式直接嵌入HTML，渲染时替换 -->
</body>
</html>
```

**步骤4: 运行应用**
- 主类`src/main/java/com/example/demo/FreemarkerDemoApplication.java`：

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FreemarkerDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(FreemarkerDemoApplication.class, args);
    }
}
```

- 运行主类，访问 http://localhost:8080/hello，页面显示“Hello, World!”。

**说明**：此案例展示了Freemarker的基本用法。控制器通过`Model`传递数据，模板使用`${}`表达式渲染。Freemarker自动配置模板路径，无需额外设置。

### 78.2.2 Freemarker各种语法案例
本案例介绍Freemarker核心语法，包括变量、条件、循环等。扩展Hello World案例，添加更多功能。

**步骤1: 更新控制器**
修改`HelloController.java`，添加更多数据：

```java
package com.example.demo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import java.util.Arrays;
import java.util.List;

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(Model model) {
        model.addAttribute("name", "World");
        model.addAttribute("age", 25);
        model.addAttribute("isAdmin", true);
        List<String> hobbies = Arrays.asList("Reading", "Traveling", "Coding");
        model.addAttribute("hobbies", hobbies);
        return "hello";
    }
}
```

**步骤2: 更新模板**
修改`hello.ftl`，演示多种语法：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Freemarker语法案例</title>
</head>
<body>
    <h1>Hello, ${name}!</h1>
    
    <!-- 条件判断：<#if> -->
    <#if age gt 18> <!-- gt表示大于 -->
        <p>年龄：${age}（成年人）</p>
    <#else>
        <p>年龄：${age}（未成年人）</p>
    </#if>
    
    <!-- 循环：<#list> -->
    <h3>兴趣爱好：</h3>
    <ul>
        <#list hobbies as hobby>
            <li>${hobby}</li>
        </#list>
    </ul>
    
    <!-- 使用内置函数：如?cap_first将首字母大写 -->
    <p>欢迎用户：${name?cap_first}</p>
    
    <!-- 宏定义（类似函数）：定义简单宏 -->
    <#macro greet person>
        <p>Hello, ${person}!</p>
    </#macro>
    <@greet person="Freemarker"/> <!-- 调用宏 -->
</body>
</html>
```

**步骤3: 运行测试**
启动应用，访问`/hello`查看效果。此案例覆盖了Freemarker常用语法，实际开发中可结合更多内置函数和指令。

### 78.2.3 Freemarker增删查改应用案例
本案例模拟用户管理CRUD应用，展示Freemarker在真实场景中的使用。使用内存列表存储数据。

**步骤1: 项目结构**
- 实体类`User`、控制器`UserController`、模板文件（如`user-list.ftl`）。

**步骤2: 代码示例**
- 实体类`src/main/java/com/example/demo/User.java`：

```java
package com.example.demo;

public class User {
    private Long id;
    private String name;
    private String email;
    
    // 构造器、getter和setter
    public User() {}
    
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

- 控制器`UserController.java`：

```java
package com.example.demo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

@Controller
@RequestMapping("/users")
public class UserController {
    private List<User> users = new ArrayList<>();
    private AtomicLong counter = new AtomicLong(1);
    
    public UserController() {
        users.add(new User(counter.getAndIncrement(), "Alice", "alice@example.com"));
        users.add(new User(counter.getAndIncrement(), "Bob", "bob@example.com"));
    }
    
    @GetMapping
    public String listUsers(Model model) {
        model.addAttribute("users", users);
        return "user-list";
    }
    
    @GetMapping("/add")
    public String addUserForm(Model model) {
        model.addAttribute("user", new User());
        return "user-form";
    }
    
    @PostMapping("/add")
    public String addUser(@ModelAttribute User user) {
        user.setId(counter.getAndIncrement());
        users.add(user);
        return "redirect:/users";
    }
    
    @GetMapping("/delete/{id}")
    public String deleteUser(@PathVariable Long id) {
        users.removeIf(u -> u.getId().equals(id));
        return "redirect:/users";
    }
}
```

- 列表模板`src/main/resources/templates/user-list.ftl`：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>用户列表</title>
</head>
<body>
    <h1>用户管理</h1>
    <a href="/users/add">添加用户</a> <!-- 硬编码URL，实际可用${springMacroRequestContext.getContextPath()}处理 -->
    <table border="1">
        <tr>
            <th>ID</th>
            <th>姓名</th>
            <th>邮箱</th>
            <th>操作</th>
        </tr>
        <#list users as user>
            <tr>
                <td>${user.id}</td>
                <td>${user.name}</td>
                <td>${user.email}</td>
                <td>
                    <a href="/users/delete/${user.id}">删除</a>
                </td>
            </tr>
        </#list>
    </table>
</body>
</html>
```

- 表单模板`user-form.ftl`：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>添加用户</title>
</head>
<body>
    <h1>添加用户</h1>
    <form action="/users/add" method="post">
        <label>姓名：</label>
        <input type="text" name="name" required/><br/>
        <label>邮箱：</label>
        <input type="email" name="email" required/><br/>
        <button type="submit">提交</button>
    </form>
    <a href="/users">返回列表</a>
</body>
</html>
```

**步骤3: 运行应用**
- 启动后访问 http://localhost:8080/users，可进行用户管理操作。此案例展示了Freemarker与SpringBoot的表单处理和重定向。

## 78.3 进一步理解
通过以下问题深入掌握Freemarker。

### 78.3.1 为什么SpringBoot中支持Freemarker？
SpringBoot支持Freemarker作为模板引擎选项，主要因为：
- **高性能和稳定性**：Freemarker编译模板缓存到内存，处理大量数据时效率高，适合高并发场景。
- **灵活的逻辑控制**：FTL语法支持复杂逻辑（如宏、嵌套循环），适用于报表生成或代码生成工具。
- **企业级应用传统**：许多遗留系统使用Freemarker，SpringBoot提供兼容支持。
- **轻量集成**：自动配置简化，无需额外依赖。但与Thymeleaf相比，Freemarker缺乏自然模板特性。

### 78.3.2 Freemarker的生态？
Freemarker拥有成熟的生态系统：
- **核心功能**：支持模板继承、宏库、国际化等。
- **Spring整合**：通过`spring-context-support`集成，支持Spring标签。
- **扩展工具**：如IDE插件（Eclipse、IntelliJ）、Maven插件用于模板预处理。
- **社区支持**：Apache基金会维护，文档完善，但更新频率低于Thymeleaf。
- **应用场景**：常用于电商平台、内容管理系统和批量数据处理。

### 78.3.3 Freemarker其它常见问题？
常见问题及解决方案：
- **模板缓存问题**：生产环境默认开启缓存，调试时可通过`spring.freemarker.cache=false`禁用。
- **语法错误调试**：Freemarker错误信息详细，可配置`spring.freemarker.settings.template_exception_handler=debug`输出堆栈。
- **安全性**：避免用户输入直接插入模板，使用内置函数转义（如`${userInput?html}`）。
- **与前端框架整合**：由于Freemarker在服务端渲染，与Vue.js等前端框架共用时需注意上下文隔离。

## 78.4 示例源码
完整代码已集成在上述案例中。可通过Spring Initializr创建项目测试。如需更多示例，参考：
- Freemarker官方指南：https://freemarker.apache.org/docs/dgui_quickstart.html
- SpringBoot文档：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.templating

## 78.5 Freemarker与Thymeleaf深度对比及流行趋势
本部分对Freemarker和Thymeleaf进行深度对比，并讨论当前流行方式，帮助您在实际项目中选择合适的模板引擎。

### 78.5.1 深度对比
从语法、性能、集成、学习曲线等维度对比：

| 特性 | Freemarker | Thymeleaf |
|------|------------|-----------|
| **语法设计** | 基于FTL专有语法（如`<#if>`、`${}`），逻辑强大，但需学习新语言。 | 基于HTML属性（如`th:`前缀），自然模板可直接预览，更符合前端习惯。 |
| **性能** | 通常更高，模板编译后缓存，适合高并发场景。Benchmark显示处理复杂逻辑时更快。 | Thymeleaf 3.0后性能提升，但仍稍慢于Freemarker，因需解析HTML结构。 |
| **与SpringBoot集成** | 自动配置，支持Spring MVC，但缺乏Thymeleaf的深度整合（如Spring Security标签）。 | 无缝集成，支持Spring生态特性（如`sec:`标签），是SpringBoot默认推荐。 |
| **学习曲线** | 语法相对复杂，尤其宏定义，但文档完善。 | 语法简单，前端开发者易上手，学习曲线平缓。 |
| **模板可预览性** | 不支持自然模板，必须通过服务器渲染才能查看效果。 | 支持自然模板，HTML文件可直接在浏览器中预览，便于协作开发。 |
| **适用场景** | 企业级应用、报表生成、代码生成、高性能需求系统。 | Web应用、快速原型开发、需要前后端分离过渡的项目。 |
| **社区和更新** | Apache维护，稳定但更新较慢，适合传统项目。 | 社区活跃，持续更新，紧跟Spring生态。 |

### 78.5.2 目前流行的方式
当前，模板引擎的选择趋势如下：
- **SpringBoot项目首选Thymeleaf**：由于其自然模板特性和与Spring生态的深度整合，Thymeleaf成为新项目的默认选择，尤其适合敏捷开发和团队协作。
- **Freemarker在特定场景仍占优势**：对于性能要求极高的系统（如金融或大数据平台），或遗留系统升级，Freemarker因稳定性和速度更受青睐。
- **前后端分离的兴起**：随着Vue.js、React等前端框架普及，许多项目转向前后端分离，后端仅提供API，模板引擎使用减少。但在服务端渲染（SSR）或简单管理后台中，模板引擎仍有价值。
- **综合建议**：
  - 如果项目强调开发效率和前端友好性，选择Thymeleaf。
  - 如果追求极致性能或处理复杂逻辑，Freemarker更合适。
  - 对于新项目，可优先评估Thymeleaf，因其是SpringBoot社区的主流推荐。

通过以上对比，您可以根据项目需求灵活选择。在实践中，两者都能良好工作，关键在于团队熟悉度和具体场景。
# 七十九、Spring Security中的CSRF Token处理：Freemarker与Thymeleaf对比

在Freemarker/Thymeleaf模板中使用`${(_csrf.headerName)!}`和`${(_csrf.token)!}`来传递CSRF token的方式是Spring Security中的常见做法。

## 79.1. Spring Security中CSRF Token的默认行为
Spring Security默认启用CSRF（跨站请求伪造）保护。当使用模板引擎（如Freemarker或Thymeleaf）时，Spring Security会自动将CSRF token的相关信息添加到模型（Model）中，以便在模板中访问。关键点如下：
- **默认启用**：Spring Security默认开启CSRF保护，无需额外配置。
- **模型属性**：Spring Security会自动向模型添加一个名为`_csrf`的对象，该对象包含：
  - `token`：CSRF token的值（字符串）。
  - `headerName`：CSRF token在HTTP头中的字段名（默认为`X-CSRF-TOKEN`）。
  - `parameterName`：CSRF token在表单参数中的字段名（默认为`_csrf`）。
- **模板引擎集成**：这一行为是Spring Security与模板引擎集成的部分，无论使用Freemarker还是Thymeleaf，只要Spring Security在类路径中，`_csrf`对象就会被注入模型。

因此，您在Freemarker中使用的语法`${(_csrf.headerName)!}`和`${(_csrf.token)!}`是Spring Security的默认支持方式。`!`是Freemarker的空值处理运算符，用于避免变量未定义时的错误。
## 79.2. 在Freemarker中实现CSRF Token传递
### 79.2.1 引入pom依赖
```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-freemarker</artifactId>
    </dependency>
```
### 79.2.2 在模板中增加定义
```html
<!DOCTYPE html>
<html>
<head>
    <meta name="_csrf_header" content="${(_csrf.headerName)!}">
    <meta name="_csrf" content="${(_csrf.token)!}">
</head>
</html>
```
## 79.3. 在Thymeleaf中实现CSRF Token传递
Thymeleaf同样支持CSRF token的集成，而且方式更为简洁。以下是具体实现方法：

### 79.3.1 步骤1: 添加Thymeleaf Spring Security依赖
在`pom.xml`中添加Thymeleaf的Spring Security扩展依赖（如果尚未添加）：
```xml
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId> <!-- 适用于Spring Security 5.x -->
    <version>3.0.4.RELEASE</version> <!-- 使用与SpringBoot兼容的版本 -->
</dependency>
```

### 79.3.2 步骤2: 在Thymeleaf模板中访问CSRF Token
Thymeleaf提供了多种方式处理CSRF token：
- **方式1: 直接使用模型属性**（与Freemarker类似）：
  ```html
  <!DOCTYPE html>
  <html xmlns:th="http://www.thymeleaf.org">
  <head>
      <meta charset="UTF-8">
      <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
      <meta name="_csrf" th:content="${_csrf.token}"/>
  </head>
  <body>
      <!-- 其他内容 -->
  </body>
  </html>
  ```
  这里使用Thymeleaf的`th:content`属性直接输出`_csrf`对象的值。这种方式与Freemarker逻辑一致。

- **方式2: 使用Thymeleaf的Spring Security标签**（推荐）：
  Thymeleaf的Spring Security扩展提供了更简洁的语法。首先，在HTML中引入安全命名空间：
  ```html
  <!DOCTYPE html>
  <html xmlns:th="http://www.thymeleaf.org"
        xmlns:sec="http://www.thymeleaf.org/extras/spring-security"> <!-- 引入安全命名空间 -->
  <head>
      <meta charset="UTF-8">
      <!-- 使用sec:csrfMetaTags自动生成CSRF meta标签 -->
      <meta sec:csrfMetaTags />
  </head>
  <body>
      <!-- 在表单中自动添加CSRF token -->
      <form method="post" action="/submit">
          <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
          <!-- 或使用更简洁的sec:csrfInput -->
          <input type="hidden" sec:csrfInput />
          <button type="submit">提交</button>
      </form>
  </body>
  </html>
  ```
  - `sec:csrfMetaTags`：自动生成包含CSRF token和header名称的meta标签（等价于您提到的Freemarker方式）。
  - `sec:csrfInput`：在表单中自动生成隐藏的CSRF token输入字段，无需手动编写。

### 79.3.3 步骤3: 确保Spring Security配置正确
CSRF token的自动注入依赖于Spring Security的默认配置。如果自定义了安全配置，需确保未禁用CSRF：
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .and()
            .csrf(); // 默认启用CSRF，无需显式调用也可
    }
}
```

## 79.4. Freemarker与Thymeleaf的CSRF处理对比
| 特性 | Freemarker | Thymeleaf |
|------|------------|-----------|
| **语法** | 使用Freemarker表达式：`${_csrf.token}`，需手动处理空值（如`!`）。 | 使用Thymeleaf属性：`th:content="${_csrf.token}"`或专用标签`sec:csrfMetaTags`。 |
| **集成度** | 依赖Spring Security的自动模型注入，无额外标签支持。 | 通过`thymeleaf-extras-springsecurity`库提供高级标签（如`sec:csrfInput`），更简洁。 |
| **默认行为** | 是Spring Security的默认支持方式，但需手动编写meta标签。 | 同样支持默认模型注入，但推荐使用扩展标签以提升可读性。 |
| **错误处理** | 需使用`!`运算符避免空值异常。 | Thymeleaf自动处理表达式空值，更安全。 |

## 79.5. 当前流行方式建议
- **Thymeleaf是SpringBoot的首选**：由于与Spring生态深度集成，Thymeleaf的`sec:`标签更符合现代开发习惯，代码更简洁。
- **Freemarker在遗留项目中常见**：如果您维护传统系统，Freemarker的方式仍然有效。
- **最佳实践**：无论使用哪种模板引擎，都建议将CSRF token通过meta标签传递给前端JavaScript，以便在AJAX请求中添加CSRF头。例如：
  ```javascript
  var csrfToken = document.querySelector("meta[name='_csrf']").getAttribute("content");
  var csrfHeader = document.querySelector("meta[name='_csrf_header']").getAttribute("content");
  // 在AJAX请求头中添加
  xhr.setRequestHeader(csrfHeader, csrfToken);
  ```
## 79.6 补充
> 为什么我们在上面介绍的时候freemarker模板只是简单的引入`spring-boot-starter-freemarker`，但是thymeleaf却有一个单独配合springsecurity的依赖`thymeleaf-extras-springsecurity`?这触及到了Thymeleaf和Freemarker在Spring生态中设计哲学的一个核心区别。

对于基础的CSRF token获取，Thymeleaf确实不需要额外依赖,引入`spring-boot-starter-thymeleaf`即可。但引入 `thymeleaf-extras-springsecurity` 依赖是为了获得**更强大、更便捷、更语义化**的集成功能。

下面我为您详细解释这背后的原因和区别。

### 79.6.1. 核心机制：Spring Security 提供数据，模板引擎负责显示

首先，无论使用Freemarker还是Thymeleaf，**提供 `_csrf` 这个模型属性的是 Spring Security 本身，而不是模板引擎**。

当Spring Security在类路径中时，它会自动将一个 `CsrfToken` 对象添加到每个请求的模型（Model）中，属性名默认为 `_csrf`。这意味着，任何模板引擎都可以通过访问模型数据来获取它。

- **Freemarker方式**：`${_csrf.token}` 直接访问模型属性。
- **Thymeleaf基础方式**：`th:content="${_csrf.token}"` 同样直接访问模型属性。

**所以，只引入 `spring-boot-starter-thymeleaf`，您完全可以使用基础方式：**

```html
<meta name="_csrf_header" th:content="${_csrf.headerName}"/>
<meta name="_csrf" th:content="${_csrf.token}"/>
```

### 79.6.2. 那么，为什么还需要额外的依赖？

`thymeleaf-extras-springsecurity` 依赖的目的不是让您“能”获取CSRF token，而是让您“更好地”与Spring Security集成。它提供了一整套专用的方言（Dialect）和标签，主要优势如下：

#### 优势一：极简的语法糖和自动化

对于CSRF token，它提供了两个极其方便的标签：

- **`<meta sec:csrfMetaTags />`**
    这行代码会自动生成完整的两个meta标签，无需您手动写两个`<meta>`标签并分别指定 `headerName` 和 `token`。更简洁，更不易出错。

- **`<input type="hidden" sec:csrfInput />`**
    在表单中，您不需要再手动写一个隐藏域。这个标签会自动生成类似 `<input type="hidden" name="_csrf" value="..."/>` 的代码。这对于保护POST表单非常方便。

#### 优势二：强大的安全表达式和条件渲染（这是最重要的原因）

CSRF处理只是这个扩展库的“开胃菜”，其核心价值在于它允许您在模板中直接使用Spring Security的权限信息进行条件判断。

**没有该依赖，您无法在Thymeleaf中做以下事情：**

```html
<!-- 根据用户权限决定是否显示某个元素 -->
<div sec:authorize="isAuthenticated()">
   <p>这段内容只有已登录用户能看到。</p>
</div>

<div sec:authorize="hasRole('ADMIN')">
   <a href="/admin">管理员后台</a>
</div>

<!-- 显示当前登录用户的用户名 -->
<p>用户名：<span sec:authentication="name"></span></p>

<!-- 检查是否有某个权限 -->
<div sec:authorize="hasAuthority('USER:DELETE')">
   <button>删除用户</button>
</div>
```

这些 `sec:authorize`、`sec:authentication` 等标签是 `thymeleaf-extras-springsecurity` 库定义的**专属方言**。没有这个依赖，Thymeleaf根本不认识 `sec:` 这个命名空间下的这些属性。

### 79.6.3. 对比总结

| 特性 | Freemarker | Thymeleaf (仅基础依赖) | Thymeleaf (引入安全扩展) |
| :--- | :--- | :--- | :--- |
| **获取CSRF Token** | ✅ 直接通过 `${_csrf}` | ✅ 直接通过 `th:content="${_csrf}"` | ✅ 直接通过 `th:content="${_csrf}"` |
| **CSRF Meta Tags** | ❌ 需手动编写两个标签 | ❌ 需手动编写两个标签 | ✅ **极简**：`<meta sec:csrfMetaTags />` |
| **CSRF 表单隐藏域** | ❌ 需手动编写 | ❌ 需手动编写 | ✅ **极简**：`<input sec:csrfInput />` |
| **基于权限的条件渲染**| ❌ 很难实现，或需自定义 | ❌ 无法实现 | ✅ **强大支持**：`sec:authorize="hasRole('ADMIN')"` |
| **获取认证信息** | ❌ 困难 | ❌ 无法实现 | ✅ **简单**：`sec:authentication="name"` |

### 结论

- **Freemarker**：设计上更“纯粹”，它是一个模板引擎，不直接与安全框架等耦合。它通过标准方式访问模型数据，功能强大但需要更多手动代码。Spring Boot没有为它提供官方的安全扩展。
- **Thymeleaf**：设计上更注重与Spring生态的**深度集成**。其核心库 (`spring-boot-starter-thymeleaf`) 解决了模板解析的基本问题，而各种 `extras` 扩展库（如针对Spring Security、Java8 Time等）则提供了针对特定场景的、更高级的、语义化的标签，极大地提升了开发效率和代码可读性。

因此，`thymeleaf-extras-springsecurity` 不是一个“必须”的依赖，而是一个“强烈推荐”的依赖。它代表了Thymeleaf在Spring生态中的优势：**通过声明式的方式，将后端安全逻辑优雅地集成到前端模板中**。如果您在项目中使用了Spring Security，引入这个依赖几乎是标准做法。
# 八十、▶SpringBoot应用部署 - 打包成jar部署
> 我们知道spring-boot-starter-web默认已经集成了web容器(tomcat)，在部署前只需要将项目打包成jar即可。那么怎么将springboot web项目打包成jar呢？本文主要介绍常见的几种方式。
## 80.1 通过Maven打包成jar
> 通过Maven打包成jar，最为常用，因为可以脚本化，这是所有自动化部署的前提。

首先， 在pom中使用SpringBoot的build插件
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```
然后通过如下步骤进行build
![281.springboot-x-jar-8.png](../../assets/images/04-主流框架/spring/281.springboot-x-jar-8.png)
## 80.2 通过Idea打包成jar
> 此外一些IDE工具也集成了打包的功能，我们看下如下通过idea打包成jar。
1. File栏选择Project Structure
![282.springboot-x-jar-1.png](../../assets/images/04-主流框架/spring/282.springboot-x-jar-1.png)
2. 在Artifacts下添加jar
![283.springboot-x-jar-2.png](../../assets/images/04-主流框架/spring/283.springboot-x-jar-2.png)
3. 选择module，main class等
![284.springboot-x-jar-3.png](../../assets/images/04-主流框架/spring/284.springboot-x-jar-3.png)
4. 确认编译后的jar输出位置
![285.springboot-x-jar-4.png](../../assets/images/04-主流框架/spring/285.springboot-x-jar-4.png)
5. 进行build
![286.springboot-x-jar-5.png](../../assets/images/04-主流框架/spring/286.springboot-x-jar-5.png)
点击build/rebuild
![287.springboot-x-jar-6.png](../../assets/images/04-主流框架/spring/287.springboot-x-jar-6.png)
6. 编译后的jar
![288.springboot-x-jar-7.png](../../assets/images/04-主流框架/spring/288.springboot-x-jar-7.png)
# 八十一、SpringBoot应用部署 - 使用第三方JAR包
> 在项目中我们经常需要使用第三方的Jar，比如某些SDK，这些SDK没有直接发布到公开的maven仓库中，这种情况下如何使用这些三方JAR呢？本文提供最常用的两种方式。
## 81.1 方案一：安装到Maven仓库
> 如果有项目的Maven仓库，则推荐按照到的Maven仓库（比如私服）中。（最好不是本地的Maven仓库，因为还有CI环境需要集成。）

配置Maven私服, server & profile
```xml
<!-- server -->
<server>
    <id>nexus</id>
    <username>pdai</username>
    <password>passw0rd</password>
</server>
<!-- profile -->
<profile>
    <id>pdai-artifactory</id>
    <repositories>
        <repository>
            <id>nexus</id>
            <url>xxx.xxx.xxx.xxx</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>
</profile>
```
```sh
# -X：详细信息输出用于调试
# -Dfile：本地jar路径
# gav: group, artifactId, verson
# -Durl：仓库地址
# -DrepositoryId：settings文件中的ID
mvn -X deploy:deploy-file -DgroupId=tech.pdai -DartifactId=test-xxx -Dversion=1.1.0 -Dpackaging=jar -Dfile=/xxxx/xxx.jar -Durl=http://nexus.pdai.tech/repository/releases/ -DrepositoryId=nexus
```
## 81.2 方案二：使用systemPath属性
> 如果Jar无法放到maven仓库，即放在项目代码中，比如项目中libs文件夹中

使用systemPath属性，`<scope>system</scope>`, 其它gav三元组是可以随意填写的。
```xml
<dependency>
    <groupId>com.aliyun</groupId>
    <artifactId>taobao-sdk-java</artifactId>
    <version>1.0.0</version>
    <scope>system</scope>
    <systemPath>${project.basedir}/libs/taobao-sdk-java-auto_1479188381469-20180831.jar</systemPath>
</dependency>
```
- SpringBoot JAR打包

springboot在打包的时候，调用spring-boot-maven-plugin，执行repackage把tomcat和resource，lib等合成一个新的jar。想要将系统jar打进去，必须配置includeSystemScope。最终会将lib放入BOOT-INF\lib
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <includeSystemScope>true</includeSystemScope>
            </configuration>
            <executions>
                <execution>
                    <goals>
                        <goal>build-info</goal>
                        <goal>repackage</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```
- SpringBoot War打包

使用mvn clean package命令打包时需要在pom文件加入以下webResources配置，并设置jar包在WEB-INF/lib目录下
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <webResources>
            <resource>
                <directory>src/main/resources/libs/</directory>
                <targetPath>WEB-INF/lib/</targetPath>
                <includes>
                    <include>**/*.jar</include>
                </includes>
            </resource>
        </webResources>
    </configuration>
</plugin>
```
# 八十二、SpringBoot应用部署 - 打包成war部署
## 82.1 概述
> 前文我们知道SpringBoot web项目默认打包成jar部署是非常方便的，那什么样的场景下还会打包成war呢？

这主要是由于在早期没有SpringBoot时，一些老的项目已经通过Tomcat独立部署war包，并构建了相应的部署体系和闭环。而且对于老的成熟的项目不期望在投入精力去升级和改造，只需要最小大家的保证运行稳定，为了投入和产出的平衡。

在这种情况下，如果有一些必要性的更新（比如高危漏洞的修复），需要编译成war包。

## 82.2 打包成war
### 82.2.1 将pom中packaging设置为war类型
默认是jar类型，需要添加或者改成war类型
```xml
<groupId>tech.pdai</groupId>
<artifactId>103-springboot-demo-helloworld-build-war</artifactId>
<packaging>war</packaging>
<version>1.0-SNAPSHOT</version>
```
### 82.2.2 移除内嵌的Tomcat，并增加servlet-api的依赖包
因为默认内嵌了tomcat，所以需要移除；并增加servlet-api相关的包。
![289.springboot-x-war-1.png](../../assets/images/04-主流框架/spring/289.springboot-x-war-1.png)
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <scope>provided</scope>
</dependency>
```
### 82.2.3 启动类继承SpringBootServletInitialize
修改项目默认启动方式，启动类继承SpringBootServletInitializer类并重写configure()方法
![290.springboot-x-war-2.png](../../assets/images/04-主流框架/spring/290.springboot-x-war-2.png)

完整代码如下
```java
/**
 * @author pdai
 */
@SpringBootApplication
@RestController
public class SpringBootHelloWorldApplication extends SpringBootServletInitializer {

    /**
     * main interface.
     *
     * @param args args
     */
    public static void main(String[] args) {
        SpringApplication.run(SpringBootHelloWorldApplication.class, args);
    }

    /**
     * hello world.
     *
     * @return hello
     */
    @GetMapping("/hello")
    public ResponseEntity<String> hello() {
        return new ResponseEntity<>("hello world", HttpStatus.OK);
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return builder.sources(SpringBootHelloWorldApplication.class);
    }
}
```
### 82.2.4 maven打包成war的插件
- 推荐使用spring-boot-maven-plugin
  -   **这是 Spring Boot 的“官方”插件**，专为 Spring Boot 项目设计。
  -   在执行 `mvn package` 时，它会根据 `pom.xml` 中的 `<packaging>war</packaging>` 配置，自动识别并打包成 war 文件。
  -   它**已经包含了 `maven-war-plugin` 的核心功能**，并且与 Spring Boot 的生命周期（如 `repackage`）完美集成。
  -   你甚至不需要在 `pom.xml` 中显式声明它，因为 Spring Boot 的 starter parent 通常已经预配置了。
```xml
<!-- 通常由 spring-boot-starter-parent 提供，无需显式配置即可工作 -->
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```
- 使用maven-war-plugin插件进行打包
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>3.3.1</version>
    <configuration>
        <failOnMissingWebXml>false</failOnMissingWebXml>
    </configuration>
</plugin>
```
### 82.2.5 打包测试
通过maven 进行打包测试
![291.springboot-x-war-3.png](../../assets/images/04-主流框架/spring/291.springboot-x-war-3.png)
# 八十三、SpringBoot应用部署 - 替换tomcat为Jetty容器
> 前文我们知道spring-boot-starter-web默认集成tomcat servlet容器(被使用广泛)；而Jetty也是servlet容器，它具有易用性，轻量级，可拓展性等，有些场景（Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境）下会使用jetty容器。本文主要介绍SpringBoot使用Jetty容器。
## 83.1 概述
### 83.1.1 什么是Jetty
Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行(stand-alone)的Java应用提供网络和web连接。
- 易用性

易用性是 Jetty 设计的基本原则，易用性主要体现在以下几个方面：
1. 通过 XML 或者 API 来对Jetty进行配置；
2. 默认配置可以满足大部分的需求；
3. 将 Jetty 嵌入到应用程序当中只需要非常少的代码；
- 可扩展性

在使用了 Ajax 的 Web 2.0 的应用程序中，每个连接需要保持更长的时间，这样线程和内存的消耗量会急剧的增加。这就使得我们担心整个程序会因为单个组件陷入瓶颈而影响整个程序的性能。但是有了 Jetty：
1. 即使在有大量服务请求的情况下，系统的性能也能保持在一个可以接受的状态。
2. 利用 Continuation 机制来处理大量的用户请求以及时间比较长的连接。
3. 另外 Jetty 设计了非常良好的接口，因此在 Jetty 的某种实现无法满足用户的需要时，用户可以非常方便地对 Jetty 的某些实现进行修改，使得 Jetty 适用于特殊的应用程序的需求。
- 易嵌入性

Jetty 设计之初就是作为一个优秀的组件来设计的，这也就意味着 Jetty 可以非常容易的嵌入到应用程序当中而不需要程序为了使用 Jetty 做修改。从某种程度上，你也可以把 Jetty 理解为一个嵌入式的Web服务器。

Jetty 可以作为嵌入式服务器使用，Jetty的运行速度较快，而且是轻量级的，可以在Java中可以从test case中控制其运行。从而可以使自动化测试不再依赖外部环境，顺利实现自动化测试。
### 83.1.2 Jetty和Tomcat容器对比
> Tomcat和Jetty都是一种Servlet引擎，他们都支持标准的servlet规范和JavaEE的规范。以下对比来源于百度百科：
- Jetty更轻量级。这是相对Tomcat而言的。

由于Tomcat除了遵循Java Servlet规范之外，自身还扩展了大量J2EE特性以满足企业级应用的需求，所以Tomcat是较重量级的，而且配置较Jetty亦复杂许多。但对于大量普通互联网应用而言，并不需要用到Tomcat其他高级特性，所以在这种情况下，使用Tomcat是很浪费资源的。这种劣势放在分布式环境下，更是明显。换成Jetty，对新的Servlet规范的支持较好，且每个应用服务器省下那几兆内存，对于大的分布式环境则是节省大量资源。而且，Jetty的轻量级也使其在处理高并发细粒度请求的场景下显得更快速高效。
- Jetty更灵活

体现在其可插拔性和可扩展性，更易于开发者对Jetty本身进行二次开发，定制一个适合自身需求的Web Server。 相比之下，重量级的Tomcat原本便支持过多特性，要对其瘦身的成本远大于丰富Jetty的成本。用自己的理解，即增肥容易减肥难。
- 然而，当支持大规模企业级应用时

Jetty也许便需要扩展，在这场景下Tomcat便是更优的。

总结：Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境。

## 83.2 替换tomcat为jetty容器
### 83.2.1 移除内嵌的Tomcat并使用jetty
移除内嵌的Tomcat相关的依赖spring-boot-starter-tomcat，并增加jetty的依赖spring-boot-starter-jetty
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```
### 83.2.2 配置jetty
jetty相关的配置可以看：
![292.springboot-x-jetty-1.png](../../assets/images/04-主流框架/spring/292.springboot-x-jetty-1.png)
### 93.2.3 简单测试
运行SpringBootApplication

结果如下
![293.springboot-x-jetty-2.png](../../assets/images/04-主流框架/spring/293.springboot-x-jetty-2.png)

运行的日志如下
```sh

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.5.3)

2022-04-18  21:09:21.749  INFO 54806 --- [           main] .p.s.h.j.SpringBootHelloWorldApplication : Starting SpringBootHelloWorldApplication using Java 1.8.0_181 on MacBook-Pro.local with PID 54806 (/Users/pdai/pdai/www/tech-pdai-spring-demos/104-springboot-demo-helloworld-jetty/target/classes started by pdai in /Users/pdai/pdai/www/tech-pdai-spring-demos)
2022-04-18  21:09:21.752  INFO 54806 --- [           main] .p.s.h.j.SpringBootHelloWorldApplication : No active profile set, falling back to default profiles: default
2022-04-18  21:09:22.484  INFO 54806 --- [           main] org.eclipse.jetty.util.log               : Logging initialized @1888ms to org.eclipse.jetty.util.log.Slf4jLog
2022-04-18  21:09:22.556  INFO 54806 --- [           main] o.s.b.w.e.j.JettyServletWebServerFactory : Server initialized with port: 8080
2022-04-18  21:09:22.558  INFO 54806 --- [           main] org.eclipse.jetty.server.Server          : jetty-9.4.43.v20210629; built: 2021-06-30T11:07:22.254Z; git: 526006ecfa3af7f1a27ef3a288e2bef7ea9dd7e8; jvm 1.8.0_181-b13
2022-04-18  21:09:22.577  INFO 54806 --- [           main] o.e.j.s.h.ContextHandler.application     : Initializing Spring embedded WebApplicationContext
2022-04-18  21:09:22.577  INFO 54806 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 755 ms
2022-04-18  21:09:22.632  INFO 54806 --- [           main] org.eclipse.jetty.server.session         : DefaultSessionIdManager workerName=node0
2022-04-18  21:09:22.632  INFO 54806 --- [           main] org.eclipse.jetty.server.session         : No SessionScavenger set, using defaults
2022-04-18  21:09:22.633  INFO 54806 --- [           main] org.eclipse.jetty.server.session         : node0 Scavenging every 660000ms
2022-04-18  21:09:22.638  INFO 54806 --- [           main] o.e.jetty.server.handler.ContextHandler  : Started o.s.b.w.e.j.JettyEmbeddedWebAppContext@232024b9{application,/,[file:///private/var/folders/p9/9xtytd4j6lxc0ttbpjx63s2c0000gn/T/jetty-docbase.8080.6026164686377179293/],AVAILABLE}
2022-04-18  21:09:22.638  INFO 54806 --- [           main] org.eclipse.jetty.server.Server          : Started @2043ms
2022-04-18  21:09:22.887  INFO 54806 --- [           main] o.e.j.s.h.ContextHandler.application     : Initializing Spring DispatcherServlet 'dispatcherServlet'
2022-04-18  21:09:22.887  INFO 54806 --- [           main] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2022-04-18  21:09:22.888  INFO 54806 --- [           main] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2022-04-18  21:09:22.905  INFO 54806 --- [           main] o.e.jetty.server.AbstractConnector       : Started ServerConnector@78461bc4{HTTP/1.1, (http/1.1)}{0.0.0.0:8080}
2022-04-18  21:09:22.906  INFO 54806 --- [           main] o.s.b.web.embedded.jetty.JettyWebServer  : Jetty started on port(s) 8080 (http/1.1) with context path '/'
2022-04-18  21:09:22.914  INFO 54806 --- [           main] .p.s.h.j.SpringBootHelloWorldApplication : Started SpringBootHelloWorldApplication in 1.648 seconds (JVM running for 2.32)
```
## 83.3 进一步理解
### 83.3.1 Google将默认的应用引擎切换为Jetty?
> Google 应用系统引擎最初是以 Apache Tomcat 作为其 webserver/servlet 容器的，但最终将切换到 Jetty 上。为什么要做这样的改变？

**不是为了性能，而是轻量级！**

Google选择Jetty的关键原因是它的体积和灵活性。在云计算里，体积的因素是很重要，如果你运行几万个Jetty的实例（Google就是这样干的），每个server省1兆，那就会省10几个G的内存（或能够给其他应用提供更多的内存）。

Jetty 被设计成了可插拔和可扩展的特性，这样Google就可以高度的自定义它。他们在其中替换了他们自己的HTTP connector，Google认证，以及他们自己的session集群。也真是奇怪，这个特性对于云计算来说是非常出色的，但同时也让Jetty非常适合嵌入小的设备中，例如手机和机顶盒。

# 八十四、SpringBoot应用部署 - 替换tomcat为Undertow容器
> 前文我们了解到Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境；那么从性能的角度来看，更为优秀的servlet容器是Undertow。本文将介绍Undertow，以及SpringBoot集成Undertow的示例。
## 84.1 概述
### 84.1.1 什么是Undertow?
> 内容来源于<a href='https://undertow.io/'>Undertow官网</a>

Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于 NIO 的非堵塞机制。Undertow 是RedHat公司的开源产品(原先是JBoss的产品，然后Redhat收购了JBoss)，是 Wildfly 默认的 Web 服务器。

Undertow 提供一个基础的架构用来构建 Web 服务器，这是一个完全为嵌入式设计的项目，提供易用的构建器 API，完全兼容 Java EE Servlet 4 和低级非堵塞的处理器。

Undertow设计为完全可嵌入的，并具有易于使用的流畅的Builder API。 Undertow的生命周期完全由嵌入应用程序控制。

**Undertow的特性有哪些？**
- HTTP/2 Support:Undertow 支持 HTTP/2 开箱即用，不需要重写引导类路径。
- 支持 HTTP 升级:支持 HTTP 升级，允许多个协议通过 HTTP 端口上进行复用。
- 支持 Web Socket:Undertow 提供对 Web 套接字的全面支持，包括对 JSR-356 的支持。
- 支持 Servlet 4.0:Undertow 提供了对 Servlet 4.0 的支持，包括对嵌入式 Servlet 的支持，还可以混合部署 Servlet 和原生 Undertow 非阻塞处理程序。
- 可嵌入式:Undertow 可以嵌入到应用程序中，也可以通过几行代码独立运行。
- 高灵活性:一个 Undertow 服务器是通过链式处理器来配置的，可以根据需要添加功能，因此可以避免添加没有必要的功能。
### 84.1.2 Undertow性能比jetty和tomcat强多少？
> 关于Undertow的性能和jetty,tomcat对于，可以看如下两篇文章：
1. <a href='https://examples.javacodegeeks.com/java-development/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/'>Tomcat vs. Jetty vs. Undertow: Comparison of Spring Boot Embedded Servlet Containers</a>
2. <a href='https://cloud.tencent.com/developer/article/1699803'>Tomcat vs Jetty vs Undertow性能对比</a>
## 84.2 替换tomcat为Undertow容器
### 84.2.1 移除内嵌的Tomcat并使用Undertow
移除内嵌的Tomcat相关的依赖spring-boot-starter-tomcat，并增加undertow的依赖spring-boot-starter-undertow
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-undertow</artifactId>
</dependency>
```
### 84.2.2 配置Undertow
Undertow相关的配置可以看：
![294.springboot-x-undertow-1.png](../../assets/images/04-主流框架/spring/294.springboot-x-undertow-1.png)

### 84.2.3 简单测试
运行SpringBootApplication

结果如下
![295.springboot-x-undertow-2.png](../../assets/images/04-主流框架/spring/295.springboot-x-undertow-2.png)

运行的日志如下
```sh

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.5.3)

2022-04-18  22:47:28.900  INFO 60368 --- [           main] .p.s.h.u.SpringBootHelloWorldApplication : Starting SpringBootHelloWorldApplication using Java 1.8.0_181 on MacBook-Pro.local with PID 60368 (/Users/pdai/pdai/www/tech-pdai-spring-demos/105-springboot-demo-helloworld-undertow/target/classes started by pdai in /Users/pdai/pdai/www/tech-pdai-spring-demos)
2022-04-18  22:47:28.902  INFO 60368 --- [           main] .p.s.h.u.SpringBootHelloWorldApplication : No active profile set, falling back to default profiles: default
2022-04-18  22:47:29.691  WARN 60368 --- [           main] io.undertow.websockets.jsr               : UT026010: Buffer pool was not set on WebSocketDeploymentInfo, the default pool will be used
2022-04-18  22:47:29.710  INFO 60368 --- [           main] io.undertow.servlet                      : Initializing Spring embedded WebApplicationContext
2022-04-18  22:47:29.710  INFO 60368 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 769 ms
2022-04-18  22:47:30.020  INFO 60368 --- [           main] io.undertow                              : starting server: Undertow - 2.2.9.Final
2022-04-18  22:47:30.025  INFO 60368 --- [           main] org.xnio                                 : XNIO version 3.8.4.Final
2022-04-18  22:47:30.029  INFO 60368 --- [           main] org.xnio.nio                             : XNIO NIO Implementation Version 3.8.4.Final
2022-04-18  22:47:30.060  INFO 60368 --- [           main] org.jboss.threads                        : JBoss Threads version 3.1.0.Final
2022-04-18  22:47:30.121  INFO 60368 --- [           main] o.s.b.w.e.undertow.UndertowWebServer     : Undertow started on port(s) 8080 (http)
2022-04-18  22:47:30.132  INFO 60368 --- [           main] .p.s.h.u.SpringBootHelloWorldApplication : Started SpringBootHelloWorldApplication in 1.586 seconds (JVM running for 2.215)
```
## 84.3 进一步理解
### 84.3.1 在异步NIO环境下的性能？
> 结论来源于：https://blog.51cto.com/u_3664660/3212743

HTTP异步的目的在帮助dispatcherservlet分担压力，提升吞吐量。但如果运行在NIO模式的服务容器上，就会产生负面影响，因为NIO本身就做了类似的事情，此时再加HTTP异步，则相当于又加了N多不必要的线程，导致性能主要消耗在线程的开销上，所以**建议使用tomcat作为内嵌容器并且没有开启tomcat的NIO模式时，可以配合HTTP异步来提升程序性能**。尤其是当业务繁重时，提升效果尤其明显。

- 如何启动HTTP异步
```java
package com.shy.test4server;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.context.request.async.WebAsyncTask;

/**
 * @ClassName: TestController
 * @Description: TODO(这里用一句话描述这个类的作用)
 * @author chengcai.shang@
 * @date 2018年12月7日 上午9:36:25
 * 
 */
@Controller
@RequestMapping("/test")
public class TestController {
	/**
	 * 未使用HTTP异步的接口
	 * 
	 * @Title: testCeilingNoAsync
	 * @Description: TODO(这里用一句话描述这个方法的作用)
	 * @date 2018年12月7日 上午9:40:57
	 */
	@GetMapping("/testCeilingNoAsync")
	public String testCeilingNoAsync() {
		return "";
	}

	/**
	 * 使用HTTP异步的接口
	 * 
	 * @Title: testCeilingNoAsync
	 * @Description: TODO(这里用一句话描述这个方法的作用)
	 * @date 2018年12月7日 上午9:40:57
	 */
	@GetMapping("/testCeilingWithAsync")
	public WebAsyncTask<String> testCeilingWithAsync() {
		return new WebAsyncTask(() -> {
			return "";
		});
	}
}
```
### 84.3.2 什么是WebAsyncTask（异步HTTP的spring实现）
`WebAsyncTask` 是 Spring MVC 中用于处理异步请求的一个实用类。让我为你详细介绍它的用法和特性：

#### 84.3.2.1. 基本概念

`WebAsyncTask` 允许你在 Spring MVC 控制器中执行异步操作，主要用于处理长时间运行的任务，避免阻塞请求线程。

```java
@RestController
public class AsyncController {
    
    @GetMapping("/async-task")
    public WebAsyncTask<String> handleAsyncRequest() {
        return new WebAsyncTask<>(30000L, () -> {
            // 模拟长时间运行的任务
            Thread.sleep(2000);
            return "异步任务完成 - " + Thread.currentThread().getName();
        });
    }
}
```

#### 84.3.2.2. 核心特性

##### 84.3.2.2.1 超时控制
```java
@GetMapping("/async-timeout")
public WebAsyncTask<String> handleWithTimeout() {
    // 设置5秒超时
    WebAsyncTask<String> webAsyncTask = new WebAsyncTask<>(5000L, () -> {
        Thread.sleep(10000); // 这个任务需要10秒，会超时
        return "任务完成";
    });
    
    webAsyncTask.onTimeout(() -> "请求超时，请稍后重试");
    return webAsyncTask;
}
```

##### 84.3.2.2.2 回调方法
```java
@GetMapping("/async-callbacks")
public WebAsyncTask<String> handleWithCallbacks() {
    Callable<String> callable = () -> {
        // 业务逻辑
        return "处理结果";
    };
    
    WebAsyncTask<String> webAsyncTask = new WebAsyncTask<>(10000L, callable);
    
    // 完成回调
    webAsyncTask.onCompletion(() -> 
        System.out.println("异步任务完成")
    );
    
    // 超时回调
    webAsyncTask.onTimeout(() -> 
        "自定义超时处理"
    );
    
    // 错误回调
    webAsyncTask.onError(() -> 
        "发生错误时的处理"
    );
    
    return webAsyncTask;
}
```

#### 84.3.2.3. 完整示例

```java
@RestController
@Slf4j
public class AsyncTaskController {
    
    private final Executor asyncExecutor;
    
    public AsyncTaskController(@Qualifier("taskExecutor") Executor asyncExecutor) {
        this.asyncExecutor = asyncExecutor;
    }
    
    @GetMapping("/complex-async")
    public WebAsyncTask<ResponseEntity<String>> complexAsyncTask(@RequestParam String data) {
        log.info("接收请求，当前线程: {}", Thread.currentThread().getName());
        
        Callable<ResponseEntity<String>> callable = () -> {
            log.info("异步处理开始，线程: {}", Thread.currentThread().getName());
            
            // 模拟业务处理
            try {
                // 数据库查询、外部API调用等耗时操作
                String result = processBusinessLogic(data);
                log.info("异步处理完成");
                return ResponseEntity.ok(result);
            } catch (Exception e) {
                log.error("处理失败", e);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("处理失败: " + e.getMessage());
            }
        };
        
        // 创建WebAsyncTask，设置10秒超时
        WebAsyncTask<ResponseEntity<String>> task = 
            new WebAsyncTask<>(10000L, callable);
        
        // 设置自定义执行器
        task.setExecutor(asyncExecutor);
        
        // 设置回调
        task.onTimeout(() -> {
            log.warn("请求超时");
            return ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
                .body("请求超时");
        });
        
        task.onCompletion(() -> 
            log.info("异步任务完成回调")
        );
        
        task.onError(() -> {
            log.error("异步任务发生错误");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("服务器内部错误");
        });
        
        return task;
    }
    
    private String processBusinessLogic(String data) throws InterruptedException {
        // 模拟业务处理
        Thread.sleep(3000);
        return "处理结果: " + data + " - " + System.currentTimeMillis();
    }
}
```

#### 84.3.2.4. 配置支持

需要在配置类中启用异步支持：

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Bean("taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
    
    @Override
    public Executor getAsyncExecutor() {
        return taskExecutor();
    }
}
```

#### 84.3.2.5. 与 DeferredResult 的区别

| 特性 | WebAsyncTask | DeferredResult |
|------|-------------|----------------|
| 返回值 | Callable<T> | 手动设置结果 |
| 超时控制 | 内置支持 | 需要手动处理 |
| 回调方法 | 丰富的回调 | 相对简单 |
| 适用场景 | 有明确返回值的异步任务 | 需要外部事件触发的任务 |

#### 84.3.2.6. 最佳实践

1. **合理设置超时时间**：根据业务需求设置合适的超时时间
2. **使用自定义线程池**：避免使用默认的简单线程池
3. **异常处理**：确保所有异常都被适当处理
4. **资源清理**：在回调中清理资源
5. **监控日志**：添加适当的日志记录

```java
// 最佳实践示例
@GetMapping("/best-practice")
public WebAsyncTask<ApiResponse> bestPractice() {
    long startTime = System.currentTimeMillis();
    
    WebAsyncTask<ApiResponse> task = new WebAsyncTask<>(15000L, () -> {
        try {
            ApiResponse result = someService.process();
            log.info("处理成功，耗时: {}ms", System.currentTimeMillis() - startTime);
            return result;
        } catch (BusinessException e) {
            log.warn("业务异常", e);
            return ApiResponse.error(e.getMessage());
        } catch (Exception e) {
            log.error("系统异常", e);
            return ApiResponse.error("系统繁忙");
        }
    });
    
    task.onTimeout(() -> {
        log.warn("请求超时，耗时: {}ms", System.currentTimeMillis() - startTime);
        return ApiResponse.error("请求超时");
    });
    
    return task;
}
```

`WebAsyncTask` 是处理异步请求的强大工具，特别适合需要精确控制超时和回调的场景。
### 84.3.3 WebAsyncTask 和@Async注解的区别
**WebAsyncTask 和 @Async 的底层原理完全不同**。让我详细解释它们的差异：

#### 84.3.3.1. WebAsyncTask - HTTP 异步请求机制

```java
@RestController
public class AsyncController {
    
    @GetMapping("/async")
    public WebAsyncTask<String> handleAsync() {
        return new WebAsyncTask<>(5000L, () -> {
            // 这个 Callable 会在异步线程中执行
            return "Result";
        });
    }
}
```

**底层原理：**
- **基于 Servlet 3.0+ 异步特性**
- **不创建新线程**，而是利用容器的异步处理能力
- **请求线程立即释放**，但 HTTP 连接保持打开
- **使用配置的 TaskExecutor** 执行实际业务逻辑
- **本质是异步非阻塞 I/O**

**工作流程：**
```
HTTP请求 → Servlet容器 → 立即返回WebAsyncTask → 释放请求线程 → 
→ 异步执行Callable → 完成后写回响应 → 关闭连接
```

#### 84.3.3.2. @Async - 方法级别的异步执行

```java
@Service
public class UserService {
    
    @Async
    public CompletableFuture<User> findUser(Long id) {
        // 这个方法会在新线程中执行
        return CompletableFuture.completedFuture(userRepository.findById(id));
    }
}
```

**底层原理：**
- **基于 Spring AOP 代理**
- **确实会创建新线程**（或使用线程池）
- **与 HTTP 请求生命周期无关**
- **纯粹的方法异步执行**

**工作流程：**
```
方法调用 → Spring AOP拦截 → 提交到线程池 → 立即返回Future → 
→ 新线程执行实际方法
```

#### 84.3.3.3. 核心区别对比

| 方面 | WebAsyncTask | @Async |
|------|-------------|--------|
| **层级** | Web层（HTTP请求级别） | 任何层（方法级别） |
| **线程模型** | 请求线程立即释放，业务在异步线程执行 | 调用线程立即返回，方法在新线程执行 |
| **HTTP连接** | 保持连接直到异步完成 | 与HTTP无关 |
| **适用场景** | 长时间HTTP请求处理 | 后台任务、并行处理 |
| **依赖** | Servlet 3.0+ 容器支持 | Spring框架支持 |

#### 84.3.3.4. 实际执行线程分析

```java
@RestController
@Slf4j
public class ThreadAnalysisController {
    
    @GetMapping("/thread-analysis")
    public WebAsyncTask<String> threadAnalysis() {
        log.info("1. Controller方法执行线程: {}", Thread.currentThread().getName());
        
        return new WebAsyncTask<>(10000L, () -> {
            log.info("2. WebAsyncTask执行线程: {}", Thread.currentThread().getName());
            return "完成";
        });
    }
    
    @Async
    public CompletableFuture<String> asyncMethod() {
        log.info("3. @Async方法执行线程: {}", Thread.currentThread().getName());
        return CompletableFuture.completedFuture("完成");
    }
}
```

**输出结果可能是：**
```
1. Controller方法执行线程: http-nio-8080-exec-1
2. WebAsyncTask执行线程: task-1
3. @Async方法执行线程: task-2
```

#### 84.3.3.5. 底层技术栈

##### 84.3.3.5.1 WebAsyncTask 技术栈：
```
Servlet 3.0 AsyncContext
    ↓
Spring MVC AsyncWebRequest
    ↓
WebAsyncManager
    ↓
WebAsyncTask/Callable
    ↓
TaskExecutor (线程池执行实际业务)
```

##### 84.3.3.5.2 @Async 技术栈：
```
Spring AOP Proxy
    ↓
AnnotationAsyncExecutionInterceptor
    ↓
TaskExecutor (线程池执行方法)
    ↓
返回 Future/CompletableFuture
```

#### 84.3.3.6. 关键理解点

**你的理解完全正确：**
- **@Async**：确实是"开个新线程"来执行方法
- **WebAsyncTask**：实现的是HTTP异步请求，利用Servlet 3.0特性

**更准确地说：**
- WebAsyncTask 是为了 **不阻塞HTTP工作线程**
- @Async 是为了 **方法的异步执行**（与HTTP无关）

#### 84.3.3.7. 实际应用选择

```java
// 场景1：需要异步HTTP响应（使用WebAsyncTask）
@GetMapping("/long-request")
public WebAsyncTask<String> longRunningRequest() {
    return new WebAsyncTask<>(30000L, () -> {
        // 长时间处理，但不阻塞HTTP线程
        return heavyService.process();
    });
}

// 场景2：服务层异步方法（使用@Async）
@Service
public class NotificationService {
    @Async
    public void sendEmailAsync(String to, String content) {
        // 发送邮件，与HTTP请求无关
        emailSender.send(to, content);
    }
}
```
### 84.3.4 DeferredResult又是什么？
`DeferredResult` 是 Spring MVC 中另一个重要的异步处理机制，它与 `WebAsyncTask` 类似但又有所不同。

#### 84.3.4.1. 基本概念

`DeferredResult` 允许你将 HTTP 请求的处理延迟到另一个线程中完成，**由你手动控制何时返回结果**。

```java
@RestController
public class DeferredResultController {
    
    private final Map<Long, DeferredResult<String>> deferredResults = new ConcurrentHashMap<>();
    
    @GetMapping("/deferred/{id}")
    public DeferredResult<String> handleDeferredRequest(@PathVariable Long id) {
        DeferredResult<String> deferredResult = new DeferredResult<>(5000L, "Timeout Result");
        
        // 存储 deferredResult，等待外部事件触发
        deferredResults.put(id, deferredResult);
        
        // 设置回调
        deferredResult.onCompletion(() -> {
            deferredResults.remove(id);
            System.out.println("DeferredResult 完成");
        });
        
        deferredResult.onTimeout(() -> {
            deferredResults.remove(id);
            System.out.println("DeferredResult 超时");
        });
        
        return deferredResult;
    }
    
    // 外部触发结果的方法
    @PostMapping("/trigger/{id}")
    public String triggerResult(@PathVariable Long id, @RequestParam String result) {
        DeferredResult<String> deferredResult = deferredResults.get(id);
        if (deferredResult != null) {
            deferredResult.setResult("处理结果: " + result);
            return "结果已设置";
        }
        return "未找到对应的 DeferredResult";
    }
}
```

#### 84.3.4.2. 三者对比：WebAsyncTask vs @Async vs DeferredResult

| 特性 | **WebAsyncTask** | **@Async** | **DeferredResult** |
|------|------------------|------------|-------------------|
| **控制方式** | 自动执行 Callable | 自动执行方法 | **手动设置结果** |
| **适用场景** | 有明确业务逻辑的异步任务 | 服务层后台任务 | **外部事件驱动的任务** |
| **结果返回** | 由 Callable 返回 | 由方法返回 | 手动调用 setResult() |
| **超时控制** | 内置 | 需要额外处理 | 内置 |
| **线程模型** | 使用配置的线程池 | 使用配置的线程池 | 可由任意线程设置结果 |

#### 84.3.4.3. DeferredResult 的核心特点

##### 84.3.4.3.1 手动控制结果
```java
@RestController
public class OrderController {
    
    private final Map<String, DeferredResult<Order>> orderResults = new ConcurrentHashMap<>();
    
    @GetMapping("/order/{orderId}")
    public DeferredResult<Order> getOrderStatus(@PathVariable String orderId) {
        DeferredResult<Order> deferredResult = new DeferredResult<>(30000L);
        orderResults.put(orderId, deferredResult);
        
        // 立即返回，不阻塞请求线程
        return deferredResult;
    }
    
    // 订单处理完成后调用此方法
    public void onOrderProcessed(String orderId, Order order) {
        DeferredResult<Order> deferredResult = orderResults.get(orderId);
        if (deferredResult != null) {
            deferredResult.setResult(order); // 手动设置结果
        }
    }
}
```

##### 84.3.4.3.2 支持外部事件触发
```java
@Component
public class MessageListener {
    
    @Autowired
    private OrderController orderController;
    
    @JmsListener(destination = "order.processed.queue")
    public void handleOrderProcessed(OrderProcessedEvent event) {
        // 当收到消息队列的消息时，触发 DeferredResult 完成
        orderController.onOrderProcessed(event.getOrderId(), event.getOrder());
    }
}
```

#### 84.3.4.4. 实际应用场景

##### 84.3.4.4.1 场景1：长轮询（Long Polling）
```java
@RestController
public class LongPollingController {
    
    private final Map<String, DeferredResult<String>> pendingRequests = new ConcurrentHashMap<>();
    
    @GetMapping("/wait-for-update/{userId}")
    public DeferredResult<String> waitForUpdate(@PathVariable String userId) {
        DeferredResult<String> deferredResult = new DeferredResult<>(30000L, "No update");
        
        // 立即检查是否有更新
        String update = checkForUpdate(userId);
        if (update != null) {
            deferredResult.setResult(update);
        } else {
            // 没有更新，加入等待队列
            pendingRequests.put(userId, deferredResult);
            
            deferredResult.onCompletion(() -> 
                pendingRequests.remove(userId)
            );
        }
        
        return deferredResult;
    }
    
    // 当有更新时调用此方法
    public void notifyUpdate(String userId, String update) {
        DeferredResult<String> deferredResult = pendingRequests.remove(userId);
        if (deferredResult != null) {
            deferredResult.setResult(update);
        }
    }
}
```

##### 84.3.4.4.2 场景2：订单状态查询
```java
@RestController
public class PaymentController {
    
    private final Map<String, DeferredResult<PaymentResult>> paymentRequests = new ConcurrentHashMap<>();
    
    @GetMapping("/payment/status/{paymentId}")
    public DeferredResult<PaymentResult> getPaymentStatus(@PathVariable String paymentId) {
        DeferredResult<PaymentResult> deferredResult = new DeferredResult<>(60000L);
        
        // 立即检查支付状态
        PaymentResult currentStatus = paymentService.getCurrentStatus(paymentId);
        if (currentStatus.isFinal()) {
            deferredResult.setResult(currentStatus);
        } else {
            paymentRequests.put(paymentId, deferredResult);
            
            deferredResult.onTimeout(() -> {
                paymentRequests.remove(paymentId);
                deferredResult.setResult(PaymentResult.timeout());
            });
        }
        
        return deferredResult;
    }
    
    // 支付回调接口
    @PostMapping("/payment/callback")
    public String paymentCallback(@RequestBody PaymentCallback callback) {
        DeferredResult<PaymentResult> deferredResult = paymentRequests.remove(callback.getPaymentId());
        if (deferredResult != null) {
            deferredResult.setResult(PaymentResult.success(callback));
        }
        return "OK";
    }
}
```

#### 84.3.4.5. 三者的选择指南

##### 84.3.4.5.1 选择 **WebAsyncTask** 当：
- 有明确的业务逻辑需要异步执行
- 需要丰富的回调处理
- 任务执行时间可预估

##### 84.3.4.5.2 选择 **@Async** 当：
- 在服务层执行与HTTP请求无关的异步任务
- 需要并行处理多个独立操作
- 执行邮件发送、文件处理等后台任务

##### 84.3.4.5.3 选择 **DeferredResult** 当：
- **结果由外部事件决定**（消息队列、WebSocket、定时任务等）
- 需要实现长轮询
- 任务完成时间不确定
- 需要手动控制结果返回时机

#### 84.3.4.6. 底层原理对比

##### 84.3.4.6.1 WebAsyncTask：
```java
// 内部使用 Callable，自动执行
WebAsyncTask<String> task = new WebAsyncTask<>(() -> {
    return someService.process(); // 自动执行并返回结果
});
```

##### 84.3.4.6.2 DeferredResult：
```java
// 需要手动设置结果
DeferredResult<String> result = new DeferredResult<>();
// ... 某个时间点手动调用
result.setResult("manual result");
```

##### 84.3.4.6.3 @Async：
```java
// 方法自动异步执行
@Async
public CompletableFuture<String> asyncMethod() {
    return CompletableFuture.completedFuture("result");
}
```

#### 84.3.4.7. 总结

**简单记忆：**
- **WebAsyncTask**：有明确业务逻辑的HTTP异步请求
- **@Async**：服务层的异步方法执行  
- **DeferredResult**：外部事件驱动的异步HTTP响应

**关键区别：**
- `WebAsyncTask` 和 `DeferredResult` 都是处理 **HTTP请求级别** 的异步
- `@Async` 是处理 **方法级别** 的异步
- `DeferredResult` 的独特之处在于 **手动控制结果返回时机**
### 84.3.5 springMVC提供了哪些HTTP异步机制
WebAsyncTask、DeferredResult、Callable 都是 Spring MVC 提供的 HTTP 异步处理方式：
```java
@RestController
public class AsyncController {
    
    // 1. Callable 方式
    @GetMapping("/callable")
    public Callable<String> callableExample() {
        return () -> {
            Thread.sleep(2000);
            return "Callable Result";
        };
    }
    
    // 2. WebAsyncTask 方式  
    @GetMapping("/webtask")
    public WebAsyncTask<String> webAsyncTaskExample() {
        return new WebAsyncTask<>(5000L, () -> {
            Thread.sleep(2000);
            return "WebAsyncTask Result";
        });
    }
    
    // 3. DeferredResult 方式
    @GetMapping("/deferred")
    public DeferredResult<String> deferredResultExample() {
        DeferredResult<String> result = new DeferredResult<>(5000L);
        
        // 模拟异步处理
        CompletableFuture.runAsync(() -> {
            try {
                Thread.sleep(2000);
                result.setResult("DeferredResult Result");
            } catch (InterruptedException e) {
                result.setErrorResult(e);
            }
        });
        
        return result;
    }
}
```
#### 84.3.5.1 三者底层都是基于 Servlet 3.0 异步特性

**共同的底层原理：**
```
HTTP请求 → Servlet容器 → Spring MVC异步处理 → 释放请求线程 → 
→ 异步执行业务逻辑 → 完成后写回响应 → 关闭连接
```

三者的关系和区别

#### 84.3.5.2 关系：
- 都是 **HTTP 请求级别** 的异步处理
- 都基于 **Servlet 3.0+ 异步支持**
- 都用于 **释放 Servlet 容器线程**，避免阻塞

#### 84.3.5.3 主要区别：
| 特性 | **Callable** | **WebAsyncTask** | **DeferredResult** |
|------|-------------|------------------|-------------------|
| **控制方式** | 自动执行 | 自动执行，但可配置超时/回调 | **完全手动控制** |
| **复杂度** | 最简单 | 中等 | 最灵活但也最复杂 |
| **适用场景** | 简单异步任务 | 需要超时和回调的异步任务 | 外部事件驱动的任务 |

#### 84.3.5.4. 实际选择建议

- 使用 **Callable**：
```java
// 简单场景：只需要异步执行，不需要复杂控制
@GetMapping("/simple")
public Callable<String> simpleAsync() {
    return () -> {
        // 简单的异步处理
        return service.process();
    };
}
```

- 使用 **WebAsyncTask**：
```java
// 中等复杂度：需要超时控制、回调处理
@GetMapping("/with-timeout")
public WebAsyncTask<String> withTimeout() {
    return new WebAsyncTask<>(10000L, () -> {
        return service.longRunningProcess();
    });
}
```

- 使用 **DeferredResult**：
```java
// 复杂场景：结果由外部事件决定
@GetMapping("/event-driven")
public DeferredResult<String> eventDriven() {
    DeferredResult<String> result = new DeferredResult<>();
    
    // 注册到事件监听器
    eventBus.register(result);
    
    return result;
}
```
#### 84.3.5.5 为什么 Callable 也是 HTTP 异步？

**Callable 本身确实只是 Java 的一个并发接口**，但在 Spring MVC 的上下文中，它被赋予了 HTTP 异步处理的能力。

```java
@GetMapping("/callable-example")
public Callable<String> callableExample() {
    // 这个 Callable 对象会被 Spring MVC 特殊处理
    return new Callable<String>() {
        @Override
        public String call() throws Exception {
            // 这里会在 Spring 管理的线程池中执行
            Thread.sleep(3000);
            return "异步处理结果";
        }
    };
}
```

##### 84.3.5.5.1 Spring MVC 的处理流程：
```
1. HTTP请求到达 → Spring MVC 接收
2. 方法返回 Callable 对象 → Spring 检测到这是异步处理
3. 立即释放 Servlet 容器线程 → 该线程可以处理其他请求
4. Spring 将 Callable 提交到任务线程池执行
5. Callable 执行完成后，Spring 用另一个线程将结果写回响应
```

##### 84.3.5.5.2 这就是为什么 Callable 也是 HTTP 异步：
- **不是**因为 Callable 本身是异步的（它只是个接口）
- **而是**因为 Spring MVC 框架对 Callable 返回值做了特殊处理
- Spring 自动帮你实现了"释放请求线程 + 后台执行 + 完成后响应"的完整异步流程

#### 84.3.5.6. Callable 的多线程本质 vs HTTP 异步

##### 84.3.5.6.1 Callable - 开启新线程的接口
```java
// 普通的 Java 多线程用法
ExecutorService executor = Executors.newFixedThreadPool(5);
Future<String> future = executor.submit(new Callable<String>() {
    public String call() {
        return "多线程结果";
    }
});
```

##### 84.3.5.6.2 但在 Spring MVC 中，Callable 被"升级"为 HTTP 异步机制：
```java
@RestController
public class AsyncController {
    
    // 这个 Callable 不是简单的多线程，而是 HTTP 异步处理
    @GetMapping("/async-callable")
    public Callable<String> httpAsyncCallable() {
        return () -> {
            // Spring 自动管理线程池和响应返回
            return businessService.heavyOperation();
        };
    }
    
    // 对比：普通的服务层异步（不是 HTTP 异步）
    @Autowired
    private BusinessService businessService;
    
    @GetMapping("/service-async")
    public String serviceAsync() {
        // 这只是方法级别的异步，HTTP 请求还是同步等待
        businessService.asyncMethod(); // 使用 @Async
        return "立即返回，但业务在后台执行";
    }
}
```

#### 84.3.5.7. 三种 HTTP 异步方式的对比

| 机制 | 本质 | Spring 的处理方式 |
|------|------|------------------|
| **Callable** | Java 并发接口 | Spring 检测到返回值是 Callable，自动启用异步处理 |
| **WebAsyncTask** | Spring 包装类 | 专门为 HTTP 异步设计的增强版 Callable |
| **DeferredResult** | Spring 异步对象 | 手动控制结果返回的异步机制 |

#### 84.3.5.8. 实际底层原理

##### 84.3.5.8.1 Servlet 3.0 异步支持：
```java
// Spring 底层大致是这样处理 Callable 的：
public void processCallable(Callable<?> callable, HttpServletRequest request, HttpServletResponse response) {
    
    // 1. 开启异步上下文
    AsyncContext asyncContext = request.startAsync();
    
    // 2. 释放当前线程
    // 原 Servlet 线程立即返回，可以处理其他请求
    
    // 3. 提交到线程池执行
    taskExecutor.execute(() -> {
        try {
            Object result = callable.call();
            
            // 4. 完成后用另一个线程写回响应
            asyncContext.getResponse().getWriter().write(result.toString());
            
        } catch (Exception e) {
            // 错误处理
        } finally {
            // 5. 完成异步处理
            asyncContext.complete();
        }
    });
}
```

#### 84.3.5.9. 总结

- **Callable**：最简单的 HTTP 异步
- **WebAsyncTask**：功能更丰富的 HTTP 异步（超时、回调）
- **DeferredResult**：最灵活的 HTTP 异步（手动控制结果）

它们都是解决同一个核心问题：**避免长时间运行的 HTTP 请求阻塞 Servlet 容器线程**，提高服务器的并发处理能力。
### 84.3.6 什么是 HTTP 异步？

**HTTP 异步**指的是在 Web 服务器处理 HTTP 请求时的一种机制：**当请求需要执行耗时操作时，服务器不会阻塞等待，而是立即释放请求线程，让这个线程可以去处理其他请求，等耗时操作完成后，再用另一个线程将结果返回给客户端。**

#### 84.3.6.1 关键特点：
- **释放线程**：避免长时间占用 Servlet 容器线程（如 Tomcat 的工作线程）
- **提高并发**：让有限的线程可以处理更多请求
- **后台处理**：耗时操作在后台执行，不阻塞请求响应流程

#### 84.3.6.2 传统同步 vs HTTP 异步：
```java
// ❌ 同步处理（阻塞线程）
@GetMapping("/sync")
public String syncMethod() {
    // 这个线程被阻塞2秒，无法处理其他请求
    Thread.sleep(2000); 
    return "Result";
}

// ✅ 异步处理（释放线程）
@GetMapping("/async")
public Callable<String> asyncMethod() {
    return () -> {
        // 在另一个线程中执行，原线程立即释放
        Thread.sleep(2000);
        return "Result";
    };
}
```
#### 84.3.6.2 HTTP 异步效果体现

1. **✅ 服务器端**：请求线程立即释放，提高并发能力
2. **✅ 浏览器端**：仍然阻塞等待直到响应返回（10秒）
3. **✅ 核心价值**：不是减少单个请求时间，而是提高服务器整体吞吐量

**HTTP异步的本质是：**
- **对用户**：请求响应时间不变（仍然要等待）
- **对服务器**：可以用有限的线程处理更多并发请求
- **适用场景**：高并发的耗时操作（文件处理、复杂计算、外部API调用）
# 八十五、SpringBoot应用部署 - 在linux环境将jar制作成service
> 前文我们将SpringBoot应用打包成jar，那么如何将jar封装成service呢？本文主要介绍将SpringBoot应用部署成linux的service。
## 85.1 概述
> 基本的java -jar运行方式，和这种运行方式的缺陷。
### 85.1.1 Java -jar运行？
Linux 运行jar包基本命令：
```sh
# 当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出
java -jar XXX.jar

# &代表在后台运行。当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。
java -jar XXX.jar &
```
nohup命令， nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行
```sh
# 当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中。
nohup java -jar XXX.jar &  

# 输出重定向到temp.txt文件
nohup java -jar XXX.jar >temp.txt &  

# 程序在后台运行，当ssh窗口关闭，程序正常运行，且不会输出文件
nohup java -jar xx.jar >/dev/null 2>&1 & 
```
### 85.1.2 这种运行方式的缺陷
1. 不优雅
2. 无法向Linux服务一样简单易用，具备start,stop,restart等service操作方式。以及开机自启等。
## 85.2 在Linux环境封装service
> 假如我们编译出了一个tech_arch-0.0.1-RELEASE.jar，如何将它封装成service呢？
### 85.2.1 文件准备
```sh
[root@docker opt]# tree -a
.
└── tech_doc
    ├── bin
    │   ├── logs
    │   │   └── service.2018-10-31.log
    │   └── tech_arch-0.0.1-RELEASE.jar
    └── tech_doc
```
### 85.2.2 创建启动文件
tech_doc
```sh
[root@docker opt]# cat tech_doc/tech_doc
#!/bin/sh

#------------------------------------------------
# function: services start
# author: pdai
# home: /opt/tech_doc/bin
# log: /var/log/tech_doc/process
#------------------------------------------------

HOME=/opt/tech_doc/bin
LOGHOME=/var/log/tech_doc/process


function serviceLoad()
{
  b=''
  i=0
  while [ $i -le  100 ]
  do
      printf "$1:[%-50s]%d%%\r" $b $i
      sleep 0.3
      i=`expr 2 + $i`
      b=#$b
  done
  echo
}

function svcStart()
{
  echo "Starting $2 ..."
  cd $1
  PID=$(ps -ef | grep "$4" | grep -v grep | awk '{print $2}')
  if [ -z "$PID" ]; then
          nohup java -jar $3  > $5 2> $6 &
    serviceLoad $SERVICE_NAME
          echo "$2 started ..."
  else
          echo "$2 is already running ..."
  fi
}

function svcStop()
{
  PID=$(ps -ef | grep "$1" | grep -v grep | awk '{print $2}')
  if [ -z "$PID" ]; then
          echo "$2 already stopped ..."
  else
    kill $PID
        echo "$2 is stoping ..."
  fi
}

function do_start()
{
  for FILE in `ls $HOME | grep jar`
  do
    FILE_NAME=$FILE
    SERVICE_JAR_PACKAGE_PATH=$HOME/$FILE
    SERVICE_NAME=${FILE_NAME%-[0-9]*}
    SERVICE_LOG_PATH="$LOGHOME/$SERVICE_NAME.log"
    SERVICE_ERR_LOG_PATH="$LOGHOME/$SERVICE_NAME.err"

    svcStart $HOME $SERVICE_NAME $SERVICE_JAR_PACKAGE_PATH $FILE_NAME $SERVICE_LOG_PATH $SERVICE_ERR_LOG_PATH
  done
}

function do_stop()
{
    for FILE in `ls $HOME | grep jar`
  do
    FILE_NAME=$FILE
    SERVICE_NAME=${FILE_NAME%-[0-9]*}
    SERVICE_PID_PATH="/tmp/$SERVICE_NAME.pid"

    svcStop $FILE_NAME $SERVICE_NAME
    sleep 1
  done
}

function do_check()
{
    for FILE in `ls $HOME | grep jar`
  do
    FILE_NAME=$FILE
    SERVICE_NAME=${FILE_NAME%-[0-9]*}
    PID=$(ps -ef | grep $FILE_NAME | grep -v grep | awk '{print $2}')
  if [ -z "$PID" ]; then
          echo "$SERVICE_NAME $PID is not running ..."
  else
        echo "$SERVICE_NAME $PID is running ..."
  fi

    sleep 1
  done
}

case "$1" in
    start)

        do_start
        echo start successful

    ;;
    stop)

        do_stop
        echo stop successful

    ;;
    restart)

        do_stop
              sleep 2
        do_start
        echo restart successful

    ;;
    status)

        do_check

    ;;
    *)
    echo "Usage: {start|stop|restart|status}" >&2
    exit 3
    ;;
esac
exit 0
```
### 85.2.3 制作服务
在init.d下创建服务
```sh
[root@docker init.d]# tree -a
.
├── functions
├── netconsole
├── network
├── README
└── tech-doc
```
tech-doc内容如下:
```sh
[root@docker opt]# cd /etc/init.d
[root@docker init.d]# ls
functions  netconsole  network  README  tech-doc
[root@docker init.d]# tree -a
.
├── functions
├── netconsole
├── network
├── README
└── tech-doc

0 directories, 5 files
[root@docker init.d]# ^C
[root@docker init.d]# cat tech-doc
#!/bin/sh
#
# /etc/init.d/tech-doc
# chkconfig: 2345 60 20
# description: ms.
# processname: tech-doc

SCRIPT_HOME=/opt/tech_doc

case $1 in
    start)
        sh $SCRIPT_HOME/tech_doc start
    ;;
    stop)
        sh $SCRIPT_HOME/tech_doc stop
    ;;
    restart)
        sh $SCRIPT_HOME/tech_doc stop
        sh $SCRIPT_HOME/tech_doc start
    ;;
    status)
        sh $SCRIPT_HOME/tech_doc status
    ;;
    *)
    echo "Usage: {start|stop|restart|status}" >&2
    exit 3
    ;;
esac
exit 0
```
### 85.2.4 赋予权限
```sh
chmod 777 /etc/init.d/tech-doc
```
### 85.2.5 开机自启
```sh
chkconfig --list
chkconfig tech-doc on
```
### 85.2.6 查看端口
```sh
netstat -nltp
```
### 85.2.7 查看防火墙
```sh
systemctl status firewalld
```
# 八十六、SpringBoot应用部署 - docker镜像打包,运行和管理
> 随着软虚拟化docker的流行，基于docker的devops技术栈也开始流行。本文主要介绍通过docker-maven-plugin将springboot应用打包成docker镜像，通过Docker桌面化管理工具或者Idea Docker插件进行管理。
## 86.1 通过docker-maven-plugin构建镜像
> 这里使用的是最为常用的maven构建，由spofity开源，具体可以看<a href='https://github.com/spotify/dockerfile-maven'>Github - docker-maven-plugin</a>
### 86.1.1 编写Dockerfile文件
> 更多Dockerfile相关的，可以看Docker官网<a href='https://docs.docker.com/reference/dockerfile'>Dockerfile配置</a>

在项目的根目录（与pom同一层级）创建Dockerfile文件
```sh
FROM openjdk:8-jre
MAINTAINER pdai
WORKDIR /
ADD target/springboot-demo-helloworld.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar"]
CMD ["app.jar"]
```
具体解释如下：
- `FROM openjdk:8-jre`，基镜像一般采用openjdk
- `MAINTAINER pdai`，创建镜像的作者，一般是作者邮件地址
- `WORKDIR /`，WORKDIR指令设置Dockerfile中的任何RUN，CMD，ENTRPOINT，COPY和ADD指令的工作目录。
- `ADD target/springboot-demo-helloworld.jar app.jar`，表示将jar包添加到镜像中，并重命名app.jar
- `EXPOSE 8080`，表示暴露的端口是8080
- `ENTRYPOINT ["java", "-jar"]`，表示启动时运行 java -jar
- `CMD ["app.jar"]`，表示参数，这里是运行的具体的jar
### 86.1.2 引入docker-maven-plugin
为方便你学习，我这边给每行添加了具体的注释
```xml
<build>
    <!-- 固定的jar的名字，这样Dockerfile可以固定写 -->
    <finalName>springboot-demo-helloworld</finalName>
    <!-- 构建的插件 -->
    <plugins>
        <!-- springboot构建jar -->
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        <!-- 构建docker镜像 -->
        <plugin>
            <groupId>com.spotify</groupId>
            <artifactId>docker-maven-plugin</artifactId>
            <version>1.2.2</version>
            <executions>
                <execution>
                    <id>build-image</id>
                    <phase>package</phase>
                    <goals>
                        <goal>build</goal>
                    </goals>
                </execution>
            </executions>
            <configuration>
                <!-- image 的名字 -->
                <imageName>${project.build.finalName}</imageName>
                <!-- image 的tag, 可以是多个 -->
                <imageTags>
                    <imageTag>latest</imageTag>
                    <imageTag>${project.version}</imageTag>
                </imageTags>
                <!-- Dockerfile所在的目录 -->
                <dockerDirectory>${project.basedir}</dockerDirectory>
                <!-- 复制jar到docker的位置 -->
                <resources>
                    <resource>
                        <targetPath>/</targetPath>
                        <!--jar 包所在的路径，对应target目录-->
                        <directory>${project.build.directory}</directory>
                        <!-- 包含的jar　-->
                        <include>${project.build.finalName}.jar</include>
                    </resource>
                </resources>
            </configuration>
        </plugin>
    </plugins>
</build>
```
### 86.1.3 构建镜像测试
执行mvn package
![296.springboot-x-docker-11.png](../../assets/images/04-主流框架/spring/296.springboot-x-docker-11.png)

编译docker image的日志
```sh
[INFO] Building image springboot-demo-helloworld
Step 1/7 : FROM openjdk:8-jre

 ---> c739d22edd6e
Step 2/7 : MAINTAINER pdai

 ---> Using cache
 ---> 06c416bae082
Step 3/7 : WORKDIR /

 ---> Using cache
 ---> b6daef7ab3f2
Step 4/7 : ADD target/springboot-demo-helloworld.jar app.jar

 ---> Using cache
 ---> 22201ebd2a12
Step 5/7 : EXPOSE 8080

 ---> Using cache
 ---> 42dd45bbeeb5
Step 6/7 : ENTRYPOINT ["java", "-jar"]

 ---> Using cache
 ---> 9725c120cda8
Step 7/7 : CMD ["app.jar"]

 ---> Using cache
 ---> d7f8c4745bf3
ProgressMessage{id=null, status=null, stream=null, error=null, progress=null, progressDetail=null}
Successfully built d7f8c4745bf3
Successfully tagged springboot-demo-helloworld:latest
[INFO] Built springboot-demo-helloworld
[INFO] Tagging springboot-demo-helloworld with latest
[INFO] Tagging springboot-demo-helloworld with 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  17.264 s
```
## 86.2 通过Docker桌面化工具管理
> 这里展示通过Docker 官方的管理工具管理，<a href='https://docs.docker.com/get-docker/'>官网地址</a>。

编译完以后，默认会在本地docker中生成镜像
![297.springboot-x-docker-2.png](../../assets/images/04-主流框架/spring/297.springboot-x-docker-2.png)

点击Run
![298.springboot-x-docker-3.png](../../assets/images/04-主流框架/spring/298.springboot-x-docker-3.png)

Run后的实例
![299.springboot-x-docker-4.png](../../assets/images/04-主流框架/spring/299.springboot-x-docker-4.png)

实例的日志
![300.springboot-x-docker-5.png](../../assets/images/04-主流框架/spring/300.springboot-x-docker-5.png)

访问接口
![301.springboot-x-docker-1.png](../../assets/images/04-主流框架/spring/301.springboot-x-docker-1.png)
## 86.3 通过idea的docker插件进行管理
> 除了docker自带的管理工具，还可以通过idea的docker插件进行管理。

（新的版本自带docker插件，如果没有可以自行下载）

配置Docker插件
![301.springboot-x-docker-21.png](../../assets/images/04-主流框架/spring/301.springboot-x-docker-21.png)

点击连接
![303.springboot-x-docker-22.png](../../assets/images/04-主流框架/spring/303.springboot-x-docker-22.png)

可以看到编译后的镜像
![304.springboot-x-docker-23.png](../../assets/images/04-主流框架/spring/304.springboot-x-docker-23.png)

右击，添加Container
![305.springboot-x-docker-24.png](../../assets/images/04-主流框架/spring/305.springboot-x-docker-24.png)

启动这个镜像的实例
![306.springboot-x-docker-25.png](../../assets/images/04-主流框架/spring/306.springboot-x-docker-25.png)
## 86.4 Maven实现自动化Docker镜像构建和发布
### 86.4.1 方案一：使用docker-maven-plugin（推荐）

```xml
<build>
    <finalName>${project.artifactId}</finalName>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        
        <!-- Docker构建插件 -->
        <plugin>
            <groupId>com.spotify</groupId>
            <artifactId>docker-maven-plugin</artifactId>
            <version>1.2.2</version>
            <configuration>
                <!-- 镜像名称（包含仓库地址） -->
                <imageName>your-registry.com/${project.groupId}/${project.artifactId}</imageName>
                <imageTags>
                    <imageTag>latest</imageTag>
                    <imageTag>${project.version}</imageTag>
                    <imageTag>${project.version}-${maven.build.timestamp}</imageTag>
                </imageTags>
                <dockerDirectory>${project.basedir}</dockerDirectory>
                <resources>
                    <resource>
                        <targetPath>/</targetPath>
                        <directory>${project.build.directory}</directory>
                        <include>${project.build.finalName}.jar</include>
                    </resource>
                </resources>
                <!-- 推送到仓库的配置 -->
                <serverId>docker-registry</serverId>
                <registryUrl>https://your-registry.com</registryUrl>
            </configuration>
            <executions>
                <execution>
                    <id>build-image</id>
                    <phase>package</phase>
                    <goals>
                        <goal>build</goal>
                    </goals>
                </execution>
                <execution>
                    <id>push-image</id>
                    <phase>deploy</phase>
                    <goals>
                        <goal>push</goal>
                    </goals>
                    <configuration>
                        <imageName>your-registry.com/${project.groupId}/${project.artifactId}</imageName>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

### 86.4.2 方案二：使用jib-maven-plugin（Google出品，更现代化）

```xml
<plugin>
    <groupId>com.google.cloud.tools</groupId>
    <artifactId>jib-maven-plugin</artifactId>
    <version>3.3.1</version>
    <configuration>
        <from>
            <image>openjdk:8-jre-alpine</image>
        </from>
        <to>
            <image>your-registry.com/${project.groupId}/${project.artifactId}</image>
            <tags>
                <tag>latest</tag>
                <tag>${project.version}</tag>
            </tags>
        </to>
        <container>
            <ports>
                <port>8080</port>
            </ports>
            <jvmFlags>
                <jvmFlag>-Djava.security.egd=file:/dev/./urandom</jvmFlag>
                <jvmFlag>-Xms256m</jvmFlag>
                <jvmFlag>-Xmx512m</jvmFlag>
            </jvmFlags>
        </container>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>build</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

### 86.4.3. 优化后的Dockerfile

```dockerfile
# 使用更小的基础镜像
FROM openjdk:8-jre-alpine

# 设置元数据
LABEL maintainer="your-email@example.com"
LABEL version="1.0"
LABEL description="Spring Boot Application"

# 创建非root用户运行（安全考虑）
RUN addgroup -S spring && adduser -S spring -G spring
USER spring

# 设置工作目录
WORKDIR /app

# 复制jar包（利用Docker缓存层）
COPY target/*.jar app.jar

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 启动命令（使用exec形式）
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### 86.4.4. 配置Docker仓库认证

#### 86.4.4.1 在Maven的settings.xml中配置：
```xml
<servers>
    <server>
        <id>docker-registry</id>
        <username>your-username</username>
        <password>your-password</password>
    </server>
</servers>
```

#### 86.4.4.2 或者使用环境变量（更安全）：
```bash
export DOCKER_REGISTRY_USERNAME=your-username
export DOCKER_REGISTRY_PASSWORD=your-password
```

### 86.4.5. 构建完成的Docker镜像是什么样的？

构建完成后，你可以通过以下命令查看：

```bash
# 查看本地镜像
docker images

# 输出示例：
REPOSITORY                                          TAG                 IMAGE ID       CREATED         SIZE
your-registry.com/com.example/my-app               latest              abc123def456   2 minutes ago   120MB
your-registry.com/com.example/my-app               1.0.0               abc123def456   2 minutes ago   120MB
```

**镜像结构：**
- **基础层**：openjdk:8-jre-alpine (~80MB)
- **应用层**：你的Spring Boot应用jar包和配置
- **总大小**：通常在100-200MB之间

### 86.4.6. 发布到镜像仓库

#### 推送到Docker Hub：
```bash
# 登录Docker Hub
docker login

# 推送镜像
docker push your-username/my-app:latest
```

#### 推送到私有仓库：
```bash
# 登录私有仓库
docker login your-registry.com

# 推送镜像
docker push your-registry.com/com.example/my-app:latest
```

#### 使用Maven自动推送：
```bash
# 构建并推送
mvn clean package docker:build docker:push

# 或者使用jib（自动推送）
mvn compile jib:build
```

### 86.4.7. 完整的CI/CD流水线示例

#### 86.4.7.1 一键构建和部署脚本
```bash
#!/bin/bash
# deploy.sh

set -e

# 1. 构建应用和Docker镜像
echo "构建应用..."
mvn clean package

# 2. 登录Docker仓库
echo "登录Docker仓库..."
docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD

# 3. 推送镜像
echo "推送镜像..."
docker push your-registry.com/com.example/my-app:latest

# 4. 在服务器上部署（通过SSH）
echo "部署到服务器..."
ssh user@server << EOF
    docker pull your-registry.com/com.example/my-app:latest
    docker stop my-app || true
    docker rm my-app || true
    docker run -d \
        --name my-app \
        -p 8080:8080 \
        -e SPRING_PROFILES_ACTIVE=prod \
        your-registry.com/com.example/my-app:latest
EOF

echo "部署完成！"
```

#### 86.4.7.2 使用Docker Compose管理
```yaml
# docker-compose.yml
version: '3.8'
services:
  my-app:
    image: your-registry.com/com.example/my-app:latest
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### 86.4.8. 实际工作流程

#### 开发流程：
```mermaid
graph LR
    A[代码变更] --> B[Git提交]
    B --> C[CI/CD流水线触发]
    C --> D[Maven构建]
    D --> E[Docker镜像打包]
    E --> F[推送到镜像仓库]
    F --> G[自动部署到服务器]
    G --> H[服务重启]
```

#### 具体操作命令：
```bash
# 开发完成后，一键部署
git add .
git commit -m "功能更新"
git push origin main

# CI/CD自动执行以下流程：
# 1. 运行测试
# 2. 构建Docker镜像
# 3. 推送到仓库
# 4. 部署到服务器
```

### 86.4.9. 优势总结

**相比传统方式：**
- ✅ **自动化**：代码提交后自动构建部署
- ✅ **环境一致**：开发、测试、生产环境完全一致
- ✅ **快速回滚**：只需切换镜像标签
- ✅ **版本管理**：每个版本都有对应的镜像
- ✅ **依赖管理**：所有依赖都打包在镜像中

**具体收益：**
- 不再需要手动上传jar包
- 部署时间从分钟级降到秒级
- 支持蓝绿部署、金丝雀发布等高级部署策略
- 更好的可观测性和健康检查

## 86.5. 实际案例：GitHub Actions自动化

```yaml
# .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up JDK 8
      uses: actions/setup-java@v2
      with:
        java-version: '8'
        distribution: 'adopt'
    
    - name: Build with Maven
      run: mvn clean package -DskipTests
      
    - name: Build Docker image
      run: |
        docker build -t your-registry.com/com.example/my-app:latest .
        
    - name: Push Docker image
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push your-registry.com/com.example/my-app:latest
        
    - name: Deploy to server
      run: |
        ssh user@server 'docker-compose pull && docker-compose up -d'
```

这样配置后，你只需要`git push`，剩下的所有流程都会自动完成！🎉
## 86.6 参考文章
1. https://blog.csdn.net/fly_duck/article/details/124709727
2. https://blog.csdn.net/weixin_33825683/article/details/92407322

# 八十七、SpringBoot应用部署 - 使用Docker Compose对容器编排管理
> 如果docker容器是相互依赖的（比如SpringBoot容器依赖另外一个MySQL的数据库容器），那就需要对容器进行编排。本文主要介绍基于Docker Compose的简单容器化编排SpringBoot应用。
## 87.1 Docker Compose编排管理
### 87.1.1 DockerCompose编排
- 整体的文件结构

PS: 注意红色的字
![307.springboot-x-docker-27.png](../../assets/images/04-主流框架/spring/307.springboot-x-docker-27.png)
- Docker Compose 配置文件

PS：参数可以设置成环境变量注入进来
```yml
version: "3.1"

services:
  db-mysql:
    image: mysql:8.0.28
    container_name: mysql8
    restart: always
    privileged: true
    volumes:
      # files
      - /usr/local/docker/mysql/files/:/var/lib/mysql-files/
#      # conf
#      - /usr/local/docker/mysql/conf/:/etc/mysql/conf.d/
#      # data
#      - /usr/local/docker/mysql/data/:/var/lib/mysql/
#      # log
#      - /usr/local/docker/mysql/logs/:/var/log/
      # init db by order
      - ./db/:/docker-entrypoint-initdb.d/
    environment:
      TZ : Asia/Shanghai
      MYSQL_ROOT_PASSWORD: bfXa4Pt2lUUScy8jakXf
      MYSQL_DATABASE: test_db
      MYSQL_USER: pdai
      MYSQL_PASSWORD: sdqiireasgadklkklk
    ports:
      - 13306:3306
    command:
      --authentication_policy=mysql_native_password
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_general_ci
      --explicit_defaults_for_timestamp=true
      --lower_case_table_names=1
    networks:
      - internal
  service-app:
    image: springboot-demo-mysql8-jpa
    container_name: springboot-demo-mysql8-jpa
    environment:
      # profile
#      SPRING_PROFILES_ACTIVE: prod
      # or
      SPRING_DATASOURCE_URL: jdbc:mysql://db-mysql:3306/test_db?useSSL=false&autoReconnect=true&characterEncoding=utf8
      SPRING_DATASOURCE_USERNAME: pdai
      SPRING_DATASOURCE_PASSWORD: sdqiireasgadklkklk
    depends_on:
      - db-mysql
    ports:
      - 18080:8080
    networks:
      - internal

networks:
  internal:
    name: internal
```
- SQL

PS: 如果需要有time_zone字段，请参考<a href='https://github.com/docker-library/mysql/issues/229'>Github</a>
```sql
use test_db;

--
-- Table structure for table `tb_role`
--

DROP TABLE IF EXISTS `tb_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `role_key` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_role`
--

LOCK TABLES `tb_role` WRITE;
/*!40000 ALTER TABLE `tb_role` DISABLE KEYS */;
INSERT INTO `tb_role` VALUES (1,'admin','admin','admin','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(45) NOT NULL,
  `password` varchar(45) NOT NULL,
  `email` varchar(45) DEFAULT NULL,
  `phone_number` int(11) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'pdai','dfasdf','suzhou.daipeng@gmail.com',1212121213,'afsdfsaf','2021-09-08 17:09:15','2021-09-08 17:09:15');
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user_role`
--

DROP TABLE IF EXISTS `tb_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tb_user_role` (
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user_role`
--

LOCK TABLES `tb_user_role` WRITE;
/*!40000 ALTER TABLE `tb_user_role` DISABLE KEYS */;
INSERT INTO `tb_user_role` VALUES (1,1);
/*!40000 ALTER TABLE `tb_user_role` ENABLE KEYS */;
UNLOCK TABLES;
```
## 87.2 测试和校验
通过docker-compose up启动，启动后的日志如下：
```sh
pdai@MacBook-Pro resources % docker-compose up                                                  
Starting mysql8 ... done
Starting springboot-demo-mysql8-jpa ... done
Attaching to mysql8, springboot-demo-mysql8-jpa
mysql8         | 2022-04-20 11:25:49+08:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.28-1debian10 started.
mysql8         | 2022-04-20 11:25:49+08:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'
mysql8         | 2022-04-20 11:25:49+08:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.28-1debian10 started.
mysql8         | 2022-04-20T03:25:49.555053Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.28) starting as process 1
mysql8         | 2022-04-20T03:25:49.563364Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.
mysql8         | 2022-04-20T03:25:49.832470Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.
mysql8         | 2022-04-20T03:25:49.935130Z 0 [System] [MY-010229] [Server] Starting XA crash recovery...
mysql8         | 2022-04-20T03:25:49.943755Z 0 [System] [MY-010232] [Server] XA crash recovery finished.
mysql8         | 2022-04-20T03:25:50.011665Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.
mysql8         | 2022-04-20T03:25:50.011719Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel.
mysql8         | 2022-04-20T03:25:50.013067Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location '/var/run/mysqld' in the path is accessible to all OS users. Consider choosing a different directory.
mysql8         | 2022-04-20T03:25:50.028686Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: '::' port: 33060, socket: /var/run/mysqld/mysqlx.sock
mysql8         | 2022-04-20T03:25:50.028772Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.28'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL.
springboot-demo-mysql8-jpa | 
springboot-demo-mysql8-jpa |   .   ____          _            __ _ _
springboot-demo-mysql8-jpa |  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
springboot-demo-mysql8-jpa | ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
springboot-demo-mysql8-jpa |  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
springboot-demo-mysql8-jpa |   '  |____| .__|_| |_|_| |_\__, | / / / /
springboot-demo-mysql8-jpa |  =========|_|==============|___/=/_/_/_/
springboot-demo-mysql8-jpa |  :: Spring Boot ::                (v2.5.3)
springboot-demo-mysql8-jpa | 
springboot-demo-mysql8-jpa | 2022-04-20 03:25:50.475  INFO 1 --- [           main] t.p.s.mysql8.jpa.dockercompose.App       : Starting App v1.0-SNAPSHOT using Java 1.8.0_322 on 468363ab8772 with PID 1 (/app.jar started by root in /)
springboot-demo-mysql8-jpa | 2022-04-20 03:25:50.477  INFO 1 --- [           main] t.p.s.mysql8.jpa.dockercompose.App       : The following profiles are active: prod
springboot-demo-mysql8-jpa | 2022-04-20 03:25:51.482  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
springboot-demo-mysql8-jpa | 2022-04-20 03:25:51.557  INFO 1 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 66 ms. Found 2 JPA repository interfaces.
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.135  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.148  INFO 1 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.148  INFO 1 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50]
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.203  INFO 1 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.203  INFO 1 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1682 ms
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.353  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.593  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.638  INFO 1 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.694  INFO 1 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.32.Final
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.824  INFO 1 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final}
springboot-demo-mysql8-jpa | 2022-04-20 03:25:52.941  INFO 1 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQLDialect
springboot-demo-mysql8-jpa | 2022-04-20 03:25:53.541  INFO 1 --- [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
springboot-demo-mysql8-jpa | 2022-04-20 03:25:53.550  INFO 1 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
springboot-demo-mysql8-jpa | 2022-04-20 03:25:54.665  INFO 1 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
springboot-demo-mysql8-jpa | 2022-04-20 03:25:54.930  INFO 1 --- [           main] t.p.s.mysql8.jpa.dockercompose.App       : Started App in 4.854 seconds (JVM running for 5.267)
```
- 查看mysql db是否正确创建

（注意：也可以不开放端口，通过服务名进行内部网络通信）
```sh
pdai@MacBook-Pro conf % docker exec -it mysql8 /bin/bash  
root@028760cee140:/# mysql -u pdai -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 8.0.28 MySQL Community Server - GPL

Copyright (c) 2000, 2022, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| test_db            |
+--------------------+
2 rows in set (0.00 sec)

mysql> use test_db;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+-------------------+
| Tables_in_test_db |
+-------------------+
| tb_role           |
| tb_user           |
| tb_user_role      |
+-------------------+
3 rows in set (0.00 sec)

mysql> 
```
# 八十八、▶SpringBoot监控 - 集成actuator监控工具
> 当SpringBoot的应用部署到生产环境中后，如何监控和管理呢？比如审计日志，监控状态，指标收集等。为了解决这个问题，SpringBoot提供了Actuator。本文主要介绍Spring Boot Actuator及实现案例。
## 88.1 知识准备
### 88.1.1 什么是Actuator?
> 致动器（actuator）是2018年公布的计算机科学技术名词。

百度百科的解释如下： 致动器能将某种形式的能量转换为机械能的驱动装置。如热致动器、磁致动器等，在磁盘中是指将电能转换为机械能并带动磁头运动的装置。

官网给的解释是：An actuator is a manufacturing term that refers to a mechanical device for moving or controlling something. Actuators can generate a large amount of motion from a small change.

从上述的解释不难知道Spring 命名这个组件为Actuator，就是为了提供监测程序的能力。
### 88.1.2 什么是Spring Boot Actuator？
> 什么是Spring Boot Actuator? 用在什么样的场景呢？

Spring Boot Actuator提供了对SpringBoot应用程序（可以是生产环境）监视和管理的能力， 可以选择通过使用HTTP Endpoint或使用JMX来管理和监控SpringBoot应用程序。
### 88.1.3 什么是Actuator Endpoints？
Spring Boot Actuator 允许你通过Endpoints对Spring Boot进行监控和交互。

Spring Boot 内置的Endpoint包括（两种Endpoint： WEB和JMX， web方式考虑到安全性默认只开启了/health）：


| ID | JMX | Web Endpoint | 功能描述 |
|:---|:---|:---|:---|
| auditevents | Yes | No | 暴露当前应用的audit events （依赖AuditEventRepository） |
| beans | Yes | No | Spring中所有Beans |
| caches | Yes | No | 暴露可用的缓存 |
| conditions | Yes | No | 展示configuration 和auto-configuration类中解析的condition，并展示是否匹配的信息. |
| configprops | Yes | No | 展示所有的@ConfigurationProperties |
| env | Yes | No | 展示环境变量，来源于ConfigurableEnvironment |
| flyway | Yes | No | flyway数据迁移信息（依赖Flyway） |
| health | Yes | Yes | 展示应用的健康信息 |
| heapdump | N/A | No | （web应用时）hprof 堆的dump文件（依赖HotSpot JVM） |
| httptrace | Yes | No | 展示HTTP trace信息, 默认展示前100个（依赖HttpTraceRepository） |
| info | Yes | No | 应用信息 |
| integrationgraph | Yes | No | 展示spring集成信息（依赖spring-integration-core） |
| jolokia | N/A | No | （web应用时）通过HTTP暴露JMX beans（依赖jolokia-core） |
| logfile | N/A | No | （web应用时）如果配置了logging.file.name 或者 logging.file.path，展示logfile内容 |
| loggers | Yes | No | 展示或者配置loggers，比如修改日志的等级 |
| liquibase | Yes | No | Liquibase 数据迁移信息（依赖Liquibase） |
| metrics | Yes | No | 指标信息 |
| mappings | Yes | No | @RequestMapping映射路径 |
| prometheus | N/A | No | （web应用时）向prometheus暴露监控信息（依赖micrometer-registry-prometheus） |
| quartz | Yes | No | 展示 quartz任务信息 |
| scheduledtasks | Yes | No | 展示Spring Scheduled 任务信息 |
| sessions | Yes | No | session信息 |
| shutdown | Yes | No | 关闭应用 |
| startup | Yes | No | 展示ApplicationStartup的startup步骤的数据（依赖通在SpringApplication配置BufferingApplicationStartup） |
| threaddump | Yes | No | 线程dump |

当然你也可以自己定义暴露哪些endpoint,

JMX时：
```yml
management:
  endpoints:
    jmx:
      exposure:
        include: "health,info"
```
web时(*代表所有)：
```yml
management:
  endpoints:
    web:
      exposure:
        include: "*"
        exclude: "env,beans"
```
## 88.2 简单示例
### 88.2.1 POM引入actuator包
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```
### 88.2.2 yml配置
自定义暴露哪些endpoint, 比如如下yml配置
```yml
server:
  port: 8080

management:
  endpoints:
    enabled-by-default: false
    web:
      base-path: /manage
      exposure:
        include: 'info,health,env,beans'
  endpoint:
    info:
      enabled: true
    health:
      enabled: true
    env:
      enabled: true
    beans:
      enabled: true
```
上述配置只暴露info,health,env,beans四个endpoints, web通过可以`/manage`访问，
![308.springboot-actuator-1.png](../../assets/images/04-主流框架/spring/308.springboot-actuator-1.png)
### 88.2.3 Endpoints的进一步拓展配置
#### 88.2.3.1 与SpringSecurity集成保障安全
正是由于endpoint可能潜在暴露应用的安全性，web方式的endpoint才在默认情况下只暴露了一个/health。

如果你需要暴露更多，并保证endpoint接口安全，可以与Spring Security集成，比如
```java
@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.requestMatcher(EndpointRequest.toAnyEndpoint())
                .authorizeRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));
        http.httpBasic();
        return http.build();
    }

}
```
#### 88.2.3.2 Endpoint跨域访问
跨域访问，可以通过如下配置：
```yml
management:
  endpoints:
    web:
      cors:
        allowed-origins: "https://example.com"
        allowed-methods: "GET,POST"
```
#### 88.2.3.3 实现自己的Endpoint
我们可以通过@JmxEndpoint or @WebEndpoint注解来定义自己的endpoint, 然后通过@ReadOperation, @WriteOperation或者@DeleteOperation来暴露操作，

比如添加系统时间date的endpoint
```java
package tech.pdai.springboot.actuator;

import java.time.LocalDateTime;

import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
import org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author pdai
 */
@RestController("custom")
@WebEndpoint(id = "date")
public class CustomEndpointController {

    @ReadOperation
    public ResponseEntity<String> currentDate() {
        return ResponseEntity.ok(LocalDateTime.now().toString());
    }
}
```
enable 自定义的date
```yml
management:
  endpoints:
    enabled-by-default: false
    web:
      base-path: /manage
      exposure:
        include: 'info,health,env,beans,date'
  endpoint:
    info:
      enabled: true
    health:
      enabled: true
    env:
      enabled: true
    beans:
      enabled: true
    date:
      enabled: true
```
你可以看到所有开放的接口中增加了date
![309.springboot-actuator-5.png](../../assets/images/04-主流框架/spring/309.springboot-actuator-5.png)

访问效果
![310.springboot-actuator-2.png](../../assets/images/04-主流框架/spring/310.springboot-actuator-2.png)
## 88.3 组件的health状况
SpringBoot默认集成了如下常见中间件的health监控
![311.springboot-actuator-3.png](../../assets/images/04-主流框架/spring/311.springboot-actuator-3.png)

当然你也可以自定义HealthIndicator
```java
package tech.pdai.springboot.actuator;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

/**
 * @author pdai
 */
@Component
public class CustomHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        int errorCode = check();
        if (errorCode!=0) {
            return Health.down().withDetail("Error Code", errorCode).build();
        }
        return Health.up().build();
    }

    private int check() {
        // perform some specific health check
        return 0;
    }

}
```
更详细的信息可以参考<a href='https://docs.spring.io/spring-boot/redirect.html?page=actuator#actuator.endpoints.health'>官网</a>

## 88.4 Metrics接入监控系统
这个也是比较常用的，具体参考
![312.springboot-actuator-4.png](../../assets/images/04-主流框架/spring/312.springboot-actuator-4.png)
## 88.5 Info信息如何获取
有细心的小伙伴会发现/info是空的，最简单的配置方式是在spring-boot-maven-plugin中加入build-info， 编译成jar后运行，即可获取info：
```xml
<plugins>
    <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <executions>
            <execution>
                <goals>
                    <goal>build-info</goal>
                </goals>
            </execution>
        </executions>
    </plugin>
</plugins>
```
# 八十九、SpringBoot进阶 - 健康检查Actuator原理

SpringBoot Actuator 是 SpringBoot 框架的一个重要模块，用于提供应用程序的监控和管理功能。其中，健康检查（Health Check）是 Actuator 的核心特性之一，它允许开发者通过 HTTP 端点实时查看应用程序的运行状态，如数据库连接、磁盘空间等。本文将从实现原理和设计思想等方面详细介绍 Actuator 的健康检查机制，帮助读者深入理解其内部工作原理。

## 89.1 实现原理

Actuator 的健康检查功能基于 SpringBoot 的自动配置和端点机制实现。其核心在于通过预定义的端点暴露健康信息，并利用 HealthIndicator 接口来收集和组合各种组件的状态。下面我们将分小节详细解析。

### 89.1.1 核心机制：端点暴露与 HealthIndicator 接口

健康检查的实现原理主要依赖于两个关键部分：端点的暴露机制和 HealthIndicator 接口的工作方式。

**端点暴露机制**  
SpringBoot Actuator 通过 HTTP 端点（如 `/actuator/health`）来提供健康信息。这些端点是基于 Spring MVC 或 WebFlux 的控制器实现的，但 Actuator 对其进行了封装，使得端点可以自动注册和暴露。当应用程序启动时，SpringBoot 的自动配置会扫描类路径下的 Actuator 相关依赖，并创建相应的端点 Bean。例如，健康检查端点由 `HealthEndpoint` 类处理，该类实现了 `Endpoint` 接口。在运行时，当用户访问 `/actuator/health` 时，Spring 的调度机制会调用 `HealthEndpoint` 的 `health()` 方法，该方法会聚合所有注册的 HealthIndicator 实例的状态信息。

**HealthIndicator 接口工作原理**  
HealthIndicator 是健康检查的核心接口，定义了一个 `health()` 方法，用于返回当前组件的健康状态（如 UP、DOWN 或未知）。SpringBoot 内置了多个 HealthIndicator 实现，例如 `DataSourceHealthIndicator`（检查数据库连接）、`DiskSpaceHealthIndicator`（检查磁盘空间）等。这些实现类通过实现 `health()` 方法，执行具体的检查逻辑（如测试数据库连接或计算磁盘使用率），并返回一个 `Health` 对象。Health 对象包含了状态详情（如错误信息或指标数据），使得健康报告更加丰富。

在实际运行中，HealthIndicator 实例是通过 Spring 的依赖注入机制管理的。当 Actuator 端点被调用时，它会从 Spring 容器中获取所有 HealthIndicator Bean，并依次调用它们的 `health()` 方法，最后将结果聚合为一个整体的健康状态。这种设计允许开发者轻松添加自定义健康检查，只需实现 HealthIndicator 接口并注册为 Bean 即可。

此外，健康检查还支持细节控制：通过配置 `management.endpoint.health.show-details` 属性，可以决定是否显示详细状态信息，这体现了 Actuator 的灵活性和安全性考虑。

总结来说，实现原理的核心是“端点驱动”和“组件聚合”：端点作为入口，HealthIndicator 作为执行单元，通过 Spring 的 IOC 容器实现松耦合的集成。

## 89.2 设计思想

Actuator 的健康检查功能不仅注重实现效率，还体现了微服务架构下的设计哲学。其设计思想主要包括松耦合、可扩展性和生产就绪性。

### 89.2.1 松耦合与可扩展性

健康检查机制采用接口驱动设计（如 HealthIndicator 接口），使得各个组件的检查逻辑相互独立，降低了模块间的耦合度。开发者可以轻松添加或移除健康指示器，而不影响核心框架。例如，如果应用程序需要检查第三方服务的状态，只需实现一个自定义的 HealthIndicator，SpringBoot 会自动将其集成到健康端点中。这种可扩展性得益于 Spring 的依赖注入和自动配置机制，它遵循“开闭原则”（对扩展开放，对修改关闭）。

同时，Actuator 通过端点抽象支持多种暴露方式（如 HTTP、JMX），适应不同的监控场景。这种设计思想确保了健康检查功能能够灵活适配各种环境，从开发到生产均可无缝使用。

### 89.2.2 生产就绪性与监控友好

Actuator 的健康检查强调“生产就绪”（Production-Ready），旨在为微服务提供可靠的监控支持。设计上，它考虑了性能和安全：健康检查端点通常轻量级，避免对应用造成负担；并通过配置限制敏感信息的暴露，防止安全风险。此外，健康状态可以集成到云平台（如 Kubernetes）的存活探针中，实现自动故障恢复，这反映了现代云原生应用的设计趋势。

总体而言，Actuator 的健康检查设计思想是以“监控驱动开发”为核心，通过标准化接口和自动化配置，提升应用程序的可维护性和可靠性。这种思想不仅简化了开发，还促进了 DevOps 实践。

DevOps（Development 和 Operations 的组合）是一种软件开发和运维的文化、实践与工具集合，旨在通过自动化和协作来缩短软件开发生命周期，提高交付速度和质量。其核心思想是打破传统开发团队和运维团队之间的壁垒，促进持续集成、持续交付和持续监控，从而实现更高效、可靠的软件发布。DevOps 强调自动化流程、快速反馈和团队协作，常用于支持微服务、云原生应用等现代技术架构。
# 九十、SpringBoot进阶 - 自定义starter
> 如何将自己的模块封装成starter， 并给其它springBoot项目使用呢？ 本文主要介绍在Springboot封装一个自定义的Starter的一个Demo，从创建一个模块->封装starter->使用。
## 90.1 思路
> 创建模块，封装starter，最后使用starter.
1. 创建一个Demo Project，模拟一个需要被封装的DemoModule模块，其中核心方法为exeModuleMethod
2. 通过starter封装可以直接初始化DemoModule的实例到Spring容器
3. 在Maven中引入starter，且在yml中配置相应到参数即可直接初始化DemoModule的实例
4. 在应用中注入DemoModule即可使用其exeModuleMethod方法
## 90.2 新建项目
- pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.7.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.pdai</groupId>
    <artifactId>demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>demo</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <!-- 注意不要引入Springboot模块-->
    </dependencies>

    <build>
        
    </build>

</project>
```
- 创建一个测试模块
```java
package com.pdai.demo.module;

/**
 *
 */
public class DemoModule {

    private String version;

    private String name;

    public String exeModuleMethod() {
        return "Demo module, name = " + name + ", version = " + version;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```
- install
![313.springboot-starter-demo-1.png](../../assets/images/04-主流框架/spring/313.springboot-starter-demo-1.png)
## 90.3 封装Starter
- 创建项目 - pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.7.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.pdai</groupId>
    <artifactId>demo-springboot-starter</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>demo-springboot-starter</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>com.pdai</groupId>
            <artifactId>demo</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```
- Properties
```java
package com.pdai.demospringbootstarter;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "com.pdai")
public class DemoProperties {
    private String version;
    private String name;

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```
- AutoConfiguration
```java
package com.pdai.demospringbootstarter;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties(DemoProperties.class)
public class DemoAutoConfiguration {

    @Bean
    public com.pdai.demo.module.DemoModule demoModule(DemoProperties properties){
        com.pdai.demo.module.DemoModule demoModule = new com.pdai.demo.module.DemoModule();
        demoModule.setName(properties.getName());
        demoModule.setVersion(properties.getVersion());
        return demoModule;

    }
}
```
- spring.factory
> 在META-INF下创建spring.factory文件
```sj
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.pdai.demospringbootstarter.DemoAutoConfiguration
```
- install
## 90.4 使用starter
只需要在application.yml中

- application.yml
```yml
com:
    pdai:
        name: DEMO
        version: v1
```
- pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.7.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.pdai</groupId>
    <artifactId>demo-usage</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>demo-usage</name>
    <description>Demo starter usage</description>

    <properties>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.pdai</groupId>
            <artifactId>demo-springboot-starter</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```
- app
```java
package com.pdai.demo.usage;

import com.pdai.demo.module.DemoModule;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoUsageApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoUsageApplication.class, args);
    }

    @Autowired
    private DemoModule demoModule;


    @GetMapping("demo")
    public String demo(){
        return demoModule.exeModuleMethod();
    }
}
```
- 输出

http://localhost:8080/demo
```sh
Demo module, name = DEMO, version = v1
```
# 第九十一章、SpringBoot进阶 - 嵌入web容器Tomcat原理

SpringBoot 作为现代 Java 应用开发的主流框架，其核心特性之一是支持嵌入式 Web 容器（如 Tomcat），这使得应用可以打包为可执行的 JAR 文件，无需外部服务器即可独立运行。这种设计极大地简化了部署和测试流程，特别适合微服务和云原生场景。本章将详细解读 SpringBoot 嵌入 Tomcat 的原理，从实现机制到设计思想，并提供核心代码指导，帮助读者深入理解其内部工作方式。

## 91.1 实现原理

SpringBoot 嵌入 Tomcat 的原理基于 Spring 框架的自动配置和 Servlet 容器抽象机制。其核心是通过 SpringBoot 的启动过程自动检测并初始化嵌入式 Tomcat 实例，替代传统的外部 Tomcat 部署。下面分小节详细解析。

### 91.1.1 核心机制：自动配置与 Tomcat 启动流程

嵌入 Tomcat 的实现原理主要依赖于 SpringBoot 的自动配置（Auto-Configuration）和 Servlet Web 服务器工厂模式。整个过程从应用启动开始，到 Tomcat 实例运行结束，涉及多个关键类和步骤。

**自动配置机制**  
当 SpringBoot 应用启动时（通过 `SpringApplication.run()` 方法），SpringBoot 会扫描类路径下的依赖。如果检测到 `spring-boot-starter-web` 依赖（它包含了 Tomcat 相关库），SpringBoot 的自动配置模块会触发 `ServletWebServerFactoryAutoConfiguration` 类。这个配置类负责创建和配置嵌入式 Web 服务器。具体来说：
- SpringBoot 使用 `TomcatServletWebServerFactory` 作为默认的 Servlet Web 服务器工厂，该类实现了 `ServletWebServerFactory` 接口。
- 在启动过程中，SpringBoot 通过条件注解（如 `@ConditionalOnClass`）确保 Tomcat 类（如 `org.apache.catalina.startup.Tomcat`）存在于类路径中，然后自动注册 `TomcatServletWebServerFactory` Bean。
- 这个工厂 Bean 负责创建和管理嵌入式 Tomcat 实例，包括设置端口、上下文路径等参数。

**Tomcat 启动流程**  
Tomcat 的启动流程由 SpringBoot 的 `SpringApplication` 驱动，大致步骤如下：
1. **应用启动**：当 `main` 方法调用 `SpringApplication.run()` 时，Spring 容器开始初始化。
2. **服务器工厂调用**：在 Spring 容器刷新阶段，`ServletWebServerApplicationContext`（Web 应用上下文）会获取 `ServletWebServerFactory` Bean（即 `TomcatServletWebServerFactory`），并调用其 `getWebServer()` 方法。
3. **Tomcat 实例化**：`getWebServer()` 方法内部会实例化一个 Apache Tomcat 对象（`new Tomcat()`），并配置基本参数，如端口（默认 8080）和基础目录。
4. **上下文配置**：SpringBoot 会将应用上下文（如 DispatcherServlet）注册到 Tomcat 中，通过 `Tomcat.addContext()` 或类似方法，确保 Spring MVC 的请求映射正常工作。
5. **服务器启动**：最后，调用 Tomcat 的 `start()` 方法启动嵌入式服务器，并等待 HTTP 请求。整个过程是异步的，但 SpringBoot 会阻塞直到服务器就绪。

这种机制的优势在于“约定优于配置”：开发者无需手动编写 Tomcat 配置，SpringBoot 自动处理所有细节。例如，端口可以通过 `application.properties` 中的 `server.port` 属性自定义，体现了灵活性。

### 91.1.2 关键组件与依赖注入

嵌入 Tomcat 的核心组件包括 `TomcatServletWebServerFactory`、`Tomcat` 类以及 Spring 的依赖注入（DI）机制。这些组件协同工作，确保嵌入式容器的高效运行。

- **TomcatServletWebServerFactory**：这是 SpringBoot 提供的工厂类，继承自 `AbstractServletWebServerFactory`，负责创建 Tomcat 实例。它通过重写 `getWebServer()` 方法，使用 Tomcat API 构建服务器。代码层面，它会设置 Connector（连接器）、Context（上下文）等 Tomcat 核心元素。
- **Tomcat 类**：来自 Apache Tomcat 库，是嵌入式模式下的主类。SpringBoot 通过反射或直接调用其 API 来初始化和启动 Tomcat，而不是使用传统的 `catalina.sh` 脚本。
- **依赖注入**：Spring 的 IOC 容器管理这些组件的生命周期。例如，当应用需要自定义 Tomcat 配置时，开发者可以定义一个 `WebServerFactoryCustomizer` Bean，SpringBoot 会自动将其注入到工厂中，用于修改 Tomcat 设置。

这种设计实现了松耦合：Tomcat 细节被抽象化，开发者只需关注业务逻辑，同时可以通过 Spring 的扩展点进行定制。

## 91.2 设计思想

SpringBoot 嵌入 Tomcat 的设计思想体现了现代软件工程的核心理念，包括简化部署、支持微服务架构和提升开发效率。其思想不仅注重技术实现，还强调生产环境下的可靠性和可维护性。

### 91.2.1 简化部署与开发效率

嵌入 Tomcat 的核心设计思想是“开箱即用”（Out-of-the-Box），通过减少外部依赖来简化开发和生产部署。传统 Java Web 应用需要单独安装和配置 Tomcat 服务器，而 SpringBoot 将 Tomcat 作为内嵌组件，使得应用可以打包为单一 JAR 文件，直接通过 `java -jar` 命令运行。这降低了环境配置的复杂性，加速了开发迭代周期。

设计上，SpringBoot 遵循“约定优于配置”原则：默认使用嵌入式 Tomcat，但如果类路径中有其他容器（如 Jetty），会自动切换。这种灵活性确保了兼容性，同时鼓励快速原型开发。例如，在测试阶段，开发者可以轻松启动内嵌服务器进行集成测试，无需搭建完整环境。

### 91.2.2 微服务友好与云原生支持

嵌入 Tomcat 的设计还契合微服务架构和云原生趋势。在微服务中，每个服务通常是轻量级的、独立部署的单元。嵌入式容器使得服务可以自包含，易于在 Docker 或 Kubernetes 中运行，支持水平扩展和健康检查（如通过 Actuator 端点）。

设计思想强调“生产就绪性”：SpringBoot 提供了丰富的配置选项（如 SSL 支持、连接池优化），确保嵌入式 Tomcat 在高并发场景下稳定运行。同时，通过自动配置避免了“配置地狱”，使团队能专注于业务逻辑，而非基础设施。这种思想促进了 DevOps 实践，实现了开发与运维的无缝衔接。

## 91.3 核心代码指导

为了帮助读者实际应用嵌入 Tomcat 的原理，本节提供核心代码示例和配置指导。这些代码基于 SpringBoot 2.x 或 3.x 版本，演示如何自定义和优化嵌入式 Tomcat。

### 91.3.1 基础配置与自定义

在 SpringBoot 中，嵌入式 Tomcat 的配置主要通过 `application.properties` 或 `application.yml` 文件完成。以下是一些常见配置示例：

- **设置端口和上下文路径**：  
  在 `application.properties` 中添加：
  ```properties
  server.port=9090  # 自定义端口，默认为8080
  server.servlet.context-path=/myapp  # 设置上下文路径
  ```

- **启用 SSL 支持**：  
  配置 HTTPS，确保安全通信：
  ```properties
  server.ssl.key-store=classpath:keystore.p12
  server.ssl.key-store-password=changeit
  server.ssl.key-store-type=PKCS12
  ```

### 91.3.2 自定义 Tomcat 配置代码

如果需要更高级的定制（如添加阀门或调整线程池），可以通过 Java 代码实现。以下是一个示例，演示如何使用 `WebServerFactoryCustomizer` 接口自定义 Tomcat：

```java
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.stereotype.Component;

@Component
public class TomcatCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {

    @Override
    public void customize(TomcatServletWebServerFactory factory) {
        // 设置端口（如果未在配置文件中指定）
        factory.setPort(8080);
        
        // 添加自定义阀门（Valve），例如用于日志记录
        factory.addEngineValves(new MyCustomValve());
        
        // 调整连接器设置，如超时时间
        factory.addConnectorCustomizers(connector -> {
            connector.setProperty("connectionTimeout", "20000");
        });
    }
}

// 示例自定义阀门类
import org.apache.catalina.Valve;
import org.apache.catalina.connector.Request;
import org.apache.catalina.connector.Response;
import javax.servlet.ServletException;
import java.io.IOException;

public class MyCustomValve implements Valve {
    @Override
    public void invoke(Request request, Response response) throws IOException, ServletException {
        // 自定义逻辑，如记录请求日志
        System.out.println("Request URI: " + request.getRequestURI());
        getNext().invoke(request, response); // 调用下一个阀门
    }
    
    // 其他必要方法省略...
}
```

### 91.3.3 启动和调试提示

- **启动应用**：确保主类使用 `@SpringBootApplication` 注解，然后运行 `main` 方法。SpringBoot 会自动启动嵌入式 Tomcat，日志中会显示类似 "Tomcat started on port(s): 8080" 的信息。
- **调试问题**：如果遇到端口冲突或启动失败，检查 `application.properties` 配置，或使用 Actuator 的 `/actuator/env` 端点查看服务器设置。对于性能优化，可以考虑调整 Tomcat 的线程池参数，如通过 `server.tomcat.max-threads` 属性。

通过以上原理和代码指导，读者可以深入理解 SpringBoot 嵌入 Tomcat 的工作机制，并灵活应用于实际项目。这种设计不仅提升了开发效率，还为微服务架构提供了坚实基础。


# 第九十二章、SpringBoot进阶 - 实现自动装配原理

SpringBoot 的自动装配（Auto-Configuration）是其核心特性之一，它通过“约定优于配置”的原则，极大地简化了 Spring 应用的开发流程。自动装配机制能够根据类路径下的依赖自动配置 Bean 和组件，减少手动编写 XML 或 Java 配置的工作量，实现开箱即用的体验。本章将详细解读 SpringBoot 自动装配的实现原理，从核心机制到设计思想，并提供核心代码指导，帮助读者深入理解这一强大功能的内在逻辑。

## 92.1 实现原理

SpringBoot 的自动装配原理基于 Spring 框架的条件化配置和类路径扫描机制。其核心是通过特定的注解和配置文件，在应用启动时自动检测并注册所需的 Bean，而无需开发者显式声明。下面分小节详细解析。

### 92.1.1 核心机制：@EnableAutoConfiguration 与 spring.factories 文件

自动装配的实现原理主要依赖于 `@EnableAutoConfiguration` 注解和 `META-INF/spring.factories` 文件的协同工作。整个过程从 SpringBoot 应用启动开始，涉及条件注解的评估和自动配置类的加载。

**@EnableAutoConfiguration 注解的作用**  
当 SpringBoot 应用启动时（通过 `@SpringBootApplication` 注解，它内部包含了 `@EnableAutoConfiguration`），该注解会触发自动配置流程。具体来说：
- `@EnableAutoConfiguration` 是一个组合注解，它通过 `@Import` 导入了 `AutoConfigurationImportSelector` 类。这个选择器负责扫描类路径下的 `META-INF/spring.factories` 文件，并加载其中定义的自动配置类。
- 在 Spring 容器的刷新阶段，`AutoConfigurationImportSelector` 会调用 `selectImports()` 方法，该方法返回一个字符串数组，包含所有需要被自动导入的配置类的全限定名。这些配置类通常是 SpringBoot 内置的，如 `DataSourceAutoConfiguration`（用于数据源配置）或 `WebMvcAutoConfiguration`（用于 MVC 配置）。

**spring.factories 文件的工作机制**  
`spring.factories` 文件是自动装配的关键配置文件，位于依赖包的 `META-INF` 目录下。它采用键值对格式，其中键为 `org.springframework.boot.autoconfigure.EnableAutoConfiguration`，值为逗号分隔的自动配置类列表。例如，SpringBoot 的 `spring-boot-autoconfigure` 包中的 `spring.factories` 文件包含了大量内置配置类：
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
...
```
当应用启动时，SpringBoot 会扫描所有依赖中的 `spring.factories` 文件，合并这些配置类，然后通过条件注解（如 `@ConditionalOnClass`）过滤掉不满足条件的类，最终只注册适用的 Bean。这种机制确保了自动装配的灵活性和准确性：例如，只有当类路径中存在 `DataSource` 类时，`DataSourceAutoConfiguration` 才会生效。

### 92.1.2 条件注解与自动配置类的执行流程

自动装配的核心在于条件注解（Conditional Annotations），它们控制配置类是否被激活。SpringBoot 提供了多种条件注解，如 `@ConditionalOnClass`、`@ConditionalOnMissingBean` 和 `@ConditionalOnProperty`，这些注解在运行时评估类路径、Bean 存在性或配置属性，以决定是否创建 Bean。

**执行流程详解**  
1. **启动阶段**：应用启动时，`AutoConfigurationImportSelector` 从 `spring.factories` 加载所有自动配置类。
2. **条件评估**：Spring 容器对每个配置类进行条件检查。例如，`@ConditionalOnClass(DataSource.class)` 会检查类路径中是否存在 `DataSource` 类，如果不存在，则跳过该配置类。
3. **Bean 注册**：通过条件的配置类会被解析，其内部的 `@Bean` 方法被调用，注册相应的 Bean 到 Spring 容器中。整个过程是自动的，开发者无需干预。
4. **顺序控制**：自动配置类通常使用 `@AutoConfigureOrder` 或 `@AutoConfigureAfter` 注解来控制加载顺序，避免依赖冲突。

这种机制实现了“智能配置”：SpringBoot 能够根据实际依赖动态调整配置，既保证了默认行为的简便性，又允许通过自定义覆盖自动配置。

## 92.2 设计思想

SpringBoot 自动装配的设计思想体现了现代软件工程的核心理念，包括简化开发、提升可维护性和支持模块化架构。其思想不仅注重技术实现，还强调开发效率和生产环境下的可靠性。

### 92.2.1 约定优于配置与开发效率

自动装配的核心设计思想是“约定优于配置”（Convention Over Configuration），通过预定义默认行为减少开发者的决策负担。例如，SpringBoot 默认内嵌 Tomcat、自动配置数据源（如果检测到 H2 数据库依赖），使得开发者只需关注业务代码，而非基础设施配置。这种设计显著提升了开发效率，尤其适合快速原型和微服务项目。

设计上，自动装配遵循“开闭原则”：它对扩展开放（允许开发者自定义配置），对修改关闭（核心机制稳定）。同时，通过条件注解实现了“按需配置”，避免了不必要的资源浪费，体现了资源优化思想。

### 92.2.2 模块化与云原生适配

自动装配的设计还支持模块化和云原生架构。在微服务场景中，每个服务可以依赖不同的 Starter（如 `spring-boot-starter-web`），自动装配机制会根据 Starter 自动加载相关配置，确保服务的独立性和轻量性。这种设计思想促进了 DevOps 实践，使应用易于在 Docker 或 Kubernetes 中部署。

此外，自动装配强调“生产就绪性”：通过丰富的条件注解，它可以适应多种环境（如开发、测试、生产），并通过配置属性（如 `application.properties`）实现灵活切换。这种思想降低了运维复杂度，支持持续集成和交付。

## 92.3 核心代码指导

为了帮助读者实际应用自动装配原理，本节提供核心代码示例和配置指导。这些代码基于 SpringBoot 2.x 或 3.x 版本，演示如何理解、自定义和调试自动配置。

### 92.3.1 查看和调试自动配置

在开发过程中，可以通过 SpringBoot 的 Actuator 端点或启动日志来查看自动配置详情。以下是一些实用方法：

- **启用自动配置报告**：在 `application.properties` 中设置：
  ```properties
  debug=true
  ```
  启动应用时，控制台会输出自动配置报告，显示哪些配置类被激活或跳过。

- **使用 Actuator 端点**：如果项目添加了 `spring-boot-starter-actuator` 依赖，访问 `/actuator/conditions` 端点可以查看详细的条件评估结果。

### 92.3.2 自定义自动配置类示例

如果需要创建自定义的自动配置（例如为第三方库添加自动支持），可以按照以下步骤实现：

1. **创建自动配置类**：使用 `@Configuration` 和条件注解定义配置类。
2. **注册到 spring.factories**：在 `src/main/resources/META-INF/spring.factories` 文件中添加配置类。

示例代码：假设我们想为自定义服务 `MyService` 创建自动配置。

- **首先，定义 MyService 类**：
```java
public class MyService {
    private String name;
    
    public MyService(String name) {
        this.name = name;
    }
    
    public String greet() {
        return "Hello from " + name;
    }
}
```

- **然后，创建自动配置类**：
```java
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnClass(MyService.class) // 仅当 MyService 类存在时生效
@EnableConfigurationProperties(MyServiceProperties.class) // 启用配置属性
public class MyServiceAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean // 仅当容器中不存在 MyService Bean 时创建
    public MyService myService(MyServiceProperties properties) {
        return new MyService(properties.getName());
    }
}

// 配置属性类，用于从 application.properties 读取配置
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "myservice")
public class MyServiceProperties {
    private String name = "defaultService"; // 默认值

    // Getter 和 Setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- **最后，在 spring.factories 中注册**：
在 `src/main/resources/META-INF/spring.factories` 文件中添加：
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.MyServiceAutoConfiguration
```

- **使用配置**：在 `application.properties` 中设置属性：
```properties
myservice.name=myCustomService
```
当应用启动时，SpringBoot 会自动创建 `MyService` Bean，并注入配置值。

### 92.3.3 排除自动配置

如果不需要某些自动配置，可以通过 `@SpringBootApplication` 注解的 `exclude` 属性排除：
```java
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
```

通过以上原理和代码指导，读者可以深入理解 SpringBoot 自动装配的工作机制，并灵活应用于实际项目。自动装配不仅简化了开发，还为现代应用架构提供了坚实基础。